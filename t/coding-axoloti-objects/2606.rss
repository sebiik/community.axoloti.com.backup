<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Coding axoloti objects</title>
    <link>https://sebiik.github.io/community.axoloti.com.backup/t/coding-axoloti-objects/2606</link>
    <description>A pretty big subject, but i think it might be useful to shed some light for newbies:

##Contents
- [What do you need to know to code objects](#needtoknow)
- [How do you start coding an object?](#startcoding)
- [How do you edit a library object?](#editlibrary)
- [Coding with input/output (and parameters)](#codeinout)
- [Local data](#localdata)
- [Init code](#initcode)
- [K-rate and S-rate cycles](#kratesrate)
- [Inlets/Outlets](#inletsoutlets)
- [Parameters](#parameters)
- [Normal range and number format](#rangeformat)
- [Elementary math in axoloti](#elementarymath)
- [32bit variables](#32bitvar)
- [Bitshifts](#bitshifts)
- [Fixed point math](#fixedpointmath)
- [Functions](#functions)
- [Assembly functions](#assembly)
- [Bitwise operations](#bitwise)


----------

## &lt;a name=&quot;needtoknow&quot;&gt;&lt;/a&gt;What do you need to know to code objects?

Basic C/C++ knowledge. You don&#39;t necessarily need to have a PhD in C++ to code objects, but you&#39;ll definitely need to know something about statements, variables, etc..
Math can be really useful, also, but all depends on what you need to code.


----------

##&lt;a name=&quot;startcoding&quot;&gt;&lt;/a&gt;How do you start coding an object?
Open a patch (or make a new one), create a patch/object object, click edit and you&#39;re good to go.


----------

##&lt;a name=&quot;editlibrary&quot;&gt;&lt;/a&gt;How do you edit a library object?
Load the object you want to edit in a patch. Click on the arrow and edit object definition.
It&#39;s not a good practice to edit factory object this way: you should do embed as patch/object and then edit the embedded object with the edit button.
If you just need to see how an object is coded you can do it the first way, but you should be careful not to overwrite stuff. 
If you do, don&#39;t panic: you can always delete the object from the folder and do a sync, but it&#39;s better to avoid the trouble.


----------

##&lt;a name=&quot;codeinout&quot;&gt;&lt;/a&gt;Coding with input/output (and parameters)
In the left side of the object editor you can see the inlets, outlets, attributes, parameters and displays tabs. Inlets and outlets are used to interface with other objects in the patcher. Parameters and displays provide some user input/output patcher-side, attributes are similar to parameters, but can be only edited before starting the patch. 
They&#39;re generally defined as int32_t or uint32_t variables (however, some attributes use string type, and buffered inlet/outlets are int32_t*).

You can access inlets, outlets, parameters and displays in init code, k-rate code°, s-rate code, and midi code. You can&#39;t access them in local data (because they&#39;re still to be declared).
Attributes can be accessed in local data.
You can read inlets, attributes or parameters in the code using the inlet_x, attr_x or param_x formulation (where x is the name of the inlet you want to read)

**Examples:** 
[code]
if (inlet_dog) dostuff();
int32_t x = inlet_dog + param_cat;
switch (attr_mice) {
{ 
case 1 : stuff1(); break;
case 2 : stuff2(); break;
}
[/code]
You get the idea.

You can write in outlets or displays with the outlet_x or disp_x formulation (where x is the name of the outlet or display you want to write to)

**Example:**
[code]
outlet_elephant = 5;
disp_zebra = 10;
[/code]

° Note: Inlets and outlets that contain &quot;buffer&quot; in the type are only accessible in s-rate code.
If you want to access them in k-rate code you must refer to them as arrays.

**Example (k-rate):**
[code]
outlet_blob[1] = inlet_plaff[6];
[/code]

----------

##&lt;a name=&quot;localdata&quot;&gt;&lt;/a&gt;Local data
This section of the code is executed once, before inlets, outlets, params and displays are declared. 
You can use this section to declare variables, constants, functions etc. You can&#39;t access i/o (because i/o does still not exist, at this point), but you can access attributes.
**Example:** table/alloc 16b


----------

##&lt;a name=&quot;initcode&quot;&gt;&lt;/a&gt;Init code
This code is executed once at the beginning of the patch after all inlets, outlets, parameters and displays are declared. You can therefore access i/o.
If you don&#39;t need this feature you can compact all the initialization code in the local data section.
**Example:** filter/allpass


----------

##&lt;a name=&quot;kratesrate&quot;&gt;&lt;/a&gt;K-rate and S-rate cycles
K-rate code is executed 3000 times in a second.
S-rate code is once for each sample  (i.e. 48000/sec)
This might seem strange, but s-rate is executed after k-rate. (Therefore in s-rate you can read/write in variables created in k-rate).

the s-rate code really is just a short hand for a k-rate equivalent, basically its just a for-loop going around each sample in the audio buffer. you can also do this yourself in the k-rate code, which sometimes is more useful. (you will see the factory objects do it quite frequently)
(note: this means just because an object doesnt have any code in the s-rate section , doesn&#39;t mean it doesn&#39;t run audio rate code.

**Example:** osc/phasor


----------

##&lt;a name=&quot;inletsoutlets&quot;&gt;&lt;/a&gt;Inlets/Outlets
They can be of four main types: bool (yellow), int (green), frac (blue), frac buffer (red)
They&#39;re all 32 bit integers, however.
Buffered i/o can be accessed in k-rate with arrays (see osc/saw cheap) or in s-rate (see osc/sine).
A special note about integers and fractionals: since axoloti is a microcontroller based audio platform, fractional input/output is implemented with fixed point math (Q format, you can check it on wikipedia). 
So, what you see in the patcher as 64 (dials) is actually a much bigger number: 2^27.
More on types later.


----------

##&lt;a name=&quot;parameters&quot;&gt;&lt;/a&gt;Parameters
There&#39;s a lot to say about parameters and very little time to do so.
frac32.X.map -&gt; dials. They can be unipolar (u.map) and bipolar (s.map). Their range is normally 0~2^27 for unipolar and -2^27~2^27 for bipolar, however some of them are scaled non linearly for particular applications.
int32 -&gt; integer parameters. Their value is what you see in the patcher.
bool32.mom and bool32.tgl -&gt; buttons, boolean 1/0.


----------

##&lt;a name=&quot;rangeformat&quot;&gt;&lt;/a&gt;Normal range and number format
You&#39;ll sometimes read about normal range. An example of a normal range is the output of dial/b, which goes from -64 to +64 (in the ui)
the output of dial/p (the p stands for positive) is 0 to 64, which is a positive normal range.

You can see that if you multiply a dial set to 64 to some other fractional value, you&#39;ll get that same fractional value.
If you multiply 32 for another fractional value, you&#39;ll get as output half the value. (You can see where i&#39;m going).

What happens under the hood is that 64 in the ui corresponds to a 2^27 integer (or 1&lt;&lt;27 if you like C) passed between objects, and most times it corresponds to a &quot;real world&quot; 1.
Most operations are done on this basis.


----------

##&lt;a name=&quot;elementarymath&quot;&gt;&lt;/a&gt;Elementary math in axoloti
Integer math is pretty straightforward: you can sum, subtract, multiply and divide (with truncation!) integers using the basic operators +-*/. 
**Examples:**
[code]
operation1 = a + b -c;
operation2 = d*e;
operation2 = f/g;
[/code]

**Examples:** 
math/+
math/-
math/* (the ones with at least one green inlet!)
math/divremc

Remember that you&#39;re working with 32bit signed variables, so you have a limited range (overflows won&#39;t break boards, but can be pretty harsh sounding).

You can do operations in floating point, by casting variables (it&#39;s a bit more expensive than doing integer math, but it can serve purposes)
Example: math/reciprocal (the integer input is cast to a float variable &quot;inf&quot;, and then 2^48 is divided by inf. )
Example: math/sqrt (the float variable is used as an argument for the VSQRTF function.)


----------

##&lt;a name=&quot;32bitvar&quot;&gt;&lt;/a&gt;32bit variables
They&#39;re mainly of two types: uint32_t (unsigned int) and int32_t (signed int).
This means that the processor works with 32 bits per variable, so you can use numbers that go from -2147483648 to 2147483647 (signed) or 0 to 4294967296 (unsigned).
Signed integers use two&#39;s complement representation: read about it on wikipedia, it&#39;s pretty cool: https://en.wikipedia.org/wiki/Two&#39;s_complement
Another pretty interesting resource i found about the topic is this:
http://www.computerworld.com/article/3010974/linux/whats-so-special-about-2147483648.html

Knowing the type of a variable is really important when you do bitshifts: in fact 1&lt;&lt;31 equals to 2147483648 in an unsigned int, but it also equals -2147483648, in a signed int (also, if you wonder what&#39;s 1&lt;&lt;31 like, here you have it: 10000000 00000000 00000000 00000000)


----------

##&lt;a name=&quot;bitshifts&quot;&gt;&lt;/a&gt;Bitshifts
The notation a &lt;&lt; b means &quot;bit shift left the variable a by a number b of bits&quot;
So, if a = 15 ( 0000 1111 in binary) and b = 2; then a &lt;&lt; b = 0011 1100 (binary) = 60 (decimal)
Bitshifting left by a number of bits n it&#39;s really like multiplying by 2^n.
This also stands for negative numbers (since they&#39;re in two&#39;s complement notation and the processor knows that), for example 1111 0000 &lt;&lt; 3 = 1000 0000 (which is -16 * 2^3 = -128)
The same thing applies for right shifts: a &gt;&gt; b means &quot;bit shift right the variable a by a number b of bits&quot;
So, if a = 15 ( 0000 1111 in binary) and b = 2; then a &gt;&gt; b = 0000 0011 (binary) = 3 (decimal)
Which it&#39;s really like dividing by 2^n.
Same thing applies for negative numbers (in two&#39;s complement)

**Examples:** 
math/&lt;&lt;
math/&gt;&gt;


----------

##&lt;a name=&quot;fixedpointmath&quot;&gt;&lt;/a&gt;Fixed point math (also not so easy math)
So, we said earlier that axoloti works with integer variables. This is due to the fact that the microprocessor works more efficiently with integer types (don&#39;t worry! there&#39;s also an fpu!).
If you already opened some library objects, you might have stumbled over functions like ___SMMUL or ___SMMLA.

_Tools:_

These are assembly functions that perform a &quot;composite&quot; operation all in one take, which is multiply a*b and shift right by 32 bits.
I&#39;ll enter in the details of these functions later, but remember some of the math you learned in high school:
the logarithm of a number returns the &quot;magnitude&quot; of that number, in a particular base.
Remember also one of the properties of logarithms: log(a*b) = log(a) + log(b), which you can read as &quot;the magnitude of the product of two numbers is equal to the sum of the magnitude of those numbers&quot;
So, if you multiply two 32-bit numbers (they have a magnitude of 32 maximum), you can get as result a number with a magnitude up to 64.
The same thing (but opposite) stands for division, so if you divide a 64 bit number (magnitude 64) by a 32bit number (magnitude 32) you&#39;ll get a number with a smaller magnitude.

_Demonstration:_

What defines 1 in real world? Well, if you multiply 1*1 you get 1. So, the magnitude remains the same.
If you want 2^27 (1&lt;&lt;27) to be your &quot;digital world 1&quot;, you can simply perform operations in a way that retains the magnitude of (1&lt;&lt;27) X (1&lt;&lt;27) (where X is our digital world multiplication)

Sooo... if A and B are two 32bit variables, and the unity is represented by (1&lt;&lt;27), you can say that log2(aA X bB) = 27 when A = 1&lt;&lt;27 and B = 1&lt;&lt;27 (a and b are two coefficients to be defined)
We don&#39;t know what operation X is, but we know that ___SMMUL does x*y&gt;&gt;32, which is equal to x*y/(2^32)
_log2(aA * bB /2^32 ) = 27_
_log2(a*2^27) + log2(b*2^27) - log2(2^32) = 27_
_log2(a) + 27 + log2(b) + 27 - 32 = 27_
_log2(a) + log2(b) = 5_

In practice, to do fixed point math with the mathematical 1 corresponding to digital (1&lt;&lt;27) we have to increase the magnitude of our two numbers by 5.

You can do this in quite a few ways:
[code]
C = ___SMMUL(A&lt;&lt;2,B&lt;&lt;3);
C = ___SMMUL(A&lt;&lt;3,B&lt;&lt;2);
C = ___SMMUL(A&lt;&lt;1,B&lt;&lt;4);
C = ___SMMUL(A&lt;&lt;4,B&lt;&lt;1);
C = ___SMMUL(A,B)&lt;&lt;5;
C = ___SMMUL(A&lt;&lt;1,B)&lt;&lt;4;
[/code]

You get the idea.

**Examples:** 
math/* (the ones without green inlets)
math/*c



----------

##&lt;a name=&quot;functions&quot;&gt;&lt;/a&gt;Functions
There isn&#39;t really a huge pool of functions that are commonly used in axoloti objects.
We already talked about ___SMMUL(a,b): this function belongs to a family of functions really useful to perform fixed point math (and you can really do lots of stuff with them: from simple operations, to filters, oscillators, physical modelling)

_Signed multiplications:_
**out = ___SMMUL(in1,in2)** Performs a multiplication between in1 and in2 and bitshifts right by 32bits
**out = ___SMMLA(in1,in2,in3)** Performs a multiplication between in1 and in2, bitshifts the result right by 32bits and adds the result to in3.
**out = ___SMMLS(in1,in2,in3)** Performs a multiplication between in1 and in2, bitshifts the result right by 32bits and subtracts the result from in3.
**Examples:**
math/* (smmul)
mix/mix 3 sq (smmla)
filter/allpass (smmls)

_Saturation functions_ 
**out = __SSAT(input,N)** Saturates a signed input to N bits
**out = __USAT(input,N)** Saturates an unsigned input to N bits
Important: N must be a constant number, you can&#39;t use variables in this argument. 
**Examples:**
math/sat (ssat)
math/satp (usat)

_Some particular lookup tables:_
**SINE2TINTERP(input,output)** An integer sine function. It calculates sin(input) and stores the result in output variable. It&#39;s not a mathematical sine, meaning that both the input and output are scaled: their range goes from -2^31 to 2^31
**HANNING2TINTERP(input,output)** An integer hanning window function. Calculates the hanning window of the input and stores the result in output variable.
**MTOF(input,output)** and **MTOFEXTENDED(input,output)** Are used to map a pitch to a phase increment (it&#39;s used in oscillators and filters to tune them), but you can use these functions also to drive envelopes.

**Examples:**
math/sin (sine2tinterp)
math/cos (sine2tinterp)
osc/sine (sine2tinterp)
math/window (hanning2tinterp)
conv/mtof (mtof)
filter/vcf3 (mtof)
env/ad (mtof)
osc/sine (mtofextended)

_Floating point functions:_
**_VSQRTF(input)** calculates the square root of a float variable. 
**Example:** math/sqrt


----------

##&lt;a name=&quot;assembly&quot;&gt;&lt;/a&gt;Assembly functions
You might wonder where do ___SMMUL, __SSAT and similar come from.
The answers can be found here: http://infocenter.arm.com/help/topic/com.arm.doc.dui0553a/CIHJJEIH.html (which is the arm cortex m4 instruction set), here: https://github.com/axoloti/axoloti/blob/605c1e9a81843a6b465193e956ae3d2e94596c81/firmware/axoloti_math.h (the definition of some of the math functions) and here: https://github.com/axoloti/axoloti/blob/605c1e9a81843a6b465193e956ae3d2e94596c81/CMSIS/Include/core_cm4_simd.h (the definition of other math functions)

Not all assembly functions are available to use, because they are not inserted in math.h and core_cm4_simd.h (which are those two includes i linked above), but don&#39;t worry: most of the time you can do everything with C.
However, sometimes you can take advantage of specific functions that do very specific operations (and it&#39;s the case of the fixed point math i mentioned above).


----------

##&lt;a name=&quot;bitwise&quot;&gt;&lt;/a&gt;## Bitwise operations
Another family of useful operations is the one of the so called &quot;bitwise operations&quot;.
These work individually on bits, changing their state. 
You can perform bitwise negation, bitwise and and bitwise or.
Let&#39;s consider two 8bit words: (A = 101; B = -394)
[code]
int32_t A = 101;
int32_t B = -394;
[/code]
These two numbers correspond to the binary


    A = 00000000 00000000 00000000 01100101
    B = 11111111 11111111 11111110 01110110
**Bitwise negation: ~a** (you can write the tilde pressing alt + 126) 
Every bit is negated (it&#39;s switched with its opposite)
[code]
int32_t C = ~A;
int32_t D = ~B;
[/code]
Will output these two numbers: 

    C = 11111111 11111111 11111111 10011010 = -102
    D = 00000000 00000000 00000001 10001001 = 393

**Bitwise and: a&amp;b**
This operation is performed between two variables (they should have the same size!)
An and operation between two bits outputs 1 if and only if both bits are set to 1, otherwise it will output 0:
0 &amp; 0 = 0
0 &amp; 1 = 0
1 &amp; 0 = 0
1 &amp; 1 = 1
This is done for every bit of the two words
[code]
int32_t E = A &amp; B;
[/code]

Will output 

`E = 00000000 00000000 00000000 01100100 = 100`

**Bitwise or: a|b**
This operation is performed between two variables (they should have the same size!)
An or operation between two bits outputs 0 if and only if both bits are set to 0, otherwise it will output 1;
0 | 0 = 0
0 | 1 = 1
1 | 0 = 1
1 | 1 = 1
This is done for every bit of the two words
[code]
int32_t F = A | B;
[/code]
Will output 

`F = 11111111 11111111 11111110 01110111 = -393`</description>
    
    <lastBuildDate>Fri, 21 Apr 2017 11:31:52 +0000</lastBuildDate>
    <category>User Guide</category>
    <atom:link href="https://sebiik.github.io/community.axoloti.com.backup/t/coding-axoloti-objects/2606.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>Coding axoloti objects</title>
        <dc:creator><![CDATA[@thetechnobear Mark Harris]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://sebiik.github.io/community.axoloti.com.backup/u/thetechnobear">@thetechnobear</a> wrote:</p>
          <blockquote>
              <p>A post was merged into an existing topic: <a href="/t/learning-to-code-axoloti-objects/1520">Learning to code Axoloti Objects</a></p>
          </blockquote>
          <p><a href="https://sebiik.github.io/community.axoloti.com.backup/t/coding-axoloti-objects/2606/11">Read full topic</a></p>
        ]]></description>
        <link>https://sebiik.github.io/community.axoloti.com.backup/t/coding-axoloti-objects/2606/11</link>
        <pubDate>Fri, 21 Apr 2017 11:32:50 +0000</pubDate>
        <guid isPermaLink="false">community.axoloti.com-post-2606-11</guid>
        <source url="https://sebiik.github.io/community.axoloti.com.backup/t/coding-axoloti-objects/2606.rss">Coding axoloti objects</source>
      </item>
      <item>
        <title>Coding axoloti objects</title>
        <dc:creator><![CDATA[@thetechnobear Mark Harris]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://sebiik.github.io/community.axoloti.com.backup/u/thetechnobear">@thetechnobear</a> wrote:</p>
          <blockquote>
              <p>this topic is a 'user guide' topic, please ask questions elsewhere, only post here when you believe the main post needs clarification points.<br>we have the axocoding  category for coding questions.</p>
          </blockquote>
          <p><a href="https://sebiik.github.io/community.axoloti.com.backup/t/coding-axoloti-objects/2606/13">Read full topic</a></p>
        ]]></description>
        <link>https://sebiik.github.io/community.axoloti.com.backup/t/coding-axoloti-objects/2606/13</link>
        <pubDate>Fri, 21 Apr 2017 11:31:52 +0000</pubDate>
        <guid isPermaLink="false">community.axoloti.com-post-2606-13</guid>
        <source url="https://sebiik.github.io/community.axoloti.com.backup/t/coding-axoloti-objects/2606.rss">Coding axoloti objects</source>
      </item>
      <item>
        <title>Coding axoloti objects</title>
        <dc:creator><![CDATA[@thetechnobear Mark Harris]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://sebiik.github.io/community.axoloti.com.backup/u/thetechnobear">@thetechnobear</a> wrote:</p>
          <blockquote>
              <p>9 posts were split to a new topic: <a href="/t/q24-encoding-questions/3244">Q24 encoding questions</a></p>
          </blockquote>
          <p><a href="https://sebiik.github.io/community.axoloti.com.backup/t/coding-axoloti-objects/2606/2">Read full topic</a></p>
        ]]></description>
        <link>https://sebiik.github.io/community.axoloti.com.backup/t/coding-axoloti-objects/2606/2</link>
        <pubDate>Fri, 21 Apr 2017 11:30:17 +0000</pubDate>
        <guid isPermaLink="false">community.axoloti.com-post-2606-2</guid>
        <source url="https://sebiik.github.io/community.axoloti.com.backup/t/coding-axoloti-objects/2606.rss">Coding axoloti objects</source>
      </item>
      <item>
        <title>Coding axoloti objects</title>
        <dc:creator><![CDATA[@thetechnobear Mark Harris]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://sebiik.github.io/community.axoloti.com.backup/u/thetechnobear">@thetechnobear</a> wrote:</p>
          <blockquote>
              <p>A post was split to a new topic: <a href="/t/code-execution-question/3243">Code execution question</a></p>
          </blockquote>
          <p><a href="https://sebiik.github.io/community.axoloti.com.backup/t/coding-axoloti-objects/2606/12">Read full topic</a></p>
        ]]></description>
        <link>https://sebiik.github.io/community.axoloti.com.backup/t/coding-axoloti-objects/2606/12</link>
        <pubDate>Fri, 21 Apr 2017 11:28:18 +0000</pubDate>
        <guid isPermaLink="false">community.axoloti.com-post-2606-12</guid>
        <source url="https://sebiik.github.io/community.axoloti.com.backup/t/coding-axoloti-objects/2606.rss">Coding axoloti objects</source>
      </item>
      <item>
        <title>Coding axoloti objects</title>
        <dc:creator><![CDATA[@Sputnki Filippo Tamagnini]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://sebiik.github.io/community.axoloti.com.backup/u/sputnki">@Sputnki</a> wrote:</p>
          <blockquote>
              <p>A pretty big subject, but i think it might be useful to shed some light for newbies:</p>

<h2>Contents</h2>

<ul>
<li><a href="#needtoknow">What do you need to know to code objects</a></li>
<li><a href="#startcoding">How do you start coding an object?</a></li>
<li><a href="#editlibrary">How do you edit a library object?</a></li>
<li><a href="#codeinout">Coding with input/output (and parameters)</a></li>
<li><a href="#localdata">Local data</a></li>
<li><a href="#initcode">Init code</a></li>
<li><a href="#kratesrate">K-rate and S-rate cycles</a></li>
<li><a href="#inletsoutlets">Inlets/Outlets</a></li>
<li><a href="#parameters">Parameters</a></li>
<li><a href="#rangeformat">Normal range and number format</a></li>
<li><a href="#elementarymath">Elementary math in axoloti</a></li>
<li><a href="#32bitvar">32bit variables</a></li>
<li><a href="#bitshifts">Bitshifts</a></li>
<li><a href="#fixedpointmath">Fixed point math</a></li>
<li><a href="#functions">Functions</a></li>
<li><a href="#assembly">Assembly functions</a></li>
<li><a href="#bitwise">Bitwise operations</a></li>
</ul>

<hr>

<h2>
<a name="needtoknow"></a>What do you need to know to code objects?</h2>

<p>Basic C/C++ knowledge. You don't necessarily need to have a PhD in C++ to code objects, but you'll definitely need to know something about statements, variables, etc..<br>Math can be really useful, also, but all depends on what you need to code.</p>

<hr>

<h2>
<a name="startcoding"></a>How do you start coding an object?</h2>

<p>Open a patch (or make a new one), create a patch/object object, click edit and you're good to go.</p>

<hr>

<h2>
<a name="editlibrary"></a>How do you edit a library object?</h2>

<p>Load the object you want to edit in a patch. Click on the arrow and edit object definition.<br>It's not a good practice to edit factory object this way: you should do embed as patch/object and then edit the embedded object with the edit button.<br>If you just need to see how an object is coded you can do it the first way, but you should be careful not to overwrite stuff. <br>If you do, don't panic: you can always delete the object from the folder and do a sync, but it's better to avoid the trouble.</p>

<hr>

<h2>
<a name="codeinout"></a>Coding with input/output (and parameters)</h2>

<p>In the left side of the object editor you can see the inlets, outlets, attributes, parameters and displays tabs. Inlets and outlets are used to interface with other objects in the patcher. Parameters and displays provide some user input/output patcher-side, attributes are similar to parameters, but can be only edited before starting the patch. <br>They're generally defined as int32_t or uint32_t variables (however, some attributes use string type, and buffered inlet/outlets are int32_t*).</p>

<p>You can access inlets, outlets, parameters and displays in init code, k-rate code°, s-rate code, and midi code. You can't access them in local data (because they're still to be declared).<br>Attributes can be accessed in local data.<br>You can read inlets, attributes or parameters in the code using the inlet_x, attr_x or param_x formulation (where x is the name of the inlet you want to read)</p>

<p><strong>Examples:</strong> <br></p>

<p></p><pre><code class="lang-auto">if (inlet_dog) dostuff();
int32_t x = inlet_dog + param_cat;
switch (attr_mice) {
{ 
case 1 : stuff1(); break;
case 2 : stuff2(); break;
}</code></pre>

<p>You get the idea.</p>

<p>You can write in outlets or displays with the outlet_x or disp_x formulation (where x is the name of the outlet or display you want to write to)</p>

<p><strong>Example:</strong><br></p>

<p></p><pre><code class="lang-auto">outlet_elephant = 5;
disp_zebra = 10;</code></pre>

<p>° Note: Inlets and outlets that contain "buffer" in the type are only accessible in s-rate code.<br>If you want to access them in k-rate code you must refer to them as arrays.</p>

<p><strong>Example (k-rate):</strong><br></p>

<p></p><pre><code class="lang-auto">outlet_blob[1] = inlet_plaff[6];</code></pre>

<hr>

<h2>
<a name="localdata"></a>Local data</h2>

<p>This section of the code is executed once, before inlets, outlets, params and displays are declared. <br>You can use this section to declare variables, constants, functions etc. You can't access i/o (because i/o does still not exist, at this point), but you can access attributes.<br><strong>Example:</strong> table/alloc 16b</p>

<hr>

<h2>
<a name="initcode"></a>Init code</h2>

<p>This code is executed once at the beginning of the patch after all inlets, outlets, parameters and displays are declared. You can therefore access i/o.<br>If you don't need this feature you can compact all the initialization code in the local data section.<br><strong>Example:</strong> filter/allpass</p>

<hr>

<h2>
<a name="kratesrate"></a>K-rate and S-rate cycles</h2>

<p>K-rate code is executed 3000 times in a second.<br>S-rate code is once for each sample  (i.e. 48000/sec)<br>This might seem strange, but s-rate is executed after k-rate. (Therefore in s-rate you can read/write in variables created in k-rate).</p>

<p>the s-rate code really is just a short hand for a k-rate equivalent, basically its just a for-loop going around each sample in the audio buffer. you can also do this yourself in the k-rate code, which sometimes is more useful. (you will see the factory objects do it quite frequently)<br>(note: this means just because an object doesnt have any code in the s-rate section , doesn't mean it doesn't run audio rate code.</p>

<p><strong>Example:</strong> osc/phasor</p>

<hr>

<h2>
<a name="inletsoutlets"></a>Inlets/Outlets</h2>

<p>They can be of four main types: bool (yellow), int (green), frac (blue), frac buffer (red)<br>They're all 32 bit integers, however.<br>Buffered i/o can be accessed in k-rate with arrays (see osc/saw cheap) or in s-rate (see osc/sine).<br>A special note about integers and fractionals: since axoloti is a microcontroller based audio platform, fractional input/output is implemented with fixed point math (Q format, you can check it on wikipedia). <br>So, what you see in the patcher as 64 (dials) is actually a much bigger number: 2^27.<br>More on types later.</p>

<hr>

<h2>
<a name="parameters"></a>Parameters</h2>

<p>There's a lot to say about parameters and very little time to do so.<br>frac32.X.map -&gt; dials. They can be unipolar (u.map) and bipolar (s.map). Their range is normally 0~2^27 for unipolar and -2^27~2^27 for bipolar, however some of them are scaled non linearly for particular applications.<br>int32 -&gt; integer parameters. Their value is what you see in the patcher.<br>bool32.mom and bool32.tgl -&gt; buttons, boolean 1/0.</p>

<hr>

<h2>
<a name="rangeformat"></a>Normal range and number format</h2>

<p>You'll sometimes read about normal range. An example of a normal range is the output of dial/b, which goes from -64 to +64 (in the ui)<br>the output of dial/p (the p stands for positive) is 0 to 64, which is a positive normal range.</p>

<p>You can see that if you multiply a dial set to 64 to some other fractional value, you'll get that same fractional value.<br>If you multiply 32 for another fractional value, you'll get as output half the value. (You can see where i'm going).</p>

<p>What happens under the hood is that 64 in the ui corresponds to a 2^27 integer (or 1&lt;&lt;27 if you like C) passed between objects, and most times it corresponds to a "real world" 1.<br>Most operations are done on this basis.</p>

<hr>

<h2>
<a name="elementarymath"></a>Elementary math in axoloti</h2>

<p></p><pre><code class="lang-auto">operation1 = a + b -c;
operation2 = d*e;
operation2 = f/g;</code></pre>

<p><strong>Examples:</strong> <br>math/+<br>math/-<br>math/* (the ones with at least one green inlet!)<br>math/divremc</p>

<p>Remember that you're working with 32bit signed variables, so you have a limited range (overflows won't break boards, but can be pretty harsh sounding).</p>

<p>You can do operations in floating point, by casting variables (it's a bit more expensive than doing integer math, but it can serve purposes)<br>Example: math/reciprocal (the integer input is cast to a float variable "inf", and then 2^48 is divided by inf. )<br>Example: math/sqrt (the float variable is used as an argument for the VSQRTF function.)</p>

<hr>

<h2>
<a name="32bitvar"></a>32bit variables</h2>

<p>They're mainly of two types: uint32_t (unsigned int) and int32_t (signed int).<br>This means that the processor works with 32 bits per variable, so you can use numbers that go from -2147483648 to 2147483647 (signed) or 0 to 4294967296 (unsigned).<br>Signed integers use two's complement representation: read about it on wikipedia, it's pretty cool: <a href="https://en.wikipedia.org/wiki/Two's_complement" rel="nofollow">https://en.wikipedia.org/wiki/Two's_complement</a><br>Another pretty interesting resource i found about the topic is this:<br><aside class="onebox whitelistedgeneric">
  <header class="source">
    <a href="http://www.computerworld.com/article/3010974/linux/whats-so-special-about-2147483648.html" target="_blank" rel="nofollow">www.computerworld.com</a>
  </header>
  <article class="onebox-body">
    <img src="http://images.techhive.com/images/article/2015/12/binary2038-100631009-primary.idge.jpg" class="thumbnail" width="620" height="413">

<h3><a href="http://www.computerworld.com/article/3010974/linux/whats-so-special-about-2147483648.html" target="_blank" rel="nofollow">What's so special about 2147483648?</a></h3>

<p>We might just run out of time!</p>

  </article>
  <div class="onebox-metadata">
    
    
  </div>
  <div style="clear: both"></div>
</aside>
</p>

<p>Knowing the type of a variable is really important when you do bitshifts: in fact 1&lt;&lt;31 equals to 2147483648 in an unsigned int, but it also equals -2147483648, in a signed int (also, if you wonder what's 1&lt;&lt;31 like, here you have it: 10000000 00000000 00000000 00000000)</p>

<hr>

<h2>
<a name="bitshifts"></a>Bitshifts</h2>

<p>The notation a &lt;&lt; b means "bit shift left the variable a by a number b of bits"<br>So, if a = 15 ( 0000 1111 in binary) and b = 2; then a &lt;&lt; b = 0011 1100 (binary) = 60 (decimal)<br>Bitshifting left by a number of bits n it's really like multiplying by 2^n.<br>This also stands for negative numbers (since they're in two's complement notation and the processor knows that), for example 1111 0000 &lt;&lt; 3 = 1000 0000 (which is -16 * 2^3 = -128)<br>The same thing applies for right shifts: a &gt;&gt; b means "bit shift right the variable a by a number b of bits"<br>So, if a = 15 ( 0000 1111 in binary) and b = 2; then a &gt;&gt; b = 0000 0011 (binary) = 3 (decimal)<br>Which it's really like dividing by 2^n.<br>Same thing applies for negative numbers (in two's complement)</p>

<p><strong>Examples:</strong> <br>math/&lt;&lt;<br>math/&gt;&gt;</p>

<hr>

<h2>
<a name="fixedpointmath"></a>Fixed point math (also not so easy math)</h2>

<p>So, we said earlier that axoloti works with integer variables. This is due to the fact that the microprocessor works more efficiently with integer types (don't worry! there's also an fpu!).<br>If you already opened some library objects, you might have stumbled over functions like ___SMMUL or ___SMMLA.</p>

<p><em>Tools:</em></p>

<p>These are assembly functions that perform a "composite" operation all in one take, which is multiply a*b and shift right by 32 bits.<br>I'll enter in the details of these functions later, but remember some of the math you learned in high school:<br>the logarithm of a number returns the "magnitude" of that number, in a particular base.<br>Remember also one of the properties of logarithms: log(a*b) = log(a) + log(b), which you can read as "the magnitude of the product of two numbers is equal to the sum of the magnitude of those numbers"<br>So, if you multiply two 32-bit numbers (they have a magnitude of 32 maximum), you can get as result a number with a magnitude up to 64.<br>The same thing (but opposite) stands for division, so if you divide a 64 bit number (magnitude 64) by a 32bit number (magnitude 32) you'll get a number with a smaller magnitude.</p>

<p><em>Demonstration:</em></p>

<p>What defines 1 in real world? Well, if you multiply 1*1 you get 1. So, the magnitude remains the same.<br>If you want 2^27 (1&lt;&lt;27) to be your "digital world 1", you can simply perform operations in a way that retains the magnitude of (1&lt;&lt;27) X (1&lt;&lt;27) (where X is our digital world multiplication)</p>

<p>Sooo... if A and B are two 32bit variables, and the unity is represented by (1&lt;&lt;27), you can say that log2(aA X bB) = 27 when A = 1&lt;&lt;27 and B = 1&lt;&lt;27 (a and b are two coefficients to be defined)<br>We don't know what operation X is, but we know that ___SMMUL does x*y&gt;&gt;32, which is equal to x*y/(2^32)<br><em>log2(aA * bB /2^32 ) = 27</em><br><em>log2(a*2^27) + log2(b*2^27) - log2(2^32) = 27</em><br><em>log2(a) + 27 + log2(b) + 27 - 32 = 27</em><br><em>log2(a) + log2(b) = 5</em></p>

<p>In practice, to do fixed point math with the mathematical 1 corresponding to digital (1&lt;&lt;27) we have to increase the magnitude of our two numbers by 5.</p>

<p>You can do this in quite a few ways:<br></p>

<p></p><pre><code class="lang-auto">C = ___SMMUL(A&lt;&lt;2,B&lt;&lt;3);
C = ___SMMUL(A&lt;&lt;3,B&lt;&lt;2);
C = ___SMMUL(A&lt;&lt;1,B&lt;&lt;4);
C = ___SMMUL(A&lt;&lt;4,B&lt;&lt;1);
C = ___SMMUL(A,B)&lt;&lt;5;
C = ___SMMUL(A&lt;&lt;1,B)&lt;&lt;4;</code></pre>

<p>You get the idea.</p>

<p><strong>Examples:</strong> <br>math/* (the ones without green inlets)<br>math/*c</p>

<hr>

<h2>
<a name="functions"></a>Functions</h2>

<p>There isn't really a huge pool of functions that are commonly used in axoloti objects.<br>We already talked about ___SMMUL(a,b): this function belongs to a family of functions really useful to perform fixed point math (and you can really do lots of stuff with them: from simple operations, to filters, oscillators, physical modelling)</p>

<p><em>Signed multiplications:</em><br><strong>out = ___SMMUL(in1,in2)</strong> Performs a multiplication between in1 and in2 and bitshifts right by 32bits<br><strong>out = ___SMMLA(in1,in2,in3)</strong> Performs a multiplication between in1 and in2, bitshifts the result right by 32bits and adds the result to in3.<br><strong>out = ___SMMLS(in1,in2,in3)</strong> Performs a multiplication between in1 and in2, bitshifts the result right by 32bits and subtracts the result from in3.<br><strong>Examples:</strong><br>math/* (smmul)<br>mix/mix 3 sq (smmla)<br>filter/allpass (smmls)</p>

<p><em>Saturation functions</em> <br><strong>out = __SSAT(input,N)</strong> Saturates a signed input to N bits<br><strong>out = __USAT(input,N)</strong> Saturates an unsigned input to N bits<br>Important: N must be a constant number, you can't use variables in this argument. <br><strong>Examples:</strong><br>math/sat (ssat)<br>math/satp (usat)</p>

<p><em>Some particular lookup tables:</em><br><strong>SINE2TINTERP(input,output)</strong> An integer sine function. It calculates sin(input) and stores the result in output variable. It's not a mathematical sine, meaning that both the input and output are scaled: their range goes from -2^31 to 2^31<br><strong>HANNING2TINTERP(input,output)</strong> An integer hanning window function. Calculates the hanning window of the input and stores the result in output variable.<br><strong>MTOF(input,output)</strong> and <strong>MTOFEXTENDED(input,output)</strong> Are used to map a pitch to a phase increment (it's used in oscillators and filters to tune them), but you can use these functions also to drive envelopes.</p>

<p><strong>Examples:</strong><br>math/sin (sine2tinterp)<br>math/cos (sine2tinterp)<br>osc/sine (sine2tinterp)<br>math/window (hanning2tinterp)<br>conv/mtof (mtof)<br>filter/vcf3 (mtof)<br>env/ad (mtof)<br>osc/sine (mtofextended)</p>

<p><em>Floating point functions:</em><br><strong>_VSQRTF(input)</strong> calculates the square root of a float variable. <br><strong>Example:</strong> math/sqrt</p>

<hr>

<h2>
<a name="assembly"></a>Assembly functions</h2>

<p>You might wonder where do ___SMMUL, __SSAT and similar come from.<br>The answers can be found here: <a href="http://infocenter.arm.com/help/topic/com.arm.doc.dui0553a/CIHJJEIH.html" rel="nofollow">http://infocenter.arm.com/help/topic/com.arm.doc.dui0553a/CIHJJEIH.html</a> (which is the arm cortex m4 instruction set), here: <a href="https://github.com/axoloti/axoloti/blob/605c1e9a81843a6b465193e956ae3d2e94596c81/firmware/axoloti_math.h" rel="nofollow">https://github.com/axoloti/axoloti/blob/605c1e9a81843a6b465193e956ae3d2e94596c81/firmware/axoloti_math.h</a> (the definition of some of the math functions) and here: <a href="https://github.com/axoloti/axoloti/blob/605c1e9a81843a6b465193e956ae3d2e94596c81/CMSIS/Include/core_cm4_simd.h" rel="nofollow">https://github.com/axoloti/axoloti/blob/605c1e9a81843a6b465193e956ae3d2e94596c81/CMSIS/Include/core_cm4_simd.h</a> (the definition of other math functions)</p>

<p>Not all assembly functions are available to use, because they are not inserted in math.h and core_cm4_simd.h (which are those two includes i linked above), but don't worry: most of the time you can do everything with C.<br>However, sometimes you can take advantage of specific functions that do very specific operations (and it's the case of the fixed point math i mentioned above).</p>

<hr>

<h2>
<a name="bitwise"></a>## Bitwise operations</h2>

<p></p><pre><code class="lang-auto">int32_t A = 101;
int32_t B = -394;</code></pre>

<p>These two numbers correspond to the binary</p>

<pre><code>A = 00000000 00000000 00000000 01100101
B = 11111111 11111111 11111110 01110110</code></pre>

<p><strong>Bitwise negation: ~a</strong> (you can write the tilde pressing alt + 126) <br>Every bit is negated (it's switched with its opposite)<br></p>

<p></p><pre><code class="lang-auto">int32_t C = ~A;
int32_t D = ~B;</code></pre>

<p>Will output these two numbers: </p>

<pre><code>C = 11111111 11111111 11111111 10011010 = -102
D = 00000000 00000000 00000001 10001001 = 393</code></pre>

<p><strong>Bitwise and: a&amp;b</strong><br>This operation is performed between two variables (they should have the same size!)<br>An and operation between two bits outputs 1 if and only if both bits are set to 1, otherwise it will output 0:<br>0 &amp; 0 = 0<br>0 &amp; 1 = 0<br>1 &amp; 0 = 0<br>1 &amp; 1 = 1<br>This is done for every bit of the two words<br></p>

<p></p><pre><code class="lang-auto">int32_t E = A &amp; B;</code></pre>

<p>Will output </p>

<p><code>E = 00000000 00000000 00000000 01100100 = 100</code></p>

<p><strong>Bitwise or: a|b</strong><br>This operation is performed between two variables (they should have the same size!)<br>An or operation between two bits outputs 0 if and only if both bits are set to 0, otherwise it will output 1;<br>0 | 0 = 0<br>0 | 1 = 1<br>1 | 0 = 1<br>1 | 1 = 1<br>This is done for every bit of the two words<br></p>

<p></p><pre><code class="lang-auto">int32_t F = A | B;</code></pre>

<p>Will output </p>

<p><code>F = 11111111 11111111 11111110 01110111 = -393</code></p>
          </blockquote>
          <p><a href="https://sebiik.github.io/community.axoloti.com.backup/t/coding-axoloti-objects/2606/1">Read full topic</a></p>
        ]]></description>
        <link>https://sebiik.github.io/community.axoloti.com.backup/t/coding-axoloti-objects/2606/1</link>
        <pubDate>Mon, 05 Dec 2016 22:44:18 +0000</pubDate>
        <guid isPermaLink="false">community.axoloti.com-post-2606-1</guid>
        <source url="https://sebiik.github.io/community.axoloti.com.backup/t/coding-axoloti-objects/2606.rss">Coding axoloti objects</source>
      </item>
  </channel>
</rss>
