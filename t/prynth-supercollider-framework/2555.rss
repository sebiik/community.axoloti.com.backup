<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Prynth Supercollider Framework</title>
    <link>https://sebiik.github.io/community.axoloti.com.backup/t/prynth-supercollider-framework/2555</link>
    <description>This popped up in my feed somewhere and seems relevant to our community&#39;s interests:
https://prynth.github.io/

It seems to be based on a custom Raspberry Pi Linux image running Supercollider (a fascinating dsp server / language). Unclear what kind of latency it achieves. What I find to be particularly fascinating about it is that it runs a webserver that serves up a Supercollider code editor where you then edit and manage your patches from a remote machine. This seems like a brilliant idea. Imagine if a piece of hardware managed all aspects of the patch editor software this way and updated itself (and ideally knew about the operation of the community library). For a casual user, this could sidestep installation on the host machine and provide reasonably consistent behavior across platforms, assuming the interface were designed to be consistent across browsers.

Anyway, food for thought...!</description>
    
    <lastBuildDate>Thu, 24 Nov 2016 17:52:29 +0000</lastBuildDate>
    <category>Lounge</category>
    <atom:link href="https://sebiik.github.io/community.axoloti.com.backup/t/prynth-supercollider-framework/2555.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>Prynth Supercollider Framework</title>
        <dc:creator><![CDATA[@thetechnobear Mark Harris]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://sebiik.github.io/community.axoloti.com.backup/u/thetechnobear">@thetechnobear</a> wrote:</p>
          <blockquote>
              <p>I had a detailed look at this yesterday.</p>

<p>its an interesting idea... latency (and more importantly jitter) is a concern using a PI, as it doesn't seem to use a specialised realtime linux build.<br>this would actually be more interesting sitting on Bela (and could be adapted easily enough), but im not sure it adds much to Bela, since it already has supercollider running, and a cape for multiplexed analog I/O.<br>but perhaps bela couldl learn something from it.</p>

<p>Im going to follow it though, it will be interesting if users start sharing designs on it...<br>(I was a bit disappointed, they hadn't publish the schematics / SC code for the MITT <img src="//community.axoloti.com/images/emoji/emoji_one/slight_smile.png?v=3" title=":slight_smile:" class="emoji" alt=":slight_smile:"> )</p>
          </blockquote>
          <p><a href="https://sebiik.github.io/community.axoloti.com.backup/t/prynth-supercollider-framework/2555/2">Read full topic</a></p>
        ]]></description>
        <link>https://sebiik.github.io/community.axoloti.com.backup/t/prynth-supercollider-framework/2555/2</link>
        <pubDate>Thu, 24 Nov 2016 17:52:29 +0000</pubDate>
        <guid isPermaLink="false">community.axoloti.com-post-2555-2</guid>
        <source url="https://sebiik.github.io/community.axoloti.com.backup/t/prynth-supercollider-framework/2555.rss">Prynth Supercollider Framework</source>
      </item>
      <item>
        <title>Prynth Supercollider Framework</title>
        <dc:creator><![CDATA[@urklang Nicolas Steven Miller]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://sebiik.github.io/community.axoloti.com.backup/u/urklang">@urklang</a> wrote:</p>
          <blockquote>
              <p>This popped up in my feed somewhere and seems relevant to our community's interests:<br><a href="https://prynth.github.io/" class="onebox" target="_blank" rel="nofollow">https://prynth.github.io/</a></p>

<p>It seems to be based on a custom Raspberry Pi Linux image running Supercollider (a fascinating dsp server / language). Unclear what kind of latency it achieves. What I find to be particularly fascinating about it is that it runs a webserver that serves up a Supercollider code editor where you then edit and manage your patches from a remote machine. This seems like a brilliant idea. Imagine if a piece of hardware managed all aspects of the patch editor software this way and updated itself (and ideally knew about the operation of the community library). For a casual user, this could sidestep installation on the host machine and provide reasonably consistent behavior across platforms, assuming the interface were designed to be consistent across browsers.</p>

<p>Anyway, food for thought...!</p>
          </blockquote>
          <p><a href="https://sebiik.github.io/community.axoloti.com.backup/t/prynth-supercollider-framework/2555/1">Read full topic</a></p>
        ]]></description>
        <link>https://sebiik.github.io/community.axoloti.com.backup/t/prynth-supercollider-framework/2555/1</link>
        <pubDate>Tue, 22 Nov 2016 05:40:00 +0000</pubDate>
        <guid isPermaLink="false">community.axoloti.com-post-2555-1</guid>
        <source url="https://sebiik.github.io/community.axoloti.com.backup/t/prynth-supercollider-framework/2555.rss">Prynth Supercollider Framework</source>
      </item>
  </channel>
</rss>
