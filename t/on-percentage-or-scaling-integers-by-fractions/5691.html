<!DOCTYPE html>
<html lang="en">
  
<!-- Mirrored from community.axoloti.com/t/on-percentage-or-scaling-integers-by-fractions/5691 by HTTrack Website Copier/3.x [XR&CO'2014], Wed, 19 Jul 2023 03:03:02 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta charset="utf-8">
    <title>On percentage (or scaling) integers by fractions - AxoObject coding - Axoloti Community</title>
    <meta name="description" content="Hello, 

I have a conversion question. Look at this code: 

/*
LOCAL VARIABLES
local_ticks_length     cycle duration in K-rate ticks (int32_t)
local_current_tick     current tick (int32_t)
local_cycle_length    percentag&amp;hellip;">
    <meta name="author" content="">
<meta name="generator" content="Discourse 1.9.0.beta3 - https://github.com/discourse/discourse version 13f3de4bf673802eb8ec595d36587b4524773209">
<link rel="icon" type="image/png" href="../../uploads/default/original/1X/ffed196003990f0e5c2a0f8227fc977345cd68be.png">
<link rel="apple-touch-icon" type="image/png" href="../../uploads/default/original/1X/ffed196003990f0e5c2a0f8227fc977345cd68be.png">
<link rel="icon" sizes="144x144" href="../../uploads/default/original/1X/ffed196003990f0e5c2a0f8227fc977345cd68be.png">
<meta name="theme-color" content="#ffffff">
<meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=yes">
<link rel="canonical" href="5691.html" />
<script type="application/ld+json">{"@context":"http://schema.org","@type":"WebSite","url":"https://sebiik.github.io/community.axoloti.com.backup","potentialAction":{"@type":"SearchAction","target":"https://sebiik.github.io/community.axoloti.com.backup/search?q={search_term_string}","query-input":"required name=search_term_string"}}</script>
<link rel="search" type="application/opensearchdescription+xml" href="../../opensearch.xml" title="Axoloti Community Search">

        <link href="../../stylesheets/desktop_d93a33ca8617326fe353f80e6ab865188244d48c8e0b.css?__ws=community.axoloti.com" media="all" rel="stylesheet" data-target="desktop"/>
    
    <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','../../../www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-56017691-4', {"cookieDomain":"auto"});
</script>

      <link rel="alternate" type="application/rss+xml" title="RSS feed of &#39;On percentage (or scaling) integers by fractions&#39;" href="5691.rss" />
  <meta property="og:site_name" content="Axoloti Community" />
<meta name="twitter:card" content="summary" />
<meta name="twitter:image" content="https://sebiik.github.io/community.axoloti.com.backup/uploads/default/original/1X/ffed196003990f0e5c2a0f8227fc977345cd68be.png" />
<meta property="og:image" content="https://sebiik.github.io/community.axoloti.com.backup/uploads/default/original/1X/ffed196003990f0e5c2a0f8227fc977345cd68be.png" />
<meta property="og:url" content="https://sebiik.github.io/community.axoloti.com.backup/t/on-percentage-or-scaling-integers-by-fractions/5691" />
<meta name="twitter:url" content="https://sebiik.github.io/community.axoloti.com.backup/t/on-percentage-or-scaling-integers-by-fractions/5691" />
<meta property="og:title" content="On percentage (or scaling) integers by fractions" />
<meta name="twitter:title" content="On percentage (or scaling) integers by fractions" />
<meta property="og:description" content="Hello,   I have a conversion question. Look at this code:   /* LOCAL VARIABLES local_ticks_length     cycle duration in K-rate ticks (int32_t) local_current_tick     current tick (int32_t) local_cycle_length    percentage of the total length (int32_t)  INLETS inlet_ticks_length    cycle duration in ticks (int32.positive)  PARAMS params_cycle_length   the percentage to apply to the total length (frac32.u.map) */  // PLEASE HELP ME!!! local_cycle_length = local_ticks_length * (params_cycle_length ..." />
<meta name="twitter:description" content="Hello,   I have a conversion question. Look at this code:   /* LOCAL VARIABLES local_ticks_length     cycle duration in K-rate ticks (int32_t) local_current_tick     current tick (int32_t) local_cycle_length    percentage of the total length (int32_t)  INLETS inlet_ticks_length    cycle duration in ticks (int32.positive)  PARAMS params_cycle_length   the percentage to apply to the total length (frac32.u.map) */  // PLEASE HELP ME!!! local_cycle_length = local_ticks_length * (params_cycle_length ..." />


  </head>
  <body class="crawler">
    
    <header>
      <a href="../../index.html"><img src="../../uploads/default/original/1X/b22e6e9ef608f1e17a1de19b733d043beff77f05.png" alt="Axoloti Community" id="site-logo" style="max-width: 150px;"></a>
    </header>
    <div id="main-outlet" class="wrap">
      <h1>
  <a href="5691.html">On percentage (or scaling) integers by fractions</a>
</h1>

<div id='breadcrumbs'>
    <div id="breadcrumb-0" itemscope itemtype="http://data-vocabulary.org/Breadcrumb"
>
      <a href="../../c/axoobject-code.html" itemprop="url">
        <span itemprop="title">AxoObject coding</span>
      </a>
    </div>
</div>





<hr>


  <div itemscope itemtype='http://schema.org/DiscussionForumPosting'>
      <div class='creator'>
        <span>
          <a href='../../u/lodevalm.html'><b itemprop='author'>lodevalm</b></a>
           
           <time datetime='2019-05-08T09:25:32Z' itemprop='datePublished'>
             2019-05-08 09:25:32 UTC
           </time>
        </span>
        <span itemprop='position'>#1</span>
      </div>
      <div class='post' itemprop='articleBody'>
        <p>Hello,</p>

<p>I have a conversion question.<br>Look at this code:</p>

<pre><code>/*
LOCAL VARIABLES
local_ticks_length     cycle duration in K-rate ticks (int32_t)
local_current_tick     current tick (int32_t)
local_cycle_length    percentage of the total length (int32_t)

INLETS
inlet_ticks_length    cycle duration in ticks (int32.positive)

PARAMS
params_cycle_length   the percentage to apply to the total length (frac32.u.map)
*/

// PLEASE HELP ME!!!
local_cycle_length = local_ticks_length * (params_cycle_length / 64);
local_current_tick = local_current_tick + 1 % local_cycle_length;</code></pre>

<p>This is a part of an object that cycles and then triggers at the beginning of the cycle.<br>What I need to do is scaling the length of the cycle using a frac32.u.map:</p>

<pre><code>local_ticks_length * (params_cycle_length / 64);</code></pre>

<p>where 64 is the upper value of the frac32.u.map. <br>I have no idea on how to convert those variables in order to cycle only in the range of the scaled length.<br>Any help would be very appreciated!</p>

<p>Thanks!<br>Daniele</p>
      </div>
      <meta itemprop='interactionCount' content='UserLikes:0'>
      <meta itemprop='interactionCount' content='UserComments:0'>
      <meta itemprop='headline' content='On percentage (or scaling) integers by fractions'>
      <hr>
  </div>
  <div itemscope itemtype='http://schema.org/DiscussionForumPosting'>
      <div class='creator'>
        <span>
          <a href='../../u/lodevalm.html'><b itemprop='author'>lodevalm</b></a>
           
           <time datetime='2019-05-09T19:20:38Z' itemprop='datePublished'>
             2019-05-09 19:20:38 UTC
           </time>
        </span>
        <span itemprop='position'>#2</span>
      </div>
      <div class='post' itemprop='articleBody'>
        <p>Here is a patch to show what I need:</p>

<p>Press the toggle button for some seconds then press it again:</p>

<p><a class="attachment" href="../../uploads/default/original/2X/c/cycles.axp">cycles.axp</a> (4.3 KB)</p>

<p>And here is the updated code, but I still don't get floating point math...</p>

<pre><code>//reset when updating cycle length
if (local_ticks_length != inlet_ticks) {
  local_ticks_length = inlet_ticks;
  local_current_tick = 0;
  local_count = 0;
}

//do nothing if length is zero
if (local_ticks_length == 0) {
  outlet_trigger = false;
  return;
}

disp_ticks = local_ticks_length;
disp_count = local_count;

if (param_cycle &gt; 0) {
  int32_t max = 0x07FFFFFF;
  outlet_test = max;
  // please help me! :-)
  // I need to convert this to correct types and round it before the % operator!
  local_cycle_length = local_ticks_length * (param_cycle / max);
  local_current_tick = (local_current_tick + 1) % local_cycle_length;
} else {
  //increase current tick
  local_current_tick = (local_current_tick + 1) % local_ticks_length;
}

//increase current tick
// local_current_tick = (local_current_tick + 1) % local_ticks_length;

if (local_current_tick == 0) {
  local_count ++;
  outlet_trigger = 1;
} else {
  outlet_trigger = 0;
}</code></pre>
      </div>
      <meta itemprop='interactionCount' content='UserLikes:0'>
      <meta itemprop='interactionCount' content='UserComments:0'>
      <meta itemprop='headline' content='On percentage (or scaling) integers by fractions'>
      <hr>
  </div>
  <div itemscope itemtype='http://schema.org/DiscussionForumPosting'>
      <div class='creator'>
        <span>
          <a href='../../u/lodevalm.html'><b itemprop='author'>lodevalm</b></a>
           
           <time datetime='2019-05-10T07:50:50Z' itemprop='datePublished'>
             2019-05-10 07:50:50 UTC
           </time>
        </span>
        <span itemprop='position'>#3</span>
      </div>
      <div class='post' itemprop='articleBody'>
        <p>Ok, so...i did a first attempt using "fixed point math", using this article:</p>

<aside class="onebox whitelistedgeneric">
  <header class="source">
    <a href="https://spin.atomicobject.com/2012/03/15/simple-fixed-point-math/" target="_blank" rel="nofollow noopener">spin.atomicobject.com</a>
  </header>
  <article class="onebox-body">
    <img src="../../../spin.atomicobject.com/wp-content/uploads/AO-Logo-Wordmark-Color.png" width="" height="" class="thumbnail">

<h3><a href="https://spin.atomicobject.com/2012/03/15/simple-fixed-point-math/" target="_blank" rel="nofollow noopener">Simple Fixed-Point Math</a></h3>

<p>A quick introduction/tutorial on simple fixed-point math.</p>

  </article>
  <div class="onebox-metadata">
    
    
  </div>
  <div style="clear: both"></div>
</aside>


<p>Now the code to calculate the scaling looks like:</p>

<pre><code>// first attempt to scale:
int32_t max = 0x07FFFFFF;
int32_t perc = ((int64_t)param_cycle * (int64_t)max) / (1 &lt;&lt; 16);
local_cycle_length = ((int64_t)local_ticks_length * (1 &lt;&lt; 16)) / perc;</code></pre>

<p>But I still don't get the expected result...</p>

<p><a class="attachment" href="../../uploads/default/original/2X/f/cycles.axp">cycles.axp</a> (4.7 KB)</p>
      </div>
      <meta itemprop='interactionCount' content='UserLikes:0'>
      <meta itemprop='interactionCount' content='UserComments:0'>
      <meta itemprop='headline' content='On percentage (or scaling) integers by fractions'>
      <hr>
  </div>
  <div itemscope itemtype='http://schema.org/DiscussionForumPosting'>
      <div class='creator'>
        <span>
          <a href='../../u/cabalowen.html'><b itemprop='author'>cabalowen</b></a>
           
           <time datetime='2022-12-07T11:23:02Z' itemprop='datePublished'>
             2022-12-07 11:23:02 UTC
           </time>
        </span>
        <span itemprop='position'>#4</span>
      </div>
      <div class='post' itemprop='articleBody'>
        <p>I have done this on Python -</p>

<p>There are a few ways to create a fraction in Python, and they all involve using the Fraction class. It’s the only thing you ever need to import from the fractions module. The class constructor accepts zero, one, or two arguments of various types:</p>

<blockquote><blockquote><blockquote><p>from fractions import Fraction<br>print(Fraction())<br>0<br>print(Fraction(0.75))<br>3/4<br>print(Fraction(3, 4))<br>3/4<br>When you call the class constructor without arguments, it creates a new fraction representing the number zero. A single-argument flavor attempts to convert the value of another data type to a fraction. Passing in a second argument makes the constructor expect a numerator and a denominator, which must be instances of the Rational class or its descendants.</p></blockquote></blockquote></blockquote>

<p>Note that you must print() a fraction to reveal its human-friendly textual representation with the slash character (/) between the numerator and the denominator. If you don’t, it will fall back to a slightly more explicit string representation made up of a piece of Python code. You’ll learn how to convert fractions to strings later in this tutorial.</p>

<p>Rational Numbers<br>When you call the Fraction() constructor with two arguments, they must both be rational numbers such as integers or other fractions. If either the numerator or denominator isn’t a rational number, then you won’t be able to create a new fraction:</p>

<blockquote><blockquote><blockquote><p>Fraction(3, 4.0)<br>Traceback (most recent call last):<br>  ...<br>    raise TypeError("both arguments should be "<br>TypeError: both arguments should be Rational instances<br>You get a TypeError instead. Although 4.0 is a rational number in mathematics, it isn’t considered as such by Python. That’s because the value is stored as a floating-point data type, which is too broad and can be used to represent any real number.</p></blockquote></blockquote></blockquote>

<p>Note: The floating-point data type can’t store irrational numbers in a computer’s memory precisely due to their non-terminating and non-repeating decimal expansion. In practice, though, it’s not a big deal because their approximations will usually be good enough. The only truly reliable way to do so would require using symbolic computation on conventional symbols like π.</p>

<p>Similarly, you can’t create a fraction whose denominator is zero because that would lead to a division by zero, which is undefined and has no meaning in mathematics:</p>

<blockquote><blockquote><blockquote>
<p>Fraction(3, 0)<br>Traceback (most recent call last):<br>  ...<br>    raise ZeroDivisionError('Fraction(%s, 0)' % numerator)<br>ZeroDivisionError: Fraction(3, 0)<br>Python raises the ZeroDivisionError. However, when you specify a valid numerator and a valid denominator, they’ll be automatically normalized for you as long as they have a common divisor:</p>
<p>Fraction(9, 12)  # GCD(9, 12) = 3<br>Fraction(3, 4)</p>
<p>Fraction(0, 12)  # GCD(0, 12) = 12<br>Fraction(0, 1)<br>Both magnitudes get simplified by their greatest common divisor (GCD), which happens to be three and twelve, respectively. The normalization also takes the minus sign into account when you define negative fractions:</p>
<p>-Fraction(9, 12)<br>Fraction(-3, 4)</p>
<p>Fraction(-9, 12)<br>Fraction(-3, 4)</p>
<p>Fraction(9, -12)<br>Fraction(-3, 4)<br>Whether you put the minus sign before the constructor or before either of the arguments, for consistency, Python will always associate the sign of a fraction with its numerator. There’s currently a way of disabling this behavior, but it’s undocumented and could get removed in the future.</p>
</blockquote></blockquote></blockquote>

<p>You’ll typically define fractions as a quotient of two integers. Whenever you provide only one integer, Python will turn that number into an improper fraction by assuming the denominator is 1:</p>

<blockquote><blockquote><blockquote>
<p>Fraction(3)<br>Fraction(3, 1)<br>Conversely, if you skip both arguments, the numerator will be 0:</p>
<p>Fraction()<br>Fraction(0, 1)<br>You don’t always have to provide integers for the numerator and denominator, though. The documentation states that they can be any rational numbers, including other fractions:</p>
<p>one_third = Fraction(1, 3)</p>
<p>Fraction(one_third, 3)<br>Fraction(1, 9)</p>
<p>Fraction(3, one_third)<br>Fraction(9, 1)</p>
<p>Fraction(one_third, one_third)<br>Fraction(1, 1)<br>In each case, you’ll get a fraction as a result, even though they sometimes represent integer values like 9 and 1. Later, you’ll see how to convert fractions to other data types.</p>
</blockquote></blockquote></blockquote>

<p>What happens if you give the Fraction constructor a single argument that also happens to be a fraction? Try this code to find out:</p>

<blockquote><blockquote><blockquote>
<p>Fraction(one_third) == one_third<br>True</p>
<p>Fraction(one_third) is one_third<br>False<br>You’re getting the same value, but it’s a distinct copy of the input fraction. That’s because calling the constructor always produces a new instance, which coincides with the fact that fractions are immutable, just like other numeric types in Python.</p>
</blockquote></blockquote></blockquote>

<p>Remove ads<br>Floating-Point and Decimal Numbers<br>So far, you’ve only used rational numbers to create fractions. After all, the two-argument version of the Fraction constructor requires that both numbers are Rational instances. However, that’s not the case with the single-argument constructor, which will happily accept any real number and even a non-numeric value such as a string.</p>

<p>Two prime examples of real number data types in Python are float and decimal.Decimal. While only the latter can represent rational numbers exactly, both can approximate irrational numbers just fine. Related to this, if you were wondering, Fraction is similar to Decimal in this regard since it’s a descendant of Real.</p>

<p>Before Python 3.2, you could only create fractions from real numbers using the .from_float() and .from_decimal() class methods. While not deprecated, they’re redundant today because the Fraction constructor can take both data types directly as an argument:</p>

<blockquote><blockquote><blockquote>
<p>from decimal import Decimal<br>Fraction(0.75) == Fraction(Decimal("0.75"))<br>True<br>Whether you make Fraction objects from float or Decimal objects, their values are the same. You’ve seen a fraction created from a floating-point value before:</p>
<p>print(Fraction(0.75))<br>3/4<br>The result is the same number expressed in fractional notation. However, this code works as expected only by coincidence. In most cases, you won’t get the intended value due to the representation error that affects float numbers, whether they’re rational or not:</p>
<p>print(Fraction(0.1))<br>3602879701896397/36028797018963968<br>Whoa! What happened here?</p>
</blockquote></blockquote></blockquote>

<p>Let’s break it down in slow motion. The previous number, which can be represented as either 0.75 or ¾, can also be expressed as the sum of ½ and ¼, which are negative powers of 2 that have exact binary representations. On the other hand, the number ⅒ can only be approximated with a non-terminating repeating expansion of binary digits:</p>

<p>The Binary Expansion of One Tenth<br>Because the binary string must eventually end due to the finite memory, its tail gets rounded. By default, Python only shows the most significant digits defined in sys.float_info.dig, but you can format a floating-point number with an arbitrary number of digits if you want to:</p>

<blockquote><blockquote><blockquote>
<p>str(0.1)<br>'0.1'</p>
<p>format(0.1, ".17f")<br>'0.10000000000000001'<br>format(0.1, ".18f")<br>'0.100000000000000006'<br>format(0.1, ".19f")<br>'0.1000000000000000056'<br>format(0.1, ".55f")<br>'0.1000000000000000055511151231257827021181583404541015625'<br>When you pass a float or a Decimal number to the Fraction constructor, it calls their .as_integer_ratio() method to obtain a tuple of two irreducible integers whose ratio gives precisely the same decimal expansion as the input argument. These two numbers are then assigned to the numerator and denominator of your new fraction.</p>
</blockquote></blockquote></blockquote>

<p>Note: Since Python 3.8, Fraction also implements .as_integer_ratio() to complement other numeric types. It can help convert your fraction into a tuple, for example.</p>

<p>Now, you can piece together where these two big numbers came from:</p>

<blockquote><blockquote><blockquote>
<p>Fraction(0.1)<br>Fraction(3602879701896397, 36028797018963968)</p>
<p>(0.1).as_integer_ratio()<br>(3602879701896397, 36028797018963968)<br>If you pull out your pocket calculator and punch these numbers in, then you’ll get back 0.1 as a result of the division. However, if you were to divide them by hand or use a tool like WolframAlpha, then you’d end up with those fifty-five decimal places you saw earlier.</p>
</blockquote></blockquote></blockquote>

<p>There is a way to find close approximations of your fraction that have more down-to-earth values. You can use .limit_denominator(), for example, which you’ll learn more about later in this tutorial:</p>

<blockquote><blockquote><blockquote>
<p>one_tenth = Fraction(0.1)<br>one_tenth<br>Fraction(3602879701896397, 36028797018963968)</p>
<p>one_tenth.limit_denominator()<br>Fraction(1, 10)</p>
<p>one_tenth.limit_denominator(max_denominator=int(1e16))<br>Fraction(1000000000000000, 9999999999999999)<br>This might not always give you the best approximation, though. The bottom line is that you should never try to create fractions straight from real numbers such as float if you want to avoid the rounding errors that will likely come up. Even the Decimal class might be susceptible to that if you’re not careful enough.</p>
</blockquote></blockquote></blockquote>

<p>Anyway, fractions let you communicate the decimal notation most accurately with a string in their constructor.</p>

<p>Strings<br>There are two string formats that the Fraction constructor accepts, which correspond to decimal and fractional notation:</p>

<blockquote><blockquote><blockquote>
<p>Fraction("0.1")<br>Fraction(1, 10)</p>
<p>Fraction("1/10")<br>Fraction(1, 10)<br>Both notations can optionally have a plus sign (+) or a minus sign (-), while the decimal one can additionally include the exponent in case you want to use the scientific notation:</p>
<p>Fraction("-2e-3")<br>Fraction(-1, 500)</p>
<p>Fraction("+2/1000")<br>Fraction(1, 500)<br>The only difference between the two results is that one is negative and one is positive.</p>
</blockquote></blockquote></blockquote>

<p>When you use the fractional notation, you can’t use whitespace characters around the slash character (/):</p>

<blockquote><blockquote><blockquote><p>Fraction("1 / 10")<br>Traceback (most recent call last):<br>  ...<br>    raise ValueError('Invalid literal for Fraction: %r' %<br>ValueError: Invalid literal for Fraction: '1 / 10'<br>To find out exactly which strings are valid or not, you can explore the regular expression in the module’s source code. Remember to create fractions from a string or a correctly instantiated Decimal object rather than a float value so that you can retain maximum precision.</p></blockquote></blockquote></blockquote>

<p>Now that you’ve created a few fractions, you might be wondering what they can do for you other than group two numbers. That’s a great question!</p>

<p>Inspecting a Python Fraction<br>The Rational abstract base class defines two read-only attributes for accessing a fraction’s numerator and denominator:</p>

<blockquote><blockquote><blockquote>
<p>from fractions import Fraction<br>half = Fraction(1, 2)<br>half.numerator<br>1<br>half.denominator<br>2<br>Since fractions are immutable, you can’t change their internal state:</p>
<p>half.numerator = 2<br>Traceback (most recent call last):<br>  File "", line 1, in <br>AttributeError: can't set attribute<br>If you try assigning a new value to one of the fraction’s attributes, then you’ll get an error. In fact, you have to create a new fraction whenever you’d like to modify one. For example, to invert your fraction, you could call .as_integer_ratio() to get a tuple and then use the slicing syntax to reverse its elements:</p>
<p>Fraction(*half.as_integer_ratio()[::-1])<br>Fraction(2, 1)<br>The unary star operator (*) unpacks your reversed tuple and relays its elements to the Fraction constructor.</p>
</blockquote></blockquote></blockquote>

<p>Another useful method that comes with every fraction lets you find the closest rational approximation to a number given in the decimal notation. It’s the .limit_denominator() method, which you’ve already touched on earlier in this tutorial. You can optionally request the maximum denominator for your approximation:</p>

<blockquote><blockquote><blockquote>
<p>pi = Fraction("3.141592653589793")</p>
<p>pi<br>Fraction(3141592653589793, 1000000000000000)</p>
<p>pi.limit_denominator(20_000)<br>Fraction(62813, 19994)</p>
<p>pi.limit_denominator(100)<br>Fraction(311, 99)</p>
<p>pi.limit_denominator(10)<br>Fraction(22, 7)<br>The initial approximation might not be the most convenient to use, but it is the most faithful. This method can also help you recover a rational number stored as a floating-point data type. Basically <br>I have to do the same and implement on <a href="https://enterprise.affle.com/ios-app-development" rel="nofollow noopener">iphone app development agency</a>. Remember that float may not represent all rational numbers exactly, even when they have terminating decimal expansions:</p>
<p>pi = Fraction(3.141592653589793)</p>
<p>pi<br>Fraction(884279719003555, 281474976710656)</p>
<p>pi.limit_denominator()<br>Fraction(3126535, 995207)</p>
<p>pi.limit_denominator(10)<br>Fraction(22, 7)<br>You’ll notice a different result on the highlighted line as compared to the previous code block, even though the float instance looks the same as the string literal that you passed to the constructor before! Later, you’ll explore an example of using .limit_denominator() to find approximations of irrational numbers.</p>
</blockquote></blockquote></blockquote>

<p>Converting a Python Fraction to Other Data Types<br>You’ve learned how to create fractions from the following data types:</p>

<p>str<br>int<br>float<br>decimal.Decimal<br>fractions.Fraction<br>What about the opposite? How do you convert a Fraction instance back to these types? You’ll find out in this section.</p>

<p>Floating-Point and Integer Numbers<br>Converting between native data types in Python usually involves calling one of the built-in functions such as int() or float() on an object. These conversions work as long as the object implements the corresponding special methods such as .<strong>int</strong>() or .<strong>float</strong>(). Fractions happen to inherit only the latter from the Rational abstract base class:</p>

<blockquote><blockquote><blockquote>
<p>from fractions import Fraction<br>three_quarters = Fraction(3, 4)</p>
<p>float(three_quarters)<br>0.75</p>
<p>three_quarters.<strong>float</strong>()  # Don't call special methods directly<br>0.75</p>
<p>three_quarters.<strong>int</strong>()<br>Traceback (most recent call last):<br>  File "", line 1, in <br>AttributeError: 'Fraction' object has no attribute '<strong>int</strong>'<br>You’re not supposed to call special methods on objects directly, but it’s helpful for demonstration purposes. Here, you’ll notice that fractions implement only .<strong>float</strong>() and not .<strong>int</strong>().</p>
</blockquote></blockquote></blockquote>

<p>When you investigate the source code, you’ll notice that the .<strong>float</strong>() method conveniently divides a fraction’s numerator by its denominator to get a floating-point number:</p>

<blockquote><blockquote><blockquote>
<p>three_quarters.numerator / three_quarters.denominator<br>0.75<br>Bear in mind that turning a Fraction instance into a float instance will likely result in a lossy conversion, meaning you might end up with a number that’s slightly off:</p>
<p>float(Fraction(3, 4)) == Fraction(3, 4)<br>True</p>
<p>float(Fraction(1, 3)) == Fraction(1, 3)<br>False</p>
<p>float(Fraction(1, 10)) == Fraction(1, 10)<br>False<br>Although fractions don’t provide the implementation for the integer conversion, all real numbers can be truncated, which is a fall-back for the int() function:</p>
<p>fraction = Fraction(14, 5)</p>
<p>int(fraction)<br>2</p>
<p>import math<br>math.trunc(fraction)<br>2</p>
<p>fraction.<strong>trunc</strong>()  # Don't call special methods directly<br>2<br>You’ll discover a few other related methods in a section about rounding fractions later on.</p>
</blockquote></blockquote></blockquote>

<p>Decimal Numbers<br>If you try creating a Decimal number from a Fraction instance, then you’ll quickly find out that such a direct conversion isn’t possible:</p>

<blockquote><blockquote><blockquote>
<p>from decimal import Decimal<br>Decimal(Fraction(3, 4))<br>Traceback (most recent call last):<br>  File "", line 1, in <br>TypeError: conversion from Fraction to Decimal is not supported<br>When you try, you get a TypeError. Since a fraction represents a division, however, you can bypass that limitation by wrapping only one of the numbers with Decimal and dividing them manually:</p>
<p>fraction = Fraction(3, 4)<br>fraction.numerator / Decimal(fraction.denominator)<br>Decimal('0.75')<br>Unlike float but similar to Fraction, the Decimal data type is free from the floating-point representation error. So, when you convert a rational number that can’t be represented exactly in binary floating-point, you’ll retain the number’s precision:</p>
<p>fraction = Fraction(1, 10)<br>decimal = fraction.numerator / Decimal(fraction.denominator)</p>
<p>fraction == decimal<br>True</p>
<p>fraction == 0.1<br>False</p>
<p>decimal == 0.1<br>False<br>At the same time, rational numbers with non-terminating repeating decimal expansion will lead to precision loss when converted from fractional to decimal notation:</p>
<p>fraction = Fraction(1, 3)<br>decimal = fraction.numerator / Decimal(fraction.denominator)</p>
<p>fraction == decimal<br>False</p>
<p>decimal<br>Decimal('0.3333333333333333333333333333')<br>That’s because there’s an infinite number of threes in the decimal expansion of one-third, or Fraction(1, 3), while the Decimal type has a fixed precision. By default, it stores only twenty-eight decimal places. You can adjust it if you want, but it’s going to be finite nevertheless.</p>
</blockquote></blockquote></blockquote>

<p>Strings<br>The string representation of fractions reveals their values using the familiar fractional notation, while their canonical representation outputs a piece of Python code comprised of a call to the Fraction constructor:</p>

<blockquote><blockquote><blockquote>
<p>one_third = Fraction(1, 3)</p>
<p>str(one_third)<br>'1/3'</p>
<p>repr(one_third)<br>'Fraction(1, 3)'<br>Whether you use str() or repr(), the result is a string, but their contents are different.</p>
</blockquote></blockquote></blockquote>

<p>Unlike other numeric types, fractions don’t support string formatting in Python:</p>

<blockquote><blockquote><blockquote>
<p>from decimal import Decimal<br>format(Decimal("0.3333333333333333333333333333"), ".2f")<br>'0.33'</p>
<p>format(Fraction(1, 3), ".2f")<br>Traceback (most recent call last):<br>  File "", line 1, in <br>TypeError: unsupported format string passed to Fraction.<strong>format</strong><br>If you try, then you get a TypeError. That might be an issue if you’d like to refer to a Fraction instance in a string template to fill out the placeholders, for example. On the other hand, you can quickly fix this by converting fractions to floating-point numbers, especially as you don’t need to care about precision in such a scenario.</p>
</blockquote></blockquote></blockquote>

<p>If you’re working in a Jupyter Notebook, then you might want to render LaTeX formulas based on your fractions instead of their regular textual representation. To do that, you must monkey patch the Fraction data type by adding a new method, .<em>repr</em>pretty_(), which Jupyter Notebook recognizes:</p>

<p>from fractions import Fraction<br>from IPython.display import display, Math</p>

<p>Fraction.<em>repr</em>pretty_ = lambda self, *args: \<br>    display(Math(rf"$$\frac{{{self.numerator}}}{{{self.denominator}}}"))<br>It wraps a piece of LaTeX markup in a Math object and sends it to your notebook’s rich display, which can render the markup using the MathJax library:</p>

<p>LaTeX Fraction In a Jupyter Notebook<br>The next time you evaluate a notebook cell that contains a Fraction instance, it’ll draw a beautiful math formula instead of printing text.</p>

<p>Performing Rational Number Arithmetic on Fractions<br>As mentioned before, you can use fractions in arithmetic expressions consisting of other numeric types. Fractions will interoperate with most numeric types except for decimal.Decimal, which has its own set of rules. Moreover, the data type of the other operand, regardless of whether it lies to the left or the right of your fraction, will determine the type of your arithmetic operation’s result.</p>

<p>Addition<br>You can add two or more fractions without having to think about reducing them to their common denominator:</p>

<blockquote><blockquote><blockquote>
<p>from fractions import Fraction<br>Fraction(1, 2) + Fraction(2, 3) + Fraction(3, 4)<br>Fraction(23, 12)<br>The result is a new fraction that’s the sum of all the input fractions. The same will happen when you add up integers and fractions:</p>
<p>Fraction(1, 2) + 3<br>Fraction(7, 2)<br>However, as soon as you start mixing fractions with non-rational numbers—that is, numbers that aren’t subclasses of numbers.Rational—then your fraction will be converted to that type first before being added:</p>
<p>Fraction(3, 10) + 0.1<br>0.4</p>
<p>float(Fraction(3, 10)) + 0.1<br>0.4<br>You get the same result whether or not you explicitly use float(). That conversion may result in some loss of precision since your fraction as well as the outcome are now stored in floating-point representation. Even though the number 0.4 seems right, it’s not exactly equal to the fraction 4/10.</p>
</blockquote></blockquote></blockquote>

<p>Subtraction<br>Subtracting fractions is no different than adding them. Python will find the common denominator for you:</p>

<blockquote><blockquote><blockquote>
<p>Fraction(3, 4) - Fraction(2, 3) - Fraction(1, 2)<br>Fraction(-5, 12)</p>
<p>Fraction(4, 10) - 0.1<br>0.30000000000000004<br>This time, the precision loss is so significant that it’s visible at a glance. Notice the long stream of zeros followed by a digit 4 at the end of the decimal expansion. It’s the result of rounding a value that would otherwise require an infinite number of binary digits.</p>
</blockquote></blockquote></blockquote>

<p>Multiplication<br>When you multiply two fractions, their numerators and denominators get multiplied element-wise, and the resulting fraction gets automatically reduced if necessary:</p>

<blockquote><blockquote><blockquote>
<p>Fraction(1, 4) * Fraction(3, 2)<br>Fraction(3, 8)</p>
<p>Fraction(1, 4) * Fraction(4, 5)  # The result is 4/20<br>Fraction(1, 5)</p>
<p>Fraction(1, 4) * 3<br>Fraction(3, 4)</p>
<p>Fraction(1, 4) * 3.0<br>0.75<br>Again, depending on the type of the other operand, you’ll end up with a different data type in the result.</p>
</blockquote></blockquote></blockquote>

<p>Division<br>There are two division operators in Python, and fractions support both of them:</p>

<p>True division: /<br>Floor division: //<br>The true division results in another fraction, while a floor division always returns a whole number with the fractional part truncated:</p>

<blockquote><blockquote><blockquote>
<p>Fraction(7, 2) / Fraction(2, 3)<br>Fraction(21, 4)</p>
<p>Fraction(7, 2) // Fraction(2, 3)<br>5</p>
<p>Fraction(7, 2) / 2<br>Fraction(7, 4)</p>
<p>Fraction(7, 2) // 2<br>1</p>
<p>Fraction(7, 2) / 2.0<br>1.75</p>
<p>Fraction(7, 2) // 2.0<br>1.0<br>Note that the floor division’s result isn’t always an integer! The result may end up a float depending on what data type you use together with the fraction. Fractions also support the modulo operator (%) as well as the divmod() function, which might help in creating mixed fractions from improper ones:</p>
<p>def mixed(fraction):<br>...     floor, rest = divmod(fraction.numerator, fraction.denominator)<br>...     return f"{floor} and {Fraction(rest, fraction.denominator)}"<br>...<br>mixed(Fraction(22, 7))<br>'3 and 1/7'<br>Instead of generating a string like in the output above, you could update the function to return a tuple comprised of the whole part and the fractional remainder. Go ahead and try modifying the return value of the function to see the difference.</p>
</blockquote></blockquote></blockquote>

<p>Exponentiation<br>You can raise fractions to a power with the binary exponentiation operator (**) or the built-in pow() function. You can also use fractions themselves as exponents. Go back to your Python interpreter now and start exploring how to raise fractions to a power:</p>

<blockquote><blockquote><blockquote>
<p>Fraction(3, 4) ** 2<br>Fraction(9, 16)</p>
<p>Fraction(3, 4) ** (-2)<br>Fraction(16, 9)</p>
<p>Fraction(3, 4) ** 2.0<br>0.5625<br>You’ll notice that you can use both positive and negative exponent values. When the exponent isn’t a Rational number, your fraction is automatically converted to float before proceeding.</p>
</blockquote></blockquote></blockquote>

<p>Things get more complicated when the exponent is a Fraction instance. Since fractional powers typically produce irrational numbers, both operands are converted to float unless the base and the exponent are whole numbers:</p>

<blockquote><blockquote><blockquote>
<p>2 ** Fraction(2, 1)<br>4</p>
<p>2.0 ** Fraction(2, 1)<br>4.0</p>
<p>Fraction(3, 4) ** Fraction(1, 2)<br>0.8660254037844386</p>
<p>Fraction(3, 4) ** Fraction(2, 1)<br>Fraction(9, 16)<br>The only time you get a fraction as a result is when the denominator of the exponent is equal to one and you’re raising a Fraction instance.</p>
</blockquote></blockquote></blockquote>

<p>Hope this will help.</p>
      </div>
      <meta itemprop='interactionCount' content='UserLikes:0'>
      <meta itemprop='interactionCount' content='UserComments:0'>
      <meta itemprop='headline' content='On percentage (or scaling) integers by fractions'>
      <hr>
  </div>






    </div>
    <footer class="container">
      <nav itemscope itemtype='http://schema.org/SiteNavigationElement'>
        <a href='../../index.html'>Home</a>
        <a href="../../categories.html">Categories</a>
        <a href="../../guidelines.html">FAQ/Guidelines</a>
        <a href="../../tos.html">Terms of Service</a>
        <a href="../../privacy.html">Privacy Policy</a>
      </nav>
      <p>Powered by <a href="https://www.discourse.org/">Discourse</a>, best viewed with JavaScript enabled</p>
    </footer>
    
    
  </body>
  

<!-- Mirrored from community.axoloti.com/t/on-percentage-or-scaling-integers-by-fractions/5691 by HTTrack Website Copier/3.x [XR&CO'2014], Wed, 19 Jul 2023 03:03:05 GMT -->
</html>
