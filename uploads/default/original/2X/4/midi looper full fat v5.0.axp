<patch-1.0 appVersion="1.0.12">
   <comment type="patch/comment" x="28" y="14" text="NOTES"/>
   <obj type="table/alloc 16b sdram load" uuid="e6b85dad3ab43565cda93ea4c43c73b668b1cd43" name="midiloop" x="1330" y="14">
      <params/>
      <attribs>
         <combo attributeName="size" selection="2097152"/>
         <file attributeName="filename" file="/midiloopfc"/>
      </attribs>
   </obj>
   <comment type="patch/comment" x="28" y="28" text="DSP load - this fluctuates a bit.Not a lot, but be careful if your patch is maxed out"/>
   <comment type="patch/comment" x="742" y="28" text="CURRENT SETUP"/>
   <comment type="patch/comment" x="742" y="42" text="resolution = 192ppq "/>
   <comment type="patch/comment" x="28" y="56" text="POLYPHONY - Note recording : there is actually a player and recorder for each midi note"/>
   <comment type="patch/comment" x="742" y="56" text="note range: all (127)"/>
   <comment type="patch/comment" x="98" y="70" text="In theory it can play a chord (all notes at same start point) of 32 notes at once. Possibly more..."/>
   <comment type="patch/comment" x="742" y="70" text=" 7 available clipslots, each with a max of 8 bars"/>
   <comment type="patch/comment" x="98" y="84" text="It is capable of playing back and recording more notes than this, and can probably play more than "/>
   <comment type="patch/comment" x="742" y="84" text="input =DIN, "/>
   <comment type="patch/comment" x="126" y="98" text="32(!) at once if they have different start points."/>
   <comment type="patch/comment" x="742" y="98" text="output = internal, port1 (for the test synth)"/>
   <comment type="patch/comment" x="98" y="112" text="You can limit the range of notes it will record/play, which will reduce the dsp load"/>
   <comment type="patch/comment" x="742" y="112" text="channel = 7"/>
   <comment type="patch/comment" x="98" y="126" text="It won&apos;t record notes outside the limits set on the object"/>
   <comment type="patch/comment" x="742" y="140" text="CONTROLS"/>
   <comment type="patch/comment" x="28" y="154" text="OBJECTS - midi sync, plus 5 different objects to record different types of messages - notes, pitchbend, cc, poly touch and mono touch"/>
   <comment type="patch/comment" x="742" y="168" text="0. select clipslot"/>
   <comment type="patch/comment" x="28" y="182" text="RESOLUTION - Highest resolution is 192ppq, lowest is 24ppq. you can set the resolution for each type of midi message in the objects"/>
   <comment type="patch/comment" x="742" y="182" text="1. Trigger an empty clipslot and it starts recording at next bar. If you trigger it again (or if it reaches the maxbar length)  playback will start at beginning of the next bar "/>
   <obj type="disp/bool" uuid="a0ee71d48208b71752cbb8c05e55145106ef3946" name="bool_6" x="1624" y="182">
      <params/>
      <attribs/>
   </obj>
   <comment type="patch/comment" x="756" y="196" text="Trigger a full clipslot and it will start playing at next bar. if already playing, it will restart"/>
   <comment type="patch/comment" x="28" y="210" text=" TABLE SIZE/DATA - Lowering the resolution on the note object  not affect table size needed"/>
   <comment type="patch/comment" x="742" y="210" text="2. click stop to stop at next bar"/>
   <comment type="patch/comment" x="126" y="224" text="Lowering the resolution on the cc/bend/touch recorders will greatly reduce the table size needed"/>
   <comment type="patch/comment" x="742" y="224" text="3. overdub toggles overdub on/off - I don&apos;t think it currently let&apos;s you overdub into an empty slot"/>
   <comment type="patch/comment" x="126" y="238" text="Lowering the amount of clipslots will reduce the table size needed"/>
   <comment type="patch/comment" x="742" y="238" text="4. record button forces record at beginning of next bar, even if slot is full/playing"/>
   <comment type="patch/comment" x="126" y="252" text="Using a smaller table size for the note object (set on the object) will reduce the max number of notes a slot can contain"/>
   <comment type="patch/comment" x="742" y="252" text="5. clear selected clipslot - you can clear a clipslot while another is playing"/>
   <comment type="patch/comment" x="742" y="266" text="6. quantize toggles on /off quantize. quantize amount can be set in the object. so far you can do 1/4, 1/8, 1/16, 1/32. planning to add triplets at some point"/>
   <comment type="patch/comment" x="28" y="280" text="INPUT/OUTPUT DEVICES/CHANNELS - you can set the inputs and outputs and channels in the objects. It will ignore the patch channel settings"/>
   <comment type="patch/comment" x="742" y="280" text="7. Quantization 0-5. if not triplets: 1bar, 1/2bar, 1/4, 1/8th, 1/16th, 1/32nd.    if triplets: 1bar, 1/3,1/6th, etc"/>
   <comment type="patch/comment" x="742" y="294" text="8. set quantize to triplets"/>
   <comment type="patch/comment" x="28" y="308" text="INTERNAL MIDI BUS ROUTING - if you want to record from AND play back from the internal midi bus, use different ports for input and output. "/>
   <comment type="patch/comment" x="742" y="308" text="9. erase shift - if on and you hold a note, any recorded notes that are played (and are the same note) will delete instead of playing"/>
   <comment type="patch/comment" x="168" y="322" text="Otherwise when you overdub it&apos;s going to keep recording it&apos;s own playback. (don&apos;t set input to omni!)"/>
   <comment type="patch/comment" x="742" y="322" text="10. Undo - deletes the last note recorded"/>
   <comment type="patch/comment" x="742" y="336" text="11. save all loops to SD card (interupts playback, and clock will probably need restarting))"/>
   <comment type="patch/comment" x="28" y="350" text="SETTINGS: If you change amount of clipslots or max bar length parameters make sure they match in all recorder objects"/>
   <comment type="patch/comment" x="742" y="350" text="12. Set maximum barlength -  (if 0, or greater than the  maxbar attribute on the  object it will be set to the attribute value)"/>
   <comment type="patch/comment" x="224" y="392" text=" start/stop transport"/>
   <comment type="patch/comment" x="182" y="406" text="(if using external midi clock leave off)"/>
   <comment type="patch/comment" x="406" y="406" text="internal clock speed"/>
   <comment type="patch/comment" x="532" y="406" text="metronom vol"/>
   <comment type="patch/comment" x="686" y="406" text="slot empty/full"/>
   <comment type="patch/comment" x="784" y="406" text="0. clipslot"/>
   <comment type="patch/comment" x="868" y="406" text="1. trigger"/>
   <comment type="patch/comment" x="966" y="406" text="2. stop"/>
   <comment type="patch/comment" x="1120" y="406" text="3. overdub"/>
   <comment type="patch/comment" x="1218" y="406" text="4. record"/>
   <obj type="ctrl/toggle" uuid="42b8134fa729d54bfc8d62d6ef3fa99498c1de99" name="toggle_1" x="238" y="420">
      <params>
         <bool32.tgl name="b" value="0"/>
      </params>
      <attribs/>
   </obj>
   <obj type="ctrl/dial p" uuid="cc5d2846c3d50e425f450c4b9851371b54f4d674" name="dial_2" x="420" y="420">
      <params>
         <frac32.u.map name="value" value="18.0"/>
      </params>
      <attribs/>
   </obj>
   <obj type="ctrl/dial p" uuid="cc5d2846c3d50e425f450c4b9851371b54f4d674" name="dial_1" x="532" y="420">
      <params>
         <frac32.u.map name="value" value="18.5"/>
      </params>
      <attribs/>
   </obj>
   <obj type="disp/bool" uuid="a0ee71d48208b71752cbb8c05e55145106ef3946" name="bool_5" x="700" y="420">
      <params/>
      <attribs/>
   </obj>
   <obj type="ctrl/i" uuid="a3786816db6ea5bc6ac4193a5cccdb2c83b83496" name="i_6" x="784" y="420">
      <params>
         <int32 name="value" value="0"/>
      </params>
      <attribs/>
   </obj>
   <obj type="ctrl/button" uuid="ef3d13774349df85aa9bfecf30dbc91ab8488b3f" name="button_7" x="868" y="420">
      <params>
         <bool32.mom name="b" value="0"/>
      </params>
      <attribs/>
   </obj>
   <obj type="ctrl/button" uuid="ef3d13774349df85aa9bfecf30dbc91ab8488b3f" name="button_2" x="966" y="420">
      <params>
         <bool32.mom name="b" value="0"/>
      </params>
      <attribs/>
   </obj>
   <obj type="ctrl/button" uuid="ef3d13774349df85aa9bfecf30dbc91ab8488b3f" name="button_4" x="1120" y="420">
      <params>
         <bool32.mom name="b" value="0"/>
      </params>
      <attribs/>
   </obj>
   <obj type="ctrl/button" uuid="ef3d13774349df85aa9bfecf30dbc91ab8488b3f" name="button_5" x="1218" y="420">
      <params>
         <bool32.mom name="b" value="0"/>
      </params>
      <attribs/>
   </obj>
   <comment type="patch/comment" x="42" y="504" text="internal midi clock"/>
   <comment type="patch/comment" x="42" y="518" text="same as factory but with inlet for speed (scaled a bit for more usable range)"/>
   <comment type="patch/comment" x="532" y="518" text="12.bar length"/>
   <comment type="patch/comment" x="686" y="518" text="5. clear"/>
   <comment type="patch/comment" x="770" y="518" text="6. quantize"/>
   <comment type="patch/comment" x="854" y="518" text="7.quantization"/>
   <comment type="patch/comment" x="952" y="518" text="8. triplets"/>
   <comment type="patch/comment" x="1120" y="518" text="9. erase shift"/>
   <comment type="patch/comment" x="1218" y="518" text="10. undo "/>
   <comment type="patch/comment" x="1344" y="518" text="11. save loops to SDcard (axo table files, not midi files)"/>
   <obj type="math/*c" uuid="7d5ef61c3bcd571ee6bbd8437ef3612125dfb225" name="*c_1" x="42" y="532">
      <params>
         <frac32.u.map name="amp" value="32.0"/>
      </params>
      <attribs/>
   </obj>
   <obj type="math/+c" uuid="13eec32bd8ad57dd0bb18a02566cc0a117d320e3" name="+c_1" x="140" y="532">
      <params>
         <frac32.u.map name="c" value="8.0"/>
      </params>
      <attribs/>
   </obj>
   <patchobj type="patch/object" uuid="275db011-dcb7-4112-bf40-6c64411dba0a" name="clock_4" x="196" y="532">
      <params/>
      <attribs/>
      <object id="patch/object" uuid="275db011-dcb7-4112-bf40-6c64411dba0a">
         <sDescription>Midi clock master, als outputs Midi clock, start, stop, and continue messages. Sends to midi/in/* objects only.</sDescription>
         <author>Johannes Taelman</author>
         <license>BSD</license>
         <inlets>
            <bool32 name="run" description="Run"/>
            <bool32.rising name="rst" description="Reset"/>
            <frac32.positive name="speed"/>
         </inlets>
         <outlets>
            <bool32 name="active" description="Song is playing"/>
            <int32 name="pos4ppq" description="Position in 4 counts per quarter"/>
            <int32 name="pos24ppq" description="Position in 24 counts per quarter"/>
         </outlets>
         <displays/>
         <params/>
         <attribs/>
         <includes/>
         <code.declaration><![CDATA[bool _active;
int32_t _posfrac;
int32_t _pos24ppq;
bool rstp;]]></code.declaration>
         <code.init><![CDATA[_active = 0;
_posfrac = 0;
_pos24ppq = 0;
rstp = 0;]]></code.init>
         <code.krate><![CDATA[if (inlet_rst & !rstp){
   rstp = 1;
   _posfrac = 0;
   _pos24ppq = 0;
} else if (!inlet_rst){
   rstp = 0;
}
if (inlet_run && !_active) {
  _active = 1;
  if (_pos24ppq) {
    PatchMidiInHandler(MIDI_DEVICE_INTERNAL, 0,MIDI_CONTINUE,0,0);
  } else {
    PatchMidiInHandler(MIDI_DEVICE_INTERNAL, 0,MIDI_START,0,0);
    PatchMidiInHandler(MIDI_DEVICE_INTERNAL, 0,MIDI_TIMING_CLOCK,0,0);
  }
} else if (!inlet_run && _active){
  _active = 0;
  PatchMidiInHandler(MIDI_DEVICE_INTERNAL, 0,MIDI_STOP,0,0);
}if (_active) {
  _posfrac += inlet_speed;
  if (_posfrac & 1<<31) {
    _posfrac &= (1<<31)-1;
    _pos24ppq++;
    PatchMidiInHandler(MIDI_DEVICE_INTERNAL, 0,MIDI_TIMING_CLOCK,0,0);
  }
}
outlet_pos4ppq = _pos24ppq/6;
outlet_pos24ppq = _pos24ppq;]]></code.krate>
      </object>
   </patchobj>
   <obj type="ctrl/i" uuid="a3786816db6ea5bc6ac4193a5cccdb2c83b83496" name="i_8" x="532" y="532">
      <params>
         <int32 name="value" value="8"/>
      </params>
      <attribs/>
   </obj>
   <obj type="ctrl/button" uuid="ef3d13774349df85aa9bfecf30dbc91ab8488b3f" name="button_8" x="686" y="532">
      <params>
         <bool32.mom name="b" value="0"/>
      </params>
      <attribs/>
   </obj>
   <obj type="ctrl/toggle" uuid="42b8134fa729d54bfc8d62d6ef3fa99498c1de99" name="toggle_2" x="770" y="532">
      <params>
         <bool32.tgl name="b" value="1"/>
      </params>
      <attribs/>
   </obj>
   <obj type="ctrl/i" uuid="a3786816db6ea5bc6ac4193a5cccdb2c83b83496" name="i_7" x="854" y="532">
      <params>
         <int32 name="value" value="4"/>
      </params>
      <attribs/>
   </obj>
   <obj type="ctrl/toggle" uuid="42b8134fa729d54bfc8d62d6ef3fa99498c1de99" name="toggle_4" x="952" y="532">
      <params>
         <bool32.tgl name="b" value="0"/>
      </params>
      <attribs/>
   </obj>
   <obj type="ctrl/toggle" uuid="42b8134fa729d54bfc8d62d6ef3fa99498c1de99" name="toggle_3" x="1120" y="532">
      <params>
         <bool32.tgl name="b" value="0"/>
      </params>
      <attribs/>
   </obj>
   <obj type="ctrl/button" uuid="ef3d13774349df85aa9bfecf30dbc91ab8488b3f" name="button_3" x="1218" y="532">
      <params>
         <bool32.mom name="b" value="0"/>
      </params>
      <attribs/>
   </obj>
   <obj type="ctrl/button" uuid="ef3d13774349df85aa9bfecf30dbc91ab8488b3f" name="button_1" x="1344" y="532">
      <params>
         <bool32.mom name="b" value="0"/>
      </params>
      <attribs/>
   </obj>
   <obj type="string/c" uuid="4aa90a90c435a742ddfa152d232883fc5b2f1b3" name="c_1" x="1624" y="602">
      <params/>
      <attribs>
         <table attributeName="str" table="/midiloopffc"/>
      </attribs>
   </obj>
   <comment type="patch/comment" x="14" y="644" text="synced 192ppq clock"/>
   <patchobj type="patch/object" uuid="d6539470-741a-4659-a2ba-2c2cfd559ec9" name="mclock_1" x="0" y="658">
      <params>
         <int32 name="clockdiv" value="16"/>
         <int32 name="clocklength" value="16"/>
      </params>
      <attribs>
         <combo attributeName="clockin" selection="omni"/>
      </attribs>
      <object id="patch/object" uuid="d6539470-741a-4659-a2ba-2c2cfd559ec9">
         <sDescription>Midi clock slave</sDescription>
         <author>Johannes Taelman</author>
         <license>BSD</license>
         <helpPatch>midi_in.axh</helpPatch>
         <inlets/>
         <outlets>
            <bool32 name="active"/>
            <int32 name="kbeat"/>
            <bool32.pulse name="start"/>
            <bool32.pulse name="stop"/>
            <int32 name="192ppq"/>
            <int32 name="bar192ppq"/>
            <int32 name="clock"/>
            <bool32.pulse name="trig"/>
            <int32 name="count" description="rough bpm"/>
            <bool32 name="pulse"/>
            <bool32.pulse name="bartrig"/>
            <int32 name="bpm"/>
         </outlets>
         <displays/>
         <params>
            <int32 name="clockdiv">
               <MinValue i="1"/>
               <MaxValue i="300"/>
            </int32>
            <int32 name="clocklength">
               <MinValue i="0"/>
               <MaxValue i="3000000"/>
            </int32>
         </params>
         <attribs>
            <combo name="clockin">
               <MenuEntries>
                  <string>omni</string>
                  <string>din</string>
                  <string>usb host port 1</string>
                  <string>usb host port 2</string>
                  <string>usb host port 3</string>
                  <string>usb host port 4</string>
                  <string>internal port 1</string>
                  <string>internal port 2</string>
                  <string>usb device port 1</string>
               </MenuEntries>
               <CEntries>
                  <string>true</string>
                  <string>dev == MIDI_DEVICE_DIN &amp;&amp; port == 1</string>
                  <string>dev == MIDI_DEVICE_USB_HOST &amp;&amp; port == 1</string>
                  <string>dev == MIDI_DEVICE_USB_HOST &amp;&amp; port == 2</string>
                  <string>dev == MIDI_DEVICE_USB_HOST &amp;&amp; port == 3</string>
                  <string>dev == MIDI_DEVICE_USB_HOST &amp;&amp; port == 4</string>
                  <string>dev == MIDI_DEVICE_INTERNAL &amp;&amp; port == 1</string>
                  <string>dev == MIDI_DEVICE_INTERNAL &amp;&amp; port == 2</string>
                  <string>dev == MIDI_DEVICE_USB_DEVICE &amp;&amp; port == 1</string>
               </CEntries>
            </combo>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[int32_t _active;
int32_t _pos;
int active;
int init;
int drift;
int driftV;
int unsynced;
int otrig;
int start;
int stop;
int newpos;
int tap;
int ppq192;
int ktick;
int newtick;
int stepos;
int prevpos;
int dialclock;
int clock192;
int x;
int xtick;
int syncV;
int bar192;
int count;
int bartrig;
int prevcount;
int resync;
int kbeat;
int k;
int prevc;
int incount;
int divclock;
int Otrig;
int prevdiv;
int Oclock;
int length;
int pulse;]]></code.declaration>
         <code.init><![CDATA[_active = 0;
_pos = -1;



stepos=-1;
init=1;

resync=45;]]></code.init>
         <code.krate><![CDATA[//create extra ticks sync
dialclock+=(1<<27)/ktick;
if (dialclock>=((1<<27)-1)){
	dialclock=(1<<27)-1;
}


//new 24ppq clock so matches ktick
newtick+=1;
if ((newtick>=ktick)&&(ktick>0) && (stepos>=0)){
	newtick=0;
	if (!unsynced){
	newpos+=1;
	}
	dialclock=0;
}

//create extra ticks
ppq192=dialclock/ ((1<<27)/8);
//stop too many extra ticks
if (ppq192>=7){
	ppq192=7;
}


///measure 24ppq pulse
x+=1;
if ((stepos!=prevpos) && (stepos>=0)){
	if (stepos==0){
		newtick=0;
		newpos=0;
		}
	
	prevpos=stepos;
	if (stepos>0){
		ktick=x;
		}
	if (unsynced){
		newpos=stepos;
		driftV=0;
		drift=0;
		newtick=0;
		dialclock=0;
		unsynced=0;
		ppq192=0;
	}
	x=0;
}

if (stepos>=0){
clock192=(newpos<<3)+ppq192;
bar192=clock192-((clock192/768)*768);
count=bar192/192;
divclock=clock192/(768/param_clockdiv);
}

else {
	clock192=-1;
	newpos=-1;
	bar192=-1;
	count=-1;
	divclock=-1;
}
incount=(stepos/24);
k+=1;
if ((incount!=prevc)&&(stepos>=0)){
	
	if (stepos>0){
		kbeat=k;
	}
	prevc=incount;
	k=0;
}


//clock difference
syncV=newpos-stepos;

//if clock is different, time it
if (syncV!=0){
	drift+=1;
	driftV=drift;
	if (!otrig){
		otrig=1;
		drift=0;
	}
}
if (syncV==0){
	driftV=drift;
	otrig=0;
}
//if clocks are different for long enough, unsync is on, resync is triggered
if ((driftV>resync) && (stepos>0)){
	unsynced=1;
}


if (count!=prevcount){
	if (count==0){
		bartrig=1;
	}
	if (stepos>=0){
	pulse=1;
	}
	prevcount=count;
}
if (start){
	active=1;
}
if (stop){
	active=0;
}
length=param_clocklength;
if (divclock!=prevdiv){
	if (divclock>=0){
		Oclock+=1;
		Otrig=1;
	}
	if ((Oclock>=length)|| (start)){
		Oclock=0;
	}
	prevdiv=divclock;
}
if (stepos<0){
	Oclock=-1;
}
outlet_active=active;
outlet_kbeat=kbeat;
outlet_bar192ppq=bar192;
outlet_192ppq=clock192;
outlet_count=count;
outlet_pulse=pulse;
outlet_clock=Oclock;
outlet_trig=Otrig;

outlet_start=start;
outlet_stop=stop;
outlet_bpm=180000/kbeat;
// bpm back to kbeat
// kbeat=180000/bpm;
outlet_bartrig=bartrig;

pulse=0;
Otrig=0;
bartrig=0;
start=0;
stop=0;]]></code.krate>
         <code.midihandler><![CDATA[if (attr_clockin){
	if ((status == MIDI_TIMING_CLOCK) &&_active) {
		if ((_pos==0)&&_active){
	  	start=1;
	  	
	  }
	  _pos++;
	  stepos++;
	  
	  
	} else if (status == MIDI_START) {
	  _active = 1;
	  _pos = 0;
	  stepos=-1;
	  
	} else if (status == MIDI_STOP) {
	  _active = 0;
	  stop=1;
	  _pos = -1;
	  stepos=-1;
	
	  
	}
}]]></code.midihandler>
      </object>
   </patchobj>
   <obj type="disp/ibar 16" uuid="302bfed4cde8894229679ce81f6b8a5c5212dd98" name="ibar_1" x="140" y="658">
      <params/>
      <attribs/>
   </obj>
   <comment type="patch/comment" x="364" y="700" text="note recording/playback and clock"/>
   <patchobj type="patch/object" uuid="0c1a6aff-186c-491b-8150-9078458b7aab" name="mnote_1" x="364" y="714">
      <params>
         <bool32.tgl name="quantize" value="0"/>
         <int32.hradio name="quantization" value="0"/>
         <bool32.tgl name="triplets" value="0"/>
      </params>
      <attribs>
         <combo attributeName="input" selection="din"/>
         <combo attributeName="output" selection="internal port 1"/>
         <spinner attributeName="channel" value="7"/>
         <objref attributeName="table" obj="midiloop"/>
         <combo attributeName="size" selection="32768"/>
         <spinner attributeName="maxbar" value="8"/>
         <spinner attributeName="maxslots" value="7"/>
         <spinner attributeName="startnote" value="0"/>
         <spinner attributeName="endnote" value="127"/>
         <combo attributeName="resolution" selection="192ppq"/>
      </attribs>
      <object id="patch/object" uuid="0c1a6aff-186c-491b-8150-9078458b7aab">
         <sDescription>writes and outputs 4 values to a table.</sDescription>
         <author>robert schirmer</author>
         <license>who cares</license>
         <inlets>
            <int32 name="offset" description="sets an offset for writing to the table"/>
            <int32 name="192ppq"/>
            <bool32 name="quantize" description="turn on quantize (turn off parameter if using inlet)"/>
            <int32 name="quantization"/>
            <bool32.risingfalling name="triplets" description="quantize in triplets (quantize needs to be turned on also"/>
            <int32 name="slot" description="select slot"/>
            <bool32.rising name="trigger" description="trigger slot. if empty, slot starts recording at beginning of next bar. if slot is full, slot starts playing at next bar. if already playing, it will restart."/>
            <bool32.rising name="stop" description="stops at next bar"/>
            <bool32.rising name="overdub" description="trigger to toggle overdub on/off"/>
            <bool32.rising name="record" description="forces record at next bar, even if slot is full"/>
            <bool32.rising name="clearslot" description="clear selected slot"/>
            <bool32.risingfalling name="erase" description="erase shift - if this input is high and you hold a note, any instances of that note that play will be deleted"/>
            <bool32.rising name="undo" description="undo (delete) last note recorded"/>
            <int32 name="maxbar"/>
         </inlets>
         <outlets>
            <int32 name="offset" description="size on table+ offset inlet"/>
            <int32 name="currentslot" description="slot that is currently playing"/>
            <bool32 name="record" description="feedback output for record"/>
            <bool32 name="play" description="feedback output for play"/>
            <bool32 name="overdub" description="feedback output for overdub"/>
            <int32 name="maxnotes" description="maximum amount of notes for each slot - depends on &quot;size&quot; and &quot;maxslots&quot; attributes"/>
            <int32 name="slotnotes" description="amount of notes recorded in current slot"/>
            <bool32 name="full" description="feedback outlet - high if clip already present"/>
            <bool32 name="wait" description="feedback outlet - high if waiting to play/stop/record"/>
            <int32 name="playstate" description="playstate - 0=stopped, 1=play, 2=record, 3=waiting"/>
            <int32 name="synclock" description="sequencer clock running at 192ppq, following the loop"/>
         </outlets>
         <displays/>
         <params>
            <bool32.tgl name="quantize"/>
            <int32.hradio name="quantization" description="if not triplets: 1bar, 1/2bar, 1/4, 1/8th, 1/16th, 1/32nd. if triplets: 1bar, 1/3,1/6th, etc">
               <MaxValue i="6"/>
            </int32.hradio>
            <bool32.tgl name="triplets"/>
         </params>
         <attribs>
            <combo name="input">
               <MenuEntries>
                  <string>omni</string>
                  <string>din</string>
                  <string>usb host port 1</string>
                  <string>usb host port 2</string>
                  <string>usb host port 3</string>
                  <string>usb host port 4</string>
                  <string>internal port 1</string>
                  <string>internal port 2</string>
                  <string>usb device port 1</string>
               </MenuEntries>
               <CEntries>
                  <string>true</string>
                  <string>dev == MIDI_DEVICE_DIN &amp;&amp; port == 1</string>
                  <string>dev == MIDI_DEVICE_USB_HOST &amp;&amp; port == 1</string>
                  <string>dev == MIDI_DEVICE_USB_HOST &amp;&amp; port == 2</string>
                  <string>dev == MIDI_DEVICE_USB_HOST &amp;&amp; port == 3</string>
                  <string>dev == MIDI_DEVICE_USB_HOST &amp;&amp; port == 4</string>
                  <string>dev == MIDI_DEVICE_INTERNAL &amp;&amp; port == 1</string>
                  <string>dev == MIDI_DEVICE_INTERNAL &amp;&amp; port == 2</string>
                  <string>dev == MIDI_DEVICE_USB_DEVICE &amp;&amp; port == 1</string>
               </CEntries>
            </combo>
            <combo name="output">
               <MenuEntries>
                  <string>din</string>
                  <string>usb host port 1</string>
                  <string>usb host port 2</string>
                  <string>usb host port 3</string>
                  <string>usb host port 4</string>
                  <string>internal port 1</string>
                  <string>internal port 2</string>
                  <string>usb device port 1</string>
               </MenuEntries>
               <CEntries>
                  <string>MIDI_DEVICE_DIN, 1</string>
                  <string>MIDI_DEVICE_USB_HOST, 1</string>
                  <string>MIDI_DEVICE_USB_HOST, 2</string>
                  <string>MIDI_DEVICE_USB_HOST, 3</string>
                  <string>MIDI_DEVICE_USB_HOST, 4</string>
                  <string>MIDI_DEVICE_INTERNAL, 1</string>
                  <string>MIDI_DEVICE_INTERNAL, 2</string>
                  <string>MIDI_DEVICE_USB_DEVICE, 1</string>
               </CEntries>
            </combo>
            <spinner name="channel" description="midi channel" MinValue="1" MaxValue="16" DefaultValue="1"/>
            <objref name="table" description="table must be same size or greater than attribute size"/>
            <combo name="size" description="total size on table">
               <MenuEntries>
                  <string>2</string>
                  <string>4</string>
                  <string>8</string>
                  <string>16</string>
                  <string>32</string>
                  <string>64</string>
                  <string>128</string>
                  <string>256</string>
                  <string>512</string>
                  <string>1024</string>
                  <string>2048</string>
                  <string>4096</string>
                  <string>8192</string>
                  <string>16384</string>
                  <string>32768</string>
                  <string>65536</string>
                  <string>131072</string>
                  <string>262144</string>
                  <string>524288</string>
                  <string>1048576</string>
                  <string>2097152</string>
                  <string>4194304</string>
               </MenuEntries>
               <CEntries>
                  <string>1</string>
                  <string>2</string>
                  <string>3</string>
                  <string>4</string>
                  <string>5</string>
                  <string>6</string>
                  <string>7</string>
                  <string>8</string>
                  <string>9</string>
                  <string>10</string>
                  <string>11</string>
                  <string>12</string>
                  <string>13</string>
                  <string>14</string>
                  <string>15</string>
                  <string>16</string>
                  <string>17</string>
                  <string>18</string>
                  <string>19</string>
                  <string>20</string>
                  <string>21</string>
                  <string>22</string>
               </CEntries>
            </combo>
            <spinner name="maxbar" description="maximum amount of bars per slot" MinValue="1" MaxValue="30000" DefaultValue="1"/>
            <spinner name="maxslots" description="maximum amount of slots" MinValue="1" MaxValue="32" DefaultValue="1"/>
            <spinner name="startnote" MinValue="0" MaxValue="127" DefaultValue="0"/>
            <spinner name="endnote" MinValue="0" MaxValue="127" DefaultValue="127"/>
            <combo name="resolution">
               <MenuEntries>
                  <string>192ppq</string>
                  <string>96ppq</string>
                  <string>48ppq</string>
                  <string>24ppq</string>
               </MenuEntries>
               <CEntries>
                  <string>0</string>
                  <string>1</string>
                  <string>2</string>
                  <string>3</string>
               </CEntries>
            </combo>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[int voices=attr_endnote-attr_startnote+1;
int noteon[127];
int gate[127];
int vel[127];
int outgateB[127];
int gtrig[127];
int goffset[127];
int gvel[127];
int gnote[127];
int gstart[127];
int gend[127];
int gon[127];
int Pmax[127];
int Plength[127];
int Pstart[127];
int Pend[127];
int Pnote[127];
int Pvel[127];
int outnote[127];
int outvel[127];
int outgate[127];
int offnote[127];
int prevoutgate[127];
int mute[127];
int Page[127];
int Oage[127];
int Quant[14];
int temp[6];
int px;

int closegates;
int PSC;
int p;
int countoffset;
int age;
int prevage;
int Cage;
int controloffset;
int size;
int synclocko;
int cltrig;
int init;
int prevslot;
int offsethold;
int Cvel;
int Cnote;
int Cstart;
int Cend;
int offset;
int restart;
int recstart;
int clear;
int barhold;
int prevmaxbar;
int play;
int synclock;
int prevsynclock;
int kquantclock;
int quantclock;
int quantize;
int quantizeon;
int recording;
int stophold;
int playhold;
int rechold;
int barrecord;
int Rnotecount;
int rec;
int halfsync;
int Pindex;
int assigned;
int early;
int trigr;
int prevPindex;
int tempR;
int tempO;
int etrig;
int erase;
int paused;
int holdscan;
int startclear;
int currentslot;
int wait;
int dialclock;
int ppq;
int cptrig;
int trigtrig;
int full;
int clearoffset;
int currentbar;
int maxbar;
int maxppq;
int untrig;
int lastnote;
int quantization;
int undo;
int loopend;
int listshift;
int Pshift;
int generation;
int pgen;
int tempG;
int Cgen;
int lastgen;
int ultrig;
int unloop;
int lock;
int maximum;
int wlight;
int scan;
int scanmax;
int prevscan;
int prevppq1;
int bar192;
int pretrig;
int ltrig;
int overdub;
int maxnotes;
int prevRnote;
int dubtrig;
int clearmax;
int playreset;
int reclight;
int recend;
int slotsize;
int ppq1;
int playstate;

bool strig;
bool sttrig;
bool ctrig;]]></code.declaration>
         <code.init><![CDATA[//barcount=-1;
Plength[1]=-1;
clear=-1;
//prevPcount=-1;


assigned=1;
Quant[0]=1;
Quant[1]=2;
Quant[2]=4;
Quant[3]=8;
Quant[4]=16;
Quant[5]=32;
Quant[6]=1;
Quant[7]=3;
Quant[8]=6;
Quant[9]=12;
Quant[10]=24;
Quant[11]=48;


init=1;]]></code.init>
         <code.krate><![CDATA[//space for 8 globals per slot - 3 used (note count, bar length and note age)
controloffset=8;
size=(1<<attr_size);
slotsize= (((1<<attr_size)-32)/attr_maxslots);
outlet_offset=size+inlet_offset;

//per slot
maxnotes=((slotsize-8)>>3)-2;
if ((inlet_maxbar<=attr_maxbar)&&(inlet_maxbar>0)){
maximum=inlet_maxbar;
}
else {maximum=attr_maxbar;}
Rnotecount=attr_table.array[countoffset];
maxbar=attr_table.array[countoffset +1];
age=attr_table.array[countoffset +2];
generation=attr_table.array[countoffset +3];
if (inlet_undo&&!untrig){
	
	if (age>1){
	lastnote=age;
	undo=1;
	untrig=1;
	}
	if (age==1){
	startclear=1;
	}
	
}
if (!inlet_undo&&!undo){
	untrig=0;
}

 
if (init){
		currentslot=inlet_slot;
		offset=inlet_offset+32+((controloffset+slotsize)*inlet_slot) +controloffset;
		countoffset=inlet_offset+32+((controloffset+slotsize)*inlet_slot);
		init=0;
		}

erase=inlet_erase;
if (inlet_erase&&!etrig){
	etrig=1;
	tempR=recording;
	tempO=overdub;
	recording=0;
	overdub=0;
}
if (!inlet_erase&&etrig){
	etrig=0;
	recording=tempR;
	overdub=tempO;
}

if (inlet_overdub&&!dubtrig){
	dubtrig=1;
	
	if (overdub){
		overdub=0;
		recording=0;
	}
	else if (!overdub){
		overdub=1;
		recording=1;
	}
}
if (!inlet_overdub){
	dubtrig=0;
}

if (inlet_clearslot&&!cltrig){
	cltrig=1;
	startclear=1;  
	}

if (!inlet_clearslot){
	cltrig=0;
}


if (startclear){
	startclear=0;
	clearoffset=inlet_offset+32+((controloffset+slotsize)*inlet_slot);
  	clearmax=attr_table.array[clearoffset]+controloffset;
  	attr_table.array[clearoffset]=0;
  	attr_table.array[clearoffset + 1]=0;
  	attr_table.array[clearoffset + 2]=0;
	clear=0;
	if (inlet_slot==currentslot){
		play=0;
		recording=0;
		playreset=1;
		reclight=0;
	}
}


quantizeon=param_quantize+inlet_quantize;
maxppq=maxbar*(768>>attr_resolution);

if ((param_quantization+inlet_quantization)<=5){
quantization=param_quantization+inlet_quantization;
}
else {quantization=5;} 

if ((!param_triplets)&&(!inlet_triplets)){
	quantize=Quant[quantization];
	}
else if (param_triplets || inlet_triplets){
	quantize=Quant[quantization+6];
}


if (inlet_slot!=prevslot){
	prevslot=inlet_slot;
	offsethold=1;
	if (reclight){
		attr_table.array[countoffset+1]=currentbar+1;
	}
	if (inlet_192ppq<0){
		offsethold=0;
	offset=inlet_offset+32+((controloffset+slotsize)*inlet_slot) +controloffset;
		countoffset=inlet_offset+32+((controloffset+slotsize)*inlet_slot);
		 Rnotecount=attr_table.array[countoffset];
		 maxbar=attr_table.array[countoffset +1];
		age=attr_table.array[countoffset +2];
		generation=attr_table.array[countoffset +3];
		 currentslot=inlet_slot;
		 prevRnote=Rnotecount;
		prevmaxbar=maxbar;
		prevage=age;
		pgen=generation;
		
	full=attr_table.array[inlet_offset+inlet_slot];
	if (full){
		play=1;
		strig=1;
		ltrig=0;
		Pshift=-2;
	}
	}
}
// create 1ppq 0-3 beat counter and a 192ppq bar loop from 192ppq counter
if (inlet_192ppq>=0){
	bar192=inlet_192ppq-((inlet_192ppq/768)*768);
	ppq1=bar192/192;
	}

else {
	bar192=-1;
	ppq1=0;	
	prevppq1=0;
	}

if ((ppq1!=prevppq1)&&(ppq1>=0)){
	prevppq1=ppq1;
	loopend=0;
	
	if ((ppq1==2)){
		
		if ((currentbar==(maximum-1)) && (barrecord)){
			wlight=1;
		}
	}
	//bartrigger
	if (ppq1==0){
		wlight=0;
		if (stophold){
			play=0;
			playreset=1;
			recording=0;
			stophold=0;
		}
		if (playhold){
			restart=1;
			play=1;
			playhold=0;
			if (overdub){
				recording=1;
				}
			}
		if (rechold){
			rec=1;
			reclight=1;
			if (!play){
				play=1;
				}
			restart=1;
			rechold=0;
			}
		if (barhold){
			reclight=0;
			barhold=0;
			barrecord=0;
			maxbar=currentbar+1;
			restart=1;
			if (!overdub){
				recording=0;currentbar=0;
				}
			}
		
		currentbar+=1;
		if (currentbar>=maxbar){
			if (barrecord&&(maxbar==maximum)){
				barhold=0;
				reclight=0;
				barrecord=0;
				maxbar=currentbar;
				restart=1;
				if (!overdub){
					recording=0;currentbar=0;
				}
			}
			currentbar=0;
			restart=1;
			}
		}
	
	
	}



//pre bar trigger (1/32nd before next bar)
if ((bar192>=744) &&!pretrig){
	pretrig=1;
	if ((offsethold) &&(rechold || playhold || barhold))
		{	//set offset when different clip triggered
		offsethold=0;
		offset=inlet_offset+32+((controloffset+slotsize)*inlet_slot) +controloffset;
		countoffset=inlet_offset+32+((controloffset+slotsize)*inlet_slot);
		 Rnotecount=attr_table.array[countoffset];
		 maxbar=attr_table.array[countoffset +1];
		age=attr_table.array[countoffset +2];
		generation=attr_table.array[countoffset +3];
		 currentslot=inlet_slot;
		 prevRnote=Rnotecount;
		prevmaxbar=maxbar;
		prevage=age;
		pgen=generation;
		}
	if (((currentbar+1)>=maxbar) || playhold || rechold || barhold || offsethold){	
			playreset=1;
			loopend=1;
			generation+=1;
	
		if ((barhold) || (barrecord&&(maxbar==(maximum-1)))){
			playreset=1;
			recend=1;
			// need to close gates? revisit
			closegates=1;
			
		}
		if (rechold){
			//clear and start recording
			recstart=1;
			clearmax=Rnotecount+controloffset;
			clearoffset=offset-controloffset;
			clear=0;
			Rnotecount=0;
			recording=1;
			}
	}

}
if (bar192==0){
	pretrig=0;
}




//clock started
if ((inlet_192ppq>=0)&&!strig){
	
	strig=1;
	if (playhold){
			restart=1;
			play=1;
			playhold=0;
			if (overdub){
				recording=1;
				}
			}
	loopend=0;
	}
//clock stopped
if ((inlet_192ppq<0)&&strig){
	strig=0;
	playreset=1;
	loopend=1;
	generation+=1;
	recording=0;
	if (play){
		playhold=1;
		play=0;
	}
} 



//clip present?
full=attr_table.array[inlet_offset+inlet_slot];

if (inlet_trigger&&!trigtrig){
	trigtrig=1;
	if (!full){
		rechold=1;
		}
	else if (full){
		if (barrecord){
			barhold=1;
			}
		if (!barrecord){
			playhold=1;
			}
		}
	}

	
if (!inlet_trigger){
	trigtrig=0;
}

if (inlet_stop&&!sttrig){
		stophold=1;
	if (playhold){
		playhold=0;
	}
	sttrig=1;
}
if (!inlet_stop){
	sttrig=0;
}

if (restart){
	restart=0;
	currentbar=0;
	}

	
if (inlet_192ppq>=0){
synclock=(bar192+(currentbar*768))>>attr_resolution;
synclocko=(bar192+(currentbar*768));
}
else {
	synclock=-1;
	synclocko=-1;
	prevsynclock=-1;
	
}

//clock info for quantize
quantclock=synclock/((768>>attr_resolution)/quantize);
halfsync=((768>>attr_resolution)/quantize)>>1;
kquantclock=quantclock*((768>>attr_resolution)/quantize);
// early or late?
if (synclock<(kquantclock+halfsync)){
	early=0;
}
if (synclock>=(kquantclock+halfsync)){
	early=1;
}

if (inlet_record&&!trigr){
	trigr=1;
	if (!barrecord){
		rechold=1;
	}
	else if (barrecord){
		barhold=1;
	}
	
}
if (!inlet_record){
	trigr=0;
}

if (rec){
	rec=0;
	currentbar=0;
	barrecord=1;
	maxbar=maximum;
	attr_table.array[currentslot+inlet_offset]=1;
	Rnotecount=0;
	recstart=0;
	}
	
//clear note data
if (clear>=0){
	if (clear<=clearmax){
		int tx;
		for (tx= 0;tx<6;tx++){	
			attr_table.array[clearoffset+(clear<<3) +tx]=0;
		}
		if (clearoffset==(offset-controloffset)){
			closegates=1;
		}
		
		
		clear+=1;
	
		if (clear>=clearmax){
			attr_table.array[inlet_slot+inlet_offset]=0;
			clear=-1;
			if (clearoffset==(offset-controloffset)){
				playreset=1;
				}
			}
		}
}



	//note assign  ===========================================================================	
if (loopend&&!ltrig){
	listshift=0;
	PSC=listshift;
	ltrig=1;
}
if (!loopend){
	ltrig=0;
}

if ((synclock==prevsynclock)&&!playreset){
	
	//assign notes from list - mute if notes clash with incoming note, delete if overdubbing
	for (Pindex = 0;Pindex<32;Pindex++){
		if ((Pindex+PSC)<maxnotes) {
				
			Cstart=attr_table.array[offset+((Pindex+PSC)<<3) +0];
			Cend=attr_table.array[offset+((Pindex+PSC)<<3) +1];
			Cnote=attr_table.array[offset+((Pindex+PSC)<<3) +2];
			Cvel=attr_table.array[offset+((Pindex+PSC)<<3) +3];
			Cage=attr_table.array[offset+((Pindex+PSC)<<3) +4];
			Cgen=attr_table.array[offset+((Pindex+PSC)<<3) +5];
			//clash?
				

			if (synclock!=Pshift){
				//ignore notes being moved by scanner
				if ((Pindex==0)&&(Cstart<(synclock+1)) && (Cstart>0) &&!loopend && (synclock>0)){
					lock+=1;
				}
						
					
				//if note start is reached	
				if   (( ( (((Cstart-1)==(synclock+1))&&!loopend) || ( ((Cstart-1)==0) && loopend))   && (Cstart>0) )  && (Cgen!=generation)){
					
						
					if (Cage>=Page[Cnote]){
						if (gate[Cnote]){
							mute[Cnote]=1;
							}
						listshift+=1;
						if (!mute[Cnote]){	
							
							Pstart[Cnote]=Cstart;
							Pend[Cnote]=Cend;
							Pnote[Cnote]=Cnote;
							Pvel[Cnote]=Cvel;
							Page[Cnote]=Cage;
							}
						else if (mute[Cnote]){
							if (((overdub&&!reclight)||(erase))  &&  (attr_table.array[offset+((Pindex+PSC)<<3) +0]>0)){
								int tx;
								for (tx= 0;tx<6;tx++){	
									attr_table.array[offset+((Pindex+PSC)<<3) +tx]=0;
									}
								Rnotecount-=1;
								}
							}
						}
					}		
				}
			}
		}
if (lock==0){
Pshift=synclock;
}
if (lock>0){
	lock=0;
}
PSC=listshift;

}
if (playreset){
	lock=0;
}


for (px = 0;px<voices;px++){
	p=px+attr_startnote;
	
	
	if (!gate[p]) {
			mute[p]=0;
			}
	
	//reset players && midi output
	if (playreset){
		Pstart[p]=0;
		Plength[p]=-1;
		outgate[p]=0;
		Page[p]=0;
		}
	//reset midi input
	if (closegates){
			gate[p]=0;
			}
	
	//  recording  **************************************************************
	//set quantize at note on
	if (gate[p]&&!gtrig[p]){
	
		gtrig[p]=1;
		if (quantizeon){
			if (early){
				goffset[p]= ( halfsync - (synclock-(kquantclock+halfsync)));
			}
			if (!early){
				goffset[p]=-(synclock-kquantclock);
			}
		}
		else if (!quantizeon){
			goffset[p]=0;
		}
		if ((synclock+goffset[p])<maxppq){
			gstart[p]=synclock+goffset[p];
			}
		else if ((synclock+goffset[p])>=maxppq){
				gstart[p]=0;
			}
		if (recstart){
				gstart[p]=0;
		}
		gnote[p]=noteon[p];
		gvel[p]=vel[p];
		if (recording){
			gon[p]=1;
			attr_table.array[offset+(Rnotecount<<3) +5]=generation;
			
		}
		
		
	}
	//stamp note data at note off
	if (!gate[p]&&gtrig[p]){
		gtrig[p]=0;
		if (gon[p]){
			gon[p]=0;
			gend[p]=synclock+goffset[p];
			if (recstart){
				gend[p]=halfsync;
		}
			//stamp note
			if (Rnotecount<maxnotes){
				attr_table.array[offset+(Rnotecount<<3) +0]=gstart[p]+1;
				attr_table.array[offset+(Rnotecount<<3) +1]=gend[p]+1;
				attr_table.array[offset+(Rnotecount<<3) +2]=gnote[p];
				attr_table.array[offset+(Rnotecount<<3) +3]=gvel[p];
				age+=1;
				attr_table.array[offset+(Rnotecount<<3) +4]=age;
				Rnotecount+=1;
				}
			}
		}
		
		///////////////////////////////////play

	
	if (synclock!=prevsynclock){
		if (play){
			// play  **********************************************
			//length - note off at end
			if (Plength[p]>=0){
				Plength[p]+=1;
				if (Plength[p]>=Pmax[p]){
					Plength[p]=-1;
					outgate[p]=0;
					Oage[p]=0;
				}
			}
			//trigger note on
			if (((synclock)==(Pstart[p]-1))&&(Pstart[p]>0)){
					if (!mute[p]){
						Plength[p]=0;
						if (Pend[p]>Pstart[p]){
							Pmax[p]=Pend[p]-Pstart[p];
						}
						else if (Pend[p]<=Pstart[p]){
							Pmax[p]=(maxppq+Pend[p])-Pstart[p];
						}
						outnote[p]=Pnote[p];
						outvel[p]=Pvel[p];
						Oage[p]=Page[p];
						outgate[p]=1;
						outgateB[p]=0;
						Pstart[p]=0;
						Pend[p]=0;
						Page[p]=0;
						}
					}
			}
			}
	//triggermidi  ===========================================
	if (outgateB[p]!=prevoutgate[p]){
		if (outgateB[p]){
			MidiSend3((midi_device_t) attr_output, MIDI_NOTE_ON + (attr_channel-1),outnote[p],outvel[p]);
			offnote[p]=outnote[p];  
		}
		else if (!outgateB[p]){
			MidiSend3((midi_device_t) attr_output, MIDI_NOTE_OFF + (attr_channel-1),offnote[p],outvel[p]);
		}
		
		prevoutgate[p]=outgateB[p];
	}
	
	outgateB[p]=outgate[p];
//// end loop
}
/////////////////////////
//keep outside loop	
prevsynclock=synclock;
playreset=0;
closegates=0;


// reorder notes for overdubbing
if (scan!=prevscan){
	
	if (((scan!=(Rnotecount+2))&& (( synclock==prevsynclock) && (synclock==Pshift)))){
			//scan counting down from last note! 

		//undo
		if ((undo)&& (attr_table.array[offset+(scan<<3) +4]==lastnote)){
			
			int tx;
			for (tx= 0;tx<6;tx++){	
				attr_table.array[offset+(scan<<3) +tx]=0;
			}
			age-=1;
			Rnotecount-=1;
			undo=0;
		}

				//if two notes at same position and same note, delete old note
		if (((attr_table.array[offset+(scan<<3) +0])==(attr_table.array[offset+(prevscan<<3) +0]))
			&& ((attr_table.array[offset+(scan<<3) +2])==(attr_table.array[offset+(prevscan<<3) +2]))
			&&
			((attr_table.array[offset+(scan<<3) +0]) !=0 )
			&&
			((attr_table.array[offset+(prevscan<<3) +0]) !=0 ) )
			{
			int tx;
			for (tx= 0;tx<6;tx++){	
				attr_table.array[offset+(scan<<3) +tx]=0;
				}
			Rnotecount-=1;
			}
	
		//swap backwards, earlier earlier - notes in ascending order.
		
		if ( (  ((attr_table.array[offset+(scan<<3) +0])>(attr_table.array[offset+(prevscan<<3) +0]))
			|| ( ((attr_table.array[offset+(scan<<3) +0])==(attr_table.array[offset+(prevscan<<3) +0])) && ((attr_table.array[offset+(scan<<3) +2])<(attr_table.array[offset+(prevscan<<3) +2])) ) )
			&&
			((attr_table.array[offset+(scan<<3) +0]) !=0 )
			&&
			((attr_table.array[offset+(prevscan<<3) +0]) !=0 ) )
			{
			int tx;
			for (tx= 0;tx<6;tx++){	
				temp[tx]=attr_table.array[offset+(prevscan<<3) +tx];		
				attr_table.array[offset+(prevscan<<3) +tx] = attr_table.array[offset+(scan<<3) +tx];	
				attr_table.array[offset+(scan<<3) +tx]=temp[tx];	
				}	
			}
				//swap 0 values other way to move deleted notes out of list
		if ( ((attr_table.array[offset+(scan<<3) +0]) ==0 ) && ((attr_table.array[offset+(prevscan<<3) +0]) !=0 ) ){
			int tx;
			for (tx= 0;tx<6;tx++){	
				attr_table.array[offset+(scan<<3) +tx] = attr_table.array[offset+(prevscan<<3) +tx];
				attr_table.array[offset+(prevscan<<3) +tx]=0;
				}
			}
		}
	prevscan=scan;
	}

scan-=1;
scanmax=Rnotecount;
if (scan<0){
	scan=Rnotecount;
	prevscan=Rnotecount+1;
}


//wait output for light feedback
if (stophold||playhold||rechold||barhold||wlight){
	wait=1;
}
if (!stophold&&!playhold&&!rechold&&!barhold&&!wlight){
	wait=0;
	
}

//write note count, bar length and last note age
if (Rnotecount!=prevRnote){
	prevRnote=Rnotecount;
 attr_table.array[countoffset]=Rnotecount;
}
if (maxbar!=prevmaxbar){
	prevmaxbar=maxbar;
 attr_table.array[countoffset+1]=maxbar;
}
if (age!=prevage){
	prevage=age;
	attr_table.array[countoffset+2]=age;
}
if (generation!=pgen){
	pgen=generation;
	attr_table.array[countoffset+3]=generation;
}

if (!reclight){
outlet_overdub=overdub;
}
if (reclight){
outlet_overdub=0;
}
outlet_record=reclight;
outlet_play=play;
outlet_maxnotes=maxnotes;
outlet_slotnotes=Rnotecount;
outlet_currentslot=currentslot;
outlet_full=full;
outlet_wait=wait;
if (play){
	outlet_synclock=synclocko;
}
else {outlet_synclock=-1;}


if (!wait&&!play&&!reclight){
	playstate=0;
	}
else if (play&&!reclight&&!wait) {
	playstate=1;
}
else if (play&&reclight&&!wait){
	playstate=2;
}
if (wait){
	playstate=3;
}
outlet_playstate=playstate;


recend=0;]]></code.krate>
         <code.midihandler><![CDATA[if (attr_input){
if ((status == MIDI_NOTE_ON + (attr_channel-1)) && (data2) && (data1>=attr_startnote) && (data1<=attr_endnote)) {

gate[data1]=1;
vel[data1]=data2;
noteon[data1]=data1;

//if note clashes with already playing note, cut it short and mute ntoe off
if (outgate[data1]){
	Plength[data1]=-1;
	outgate[data1]=0;
	outgateB[data1]=0;
	Oage[data1]=0;
	prevoutgate[data1]=outgateB[data1];
	
	}

	
} else if (((status == MIDI_NOTE_ON + (attr_channel-1)) && (!data2))||
          (status == MIDI_NOTE_OFF + (attr_channel-1))) {
      if ((data1>=attr_startnote) && (data1<=attr_endnote)){
          gate[data1]=0;
      }
          	
          	
          	
          	
          	
			
          }

          	

}]]></code.midihandler>
      </object>
   </patchobj>
   <comment type="patch/comment" x="686" y="714" text="rough bpm"/>
   <comment type="patch/comment" x="896" y="714" text="waiting"/>
   <comment type="patch/comment" x="994" y="714" text="overdub"/>
   <comment type="patch/comment" x="1092" y="714" text="record"/>
   <comment type="patch/comment" x="1190" y="714" text="play"/>
   <comment type="patch/comment" x="1260" y="714" text="playing slot"/>
   <obj type="disp/i" uuid="5e35fd0c62d81e70017289250cf28edd26e19e4a" name="i_2" x="686" y="728">
      <params/>
      <attribs/>
   </obj>
   <obj type="disp/bool" uuid="a0ee71d48208b71752cbb8c05e55145106ef3946" name="bool_27" x="896" y="728">
      <params/>
      <attribs/>
   </obj>
   <obj type="disp/bool" uuid="a0ee71d48208b71752cbb8c05e55145106ef3946" name="bool_3" x="994" y="728">
      <params/>
      <attribs/>
   </obj>
   <obj type="disp/bool" uuid="a0ee71d48208b71752cbb8c05e55145106ef3946" name="bool_4" x="1092" y="728">
      <params/>
      <attribs/>
   </obj>
   <obj type="disp/bool" uuid="a0ee71d48208b71752cbb8c05e55145106ef3946" name="bool_26" x="1190" y="728">
      <params/>
      <attribs/>
   </obj>
   <obj type="disp/i" uuid="5e35fd0c62d81e70017289250cf28edd26e19e4a" name="i_1" x="1274" y="728">
      <params/>
      <attribs/>
   </obj>
   <obj type="table/save" uuid="3e4108b607d56d9e1cd10abb898b58eea11e53b2" name="save_1" x="1610" y="728">
      <params/>
      <attribs>
         <objref attributeName="table" obj="midiloop"/>
      </attribs>
   </obj>
   <comment type="patch/comment" x="686" y="798" text="max notes per slot"/>
   <comment type="patch/comment" x="812" y="798" text="amount of notesrecorded in slot"/>
   <comment type="patch/comment" x="994" y="798" text="192ppq clock that follows the clip"/>
   <comment type="patch/comment" x="1204" y="798" text="playstate - 0=stopped, 1=play, 2= record, 3= waiting"/>
   <obj type="disp/i" uuid="5e35fd0c62d81e70017289250cf28edd26e19e4a" name="i_16" x="686" y="812">
      <params/>
      <attribs/>
   </obj>
   <obj type="disp/i" uuid="5e35fd0c62d81e70017289250cf28edd26e19e4a" name="i_9" x="826" y="812">
      <params/>
      <attribs/>
   </obj>
   <obj type="disp/i" uuid="5e35fd0c62d81e70017289250cf28edd26e19e4a" name="i_10" x="1036" y="812">
      <params/>
      <attribs/>
   </obj>
   <obj type="disp/i" uuid="5e35fd0c62d81e70017289250cf28edd26e19e4a" name="i_3" x="1204" y="812">
      <params/>
      <attribs/>
   </obj>
   <comment type="patch/comment" x="588" y="882" text="poly touch recorder"/>
   <comment type="patch/comment" x="742" y="882" text="pitch bend recorder"/>
   <comment type="patch/comment" x="896" y="882" text="channel touch recorder"/>
   <comment type="patch/comment" x="1036" y="882" text="cc recorder"/>
   <comment type="patch/comment" x="1176" y="882" text="total size on table"/>
   <patchobj type="patch/object" uuid="ff5f58fd-7957-4f21-a1ac-1d7ca63ec6bf" name="poly touch" x="588" y="896">
      <params/>
      <attribs>
         <combo attributeName="input" selection="din"/>
         <combo attributeName="output" selection="internal port 1"/>
         <spinner attributeName="channel" value="7"/>
         <objref attributeName="table" obj="midiloop"/>
         <spinner attributeName="maxbar" value="8"/>
         <spinner attributeName="maxslots" value="7"/>
         <combo attributeName="resolution" selection="192ppq"/>
      </attribs>
      <object id="patch/object" uuid="ff5f58fd-7957-4f21-a1ac-1d7ca63ec6bf">
         <sDescription>object that records pitch bend, after touch and midi CCs.
for use with the midi looper objects.
could be used standalone, inlet stepunQCC expects a clock running at 96ppq</sDescription>
         <author>Mattilyn Mattroe</author>
         <license>if you use the object to play a wedding in september you have to come round and fix the dodgy extractor fan in my bathroom. otherwise, do as you will</license>
         <helpPatch>midi looper help.axh</helpPatch>
         <inlets>
            <int32 name="offset"/>
            <int32 name="slot"/>
            <int32 name="synclock"/>
            <bool32 name="rec"/>
            <bool32 name="play"/>
            <bool32 name="reset"/>
            <bool32 name="overdub"/>
            <bool32 name="clear"/>
            <int32 name="cslot"/>
         </inlets>
         <outlets>
            <int32 name="offset"/>
         </outlets>
         <displays/>
         <params/>
         <attribs>
            <combo name="input">
               <MenuEntries>
                  <string>omni</string>
                  <string>din</string>
                  <string>usb host port 1</string>
                  <string>usb host port 2</string>
                  <string>usb host port 3</string>
                  <string>usb host port 4</string>
                  <string>internal port 1</string>
                  <string>internal port 2</string>
                  <string>usb device port 1</string>
               </MenuEntries>
               <CEntries>
                  <string>true</string>
                  <string>dev == MIDI_DEVICE_DIN &amp;&amp; port == 1</string>
                  <string>dev == MIDI_DEVICE_USB_HOST &amp;&amp; port == 1</string>
                  <string>dev == MIDI_DEVICE_USB_HOST &amp;&amp; port == 2</string>
                  <string>dev == MIDI_DEVICE_USB_HOST &amp;&amp; port == 3</string>
                  <string>dev == MIDI_DEVICE_USB_HOST &amp;&amp; port == 4</string>
                  <string>dev == MIDI_DEVICE_INTERNAL &amp;&amp; port == 1</string>
                  <string>dev == MIDI_DEVICE_INTERNAL &amp;&amp; port == 2</string>
                  <string>dev == MIDI_DEVICE_USB_DEVICE &amp;&amp; port == 1</string>
               </CEntries>
            </combo>
            <combo name="output">
               <MenuEntries>
                  <string>din</string>
                  <string>usb host port 1</string>
                  <string>usb host port 2</string>
                  <string>usb host port 3</string>
                  <string>usb host port 4</string>
                  <string>internal port 1</string>
                  <string>internal port 2</string>
                  <string>usb device port 1</string>
               </MenuEntries>
               <CEntries>
                  <string>MIDI_DEVICE_DIN, 1</string>
                  <string>MIDI_DEVICE_USB_HOST, 1</string>
                  <string>MIDI_DEVICE_USB_HOST, 2</string>
                  <string>MIDI_DEVICE_USB_HOST, 3</string>
                  <string>MIDI_DEVICE_USB_HOST, 4</string>
                  <string>MIDI_DEVICE_INTERNAL, 1</string>
                  <string>MIDI_DEVICE_INTERNAL, 2</string>
                  <string>MIDI_DEVICE_USB_DEVICE, 1</string>
               </CEntries>
            </combo>
            <spinner name="channel" MinValue="1" MaxValue="16" DefaultValue="1"/>
            <objref name="table"/>
            <spinner name="maxbar" MinValue="1" MaxValue="32" DefaultValue="0"/>
            <spinner name="maxslots" MinValue="1" MaxValue="32" DefaultValue="1"/>
            <combo name="resolution">
               <MenuEntries>
                  <string>192ppq</string>
                  <string>96ppq</string>
                  <string>48ppq</string>
                  <string>24ppq</string>
               </MenuEntries>
               <CEntries>
                  <string>0</string>
                  <string>1</string>
                  <string>2</string>
                  <string>3</string>
               </CEntries>
            </combo>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[int note;
int touch;
int synclock;




int intouch[9];
int Tnote[9];
int Ttouch[9];
int Onote[9];
int Otouch[9];
int poly;

int prevstep;
int voice;
int slotsize;
int play;
int rec;
int offset;
int clear;
int ctrig;


int resetrig;]]></code.declaration>
         <code.init><![CDATA[voice=(768*attr_maxbar)>>attr_resolution;
slotsize=(voice*18);
clear=-1;]]></code.init>
         <code.krate><![CDATA[offset=inlet_offset + (slotsize*inlet_slot);
outlet_offset=inlet_offset + (slotsize*attr_maxslots)+slotsize;
if (inlet_synclock>=0){
	synclock=inlet_synclock>>attr_resolution;
	}
else {synclock=-1;}

Onote[0]=attr_table.array[synclock+offset];
Otouch[0]=attr_table.array[synclock+offset+voice];
Onote[1]=attr_table.array[synclock+offset+voice+voice];
Otouch[1]=attr_table.array[synclock+offset+voice+voice+voice];
Onote[2]=attr_table.array[synclock+offset+voice+voice+voice+voice];
Otouch[2]=attr_table.array[synclock+offset+voice+voice+voice+voice+voice];
Onote[3]=attr_table.array[synclock+offset+voice+voice+voice+voice+voice+voice];
Otouch[3]=attr_table.array[synclock+offset+voice+voice+voice+voice+voice+voice+voice];
Onote[4]=attr_table.array[synclock+offset+voice+voice+voice+voice+voice+voice+voice+voice];
Otouch[4]=attr_table.array[synclock+offset+voice+voice+voice+voice+voice+voice+voice+voice+voice];
Onote[5]=attr_table.array[synclock+offset+voice+voice+voice+voice+voice+voice+voice+voice+voice+voice];
Otouch[5]=attr_table.array[synclock+offset+voice+voice+voice+voice+voice+voice+voice+voice+voice+voice+voice];
Onote[6]=attr_table.array[synclock+offset+voice+voice+voice+voice+voice+voice+voice+voice+voice+voice+voice+voice];
Otouch[6]=attr_table.array[synclock+offset+voice+voice+voice+voice+voice+voice+voice+voice+voice+voice+voice+voice+voice];
Onote[7]=attr_table.array[synclock+offset+voice+voice+voice+voice+voice+voice+voice+voice+voice+voice+voice+voice+voice+voice];
Otouch[7]=attr_table.array[synclock+offset+voice+voice+voice+voice+voice+voice+voice+voice+voice+voice+voice+voice+voice+voice+voice];
Onote[8]=attr_table.array[synclock+offset+voice+voice+voice+voice+voice+voice+voice+voice+voice+voice+voice+voice+voice+voice+voice+voice];
Otouch[8]=attr_table.array[synclock+offset+voice+voice+voice+voice+voice+voice+voice+voice+voice+voice+voice+voice+voice+voice+voice+voice+voice];


if (inlet_clear&&!ctrig){
	clear=0;
	ctrig=1;
}
if (!inlet_clear){
	ctrig=0;
}
if ((clear>=0)&& (clear<slotsize)){
	attr_table.array[clear+inlet_offset + (slotsize*inlet_cslot)]= 0;
	attr_table.array[clear+inlet_offset + (slotsize*inlet_cslot)+voice]= 0;
	attr_table.array[clear+inlet_offset + (slotsize*inlet_cslot)+voice+voice]= 0;
	attr_table.array[clear+inlet_offset + (slotsize*inlet_cslot)+voice+voice+voice]= 0;
	attr_table.array[clear+inlet_offset + (slotsize*inlet_cslot)+voice+voice+voice+voice]= 0;
	attr_table.array[clear+inlet_offset + (slotsize*inlet_cslot)+voice+voice+voice+voice+voice]= 0;
	attr_table.array[clear+inlet_offset + (slotsize*inlet_cslot)+voice+voice+voice+voice+voice+voice]= 0;
	attr_table.array[clear+inlet_offset + (slotsize*inlet_cslot)+voice+voice+voice+voice+voice+voice+voice]= 0;
	attr_table.array[clear+inlet_offset + (slotsize*inlet_cslot)+voice+voice+voice+voice+voice+voice+voice+voice]= 0;
	attr_table.array[clear+inlet_offset + (slotsize*inlet_cslot)+voice+voice+voice+voice+voice+voice+voice+voice+voice]= 0;
	attr_table.array[clear+inlet_offset + (slotsize*inlet_cslot)+voice+voice+voice+voice+voice+voice+voice+voice+voice+voice]= 0;
	attr_table.array[clear+inlet_offset + (slotsize*inlet_cslot)+voice+voice+voice+voice+voice+voice+voice+voice+voice+voice+voice]= 0;
	attr_table.array[clear+inlet_offset + (slotsize*inlet_cslot)+voice+voice+voice+voice+voice+voice+voice+voice+voice+voice+voice+voice]= 0;
	attr_table.array[clear+inlet_offset + (slotsize*inlet_cslot)+voice+voice+voice+voice+voice+voice+voice+voice+voice+voice+voice+voice+voice]= 0;
	attr_table.array[clear+inlet_offset + (slotsize*inlet_cslot)+voice+voice+voice+voice+voice+voice+voice+voice+voice+voice+voice+voice+voice+voice]= 0;
	attr_table.array[clear+inlet_offset + (slotsize*inlet_cslot)+voice+voice+voice+voice+voice+voice+voice+voice+voice+voice+voice+voice+voice+voice+voice]= 0;
	attr_table.array[clear+inlet_offset + (slotsize*inlet_cslot)+voice+voice+voice+voice+voice+voice+voice+voice+voice+voice+voice+voice+voice+voice+voice+voice]= 0;
	attr_table.array[clear+inlet_offset + (slotsize*inlet_cslot)+voice+voice+voice+voice+voice+voice+voice+voice+voice+voice+voice+voice+voice+voice+voice+voice+voice]= 0;
	
	
	
	
	clear+=1;
	if (clear>=voice){
		clear=-1;
	}
}
if (synclock!=prevstep){
//play
	if (inlet_play&&!inlet_rec){
		if (Otouch[0]>0){
			
			MidiSend3((midi_device_t) attr_output, MIDI_POLY_PRESSURE + (attr_channel-1),(Onote[0]-1),(Otouch[0]-1)); 
		}
		if (Otouch[1]>0){
			MidiSend3((midi_device_t) attr_output, MIDI_POLY_PRESSURE + (attr_channel-1),(Onote[1]-1),(Otouch[1]-1));
		}
		if (Otouch[2]>0){
			MidiSend3((midi_device_t) attr_output, MIDI_POLY_PRESSURE + (attr_channel-1),(Onote[2]-1),(Otouch[2]-1));
		}
		if (Otouch[3]>0){
			MidiSend3((midi_device_t) attr_output, MIDI_POLY_PRESSURE + (attr_channel-1),(Onote[3]-1),(Otouch[3]-1));
		}
		if (Otouch[4]>0){
			MidiSend3((midi_device_t) attr_output, MIDI_POLY_PRESSURE + (attr_channel-1),(Onote[4]-1),(Otouch[4]-1));
		}
		if (Otouch[5]>0){
			MidiSend3((midi_device_t) attr_output, MIDI_POLY_PRESSURE+ (attr_channel-1),(Onote[5]-1),(Otouch[5]-1));
		}
		if (Otouch[6]>0){
			MidiSend3((midi_device_t) attr_output, MIDI_POLY_PRESSURE + (attr_channel-1),(Onote[6]-1),(Otouch[6]-1));
		}
		if (Otouch[7]>0){
			MidiSend3((midi_device_t) attr_output, MIDI_POLY_PRESSURE + (attr_channel-1),(Onote[7]-1),(Otouch[7]-1));
		}
		if (Otouch[8]>0){
			MidiSend3((midi_device_t) attr_output, MIDI_POLY_PRESSURE + (attr_channel-1),(Onote[8]-1),(Otouch[8]-1));
		}
		
		
	
		
		}

//record
	if (inlet_rec){
			attr_table.array[synclock+offset]= 0;
			attr_table.array[synclock+offset+voice]= 0;
			attr_table.array[synclock+offset+voice+voice]= 0;
			attr_table.array[synclock+offset+voice+voice+voice]= 0;
			attr_table.array[synclock+offset+voice+voice+voice+voice]= 0;
			attr_table.array[synclock+offset+voice+voice+voice+voice+voice]= 0;
			attr_table.array[synclock+offset+voice+voice+voice+voice+voice+voice]= 0;
			attr_table.array[synclock+offset+voice+voice+voice+voice+voice+voice+voice]= 0;
			attr_table.array[synclock+offset+voice+voice+voice+voice+voice+voice+voice+voice]= 0;
			attr_table.array[synclock+offset+voice+voice+voice+voice+voice+voice+voice+voice+voice]= 0;
			attr_table.array[synclock+offset+voice+voice+voice+voice+voice+voice+voice+voice+voice+voice]= 0;
			attr_table.array[synclock+offset+voice+voice+voice+voice+voice+voice+voice+voice+voice+voice+voice]= 0;
			attr_table.array[synclock+offset+voice+voice+voice+voice+voice+voice+voice+voice+voice+voice+voice+voice]= 0;
			attr_table.array[synclock+offset+voice+voice+voice+voice+voice+voice+voice+voice+voice+voice+voice+voice+voice]= 0;
			attr_table.array[synclock+offset+voice+voice+voice+voice+voice+voice+voice+voice+voice+voice+voice+voice+voice+voice]= 0;
			attr_table.array[synclock+offset+voice+voice+voice+voice+voice+voice+voice+voice+voice+voice+voice+voice+voice+voice+voice]= 0;
			
		
			
		}
//overdub
	if ((inlet_rec || inlet_overdub) && (inlet_play)){
		
			if (Ttouch[0]) {
					attr_table.array[synclock+offset]= Tnote[0];
					attr_table.array[synclock+offset+voice]= Ttouch[0];
					}
			if (Ttouch[1]) {
					attr_table.array[synclock+offset+voice+voice]= Tnote[1];
					attr_table.array[synclock+offset+voice+voice+voice]= Ttouch[1];
					}
			if (Ttouch[2]) {
					attr_table.array[synclock+offset+voice+voice+voice+voice]= Tnote[2];
					attr_table.array[synclock+offset+voice+voice+voice+voice+voice]= Ttouch[2];
					}
			if (Ttouch[3]) {
					attr_table.array[synclock+offset+voice+voice+voice+voice+voice+voice]= Tnote[3];
					attr_table.array[synclock+offset+voice+voice+voice+voice+voice+voice+voice]= Ttouch[3];
					}
			if (Ttouch[4]) {
					attr_table.array[synclock+offset+voice+voice+voice+voice+voice+voice+voice+voice]= Tnote[4];
					attr_table.array[synclock+offset+voice+voice+voice+voice+voice+voice+voice+voice+voice]= Ttouch[4];
					}
			if (Ttouch[5]) {
					attr_table.array[synclock+offset+voice+voice+voice+voice+voice+voice+voice+voice]= Tnote[5];
					attr_table.array[synclock+offset+voice+voice+voice+voice+voice+voice+voice+voice+voice]= Ttouch[5];
					}
			if (Ttouch[6]) {
					attr_table.array[synclock+offset+voice+voice+voice+voice+voice+voice+voice+voice+voice+voice]= Tnote[6];
					attr_table.array[synclock+offset+voice+voice+voice+voice+voice+voice+voice+voice+voice+voice+voice]= Ttouch[6];
					}
			if (Ttouch[7]) {
					attr_table.array[synclock+offset+voice+voice+voice+voice+voice+voice+voice+voice+voice+voice+voice+voice]= Tnote[7];
					attr_table.array[synclock+offset+voice+voice+voice+voice+voice+voice+voice+voice+voice+voice+voice+voice+voice]= Ttouch[7];
					}
			if (Ttouch[8]) {
					attr_table.array[synclock+offset+voice+voice+voice+voice+voice+voice+voice+voice+voice+voice+voice+voice+voice+voice]= Tnote[8];
					attr_table.array[synclock+offset+voice+voice+voice+voice+voice+voice+voice+voice+voice+voice+voice+voice+voice+voice+voice]= Ttouch[8];
					}
			
			
			
			
			
		}

	
	
	Ttouch[0]=0;
	Ttouch[1]=0;
	Ttouch[2]=0;
	Ttouch[3]=0;
	Ttouch[4]=0;
	Ttouch[5]=0;
	Ttouch[6]=0;
	Ttouch[7]=0;
	Ttouch[8]=0;

	
	touch=0;
	prevstep=synclock;
	}



//reset bend & touch
	if ((inlet_reset || (synclock<1))&&!resetrig){
		
		MidiSend2((midi_device_t) attr_output, MIDI_CHANNEL_PRESSURE + (attr_channel-1),0); 
		resetrig=1;

		MidiSend3((midi_device_t) attr_output, MIDI_POLY_PRESSURE + (attr_channel-1),(Onote[0]-1),0); 
		MidiSend3((midi_device_t) attr_output, MIDI_POLY_PRESSURE + (attr_channel-1),(Onote[1]-1),0); 
		MidiSend3((midi_device_t) attr_output, MIDI_POLY_PRESSURE + (attr_channel-1),(Onote[2]-1),0); 
		MidiSend3((midi_device_t) attr_output, MIDI_POLY_PRESSURE + (attr_channel-1),(Onote[3]-1),0); 
		MidiSend3((midi_device_t) attr_output, MIDI_POLY_PRESSURE + (attr_channel-1),(Onote[4]-1),0); 
		MidiSend3((midi_device_t) attr_output, MIDI_POLY_PRESSURE + (attr_channel-1),(Onote[5]-1),0); 
		MidiSend3((midi_device_t) attr_output, MIDI_POLY_PRESSURE + (attr_channel-1),(Onote[6]-1),0); 
		MidiSend3((midi_device_t) attr_output, MIDI_POLY_PRESSURE + (attr_channel-1),(Onote[7]-1),0); 
		MidiSend3((midi_device_t) attr_output, MIDI_POLY_PRESSURE + (attr_channel-1),(Onote[8]-1),0); 
	
		
		}

if (!inlet_reset && (synclock>0)){
	resetrig=0;
	}]]></code.krate>
         <code.midihandler><![CDATA[if(attr_input) {

if (status == (attr_channel-1) + MIDI_POLY_PRESSURE){
	if ((Onote[0]==(data1+1)) && (Otouch[0])){
		Tnote[0]=data1+1;
		Ttouch[0]=data2+1;
		
	}
	else if ((Onote[1]==(data1+1)) && (Otouch[1])){
		Tnote[1]=data1+1;
		Ttouch[1]=data2+1;
		
	}
	else if ((Onote[2]==(data1+1)) && (Otouch[2])){
		Tnote[2]=data1+1;
		Ttouch[2]=data2+1;
		
	}
	else if ((Onote[3]==(data1+1)) && (Otouch[3])){
		Tnote[3]=data1+1;
		Ttouch[3]=data2+1;
		
	}
	else if ((Onote[4]==(data1+1)) && (Otouch[4])){
		Tnote[4]=data1+1;
		Ttouch[4]=data2+1;
		
	}
	else if ((Onote[5]==(data1+1)) && (Otouch[5])){
		Tnote[5]=data1+1;
		Ttouch[5]=data2+1;
		
	}
	else if ((Onote[6]==(data1+1)) && (Otouch[6])){
		Tnote[6]=data1+1;
		Ttouch[6]=data2+1;
		
	}
	else if ((Onote[7]==(data1+1)) && (Otouch[7])){
		Tnote[7]=data1+1;
		Ttouch[7]=data2+1;
		
	}
	else if (Tnote[0]==(data1+1)){
		Tnote[0]=data1+1;
		Ttouch[0]=data2+1;
		
	}
	else if (Tnote[1]==(data1+1)){
		Tnote[1]=data1+1;
		Ttouch[1]=data2+1;
		
	}
	else if (Tnote[2]==(data1+1)){
		Tnote[2]=data1+1;
		Ttouch[2]=data2+1;
		
	}
	else if (Tnote[3]==(data1+1)){
		Tnote[3]=data1+1;
		Ttouch[3]=data2+1;
		
	}
	else if (Tnote[4]==(data1+1)){
		Tnote[4]=data1+1;
		Ttouch[4]=data2+1;
		
	}
	else if (Tnote[5]==(data1+1)){
		Tnote[5]=data1+1;
		Ttouch[5]=data2+1;
		
	}
	else if (Tnote[6]==(data1+1)){
		Tnote[6]=data1+1;
		Ttouch[6]=data2+1;
		
	}
	else if (Tnote[7]==(data1+1)){
		Tnote[7]=data1+1;
		Ttouch[7]=data2+1;
		
	}
	else	if (!Ttouch[0]){
		Tnote[0]=data1+1;
		Ttouch[0]=data2+1;
		
	}
	else if (!Ttouch[1]){
		Tnote[1]=data1+1;
		Ttouch[1]=data2+1;
		
	}
	else if (!Ttouch[2]){
		Tnote[2]=data1+1;
		Ttouch[2]=data2+1;
		
	}
	else if (!Ttouch[3]){
		Tnote[3]=data1+1;
		Ttouch[3]=data2+1;
		
	}
	else if (!Ttouch[4]){
		Tnote[4]=data1+1;
		Ttouch[4]=data2+1;
		
	}
	else if (!Ttouch[5]){
		Tnote[5]=data1+1;
		Ttouch[5]=data2+1;
		
	}
	else if (!Ttouch[6]){
		Tnote[6]=data1+1;
		Ttouch[6]=data2+1;
		
	}
	else if (!Ttouch[7]){
		Tnote[7]=data1+1;
		Ttouch[7]=data2+1;
		
	}
	else if (!Ttouch[8]){
		Tnote[8]=data1+1;
		Ttouch[8]=data2+1;
		
	}
	
	

	
	}



	
}]]></code.midihandler>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="16d73047-6c6f-4799-aca2-f26ae67c5ffa" name="bend" x="742" y="896">
      <params/>
      <attribs>
         <combo attributeName="input" selection="din"/>
         <combo attributeName="output" selection="internal port 1"/>
         <spinner attributeName="channel" value="7"/>
         <objref attributeName="table" obj="midiloop"/>
         <spinner attributeName="maxbar" value="8"/>
         <spinner attributeName="maxslots" value="7"/>
         <combo attributeName="resolution" selection="192ppq"/>
      </attribs>
      <object id="patch/object" uuid="16d73047-6c6f-4799-aca2-f26ae67c5ffa">
         <sDescription>object that records pitch bend, after touch and midi CCs.
for use with the midi looper objects.
could be used standalone, inlet stepunQCC expects a clock running at 96ppq</sDescription>
         <author>Mattilyn Mattroe</author>
         <license>if you use the object to play a wedding in september you have to come round and fix the dodgy extractor fan in my bathroom. otherwise, do as you will</license>
         <helpPatch>midi looper help.axh</helpPatch>
         <inlets>
            <int32 name="offset"/>
            <int32 name="slot"/>
            <int32 name="synclock"/>
            <bool32 name="rec"/>
            <bool32 name="play"/>
            <bool32 name="reset"/>
            <bool32 name="overdub"/>
            <bool32 name="clear"/>
            <int32 name="cslot"/>
         </inlets>
         <outlets>
            <int32 name="offset"/>
         </outlets>
         <displays/>
         <params/>
         <attribs>
            <combo name="input">
               <MenuEntries>
                  <string>omni</string>
                  <string>din</string>
                  <string>usb host port 1</string>
                  <string>usb host port 2</string>
                  <string>usb host port 3</string>
                  <string>usb host port 4</string>
                  <string>internal port 1</string>
                  <string>internal port 2</string>
                  <string>usb device port 1</string>
               </MenuEntries>
               <CEntries>
                  <string>true</string>
                  <string>dev == MIDI_DEVICE_DIN &amp;&amp; port == 1</string>
                  <string>dev == MIDI_DEVICE_USB_HOST &amp;&amp; port == 1</string>
                  <string>dev == MIDI_DEVICE_USB_HOST &amp;&amp; port == 2</string>
                  <string>dev == MIDI_DEVICE_USB_HOST &amp;&amp; port == 3</string>
                  <string>dev == MIDI_DEVICE_USB_HOST &amp;&amp; port == 4</string>
                  <string>dev == MIDI_DEVICE_INTERNAL &amp;&amp; port == 1</string>
                  <string>dev == MIDI_DEVICE_INTERNAL &amp;&amp; port == 2</string>
                  <string>dev == MIDI_DEVICE_USB_DEVICE &amp;&amp; port == 1</string>
               </CEntries>
            </combo>
            <combo name="output">
               <MenuEntries>
                  <string>din</string>
                  <string>usb host port 1</string>
                  <string>usb host port 2</string>
                  <string>usb host port 3</string>
                  <string>usb host port 4</string>
                  <string>internal port 1</string>
                  <string>internal port 2</string>
                  <string>usb device port 1</string>
               </MenuEntries>
               <CEntries>
                  <string>MIDI_DEVICE_DIN, 1</string>
                  <string>MIDI_DEVICE_USB_HOST, 1</string>
                  <string>MIDI_DEVICE_USB_HOST, 2</string>
                  <string>MIDI_DEVICE_USB_HOST, 3</string>
                  <string>MIDI_DEVICE_USB_HOST, 4</string>
                  <string>MIDI_DEVICE_INTERNAL, 1</string>
                  <string>MIDI_DEVICE_INTERNAL, 2</string>
                  <string>MIDI_DEVICE_USB_DEVICE, 1</string>
               </CEntries>
            </combo>
            <spinner name="channel" MinValue="1" MaxValue="16" DefaultValue="1"/>
            <objref name="table"/>
            <spinner name="maxbar" MinValue="1" MaxValue="32" DefaultValue="0"/>
            <spinner name="maxslots" MinValue="1" MaxValue="32" DefaultValue="1"/>
            <combo name="resolution">
               <MenuEntries>
                  <string>192ppq</string>
                  <string>96ppq</string>
                  <string>48ppq</string>
                  <string>24ppq</string>
               </MenuEntries>
               <CEntries>
                  <string>0</string>
                  <string>1</string>
                  <string>2</string>
                  <string>3</string>
               </CEntries>
            </combo>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[int bendA;
int bendB;




int synclock;
int ObendA;
int ObendB;

int prevstep;
int voice;
int slotsize;

int offset;
int clear;
int ctrig;


int resetrig;]]></code.declaration>
         <code.init><![CDATA[voice=(768*attr_maxbar)>>attr_resolution;
slotsize=(voice*2);
clear=-1;]]></code.init>
         <code.krate><![CDATA[offset=inlet_offset + (slotsize*inlet_slot);
outlet_offset=inlet_offset + (slotsize*attr_maxslots);
if (inlet_synclock>=0){
	synclock=inlet_synclock>>attr_resolution;
	}
else {synclock=-1;}

ObendA=attr_table.array[synclock+offset];
ObendB=attr_table.array[synclock+offset+voice];

if (inlet_clear&&!ctrig){
	clear=0;
	ctrig=1;
}
if (!inlet_clear){
	ctrig=0;
}
if ((clear>=0)&& (clear<slotsize)){
	attr_table.array[clear+inlet_offset + (slotsize*inlet_cslot)]= 0;
	attr_table.array[clear+inlet_offset + (slotsize*inlet_cslot)+voice]= 0;
	
	
	
	clear+=1;
	if (clear>=slotsize){
		clear=-1;
	}
}
if (synclock!=prevstep){
//play
	if (inlet_play){
	
		
		if ((ObendA>0)||(ObendB>0)){
			MidiSend3((midi_device_t) attr_output, MIDI_PITCH_BEND + (attr_channel-1),(ObendA-1),(ObendB-1));
			}
	}

//record
	if (inlet_rec){
			attr_table.array[synclock+offset]= 0;
			attr_table.array[synclock+offset+voice]= 0;
		
			
		}
	if ((inlet_rec || inlet_overdub) && (inlet_play)){
		
		
			if ((bendA>0)||(bendB>0)){
					attr_table.array[synclock+offset]= bendA;
					attr_table.array[synclock+offset+voice]= bendB;
				}
			
			
		}


	bendA=0;
	bendB=0;

	prevstep=synclock;
	}


//reset bend & touch
	if ((inlet_reset || (synclock<1))&&!resetrig){
		MidiSend3((midi_device_t) attr_output, MIDI_PITCH_BEND+ (attr_channel-1),0,64);
		
		resetrig=1;
		
		}

if (!inlet_reset && (synclock>0)){
	resetrig=0;
	}]]></code.krate>
         <code.midihandler><![CDATA[if(attr_input) {
       


if (status == MIDI_PITCH_BEND +(attr_channel-1)){
	bendA=data1+1;
	bendB=data2+1;

	
	}

	
}]]></code.midihandler>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="16d73047-6c6f-4799-aca2-f26ae67c5ffa" name="channel touch" x="896" y="896">
      <params/>
      <attribs>
         <combo attributeName="input" selection="din"/>
         <combo attributeName="output" selection="internal port 1"/>
         <spinner attributeName="channel" value="7"/>
         <objref attributeName="table" obj="midiloop"/>
         <spinner attributeName="maxbar" value="8"/>
         <spinner attributeName="maxslots" value="7"/>
         <combo attributeName="resolution" selection="192ppq"/>
      </attribs>
      <object id="patch/object" uuid="16d73047-6c6f-4799-aca2-f26ae67c5ffa">
         <sDescription>object that records pitch bend, after touch and midi CCs.
for use with the midi looper objects.
could be used standalone, inlet stepunQCC expects a clock running at 96ppq</sDescription>
         <author>Mattilyn Mattroe</author>
         <license>if you use the object to play a wedding in september you have to come round and fix the dodgy extractor fan in my bathroom. otherwise, do as you will</license>
         <helpPatch>midi looper help.axh</helpPatch>
         <inlets>
            <int32 name="offset"/>
            <int32 name="slot"/>
            <int32 name="synclock"/>
            <bool32 name="rec"/>
            <bool32 name="play"/>
            <bool32 name="reset"/>
            <bool32 name="overdub"/>
            <bool32 name="clear"/>
            <int32 name="cslot"/>
         </inlets>
         <outlets>
            <int32 name="offset"/>
         </outlets>
         <displays/>
         <params/>
         <attribs>
            <combo name="input">
               <MenuEntries>
                  <string>omni</string>
                  <string>din</string>
                  <string>usb host port 1</string>
                  <string>usb host port 2</string>
                  <string>usb host port 3</string>
                  <string>usb host port 4</string>
                  <string>internal port 1</string>
                  <string>internal port 2</string>
                  <string>usb device port 1</string>
               </MenuEntries>
               <CEntries>
                  <string>true</string>
                  <string>dev == MIDI_DEVICE_DIN &amp;&amp; port == 1</string>
                  <string>dev == MIDI_DEVICE_USB_HOST &amp;&amp; port == 1</string>
                  <string>dev == MIDI_DEVICE_USB_HOST &amp;&amp; port == 2</string>
                  <string>dev == MIDI_DEVICE_USB_HOST &amp;&amp; port == 3</string>
                  <string>dev == MIDI_DEVICE_USB_HOST &amp;&amp; port == 4</string>
                  <string>dev == MIDI_DEVICE_INTERNAL &amp;&amp; port == 1</string>
                  <string>dev == MIDI_DEVICE_INTERNAL &amp;&amp; port == 2</string>
                  <string>dev == MIDI_DEVICE_USB_DEVICE &amp;&amp; port == 1</string>
               </CEntries>
            </combo>
            <combo name="output">
               <MenuEntries>
                  <string>din</string>
                  <string>usb host port 1</string>
                  <string>usb host port 2</string>
                  <string>usb host port 3</string>
                  <string>usb host port 4</string>
                  <string>internal port 1</string>
                  <string>internal port 2</string>
                  <string>usb device port 1</string>
               </MenuEntries>
               <CEntries>
                  <string>MIDI_DEVICE_DIN, 1</string>
                  <string>MIDI_DEVICE_USB_HOST, 1</string>
                  <string>MIDI_DEVICE_USB_HOST, 2</string>
                  <string>MIDI_DEVICE_USB_HOST, 3</string>
                  <string>MIDI_DEVICE_USB_HOST, 4</string>
                  <string>MIDI_DEVICE_INTERNAL, 1</string>
                  <string>MIDI_DEVICE_INTERNAL, 2</string>
                  <string>MIDI_DEVICE_USB_DEVICE, 1</string>
               </CEntries>
            </combo>
            <spinner name="channel" MinValue="1" MaxValue="16" DefaultValue="1"/>
            <objref name="table"/>
            <spinner name="maxbar" MinValue="1" MaxValue="32" DefaultValue="0"/>
            <spinner name="maxslots" MinValue="1" MaxValue="32" DefaultValue="1"/>
            <combo name="resolution">
               <MenuEntries>
                  <string>192ppq</string>
                  <string>96ppq</string>
                  <string>48ppq</string>
                  <string>24ppq</string>
               </MenuEntries>
               <CEntries>
                  <string>0</string>
                  <string>1</string>
                  <string>2</string>
                  <string>3</string>
               </CEntries>
            </combo>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[int touch;


int synclock;

int Otouch;
int prevstep;
int voice;
int slotsize;
int play;
int rec;
int offset;
int clear;
int ctrig;


int resetrig;]]></code.declaration>
         <code.init><![CDATA[voice=(768*attr_maxbar)>>attr_resolution;
slotsize=voice;
clear=-1;]]></code.init>
         <code.krate><![CDATA[offset=inlet_offset + (slotsize*inlet_slot);
outlet_offset=inlet_offset + (slotsize*attr_maxslots);
if (inlet_synclock>=0){
	synclock=inlet_synclock>>attr_resolution;
	}
else {synclock=-1;}

Otouch=attr_table.array[synclock+offset];
if (inlet_clear&&!ctrig){
	clear=0;
	ctrig=1;
}
if (!inlet_clear){
	ctrig=0;
}
if ((clear>=0)&& (clear<slotsize)){
	attr_table.array[clear+inlet_offset + (slotsize*inlet_cslot)]= 0;

	
	
	clear+=1;
	if (clear>=slotsize){
		clear=-1;
	}
}
if (synclock!=prevstep){
//play
	if (inlet_play){
		
		if (Otouch>0){
			MidiSend2((midi_device_t) attr_output, MIDI_CHANNEL_PRESSURE + (attr_channel-1),(Otouch-1)); 
			}
		}

//record
	if (inlet_rec){
			attr_table.array[synclock+offset]= 0;
			
			
		}
//overdub
	if ((inlet_rec || inlet_overdub) && (inlet_play)){
		
			
				
			
			if (touch>0){
					attr_table.array[synclock+offset]= touch;
				}
		}


	touch=0;
	prevstep=synclock;
	}


//reset bend & touch
	if ((inlet_reset || (synclock<1))&&!resetrig){
	
		MidiSend2((midi_device_t) attr_output, MIDI_CHANNEL_PRESSURE + (attr_channel-1),0); 
		resetrig=1;
		
		}

if (!inlet_reset && (synclock>0)){
	resetrig=0;
	}]]></code.krate>
         <code.midihandler><![CDATA[if(attr_input) {
       


if (status == MIDI_CHANNEL_PRESSURE+(attr_channel-1)){
	touch=data1+1;

	
	}
	
}]]></code.midihandler>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="16d73047-6c6f-4799-aca2-f26ae67c5ffa" name="CC" x="1036" y="896">
      <params/>
      <attribs>
         <combo attributeName="input" selection="din"/>
         <combo attributeName="output" selection="internal port 1"/>
         <spinner attributeName="channel" value="7"/>
         <objref attributeName="table" obj="midiloop"/>
         <spinner attributeName="maxbar" value="8"/>
         <spinner attributeName="maxslots" value="7"/>
         <combo attributeName="resolution" selection="192ppq"/>
      </attribs>
      <object id="patch/object" uuid="16d73047-6c6f-4799-aca2-f26ae67c5ffa">
         <sDescription>object that records pitch bend, after touch and midi CCs.
for use with the midi looper objects.
could be used standalone, inlet stepunQCC expects a clock running at 96ppq</sDescription>
         <author>Mattilyn Mattroe</author>
         <license>if you use the object to play a wedding in september you have to come round and fix the dodgy extractor fan in my bathroom. otherwise, do as you will</license>
         <helpPatch>midi looper help.axh</helpPatch>
         <inlets>
            <int32 name="offset"/>
            <int32 name="slot"/>
            <int32 name="synclock"/>
            <bool32 name="rec"/>
            <bool32 name="play"/>
            <bool32 name="overdub"/>
            <bool32 name="clear"/>
            <int32 name="cslot"/>
         </inlets>
         <outlets>
            <int32 name="offset"/>
         </outlets>
         <displays/>
         <params/>
         <attribs>
            <combo name="input">
               <MenuEntries>
                  <string>omni</string>
                  <string>din</string>
                  <string>usb host port 1</string>
                  <string>usb host port 2</string>
                  <string>usb host port 3</string>
                  <string>usb host port 4</string>
                  <string>internal port 1</string>
                  <string>internal port 2</string>
                  <string>usb device port 1</string>
               </MenuEntries>
               <CEntries>
                  <string>true</string>
                  <string>dev == MIDI_DEVICE_DIN &amp;&amp; port == 1</string>
                  <string>dev == MIDI_DEVICE_USB_HOST &amp;&amp; port == 1</string>
                  <string>dev == MIDI_DEVICE_USB_HOST &amp;&amp; port == 2</string>
                  <string>dev == MIDI_DEVICE_USB_HOST &amp;&amp; port == 3</string>
                  <string>dev == MIDI_DEVICE_USB_HOST &amp;&amp; port == 4</string>
                  <string>dev == MIDI_DEVICE_INTERNAL &amp;&amp; port == 1</string>
                  <string>dev == MIDI_DEVICE_INTERNAL &amp;&amp; port == 2</string>
                  <string>dev == MIDI_DEVICE_USB_DEVICE &amp;&amp; port == 1</string>
               </CEntries>
            </combo>
            <combo name="output">
               <MenuEntries>
                  <string>din</string>
                  <string>usb host port 1</string>
                  <string>usb host port 2</string>
                  <string>usb host port 3</string>
                  <string>usb host port 4</string>
                  <string>internal port 1</string>
                  <string>internal port 2</string>
                  <string>usb device port 1</string>
               </MenuEntries>
               <CEntries>
                  <string>MIDI_DEVICE_DIN, 1</string>
                  <string>MIDI_DEVICE_USB_HOST, 1</string>
                  <string>MIDI_DEVICE_USB_HOST, 2</string>
                  <string>MIDI_DEVICE_USB_HOST, 3</string>
                  <string>MIDI_DEVICE_USB_HOST, 4</string>
                  <string>MIDI_DEVICE_INTERNAL, 1</string>
                  <string>MIDI_DEVICE_INTERNAL, 2</string>
                  <string>MIDI_DEVICE_USB_DEVICE, 1</string>
               </CEntries>
            </combo>
            <spinner name="channel" MinValue="1" MaxValue="16" DefaultValue="1"/>
            <objref name="table"/>
            <spinner name="maxbar" MinValue="1" MaxValue="32" DefaultValue="0"/>
            <spinner name="maxslots" MinValue="1" MaxValue="32" DefaultValue="1"/>
            <combo name="resolution">
               <MenuEntries>
                  <string>192ppq</string>
                  <string>96ppq</string>
                  <string>48ppq</string>
                  <string>24ppq</string>
               </MenuEntries>
               <CEntries>
                  <string>0</string>
                  <string>1</string>
                  <string>2</string>
                  <string>3</string>
               </CEntries>
            </combo>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[int cc;
int ccv;
int bendA;
int bendB;
int touch;

int Occ;
int Occv;
int OccB;
int OccvB;
int OccC;
int OccvC;

int synclock;
int ObendA;
int ObendB;
int Otouch;
int prevstep;
int voice;
int slotsize;
int play;
int rec;
int offset;
int clear;
int ctrig;


int resetrig;]]></code.declaration>
         <code.init><![CDATA[voice=(768*attr_maxbar)>>attr_resolution;
slotsize=(voice*6);
clear=-1;]]></code.init>
         <code.krate><![CDATA[offset=inlet_offset + (slotsize*inlet_slot);
outlet_offset=inlet_offset + (slotsize*attr_maxslots);
if (inlet_synclock>=0){
	synclock=inlet_synclock>>attr_resolution;
	}
else {synclock=-1;}
Occ=attr_table.array[synclock+offset];
Occv=attr_table.array[synclock+offset+voice];
OccB=attr_table.array[synclock+offset+voice+voice];
OccvB=attr_table.array[synclock+offset+voice+voice+voice];
OccC=attr_table.array[synclock+offset+voice+voice+voice+voice];
OccvC=attr_table.array[synclock+offset+voice+voice+voice+voice+voice];

if (inlet_clear&&!ctrig){
	clear=0;
	ctrig=1;
}
if (!inlet_clear){
	ctrig=0;
}
if ((clear>=0)&& (clear<slotsize)){
	attr_table.array[clear+inlet_offset + (slotsize*inlet_cslot)]= 0;
	attr_table.array[clear+inlet_offset + (slotsize*inlet_cslot)+voice]= 0;
	attr_table.array[clear+inlet_offset + (slotsize*inlet_cslot)+voice+voice]= 0;
	attr_table.array[clear+inlet_offset + (slotsize*inlet_cslot)+voice+voice+voice]= 0;
	attr_table.array[clear+inlet_offset + (slotsize*inlet_cslot)+voice+voice+voice+voice]= 0;
	attr_table.array[clear+inlet_offset + (slotsize*inlet_cslot)+voice+voice+voice+voice+voice]= 0;
	
	
	
	clear+=1;
	if (clear>=slotsize){
		clear=-1;
	}
}
if (synclock!=prevstep){
//play
	if (inlet_play){
		if (Occv>0){
			MidiSend3((midi_device_t) attr_output, MIDI_CONTROL_CHANGE + (attr_channel-1),(Occ-1),(Occv-1));
		}
		if (OccvB>0){
			MidiSend3((midi_device_t) attr_output, MIDI_CONTROL_CHANGE + (attr_channel-1),(OccB-1),(OccvB-1));
		}
		if (OccvC>0){
			MidiSend3((midi_device_t) attr_output, MIDI_CONTROL_CHANGE + (attr_channel-1),(OccC-1),(OccvC-1));
		}
		
		
		}

//record
	if (inlet_rec){
			attr_table.array[synclock+offset]= 0;
			attr_table.array[synclock+offset+voice]= 0;
			attr_table.array[synclock+offset+voice+voice]= 0;
			attr_table.array[synclock+offset+voice+voice+voice]= 0;
			attr_table.array[synclock+offset+voice+voice+voice+voice]= 0;
			attr_table.array[synclock+offset+voice+voice+voice+voice+voice]= 0;
			
			
		}
//overdub
	if ((inlet_rec || inlet_overdub) && (inlet_play)){
		
			if (ccv>0){
				if (Occv && (Occ==cc))   {
					attr_table.array[synclock+offset]= cc;
					attr_table.array[synclock+offset+voice]= ccv;
					}
				else if (OccvB && (OccB==cc)){
					attr_table.array[synclock+offset+voice+voice]= cc;
					attr_table.array[synclock+offset+voice+voice+voice]= ccv;
				}
				else if (OccvC && (OccC==cc)){
					attr_table.array[synclock+offset+voice+voice+voice+voice]= cc;
					attr_table.array[synclock+offset+voice+voice+voice+voice+voice]= ccv;
				}
				else if (!Occv)   {
					attr_table.array[synclock+offset]= cc;
					attr_table.array[synclock+offset+voice]= ccv;
					}
				else if (!OccvB){
					attr_table.array[synclock+offset+voice+voice]= cc;
					attr_table.array[synclock+offset+voice+voice+voice]= ccv;
				}
				else if (!OccvC){
					attr_table.array[synclock+offset+voice+voice+voice+voice]= cc;
					attr_table.array[synclock+offset+voice+voice+voice+voice+voice]= ccv;
				}
				}
			
		}

	cc=0;
	ccv=0;
	
	prevstep=synclock;
	}]]></code.krate>
         <code.midihandler><![CDATA[if(attr_input) {
       
if (status == MIDI_CONTROL_CHANGE+(attr_channel-1)){
	cc=data1+1;
	ccv=data2+1;

	
	}


	
}]]></code.midihandler>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="f286242b-4a12-46f8-995e-6eeb6ad540dd" name="i_4" x="1176" y="896">
      <params/>
      <attribs/>
      <object id="patch/object" uuid="f286242b-4a12-46f8-995e-6eeb6ad540dd">
         <sDescription>display integer</sDescription>
         <author>Johannes Taelman</author>
         <license>BSD</license>
         <helpPatch>disp.axh</helpPatch>
         <inlets>
            <int32 name="in" description="input"/>
         </inlets>
         <outlets/>
         <displays>
            <int32.label name="v" noLabel="true"/>
         </displays>
         <params/>
         <attribs/>
         <includes/>
         <code.krate><![CDATA[disp_v=inlet_in;
]]></code.krate>
      </object>
   </patchobj>
   <comment type="patch/comment" x="1414" y="966" text="simple test synth"/>
   <patcher type="patch/patcher" uuid="0fce35a4-2c8c-4454-89a1-1ea50c790363" name="patcher_1" x="1414" y="980">
      <params>
         <frac32.s.map name="filter:pitch" value="16.0"/>
         <frac32.u.map name="filter:reso" value="11.5"/>
         <frac32.s.map name="adsr:a" value="-52.0"/>
         <frac32.s.map name="adsr:d" value="-4.0"/>
         <frac32.u.map name="adsr:s" value="14.0"/>
         <frac32.s.map name="adsr:r" value="-10.0"/>
         <frac32.u.map name="vol" value="31.0"/>
      </params>
      <attribs>
         <combo attributeName="poly" selection="16"/>
         <combo attributeName="midichannel" selection="7"/>
         <combo attributeName="mididevice" selection="omni"/>
         <combo attributeName="midiport" selection="omni"/>
      </attribs>
      <subpatch appVersion="1.0.12">
         <obj type="midi/in/keyb touch" uuid="edfcb4cfd5b2064e95f5a7ee644bca56252ec11f" name="keyb_1" x="280" y="126">
            <params/>
            <attribs/>
         </obj>
         <obj type="midi/in/bend" uuid="7bd8cace52a8c26ed61d80f65e238408d5d621f4" name="bend_1" x="434" y="126">
            <params/>
            <attribs/>
         </obj>
         <obj type="math/*c" uuid="7d5ef61c3bcd571ee6bbd8437ef3612125dfb225" name="*c_2" x="532" y="126">
            <params>
               <frac32.u.map name="amp" value="12.0"/>
            </params>
            <attribs/>
         </obj>
         <obj type="math/+" uuid="44553fdc8628c67ab535845ed1be304ad6c9553b" name="+_1" x="700" y="154">
            <params/>
            <attribs/>
         </obj>
         <obj type="osc/square cheap" uuid="58dc60ffca7e6c5029f12ec68787945c669b7a8f" name="square_1" x="826" y="210">
            <params>
               <frac32.s.map name="pitch" value="0.0"/>
            </params>
            <attribs/>
         </obj>
         <obj type="filter/lp m" uuid="1aa1bc51da479ed92429af700591f9d7b9f45f22" name="filter" x="1008" y="210">
            <params>
               <frac32.s.map name="pitch" onParent="true" value="0.0"/>
               <frac32.u.map name="reso" onParent="true" value="0.0"/>
            </params>
            <attribs/>
         </obj>
         <obj type="env/adsr" uuid="d1dbcc5fa6f87b98a6a91c87fd44acee5e690bac" name="adsr" x="1148" y="210">
            <params>
               <frac32.s.map name="a" onParent="true" value="-64.0"/>
               <frac32.s.map name="d" onParent="true" value="-34.0"/>
               <frac32.u.map name="s" onParent="true" value="23.5"/>
               <frac32.s.map name="r" onParent="true" value="-10.0"/>
            </params>
            <attribs/>
         </obj>
         <obj type="gain/vca" uuid="a9f2dcd18043e2f47364e45cb8814f63c2a37c0d" name="vca_6" x="1246" y="210">
            <params/>
            <attribs/>
         </obj>
         <obj type="math/*c" uuid="7a66f52a9594e7e9eb31328ea725cb3641a80b55" name="vol" x="1316" y="210">
            <params>
               <frac32.u.map name="amp" onParent="true" value="36.5"/>
            </params>
            <attribs/>
         </obj>
         <obj type="audio/out left" uuid="b11a3c09b2fdd575ea8212f2ce7743d5269253b1" name="out_4" x="1428" y="210">
            <params/>
            <attribs/>
         </obj>
         <nets>
            <net>
               <source obj="vca_6" outlet="o"/>
               <dest obj="vol" inlet="in"/>
            </net>
            <net>
               <source obj="vol" outlet="out"/>
               <dest obj="out_4" inlet="wave"/>
            </net>
            <net>
               <source obj="square_1" outlet="wave"/>
               <dest obj="filter" inlet="in"/>
            </net>
            <net>
               <source obj="adsr" outlet="env"/>
               <dest obj="vca_6" inlet="v"/>
            </net>
            <net>
               <source obj="keyb_1" outlet="gate"/>
               <dest obj="adsr" inlet="gate"/>
            </net>
            <net>
               <source obj="keyb_1" outlet="note"/>
               <dest obj="+_1" inlet="in1"/>
            </net>
            <net>
               <source obj="+_1" outlet="out"/>
               <dest obj="square_1" inlet="pitch"/>
            </net>
            <net>
               <source obj="*c_2" outlet="out"/>
               <dest obj="+_1" inlet="in2"/>
            </net>
            <net>
               <source obj="filter" outlet="out"/>
               <dest obj="vca_6" inlet="a"/>
            </net>
            <net>
               <source obj="bend_1" outlet="bend"/>
               <dest obj="*c_2" inlet="in"/>
            </net>
            <net>
               <source obj="keyb_1" outlet="touch"/>
               <dest obj="filter" inlet="pitch"/>
            </net>
         </nets>
         <settings>
            <subpatchmode>polyphonic</subpatchmode>
            <MidiChannel>7</MidiChannel>
            <HasMidiChannelSelector>true</HasMidiChannelSelector>
            <NPresets>8</NPresets>
            <NPresetEntries>32</NPresetEntries>
            <NModulationSources>8</NModulationSources>
            <NModulationTargetsPerSource>8</NModulationTargetsPerSource>
         </settings>
         <notes><![CDATA[]]></notes>
         <windowPos>
            <x>-8</x>
            <y>-8</y>
            <width>1616</width>
            <height>876</height>
         </windowPos>
      </subpatch>
   </patcher>
   <comment type="patch/comment" x="196" y="1148" text="metronom"/>
   <obj type="noise/pink" uuid="72c03a2468ee865f248733fcf9b12d4cf42b5a61" name="pink_1" x="98" y="1162">
      <params/>
      <attribs/>
   </obj>
   <obj type="env/d" uuid="190ae648e41832b41adbedb465317c18a010aefe" name="d_1" x="196" y="1162">
      <params>
         <frac32.s.map name="d" value="-46.0"/>
      </params>
      <attribs/>
   </obj>
   <obj type="math/*" uuid="922423f2db9f222aa3e5ba095778288c446da47a" name="*_2" x="322" y="1162">
      <params/>
      <attribs/>
   </obj>
   <obj type="gain/vca" uuid="a9f2dcd18043e2f47364e45cb8814f63c2a37c0d" name="vca_4" x="392" y="1162">
      <params/>
      <attribs/>
   </obj>
   <obj type="audio/out left" uuid="b11a3c09b2fdd575ea8212f2ce7743d5269253b1" name="out_2" x="490" y="1162">
      <params/>
      <attribs/>
   </obj>
   <comment type="patch/comment" x="196" y="1246" text="bar pulse"/>
   <obj type="env/d" uuid="190ae648e41832b41adbedb465317c18a010aefe" name="d_2" x="196" y="1260">
      <params>
         <frac32.s.map name="d" value="-23.0"/>
      </params>
      <attribs/>
   </obj>
   <obj type="math/*" uuid="922423f2db9f222aa3e5ba095778288c446da47a" name="*_1" x="308" y="1260">
      <params/>
      <attribs/>
   </obj>
   <obj type="gain/vca" uuid="a9f2dcd18043e2f47364e45cb8814f63c2a37c0d" name="vca_5" x="378" y="1260">
      <params/>
      <attribs/>
   </obj>
   <obj type="audio/out left" uuid="b11a3c09b2fdd575ea8212f2ce7743d5269253b1" name="out_3" x="490" y="1260">
      <params/>
      <attribs/>
   </obj>
   <nets>
      <net>
         <source obj="pink_1" outlet="out"/>
         <dest obj="vca_4" inlet="a"/>
         <dest obj="vca_5" inlet="a"/>
      </net>
      <net>
         <source obj="d_1" outlet="env"/>
         <dest obj="*_2" inlet="a"/>
      </net>
      <net>
         <source obj="d_2" outlet="env"/>
         <dest obj="*_1" inlet="a"/>
      </net>
      <net>
         <source obj="button_5" outlet="o"/>
         <dest obj="mnote_1" inlet="record"/>
      </net>
      <net>
         <source obj="button_2" outlet="o"/>
         <dest obj="mnote_1" inlet="stop"/>
      </net>
      <net>
         <source obj="button_4" outlet="o"/>
         <dest obj="mnote_1" inlet="overdub"/>
      </net>
      <net>
         <source obj="mnote_1" outlet="maxnotes"/>
         <dest obj="i_16" inlet="in"/>
      </net>
      <net>
         <source obj="mnote_1" outlet="slotnotes"/>
         <dest obj="i_9" inlet="in"/>
      </net>
      <net>
         <source obj="i_6" outlet="out"/>
         <dest obj="poly touch" inlet="cslot"/>
         <dest obj="bend" inlet="cslot"/>
         <dest obj="channel touch" inlet="cslot"/>
         <dest obj="mnote_1" inlet="slot"/>
         <dest obj="CC" inlet="cslot"/>
      </net>
      <net>
         <source obj="button_8" outlet="o"/>
         <dest obj="poly touch" inlet="clear"/>
         <dest obj="bend" inlet="clear"/>
         <dest obj="channel touch" inlet="clear"/>
         <dest obj="mnote_1" inlet="clearslot"/>
         <dest obj="CC" inlet="clear"/>
      </net>
      <net>
         <source obj="button_7" outlet="o"/>
         <dest obj="mnote_1" inlet="trigger"/>
      </net>
      <net>
         <source obj="toggle_2" outlet="o"/>
         <dest obj="mnote_1" inlet="quantize"/>
      </net>
      <net>
         <source obj="dial_1" outlet="out"/>
         <dest obj="*_2" inlet="b"/>
         <dest obj="*_1" inlet="b"/>
      </net>
      <net>
         <source obj="mnote_1" outlet="full"/>
         <dest obj="bool_5" inlet="in"/>
      </net>
      <net>
         <source obj="mnote_1" outlet="wait"/>
         <dest obj="bool_27" inlet="in"/>
      </net>
      <net>
         <source obj="mnote_1" outlet="playstate"/>
         <dest obj="i_3" inlet="in"/>
      </net>
      <net>
         <source obj="c_1" outlet="out"/>
         <dest obj="save_1" inlet="filename"/>
      </net>
      <net>
         <source obj="button_1" outlet="o"/>
         <dest obj="save_1" inlet="trig"/>
      </net>
      <net>
         <source obj="toggle_3" outlet="o"/>
         <dest obj="mnote_1" inlet="erase"/>
      </net>
      <net>
         <source obj="mclock_1" outlet="bpm"/>
         <dest obj="i_2" inlet="in"/>
      </net>
      <net>
         <source obj="button_3" outlet="o"/>
         <dest obj="mnote_1" inlet="undo"/>
      </net>
      <net>
         <source obj="*_1" outlet="result"/>
         <dest obj="vca_5" inlet="v"/>
      </net>
      <net>
         <source obj="vca_4" outlet="o"/>
         <dest obj="out_2" inlet="wave"/>
      </net>
      <net>
         <source obj="vca_5" outlet="o"/>
         <dest obj="out_3" inlet="wave"/>
      </net>
      <net>
         <source obj="*_2" outlet="result"/>
         <dest obj="vca_4" inlet="v"/>
      </net>
      <net>
         <source obj="i_7" outlet="out"/>
         <dest obj="mnote_1" inlet="quantization"/>
      </net>
      <net>
         <source obj="toggle_4" outlet="o"/>
         <dest obj="mnote_1" inlet="triplets"/>
      </net>
      <net>
         <source obj="mnote_1" outlet="overdub"/>
         <dest obj="bool_3" inlet="in"/>
         <dest obj="poly touch" inlet="overdub"/>
         <dest obj="bend" inlet="overdub"/>
         <dest obj="channel touch" inlet="overdub"/>
         <dest obj="CC" inlet="overdub"/>
      </net>
      <net>
         <source obj="mnote_1" outlet="record"/>
         <dest obj="bool_4" inlet="in"/>
         <dest obj="poly touch" inlet="rec"/>
         <dest obj="bend" inlet="rec"/>
         <dest obj="channel touch" inlet="rec"/>
         <dest obj="CC" inlet="rec"/>
      </net>
      <net>
         <source obj="mnote_1" outlet="play"/>
         <dest obj="bool_26" inlet="in"/>
         <dest obj="poly touch" inlet="play"/>
         <dest obj="bend" inlet="play"/>
         <dest obj="channel touch" inlet="play"/>
         <dest obj="CC" inlet="play"/>
      </net>
      <net>
         <source obj="mclock_1" outlet="start"/>
         <dest obj="poly touch" inlet="reset"/>
         <dest obj="bend" inlet="reset"/>
         <dest obj="channel touch" inlet="reset"/>
      </net>
      <net>
         <source obj="mnote_1" outlet="synclock"/>
         <dest obj="i_10" inlet="in"/>
         <dest obj="poly touch" inlet="synclock"/>
         <dest obj="bend" inlet="synclock"/>
         <dest obj="channel touch" inlet="synclock"/>
         <dest obj="CC" inlet="synclock"/>
      </net>
      <net>
         <source obj="mnote_1" outlet="currentslot"/>
         <dest obj="i_1" inlet="in"/>
         <dest obj="poly touch" inlet="slot"/>
         <dest obj="bend" inlet="slot"/>
         <dest obj="channel touch" inlet="slot"/>
         <dest obj="CC" inlet="slot"/>
      </net>
      <net>
         <source obj="poly touch" outlet="offset"/>
         <dest obj="bend" inlet="offset"/>
      </net>
      <net>
         <source obj="bend" outlet="offset"/>
         <dest obj="channel touch" inlet="offset"/>
      </net>
      <net>
         <source obj="channel touch" outlet="offset"/>
         <dest obj="CC" inlet="offset"/>
      </net>
      <net>
         <source obj="CC" outlet="offset"/>
         <dest obj="i_4" inlet="in"/>
      </net>
      <net>
         <source obj="mnote_1" outlet="offset"/>
         <dest obj="poly touch" inlet="offset"/>
      </net>
      <net>
         <source obj="i_8" outlet="out"/>
         <dest obj="mnote_1" inlet="maxbar"/>
      </net>
      <net>
         <source obj="mclock_1" outlet="192ppq"/>
         <dest obj="mnote_1" inlet="192ppq"/>
      </net>
      <net>
         <source obj="mclock_1" outlet="pulse"/>
         <dest obj="d_1" inlet="trig"/>
      </net>
      <net>
         <source obj="mclock_1" outlet="bartrig"/>
         <dest obj="d_2" inlet="trig"/>
      </net>
      <net>
         <source obj="mclock_1" outlet="clock"/>
         <dest obj="ibar_1" inlet="in"/>
      </net>
      <net>
         <source obj="toggle_1" outlet="o"/>
         <dest obj="clock_4" inlet="run"/>
         <dest obj="clock_4" inlet="rst"/>
      </net>
      <net>
         <source obj="*c_1" outlet="out"/>
         <dest obj="+c_1" inlet="in"/>
      </net>
      <net>
         <source obj="+c_1" outlet="out"/>
         <dest obj="clock_4" inlet="speed"/>
      </net>
      <net>
         <source obj="dial_2" outlet="out"/>
         <dest obj="*c_1" inlet="in"/>
      </net>
   </nets>
   <settings>
      <subpatchmode>no</subpatchmode>
      <MidiChannel>1</MidiChannel>
      <NPresets>8</NPresets>
      <NPresetEntries>32</NPresetEntries>
      <NModulationSources>8</NModulationSources>
      <NModulationTargetsPerSource>8</NModulationTargetsPerSource>
   </settings>
   <notes><![CDATA[]]></notes>
   <windowPos>
      <x>355</x>
      <y>144</y>
      <width>1616</width>
      <height>876</height>
   </windowPos>
</patch-1.0>