<patch-1.0 appVersion="1.0.12">
   <obj type="ctrl/dial p" uuid="cc5d2846c3d50e425f450c4b9851371b54f4d674" name="dial_1" x="504" y="0">
      <params>
         <frac32.u.map name="value" value="34.829999923706055"/>
      </params>
      <attribs/>
   </obj>
   <obj type="ctrl/dial p" uuid="cc5d2846c3d50e425f450c4b9851371b54f4d674" name="dial_3" x="574" y="0">
      <params>
         <frac32.u.map name="value" value="29.359999656677246"/>
      </params>
      <attribs/>
   </obj>
   <obj type="ctrl/dial p" uuid="cc5d2846c3d50e425f450c4b9851371b54f4d674" name="dial_4" x="644" y="0">
      <params>
         <frac32.u.map name="value" value="17.5"/>
      </params>
      <attribs/>
   </obj>
   <obj type="ctrl/dial p" uuid="cc5d2846c3d50e425f450c4b9851371b54f4d674" name="dial_5" x="714" y="0">
      <params>
         <frac32.u.map name="value" value="39.40499925613403"/>
      </params>
      <attribs/>
   </obj>
   <obj type="ctrl/dial p" uuid="cc5d2846c3d50e425f450c4b9851371b54f4d674" name="dial_6" x="784" y="0">
      <params>
         <frac32.u.map name="value" value="36.5"/>
      </params>
      <attribs/>
   </obj>
   <obj type="ctrl/dial p" uuid="cc5d2846c3d50e425f450c4b9851371b54f4d674" name="dial_7" x="854" y="0">
      <params>
         <frac32.u.map name="value" value="18.339999675750732"/>
      </params>
      <attribs/>
   </obj>
   <obj type="ctrl/dial p" uuid="cc5d2846c3d50e425f450c4b9851371b54f4d674" name="dial_8" x="924" y="0">
      <params>
         <frac32.u.map name="value" value="37.0"/>
      </params>
      <attribs/>
   </obj>
   <obj type="ctrl/dial p" uuid="cc5d2846c3d50e425f450c4b9851371b54f4d674" name="dial_9" x="994" y="0">
      <params>
         <frac32.u.map name="value" value="29.0"/>
      </params>
      <attribs/>
   </obj>
   <obj type="ctrl/dial p" uuid="cc5d2846c3d50e425f450c4b9851371b54f4d674" name="dial_25" x="1106" y="0">
      <params>
         <frac32.u.map name="value" value="38.5"/>
      </params>
      <attribs/>
   </obj>
   <obj type="ctrl/dial p" uuid="cc5d2846c3d50e425f450c4b9851371b54f4d674" name="dial_34" x="1176" y="0">
      <params>
         <frac32.u.map name="value" value="8.0"/>
      </params>
      <attribs/>
   </obj>
   <obj type="ctrl/dial p" uuid="cc5d2846c3d50e425f450c4b9851371b54f4d674" name="dial_35" x="1246" y="0">
      <params>
         <frac32.u.map name="value" value="41.5"/>
      </params>
      <attribs/>
   </obj>
   <obj type="ctrl/dial p" uuid="cc5d2846c3d50e425f450c4b9851371b54f4d674" name="dial_36" x="1316" y="0">
      <params>
         <frac32.u.map name="value" value="24.209999561309814"/>
      </params>
      <attribs/>
   </obj>
   <obj type="ctrl/dial p" uuid="cc5d2846c3d50e425f450c4b9851371b54f4d674" name="dial_37" x="1386" y="0">
      <params>
         <frac32.u.map name="value" value="26.0"/>
      </params>
      <attribs/>
   </obj>
   <obj type="ctrl/dial p" uuid="cc5d2846c3d50e425f450c4b9851371b54f4d674" name="dial_38" x="1456" y="0">
      <params>
         <frac32.u.map name="value" value="18.339999675750732"/>
      </params>
      <attribs/>
   </obj>
   <obj type="ctrl/dial p" uuid="cc5d2846c3d50e425f450c4b9851371b54f4d674" name="dial_39" x="1526" y="0">
      <params>
         <frac32.u.map name="value" value="49.5"/>
      </params>
      <attribs/>
   </obj>
   <obj type="ctrl/dial p" uuid="cc5d2846c3d50e425f450c4b9851371b54f4d674" name="dial_40" x="1596" y="0">
      <params>
         <frac32.u.map name="value" value="36.5"/>
      </params>
      <attribs/>
   </obj>
   <patchobj type="patch/object" uuid="9d1f58bb-bc4b-4a18-8eba-c89a5f0c857f" name="1x16Bctrl" x="504" y="84">
      <params/>
      <attribs>
         <spinner attributeName="cc1" value="0"/>
         <spinner attributeName="cc2" value="1"/>
         <spinner attributeName="cc3" value="2"/>
         <spinner attributeName="cc4" value="6"/>
         <spinner attributeName="cc5" value="4"/>
         <spinner attributeName="cc6" value="5"/>
         <spinner attributeName="cc7" value="12"/>
         <spinner attributeName="cc8" value="19"/>
         <spinner attributeName="channel" value="9"/>
      </attribs>
      <object id="patch/object" uuid="9d1f58bb-bc4b-4a18-8eba-c89a5f0c857f">
         <sDescription>add</sDescription>
         <author>Johannes Taelman</author>
         <license>BSD</license>
         <helpPatch>math.axh</helpPatch>
         <inlets>
            <frac32.positive name="i1"/>
            <frac32.positive name="i2"/>
            <frac32.positive name="i3"/>
            <frac32.positive name="i4"/>
            <frac32.positive name="i5"/>
            <frac32.positive name="i6"/>
            <frac32.positive name="i7"/>
            <frac32.positive name="i8"/>
         </inlets>
         <outlets>
            <frac32.positive name="out"/>
         </outlets>
         <displays/>
         <params/>
         <attribs>
            <spinner name="cc1" MinValue="0" MaxValue="1023" DefaultValue="0"/>
            <spinner name="cc2" MinValue="0" MaxValue="1023" DefaultValue="0"/>
            <spinner name="cc3" MinValue="0" MaxValue="1023" DefaultValue="0"/>
            <spinner name="cc4" MinValue="0" MaxValue="1023" DefaultValue="0"/>
            <spinner name="cc5" MinValue="0" MaxValue="1023" DefaultValue="0"/>
            <spinner name="cc6" MinValue="0" MaxValue="1023" DefaultValue="0"/>
            <spinner name="cc7" MinValue="0" MaxValue="1023" DefaultValue="0"/>
            <spinner name="cc8" MinValue="0" MaxValue="1023" DefaultValue="0"/>
            <spinner name="channel" MinValue="0" MaxValue="15" DefaultValue="0"/>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[int type=1; // 1x 16bit control
int busy;
int16_t bufV[32];
int16_t bufP[32];
int32_t in[8],prv[8],ctrl[8],i,wp,rp;
uint32_t out;
//channel        4 bits
//messagetype    2 bits
//message index 10 bits
//value		 16 bits]]></code.declaration>
         <code.init><![CDATA[wp=0;
rp=0;
ctrl[0]=attr_cc1;
ctrl[1]=attr_cc2;
ctrl[2]=attr_cc3;
ctrl[3]=attr_cc4;
ctrl[4]=attr_cc5;
ctrl[5]=attr_cc6;
ctrl[6]=attr_cc7;
ctrl[7]=attr_cc8;
busy=0;
for(i=0;i<8;i++){
	prv[i]=0;
}
for(i=0;i<32;i++){
	bufV[i]=0;
	bufP[i]=0;
}]]></code.init>
         <code.krate><![CDATA[in[0]=inlet_i1;
in[1]=inlet_i2;
in[2]=inlet_i3;
in[3]=inlet_i4;
in[4]=inlet_i5;
in[5]=inlet_i6;
in[6]=inlet_i7;
in[7]=inlet_i8;
outlet_out=0;

for(i=0;i<8;i++)
{
	if(!(in[i]==prv[i]))
	{
		bufV[wp]=__USAT(in[i],27)>>12;
		bufP[wp]=i;
		wp=(1+wp)&31;
	}	
	prv[i]=in[i];
}


out=0;
if(!(wp==rp)){
out=attr_channel;
out+=type<<4;
out+=ctrl[(bufP[rp])]<<6;
out+=(uint32_t)bufV[rp]<<16;
rp=(rp+1)&31;
}

outlet_out=out;


/*
if(busy>0){
if(busy==33){outlet_out=1;}
else if(busy>28){
outlet_out=(attr_channel>>(busy-29))&1;
}
else if(busy>26){
outlet_out=(type>>(busy-27))&1;
}
else if(busy>16){
outlet_out=(ctrl[(bufP[rp])]>>(busy-17))&1;
}
else{
outlet_out=(bufV[rp]>>(busy-1))&1;
}

busy-=1;
if(busy==0){
	rp=(rp+1)&31;
}
}
*/]]></code.krate>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="9d1f58bb-bc4b-4a18-8eba-c89a5f0c857f" name="1x16Bctrl_" x="1106" y="84">
      <params/>
      <attribs>
         <spinner attributeName="cc1" value="0"/>
         <spinner attributeName="cc2" value="1"/>
         <spinner attributeName="cc3" value="2"/>
         <spinner attributeName="cc4" value="6"/>
         <spinner attributeName="cc5" value="4"/>
         <spinner attributeName="cc6" value="5"/>
         <spinner attributeName="cc7" value="12"/>
         <spinner attributeName="cc8" value="19"/>
         <spinner attributeName="channel" value="7"/>
      </attribs>
      <object id="patch/object" uuid="9d1f58bb-bc4b-4a18-8eba-c89a5f0c857f">
         <sDescription>add</sDescription>
         <author>Johannes Taelman</author>
         <license>BSD</license>
         <helpPatch>math.axh</helpPatch>
         <inlets>
            <frac32.positive name="i1"/>
            <frac32.positive name="i2"/>
            <frac32.positive name="i3"/>
            <frac32.positive name="i4"/>
            <frac32.positive name="i5"/>
            <frac32.positive name="i6"/>
            <frac32.positive name="i7"/>
            <frac32.positive name="i8"/>
         </inlets>
         <outlets>
            <frac32.positive name="out"/>
         </outlets>
         <displays/>
         <params/>
         <attribs>
            <spinner name="cc1" MinValue="0" MaxValue="1023" DefaultValue="0"/>
            <spinner name="cc2" MinValue="0" MaxValue="1023" DefaultValue="0"/>
            <spinner name="cc3" MinValue="0" MaxValue="1023" DefaultValue="0"/>
            <spinner name="cc4" MinValue="0" MaxValue="1023" DefaultValue="0"/>
            <spinner name="cc5" MinValue="0" MaxValue="1023" DefaultValue="0"/>
            <spinner name="cc6" MinValue="0" MaxValue="1023" DefaultValue="0"/>
            <spinner name="cc7" MinValue="0" MaxValue="1023" DefaultValue="0"/>
            <spinner name="cc8" MinValue="0" MaxValue="1023" DefaultValue="0"/>
            <spinner name="channel" MinValue="0" MaxValue="15" DefaultValue="0"/>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[int type=1; // 1x 16bit control
int busy;
int16_t bufV[32];
int16_t bufP[32];
int32_t in[8],prv[8],ctrl[8],i,wp,rp;
uint32_t out;
//channel        4 bits
//messagetype    2 bits
//message index 10 bits
//value		 16 bits]]></code.declaration>
         <code.init><![CDATA[wp=0;
rp=0;
ctrl[0]=attr_cc1;
ctrl[1]=attr_cc2;
ctrl[2]=attr_cc3;
ctrl[3]=attr_cc4;
ctrl[4]=attr_cc5;
ctrl[5]=attr_cc6;
ctrl[6]=attr_cc7;
ctrl[7]=attr_cc8;
busy=0;
for(i=0;i<8;i++){
	prv[i]=0;
}
for(i=0;i<32;i++){
	bufV[i]=0;
	bufP[i]=0;
}]]></code.init>
         <code.krate><![CDATA[in[0]=inlet_i1;
in[1]=inlet_i2;
in[2]=inlet_i3;
in[3]=inlet_i4;
in[4]=inlet_i5;
in[5]=inlet_i6;
in[6]=inlet_i7;
in[7]=inlet_i8;
outlet_out=0;

for(i=0;i<8;i++)
{
	if(!(in[i]==prv[i]))
	{
		bufV[wp]=__USAT(in[i],27)>>12;
		bufP[wp]=i;
		wp=(1+wp)&31;
	}	
	prv[i]=in[i];
}


out=0;
if(!(wp==rp)){
out=attr_channel;
out+=type<<4;
out+=ctrl[(bufP[rp])]<<6;
out+=(uint32_t)bufV[rp]<<16;
rp=(rp+1)&31;
}

outlet_out=out;


/*
if(busy>0){
if(busy==33){outlet_out=1;}
else if(busy>28){
outlet_out=(attr_channel>>(busy-29))&1;
}
else if(busy>26){
outlet_out=(type>>(busy-27))&1;
}
else if(busy>16){
outlet_out=(ctrl[(bufP[rp])]>>(busy-17))&1;
}
else{
outlet_out=(bufV[rp]>>(busy-1))&1;
}

busy-=1;
if(busy==0){
	rp=(rp+1)&31;
}
}
*/]]></code.krate>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="9d1f58bb-bc4b-4a18-8eba-c89a5f0c857f" name="single cv2serial coverter" x="1736" y="84">
      <params/>
      <attribs>
         <spinner attributeName="cc1" value="0"/>
         <spinner attributeName="cc2" value="1"/>
         <spinner attributeName="cc3" value="2"/>
         <spinner attributeName="cc4" value="6"/>
         <spinner attributeName="cc5" value="4"/>
         <spinner attributeName="cc6" value="5"/>
         <spinner attributeName="cc7" value="12"/>
         <spinner attributeName="cc8" value="19"/>
         <spinner attributeName="channel" value="9"/>
      </attribs>
      <object id="patch/object" uuid="9d1f58bb-bc4b-4a18-8eba-c89a5f0c857f">
         <sDescription>add</sDescription>
         <author>Johannes Taelman</author>
         <license>BSD</license>
         <helpPatch>math.axh</helpPatch>
         <inlets>
            <frac32 name="i1"/>
            <frac32 name="i2"/>
            <frac32 name="i3"/>
            <frac32 name="i4"/>
            <frac32 name="i5"/>
            <frac32 name="i6"/>
            <frac32 name="i7"/>
            <frac32 name="i8"/>
         </inlets>
         <outlets>
            <bool32 name="out"/>
         </outlets>
         <displays/>
         <params/>
         <attribs>
            <spinner name="cc1" MinValue="0" MaxValue="1023" DefaultValue="0"/>
            <spinner name="cc2" MinValue="0" MaxValue="1023" DefaultValue="0"/>
            <spinner name="cc3" MinValue="0" MaxValue="1023" DefaultValue="0"/>
            <spinner name="cc4" MinValue="0" MaxValue="1023" DefaultValue="0"/>
            <spinner name="cc5" MinValue="0" MaxValue="1023" DefaultValue="0"/>
            <spinner name="cc6" MinValue="0" MaxValue="1023" DefaultValue="0"/>
            <spinner name="cc7" MinValue="0" MaxValue="1023" DefaultValue="0"/>
            <spinner name="cc8" MinValue="0" MaxValue="1023" DefaultValue="0"/>
            <spinner name="channel" MinValue="0" MaxValue="15" DefaultValue="0"/>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[int type=1; // 1x 16bit control
int busy;
int16_t bufV[32];
int16_t bufP[32];
int32_t in[8],prv[8],ctrl[8],i,wp,rp;

//channel        4 bits
//messagetype    2 bits
//message index 10 bits
//value		 16 bits]]></code.declaration>
         <code.init><![CDATA[wp=0;
rp=0;
ctrl[0]=attr_cc1;
ctrl[1]=attr_cc2;
ctrl[2]=attr_cc3;
ctrl[3]=attr_cc4;
ctrl[4]=attr_cc5;
ctrl[5]=attr_cc6;
ctrl[6]=attr_cc7;
ctrl[7]=attr_cc8;
busy=0;
for(i=0;i<8;i++){
	prv[i]=0;
}
for(i=0;i<32;i++){
	bufV[i]=0;
	bufP[i]=0;
}]]></code.init>
         <code.krate><![CDATA[in[0]=inlet_i1;
in[1]=inlet_i2;
in[2]=inlet_i3;
in[3]=inlet_i4;
in[4]=inlet_i5;
in[5]=inlet_i6;
in[6]=inlet_i7;
in[7]=inlet_i8;
outlet_out=0;

for(i=0;i<8;i++)
{
	if(!(in[i]==prv[i]))
	{
		bufV[wp]=__SSAT(in[i],28)>>12;
		bufP[wp]=i;
		wp=(1+wp)&31;
	}	
	prv[i]=in[i];
}


if(busy==0){
if(!(wp==rp)){
busy=33;
}
}


if(busy>0){
if(busy==33){outlet_out=1;}
else if(busy>28){
outlet_out=(attr_channel>>(busy-29))&1;
}
else if(busy>26){
outlet_out=(type>>(busy-27))&1;
}
else if(busy>16){
outlet_out=(ctrl[(bufP[rp])]>>(busy-17))&1;
}
else{
outlet_out=(bufV[rp]>>(busy-1))&1;
}

busy-=1;
if(busy==0){
	rp=(rp+1)&31;
}
}]]></code.krate>
      </object>
   </patchobj>
   <comment type="patch/comment" x="602" y="210" text="an 16bit single control encoder. eg. connect normal controls to this or midi controls that are combined"/>
   <comment type="patch/comment" x="1204" y="210" text="same as the first one, just example for selecting different channels"/>
   <comment type="patch/comment" x="1862" y="210" text="this was the first version, just encoding 8 controls into one serial stream"/>
   <comment type="patch/comment" x="602" y="224" text="as one LSB and one MSB"/>
   <comment type="patch/comment" x="1862" y="224" text="it can be used with the receive modules, but not with the send modules or data combiner"/>
   <comment type="patch/comment" x="210" y="350" text="select the right channel to send to the right control receivers"/>
   <obj type="ctrl/dial p" uuid="cc5d2846c3d50e425f450c4b9851371b54f4d674" name="dial_17" x="504" y="434">
      <params>
         <frac32.u.map name="value" value="31.5"/>
      </params>
      <attribs/>
   </obj>
   <obj type="ctrl/dial p" uuid="cc5d2846c3d50e425f450c4b9851371b54f4d674" name="dial_18" x="574" y="434">
      <params>
         <frac32.u.map name="value" value="38.0"/>
      </params>
      <attribs/>
   </obj>
   <obj type="ctrl/dial p" uuid="cc5d2846c3d50e425f450c4b9851371b54f4d674" name="dial_19" x="644" y="434">
      <params>
         <frac32.u.map name="value" value="43.90999984741211"/>
      </params>
      <attribs/>
   </obj>
   <obj type="ctrl/dial p" uuid="cc5d2846c3d50e425f450c4b9851371b54f4d674" name="dial_20" x="714" y="434">
      <params>
         <frac32.u.map name="value" value="24.709999561309814"/>
      </params>
      <attribs/>
   </obj>
   <obj type="ctrl/dial p" uuid="cc5d2846c3d50e425f450c4b9851371b54f4d674" name="dial_21" x="784" y="434">
      <params>
         <frac32.u.map name="value" value="29.5"/>
      </params>
      <attribs/>
   </obj>
   <obj type="ctrl/dial p" uuid="cc5d2846c3d50e425f450c4b9851371b54f4d674" name="dial_22" x="854" y="434">
      <params>
         <frac32.u.map name="value" value="32.33999967575073"/>
      </params>
      <attribs/>
   </obj>
   <obj type="ctrl/dial p" uuid="cc5d2846c3d50e425f450c4b9851371b54f4d674" name="dial_23" x="924" y="434">
      <params>
         <frac32.u.map name="value" value="18.0"/>
      </params>
      <attribs/>
   </obj>
   <obj type="ctrl/dial p" uuid="cc5d2846c3d50e425f450c4b9851371b54f4d674" name="dial_24" x="994" y="434">
      <params>
         <frac32.u.map name="value" value="47.0"/>
      </params>
      <attribs/>
   </obj>
   <patchobj type="patch/object" uuid="9d1f58bb-bc4b-4a18-8eba-c89a5f0c857f" name="2x8Bctrl" x="504" y="518">
      <params/>
      <attribs>
         <spinner attributeName="cc1" value="0"/>
         <spinner attributeName="cc2" value="1"/>
         <spinner attributeName="cc3" value="2"/>
         <spinner attributeName="cc4" value="3"/>
         <spinner attributeName="channel" value="8"/>
      </attribs>
      <object id="patch/object" uuid="9d1f58bb-bc4b-4a18-8eba-c89a5f0c857f">
         <sDescription>add</sDescription>
         <author>Johannes Taelman</author>
         <license>BSD</license>
         <helpPatch>math.axh</helpPatch>
         <inlets>
            <frac32.positive name="i1x"/>
            <frac32.positive name="i1y"/>
            <frac32.positive name="i2x"/>
            <frac32.positive name="i2y"/>
            <frac32.positive name="i3x"/>
            <frac32.positive name="i3y"/>
            <frac32.positive name="i4x"/>
            <frac32.positive name="i4y"/>
         </inlets>
         <outlets>
            <frac32.positive name="out"/>
         </outlets>
         <displays/>
         <params/>
         <attribs>
            <spinner name="cc1" MinValue="0" MaxValue="1023" DefaultValue="0"/>
            <spinner name="cc2" MinValue="0" MaxValue="1023" DefaultValue="0"/>
            <spinner name="cc3" MinValue="0" MaxValue="1023" DefaultValue="0"/>
            <spinner name="cc4" MinValue="0" MaxValue="1023" DefaultValue="0"/>
            <spinner name="channel" MinValue="0" MaxValue="15" DefaultValue="0"/>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[int type=2; // 2x 8bit control
int busy;
int16_t bufV[32];
int16_t bufP[32];
int32_t in[8],prv[8],ctrl[4],i,wp,rp;
uint32_t out;
//channel        4 bits
//messagetype    2 bits
//message index 10 bits
//value		 16 bits]]></code.declaration>
         <code.init><![CDATA[wp=0;
rp=0;
ctrl[0]=attr_cc1;
ctrl[1]=attr_cc2;
ctrl[2]=attr_cc3;
ctrl[3]=attr_cc4;

busy=0;
for(i=0;i<8;i++){
	prv[i]=0;
}
for(i=0;i<32;i++){
	bufV[i]=0;
	bufP[i]=0;
}]]></code.init>
         <code.krate><![CDATA[in[0]=inlet_i1x;
in[1]=inlet_i1y;
in[2]=inlet_i2x;
in[3]=inlet_i2y;
in[4]=inlet_i3x;
in[5]=inlet_i3y;
in[6]=inlet_i4x;
in[7]=inlet_i4y;
outlet_out=0;

for(i=0;i<8;i++)
{
	if(!(in[i]==prv[i]))
	{	int k=(i>>1)<<1;
		bufV[wp]=(__USAT(in[k],27)>>20)+((__USAT(in[k+1],27)>>20)<<8);
		bufP[wp]=i>>1;
		wp=(1+wp)&31;
	}	
	prv[i]=in[i];
}


out=0;
if(!(wp==rp)){
out=attr_channel;
out+=type<<4;
out+=ctrl[(bufP[rp])]<<6;
out+=(uint32_t)bufV[rp]<<16;
rp=(rp+1)&31;
}

outlet_out=out;]]></code.krate>
      </object>
   </patchobj>
   <comment type="patch/comment" x="602" y="574" text="an 8bit dual control encoder. eg. connect midi xy controllers to this"/>
   <comment type="patch/comment" x="1442" y="574" text="there&apos;s still one data type open"/>
   <comment type="patch/comment" x="1442" y="588" text="type 0=midi notes"/>
   <comment type="patch/comment" x="1442" y="602" text="type 1=&quot;normal&quot; single 16bit control"/>
   <comment type="patch/comment" x="1442" y="616" text="type 2=&quot;normal&quot; dual 8bit control (X/Y)"/>
   <comment type="patch/comment" x="1442" y="630" text="type 3= unused, but could be used for lists for example"/>
   <comment type="patch/comment" x="210" y="658" text="note that the controls are being send as pairs on a single CC"/>
   <comment type="patch/comment" x="210" y="714" text="select the right channel to send to the right control receivers"/>
   <comment type="patch/comment" x="462" y="826" text="a couple of very nice pattern generators :)"/>
   <comment type="patch/comment" x="686" y="826" text="ok.. the gate output is still under construction.."/>
   <obj type="lfo/square" uuid="de6909eb64db13af5b43f979a4c130024b3a4793" name="square_1" x="308" y="840">
      <params>
         <frac32.s.map name="pitch" value="-17.0"/>
      </params>
      <attribs/>
   </obj>
   <patchobj type="patch/object" uuid="596a9ba6-b10a-40f5-9e6d-9a35efd4f2db" name="counter_28" x="406" y="840">
      <params>
         <int32 name="bar" value="8"/>
         <int32 name="bars" value="2"/>
         <frac32.u.map name="start" value="48.0"/>
         <frac32.u.map name="shift" value="0.0"/>
         <int32 name="octaves" value="3"/>
         <int32 name="semis" value="7"/>
         <bool32.tgl name="integrate" value="0"/>
         <frac32.u.map name="gatelength" value="54.0"/>
      </params>
      <attribs>
         <combo attributeName="size" selection="16"/>
      </attribs>
      <object id="patch/object" uuid="596a9ba6-b10a-40f5-9e6d-9a35efd4f2db">
         <sDescription>stackable melody generator
Each stacked generator can add it&apos;s own note change to the entire sequence
Together they create an entire sequence with multiple layers to connect your oscillators to.
Each bar a &quot;fill&quot; is generated which starts from the &quot;start&quot; minus the shift parameter for the length of &quot;barlenght-start&quot;(what&apos;s left). The fill goes around the semitone scale toward the next note in the bars-sequence in steps based on chord scaling (2 steps within the scale each time) and holds this new note until the bar restarts (and then it is the actual current note).
Stacking several of them with first a couple short, quick sequences with not many octaves and semitones in it, followed by a couple of slower ones, provides a really nice start to experiment.</sDescription>
         <author>Remco van der Most</author>
         <license>BSD</license>
         <helpPatch>counter.axh</helpPatch>
         <inlets>
            <bool32.rising name="trig" description="trigger to advance sequence"/>
            <bool32.rising name="r" description="reset sequencer"/>
            <bool32 name="gate" description="this needs a high gate to be able produce gates at the output!"/>
            <int32 name="semi" description="connect to former stacked semi output (inlet acts as INDEX!! selector for notes within a chord!)"/>
            <int32 name="oct" description="connect to former stacked oct output (octave index as in +1,+2,+3,etc)"/>
            <bool32.risingfalling name="rnd"/>
            <int32 name="count"/>
            <int32 name="max"/>
            <frac32 name="start"/>
            <frac32 name="shift"/>
            <frac32 name="gatelength"/>
         </inlets>
         <outlets>
            <bool32.pulse name="restartbar" description="carry pulse of bar restart"/>
            <bool32.pulse name="restartbars" description="carry pulse of bar repeat restart"/>
            <bool32 name="lastpart"/>
            <bool32 name="gate"/>
            <int32 name="semi" description="connect to semi-input of next stacked module (outputs semitone INDEX!! for 7 semitones in a scale, thus not actual semitone pitch!)"/>
            <int32 name="oct" description="connect to octi-input of next stacked module (outputs the octave value as +1/+2 etc)"/>
            <int32 name="self" description="outputs it&apos;s own internal sequence (in actual pitch info)"/>
            <int32 name="sum" description="outputs the sum of external and internal sequences (in actual pitch info)"/>
         </outlets>
         <displays/>
         <params>
            <int32 name="bar" description="bar count length">
               <MinValue i="1"/>
               <MaxValue i="128"/>
            </int32>
            <int32 name="bars" description="amount of bar repeats">
               <MinValue i="1"/>
               <MaxValue i="128"/>
            </int32>
            <frac32.u.map name="start" description="startpoint of fill in relation to bar length (length=barlength-start)"/>
            <frac32.u.map name="shift" description="shifts the start of the fill forward"/>
            <int32 name="octaves" description="maximum amount of octaves">
               <MinValue i="1"/>
               <MaxValue i="6"/>
            </int32>
            <int32 name="semis" description="amount of semi tones present (above 1 is multiplied by two and only selecting within scale to select notes in standard chords)">
               <MinValue i="1"/>
               <MaxValue i="7"/>
            </int32>
            <bool32.tgl name="integrate" description="integrates the external semi and octave inputs into it&apos;s  own limitators"/>
            <frac32.u.map name="gatelength"/>
         </params>
         <attribs>
            <combo name="size">
               <MenuEntries>
                  <string>2</string>
                  <string>4</string>
                  <string>8</string>
                  <string>16</string>
                  <string>32</string>
                  <string>64</string>
                  <string>128</string>
                  <string>256</string>
                  <string>512</string>
                  <string>1024</string>
                  <string>2048</string>
                  <string>4096</string>
                  <string>8192</string>
                  <string>16384</string>
                  <string>32768</string>
                  <string>65536</string>
                  <string>131072</string>
                  <string>262144</string>
                  <string>524288</string>
                  <string>1048576</string>
                  <string>2097152</string>
                  <string>4194304</string>
               </MenuEntries>
               <CEntries>
                  <string>1</string>
                  <string>2</string>
                  <string>3</string>
                  <string>4</string>
                  <string>5</string>
                  <string>6</string>
                  <string>7</string>
                  <string>8</string>
                  <string>9</string>
                  <string>10</string>
                  <string>11</string>
                  <string>12</string>
                  <string>13</string>
                  <string>14</string>
                  <string>15</string>
                  <string>16</string>
                  <string>17</string>
                  <string>18</string>
                  <string>19</string>
                  <string>20</string>
                  <string>21</string>
                  <string>22</string>
               </CEntries>
            </combo>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[int ntrig;
   int rtrig,i,rnd;
   int count, start;

static const uint32_t LENGTHPOW = (attr_size);
static const uint32_t LENGTH = (1<<attr_size);
static const uint32_t LENGTHMASK = ((1<<attr_size)-1);
static const uint32_t BITS = 8;
static const uint32_t GAIN = 20;
int8_t *array;
int32_t cnt;
int note[7]={0,2,4,5,7,9,11};
int stp,ofs,dvs,jmp;
int gate;]]></code.declaration>
         <code.init><![CDATA[count=0;
   ntrig = 0;
   rtrig = 0;
static int8_t _array[attr_poly][LENGTH] __attribute__ ((section (".sdram")));
array = &_array[parent->polyIndex][0];
{ 

  array[0]=0;
  for(i=1;i<LENGTH;i++){
  	int chg=(int32_t)(GenerateRandomNumber()%21);
  	chg+=(chg%7)==0?1:0;
  	array[i]=array[i-1]+chg;
  }
}
stp=(int32_t)GenerateRandomNumber()%14;
stp+=(stp%7)==0?1:0;
dvs=1;]]></code.init>
         <code.krate><![CDATA[outlet_restartbar=0;
outlet_restartbars=0;
int s1,s2,o1,o2;
if(inlet_rnd&&!rnd){
	rnd=1;
	  array[0]=(int32_t)(GenerateRandomNumber()%21);;
     for(i=1;i<LENGTH;i++){
  	int chg=(int32_t)(GenerateRandomNumber()%21);
  	chg+=(chg%7)==0?1:0;
  	array[i]=array[i-1]+chg;
  }

stp=(int32_t)GenerateRandomNumber()%14;
stp+=(stp%7)==0?1:0;
}
else if(!inlet_rnd){rnd=0;}

if(param_integrate){
	s1=o1=0;
	s2=inlet_semi;
	o2=inlet_oct*7;
}
else{
	s2=o2=0;
	s1=inlet_semi;
	o1=inlet_oct;
}
if ((inlet_trig>0) && !ntrig) {
   count += 1; 
   if(count>=param_bar)
   { ofs=0;
   	count = 0;
   	outlet_restartbar = 1;
   	cnt+=1;
   	stp=((int32_t)GenerateRandomNumber()%4);//sets stepsize towards next note
   	stp+=(stp%7)==0?1:0;
   	jmp=((int32_t)GenerateRandomNumber()%3);
   	dvs=(int32_t)GenerateRandomNumber();//sets division of fill (divides count)
   	dvs=(___SMMUL(dvs,dvs)>>28)+1;
   	if(cnt>=param_bars)
   	{
   		cnt=0;
   		outlet_restartbars=1;
   	}
   	
   }
   ntrig=1;
}
else if (!(inlet_trig>0)) {ntrig=0;}

if ((inlet_r>0) && !rtrig) {count=0; cnt=0;rtrig = 1;outlet_restartbar=1;}
else if (!(inlet_r>0)) {rtrig=0;}
int shft=___SMMUL(__USAT(param_shift+inlet_shift,27),param_bar<<5);
int ct=(count+shft)%param_bar;
start=___SMMUL(param_bar<<5,__USAT(param_start+inlet_start,27));
int left=__USAT((ct-start),28);
ct=cnt;
int tbar=(param_bar-start-left);
int tlft=tbar/dvs*dvs;
if(left>0){
	left=tlft*stp+(tbar/3)*jmp;
	if(shft<3){
	ofs=1;
	}
	else{ofs=0;}
}
else if(count>=param_bar-1){ofs=1;left=stp;}
else if(left<1){ofs=0;}

int mem=(array[ct+ofs&LENGTHMASK]+left);
left=mem+s2+o2;

int oct=left/param_semis;
if((left<0)&&(left>-param_semis)){oct-=1;}
left=left%param_semis;
left+=left<0?param_semis:0;
left*=2;
left+=s1;
left=left%7;
left+=left<0?7:0;

oct=oct%param_octaves;
oct+=(oct<0?param_octaves:0)+o1;
outlet_sum= note[left]+oct*12;
outlet_semi=left;
outlet_oct=oct;


left=mem;
oct=left/param_semis;
if((left<0)&&(left>-param_semis)){oct-=1;}
left=left%param_semis;
left+=left<0?param_semis:0;
left*=2;
left=left%7;
left+=left<0?7:0;
outlet_self=note[left]+oct*12;
gate=0;
if(count<(___SMMUL((start-shft-1)<<1,__USAT(param_gatelength+inlet_gatelength,27)<<4))){
	gate=1;
}
else if(count<(param_bar-shft)){
	gate=inlet_trig&(tbar==tlft);
}
else if(count<((param_bar-shft)+___SMMUL(shft<<1,param_gatelength))){gate=1;}



outlet_gate=(gate||inlet_gate);
outlet_lastpart=(count==(param_bars-1))&&(cnt>start);]]></code.krate>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="596a9ba6-b10a-40f5-9e6d-9a35efd4f2db" name="counter_29" x="560" y="840">
      <params>
         <int32 name="bar" value="12"/>
         <int32 name="bars" value="4"/>
         <frac32.u.map name="start" value="37.0"/>
         <frac32.u.map name="shift" value="7.0"/>
         <int32 name="octaves" value="4"/>
         <int32 name="semis" value="4"/>
         <bool32.tgl name="integrate" value="1"/>
         <frac32.u.map name="gatelength" value="47.5"/>
      </params>
      <attribs>
         <combo attributeName="size" selection="16"/>
      </attribs>
      <object id="patch/object" uuid="596a9ba6-b10a-40f5-9e6d-9a35efd4f2db">
         <sDescription>stackable melody generator
Each stacked generator can add it&apos;s own note change to the entire sequence
Together they create an entire sequence with multiple layers to connect your oscillators to.
Each bar a &quot;fill&quot; is generated which starts from the &quot;start&quot; minus the shift parameter for the length of &quot;barlenght-start&quot;(what&apos;s left). The fill goes around the semitone scale toward the next note in the bars-sequence in steps based on chord scaling (2 steps within the scale each time) and holds this new note until the bar restarts (and then it is the actual current note).
Stacking several of them with first a couple short, quick sequences with not many octaves and semitones in it, followed by a couple of slower ones, provides a really nice start to experiment.</sDescription>
         <author>Remco van der Most</author>
         <license>BSD</license>
         <helpPatch>counter.axh</helpPatch>
         <inlets>
            <bool32.rising name="trig" description="trigger to advance sequence"/>
            <bool32.rising name="r" description="reset sequencer"/>
            <bool32 name="gate" description="this needs a high gate to be able produce gates at the output!"/>
            <int32 name="semi" description="connect to former stacked semi output (inlet acts as INDEX!! selector for notes within a chord!)"/>
            <int32 name="oct" description="connect to former stacked oct output (octave index as in +1,+2,+3,etc)"/>
            <bool32.risingfalling name="rnd"/>
            <int32 name="count"/>
            <int32 name="max"/>
            <frac32 name="start"/>
            <frac32 name="shift"/>
            <frac32 name="gatelength"/>
         </inlets>
         <outlets>
            <bool32.pulse name="restartbar" description="carry pulse of bar restart"/>
            <bool32.pulse name="restartbars" description="carry pulse of bar repeat restart"/>
            <bool32 name="lastpart"/>
            <bool32 name="gate"/>
            <int32 name="semi" description="connect to semi-input of next stacked module (outputs semitone INDEX!! for 7 semitones in a scale, thus not actual semitone pitch!)"/>
            <int32 name="oct" description="connect to octi-input of next stacked module (outputs the octave value as +1/+2 etc)"/>
            <int32 name="self" description="outputs it&apos;s own internal sequence (in actual pitch info)"/>
            <int32 name="sum" description="outputs the sum of external and internal sequences (in actual pitch info)"/>
         </outlets>
         <displays/>
         <params>
            <int32 name="bar" description="bar count length">
               <MinValue i="1"/>
               <MaxValue i="128"/>
            </int32>
            <int32 name="bars" description="amount of bar repeats">
               <MinValue i="1"/>
               <MaxValue i="128"/>
            </int32>
            <frac32.u.map name="start" description="startpoint of fill in relation to bar length (length=barlength-start)"/>
            <frac32.u.map name="shift" description="shifts the start of the fill forward"/>
            <int32 name="octaves" description="maximum amount of octaves">
               <MinValue i="1"/>
               <MaxValue i="6"/>
            </int32>
            <int32 name="semis" description="amount of semi tones present (above 1 is multiplied by two and only selecting within scale to select notes in standard chords)">
               <MinValue i="1"/>
               <MaxValue i="7"/>
            </int32>
            <bool32.tgl name="integrate" description="integrates the external semi and octave inputs into it&apos;s  own limitators"/>
            <frac32.u.map name="gatelength"/>
         </params>
         <attribs>
            <combo name="size">
               <MenuEntries>
                  <string>2</string>
                  <string>4</string>
                  <string>8</string>
                  <string>16</string>
                  <string>32</string>
                  <string>64</string>
                  <string>128</string>
                  <string>256</string>
                  <string>512</string>
                  <string>1024</string>
                  <string>2048</string>
                  <string>4096</string>
                  <string>8192</string>
                  <string>16384</string>
                  <string>32768</string>
                  <string>65536</string>
                  <string>131072</string>
                  <string>262144</string>
                  <string>524288</string>
                  <string>1048576</string>
                  <string>2097152</string>
                  <string>4194304</string>
               </MenuEntries>
               <CEntries>
                  <string>1</string>
                  <string>2</string>
                  <string>3</string>
                  <string>4</string>
                  <string>5</string>
                  <string>6</string>
                  <string>7</string>
                  <string>8</string>
                  <string>9</string>
                  <string>10</string>
                  <string>11</string>
                  <string>12</string>
                  <string>13</string>
                  <string>14</string>
                  <string>15</string>
                  <string>16</string>
                  <string>17</string>
                  <string>18</string>
                  <string>19</string>
                  <string>20</string>
                  <string>21</string>
                  <string>22</string>
               </CEntries>
            </combo>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[int ntrig;
   int rtrig,i,rnd;
   int count, start;

static const uint32_t LENGTHPOW = (attr_size);
static const uint32_t LENGTH = (1<<attr_size);
static const uint32_t LENGTHMASK = ((1<<attr_size)-1);
static const uint32_t BITS = 8;
static const uint32_t GAIN = 20;
int8_t *array;
int32_t cnt;
int note[7]={0,2,4,5,7,9,11};
int stp,ofs,dvs,jmp;
int gate;]]></code.declaration>
         <code.init><![CDATA[count=0;
   ntrig = 0;
   rtrig = 0;
static int8_t _array[attr_poly][LENGTH] __attribute__ ((section (".sdram")));
array = &_array[parent->polyIndex][0];
{ 

  array[0]=0;
  for(i=1;i<LENGTH;i++){
  	int chg=(int32_t)(GenerateRandomNumber()%21);
  	chg+=(chg%7)==0?1:0;
  	array[i]=array[i-1]+chg;
  }
}
stp=(int32_t)GenerateRandomNumber()%14;
stp+=(stp%7)==0?1:0;
dvs=1;]]></code.init>
         <code.krate><![CDATA[outlet_restartbar=0;
outlet_restartbars=0;
int s1,s2,o1,o2;
if(inlet_rnd&&!rnd){
	rnd=1;
	  array[0]=0;   // (int32_t)(GenerateRandomNumber()%21);  set 0 if used as offset from tonic, other value if it sets tonic or offset is wanted
     for(i=1;i<LENGTH;i++){
  	int chg=(int32_t)(GenerateRandomNumber()%21);
  	chg+=(chg%7)==0?1:0;
  	array[i]=array[i-1]+chg;
  }

stp=(int32_t)GenerateRandomNumber()%14;
stp+=(stp%7)==0?1:0;
}
else if(!inlet_rnd){rnd=0;}

if(param_integrate){
	s1=o1=0;
	s2=inlet_semi;
	o2=inlet_oct*7;
}
else{
	s2=o2=0;
	s1=inlet_semi;
	o1=inlet_oct;
}
if ((inlet_trig>0) && !ntrig) {
   count += 1; 
   if(count>=param_bar)
   { ofs=0;
   	count = 0;
   	outlet_restartbar = 1;
   	cnt+=1;
   	stp=((int32_t)GenerateRandomNumber()%4);//sets stepsize towards next note
   	stp+=(stp%7)==0?1:0;
   	jmp=((int32_t)GenerateRandomNumber()%3);
   	dvs=(int32_t)GenerateRandomNumber();//sets division of fill (divides count)
   	dvs=(___SMMUL(dvs,dvs)>>28)+1;
   	if(cnt>=param_bars)
   	{
   		cnt=0;
   		outlet_restartbars=1;
   	}
   	
   }
   ntrig=1;
}
else if (!(inlet_trig>0)) {ntrig=0;}

if ((inlet_r>0) && !rtrig) {count=0; cnt=0;rtrig = 1;outlet_restartbar=1;}
else if (!(inlet_r>0)) {rtrig=0;}
int shft=___SMMUL(__USAT(param_shift+inlet_shift,27),param_bar<<5);
int ct=(count+shft)%param_bar;
start=___SMMUL(param_bar<<5,__USAT(param_start+inlet_start,27));
int left=__USAT((ct-start),28);
ct=cnt;
int tbar=(param_bar-start-left);
int tlft=tbar/dvs*dvs;
if(left>0){
	left=tlft*stp+(tbar/3)*jmp;
	if(shft<3){
	ofs=1;
	}
	else{ofs=0;}
}
else if(count>=param_bar-1){ofs=1;left=stp;}
else if(left<1){ofs=0;}

int mem=(array[ct+ofs&LENGTHMASK]+left);
left=mem+s2+o2;

int oct=left/param_semis;
if((left<0)&&(left>-param_semis)){oct-=1;}
left=left%param_semis;
left+=left<0?param_semis:0;
left*=2;
left+=s1;
left=left%7;
left+=left<0?7:0;

oct=oct%param_octaves;
oct+=(oct<0?param_octaves:0)+o1;
outlet_sum= note[left]+oct*12;
outlet_semi=left;
outlet_oct=oct;


left=mem;
oct=left/param_semis;
if((left<0)&&(left>-param_semis)){oct-=1;}
left=left%param_semis;
left+=left<0?param_semis:0;
left*=2;
left=left%7;
left+=left<0?7:0;
outlet_self=note[left]+oct*12;
gate=0;
if(count<(___SMMUL((start-shft-1)<<1,__USAT(param_gatelength+inlet_gatelength,27)<<4))){
	gate=1;
}
else if(count<(param_bar-shft)){
	gate=inlet_trig&(tbar==tlft);
}
else if(count<((param_bar-shft)+___SMMUL(shft<<1,param_gatelength))){gate=1;}



outlet_gate=(gate||inlet_gate);
outlet_lastpart=(count==(param_bars-1))&&(cnt>start);]]></code.krate>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="596a9ba6-b10a-40f5-9e6d-9a35efd4f2db" name="counter_30" x="714" y="840">
      <params>
         <int32 name="bar" value="6"/>
         <int32 name="bars" value="4"/>
         <frac32.u.map name="start" value="48.0"/>
         <frac32.u.map name="shift" value="0.0"/>
         <int32 name="octaves" value="2"/>
         <int32 name="semis" value="7"/>
         <bool32.tgl name="integrate" value="1"/>
         <frac32.u.map name="gatelength" value="54.0"/>
      </params>
      <attribs>
         <combo attributeName="size" selection="16"/>
      </attribs>
      <object id="patch/object" uuid="596a9ba6-b10a-40f5-9e6d-9a35efd4f2db">
         <sDescription>stackable melody generator
Each stacked generator can add it&apos;s own note change to the entire sequence
Together they create an entire sequence with multiple layers to connect your oscillators to.
Each bar a &quot;fill&quot; is generated which starts from the &quot;start&quot; minus the shift parameter for the length of &quot;barlenght-start&quot;(what&apos;s left). The fill goes around the semitone scale toward the next note in the bars-sequence in steps based on chord scaling (2 steps within the scale each time) and holds this new note until the bar restarts (and then it is the actual current note).
Stacking several of them with first a couple short, quick sequences with not many octaves and semitones in it, followed by a couple of slower ones, provides a really nice start to experiment.</sDescription>
         <author>Remco van der Most</author>
         <license>BSD</license>
         <helpPatch>counter.axh</helpPatch>
         <inlets>
            <bool32.rising name="trig" description="trigger to advance sequence"/>
            <bool32.rising name="r" description="reset sequencer"/>
            <bool32 name="gate" description="this needs a high gate to be able produce gates at the output!"/>
            <int32 name="semi" description="connect to former stacked semi output (inlet acts as INDEX!! selector for notes within a chord!)"/>
            <int32 name="oct" description="connect to former stacked oct output (octave index as in +1,+2,+3,etc)"/>
            <bool32.risingfalling name="rnd"/>
            <int32 name="count"/>
            <int32 name="max"/>
            <frac32 name="start"/>
            <frac32 name="shift"/>
            <frac32 name="gatelength"/>
         </inlets>
         <outlets>
            <bool32.pulse name="restartbar" description="carry pulse of bar restart"/>
            <bool32.pulse name="restartbars" description="carry pulse of bar repeat restart"/>
            <bool32 name="lastpart"/>
            <bool32 name="gate"/>
            <int32 name="semi" description="connect to semi-input of next stacked module (outputs semitone INDEX!! for 7 semitones in a scale, thus not actual semitone pitch!)"/>
            <int32 name="oct" description="connect to octi-input of next stacked module (outputs the octave value as +1/+2 etc)"/>
            <int32 name="self" description="outputs it&apos;s own internal sequence (in actual pitch info)"/>
            <int32 name="sum" description="outputs the sum of external and internal sequences (in actual pitch info)"/>
         </outlets>
         <displays/>
         <params>
            <int32 name="bar" description="bar count length">
               <MinValue i="1"/>
               <MaxValue i="128"/>
            </int32>
            <int32 name="bars" description="amount of bar repeats">
               <MinValue i="1"/>
               <MaxValue i="128"/>
            </int32>
            <frac32.u.map name="start" description="startpoint of fill in relation to bar length (length=barlength-start)"/>
            <frac32.u.map name="shift" description="shifts the start of the fill forward"/>
            <int32 name="octaves" description="maximum amount of octaves">
               <MinValue i="1"/>
               <MaxValue i="6"/>
            </int32>
            <int32 name="semis" description="amount of semi tones present (above 1 is multiplied by two and only selecting within scale to select notes in standard chords)">
               <MinValue i="1"/>
               <MaxValue i="7"/>
            </int32>
            <bool32.tgl name="integrate" description="integrates the external semi and octave inputs into it&apos;s  own limitators"/>
            <frac32.u.map name="gatelength"/>
         </params>
         <attribs>
            <combo name="size">
               <MenuEntries>
                  <string>2</string>
                  <string>4</string>
                  <string>8</string>
                  <string>16</string>
                  <string>32</string>
                  <string>64</string>
                  <string>128</string>
                  <string>256</string>
                  <string>512</string>
                  <string>1024</string>
                  <string>2048</string>
                  <string>4096</string>
                  <string>8192</string>
                  <string>16384</string>
                  <string>32768</string>
                  <string>65536</string>
                  <string>131072</string>
                  <string>262144</string>
                  <string>524288</string>
                  <string>1048576</string>
                  <string>2097152</string>
                  <string>4194304</string>
               </MenuEntries>
               <CEntries>
                  <string>1</string>
                  <string>2</string>
                  <string>3</string>
                  <string>4</string>
                  <string>5</string>
                  <string>6</string>
                  <string>7</string>
                  <string>8</string>
                  <string>9</string>
                  <string>10</string>
                  <string>11</string>
                  <string>12</string>
                  <string>13</string>
                  <string>14</string>
                  <string>15</string>
                  <string>16</string>
                  <string>17</string>
                  <string>18</string>
                  <string>19</string>
                  <string>20</string>
                  <string>21</string>
                  <string>22</string>
               </CEntries>
            </combo>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[int ntrig;
   int rtrig,i,rnd;
   int count, start;

static const uint32_t LENGTHPOW = (attr_size);
static const uint32_t LENGTH = (1<<attr_size);
static const uint32_t LENGTHMASK = ((1<<attr_size)-1);
static const uint32_t BITS = 8;
static const uint32_t GAIN = 20;
int8_t *array;
int32_t cnt;
int note[7]={0,2,4,5,7,9,11};
int stp,ofs,dvs,jmp;
int gate;]]></code.declaration>
         <code.init><![CDATA[count=0;
   ntrig = 0;
   rtrig = 0;
static int8_t _array[attr_poly][LENGTH] __attribute__ ((section (".sdram")));
array = &_array[parent->polyIndex][0];
{ 

  array[0]=0;
  for(i=1;i<LENGTH;i++){
  	int chg=(int32_t)(GenerateRandomNumber()%21);
  	chg+=(chg%7)==0?1:0;
  	array[i]=array[i-1]+chg;
  }
}
stp=(int32_t)GenerateRandomNumber()%14;
stp+=(stp%7)==0?1:0;
dvs=1;]]></code.init>
         <code.krate><![CDATA[outlet_restartbar=0;
outlet_restartbars=0;
int s1,s2,o1,o2;
if(inlet_rnd&&!rnd){
	rnd=1;
	  array[0]=(int32_t)(GenerateRandomNumber()%21);;
     for(i=1;i<LENGTH;i++){
  	int chg=(int32_t)(GenerateRandomNumber()%21);
  	chg+=(chg%7)==0?1:0;
  	array[i]=array[i-1]+chg;
  }

stp=(int32_t)GenerateRandomNumber()%14;
stp+=(stp%7)==0?1:0;
}
else if(!inlet_rnd){rnd=0;}

if(param_integrate){
	s1=o1=0;
	s2=inlet_semi;
	o2=inlet_oct*7;
}
else{
	s2=o2=0;
	s1=inlet_semi;
	o1=inlet_oct;
}
if ((inlet_trig>0) && !ntrig) {
   count += 1; 
   if(count>=param_bar)
   { ofs=0;
   	count = 0;
   	outlet_restartbar = 1;
   	cnt+=1;
   	stp=((int32_t)GenerateRandomNumber()%4);//sets stepsize towards next note
   	stp+=(stp%7)==0?1:0;
   	jmp=((int32_t)GenerateRandomNumber()%3);
   	dvs=(int32_t)GenerateRandomNumber();//sets division of fill (divides count)
   	dvs=(___SMMUL(dvs,dvs)>>28)+1;
   	if(cnt>=param_bars)
   	{
   		cnt=0;
   		outlet_restartbars=1;
   	}
   	
   }
   ntrig=1;
}
else if (!(inlet_trig>0)) {ntrig=0;}

if ((inlet_r>0) && !rtrig) {count=0; cnt=0;rtrig = 1;outlet_restartbar=1;}
else if (!(inlet_r>0)) {rtrig=0;}
int shft=___SMMUL(__USAT(param_shift+inlet_shift,27),param_bar<<5);
int ct=(count+shft)%param_bar;
start=___SMMUL(param_bar<<5,__USAT(param_start+inlet_start,27));
int left=__USAT((ct-start),28);
ct=cnt;
int tbar=(param_bar-start-left);
int tlft=tbar/dvs*dvs;
if(left>0){
	left=tlft*stp+(tbar/3)*jmp;
	if(shft<3){
	ofs=1;
	}
	else{ofs=0;}
}
else if(count>=param_bar-1){ofs=1;left=stp;}
else if(left<1){ofs=0;}

int mem=(array[ct+ofs&LENGTHMASK]+left);
left=mem+s2+o2;

int oct=left/param_semis;
if((left<0)&&(left>-param_semis)){oct-=1;}
left=left%param_semis;
left+=left<0?param_semis:0;
left*=2;
left+=s1;
left=left%7;
left+=left<0?7:0;

oct=oct%param_octaves;
oct+=(oct<0?param_octaves:0)+o1;
outlet_sum= note[left]+oct*12;
outlet_semi=left;
outlet_oct=oct;


left=mem;
oct=left/param_semis;
if((left<0)&&(left>-param_semis)){oct-=1;}
left=left%param_semis;
left+=left<0?param_semis:0;
left*=2;
left=left%7;
left+=left<0?7:0;
outlet_self=note[left]+oct*12;
gate=0;
if(count<(___SMMUL((start-shft-1)<<1,__USAT(param_gatelength+inlet_gatelength,27)<<4))){
	gate=1;
}
else if(count<(param_bar-shft)){
	gate=inlet_trig&(tbar==tlft);
}
else if(count<((param_bar-shft)+___SMMUL(shft<<1,param_gatelength))){gate=1;}



outlet_gate=(gate||inlet_gate);
outlet_lastpart=(count==(param_bars-1))&&(cnt>start);]]></code.krate>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="596a9ba6-b10a-40f5-9e6d-9a35efd4f2db" name="counter_31" x="868" y="840">
      <params>
         <int32 name="bar" value="8"/>
         <int32 name="bars" value="3"/>
         <frac32.u.map name="start" value="37.0"/>
         <frac32.u.map name="shift" value="7.0"/>
         <int32 name="octaves" value="4"/>
         <int32 name="semis" value="4"/>
         <bool32.tgl name="integrate" value="1"/>
         <frac32.u.map name="gatelength" value="47.5"/>
      </params>
      <attribs>
         <combo attributeName="size" selection="16"/>
      </attribs>
      <object id="patch/object" uuid="596a9ba6-b10a-40f5-9e6d-9a35efd4f2db">
         <sDescription>stackable melody generator
Each stacked generator can add it&apos;s own note change to the entire sequence
Together they create an entire sequence with multiple layers to connect your oscillators to.
Each bar a &quot;fill&quot; is generated which starts from the &quot;start&quot; minus the shift parameter for the length of &quot;barlenght-start&quot;(what&apos;s left). The fill goes around the semitone scale toward the next note in the bars-sequence in steps based on chord scaling (2 steps within the scale each time) and holds this new note until the bar restarts (and then it is the actual current note).
Stacking several of them with first a couple short, quick sequences with not many octaves and semitones in it, followed by a couple of slower ones, provides a really nice start to experiment.</sDescription>
         <author>Remco van der Most</author>
         <license>BSD</license>
         <helpPatch>counter.axh</helpPatch>
         <inlets>
            <bool32.rising name="trig" description="trigger to advance sequence"/>
            <bool32.rising name="r" description="reset sequencer"/>
            <bool32 name="gate" description="this needs a high gate to be able produce gates at the output!"/>
            <int32 name="semi" description="connect to former stacked semi output (inlet acts as INDEX!! selector for notes within a chord!)"/>
            <int32 name="oct" description="connect to former stacked oct output (octave index as in +1,+2,+3,etc)"/>
            <bool32.risingfalling name="rnd"/>
            <int32 name="count"/>
            <int32 name="max"/>
            <frac32 name="start"/>
            <frac32 name="shift"/>
            <frac32 name="gatelength"/>
         </inlets>
         <outlets>
            <bool32.pulse name="restartbar" description="carry pulse of bar restart"/>
            <bool32.pulse name="restartbars" description="carry pulse of bar repeat restart"/>
            <bool32 name="lastpart"/>
            <bool32 name="gate"/>
            <int32 name="semi" description="connect to semi-input of next stacked module (outputs semitone INDEX!! for 7 semitones in a scale, thus not actual semitone pitch!)"/>
            <int32 name="oct" description="connect to octi-input of next stacked module (outputs the octave value as +1/+2 etc)"/>
            <int32 name="self" description="outputs it&apos;s own internal sequence (in actual pitch info)"/>
            <int32 name="sum" description="outputs the sum of external and internal sequences (in actual pitch info)"/>
         </outlets>
         <displays/>
         <params>
            <int32 name="bar" description="bar count length">
               <MinValue i="1"/>
               <MaxValue i="128"/>
            </int32>
            <int32 name="bars" description="amount of bar repeats">
               <MinValue i="1"/>
               <MaxValue i="128"/>
            </int32>
            <frac32.u.map name="start" description="startpoint of fill in relation to bar length (length=barlength-start)"/>
            <frac32.u.map name="shift" description="shifts the start of the fill forward"/>
            <int32 name="octaves" description="maximum amount of octaves">
               <MinValue i="1"/>
               <MaxValue i="6"/>
            </int32>
            <int32 name="semis" description="amount of semi tones present (above 1 is multiplied by two and only selecting within scale to select notes in standard chords)">
               <MinValue i="1"/>
               <MaxValue i="7"/>
            </int32>
            <bool32.tgl name="integrate" description="integrates the external semi and octave inputs into it&apos;s  own limitators"/>
            <frac32.u.map name="gatelength"/>
         </params>
         <attribs>
            <combo name="size">
               <MenuEntries>
                  <string>2</string>
                  <string>4</string>
                  <string>8</string>
                  <string>16</string>
                  <string>32</string>
                  <string>64</string>
                  <string>128</string>
                  <string>256</string>
                  <string>512</string>
                  <string>1024</string>
                  <string>2048</string>
                  <string>4096</string>
                  <string>8192</string>
                  <string>16384</string>
                  <string>32768</string>
                  <string>65536</string>
                  <string>131072</string>
                  <string>262144</string>
                  <string>524288</string>
                  <string>1048576</string>
                  <string>2097152</string>
                  <string>4194304</string>
               </MenuEntries>
               <CEntries>
                  <string>1</string>
                  <string>2</string>
                  <string>3</string>
                  <string>4</string>
                  <string>5</string>
                  <string>6</string>
                  <string>7</string>
                  <string>8</string>
                  <string>9</string>
                  <string>10</string>
                  <string>11</string>
                  <string>12</string>
                  <string>13</string>
                  <string>14</string>
                  <string>15</string>
                  <string>16</string>
                  <string>17</string>
                  <string>18</string>
                  <string>19</string>
                  <string>20</string>
                  <string>21</string>
                  <string>22</string>
               </CEntries>
            </combo>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[int ntrig;
   int rtrig,i,rnd;
   int count, start;

static const uint32_t LENGTHPOW = (attr_size);
static const uint32_t LENGTH = (1<<attr_size);
static const uint32_t LENGTHMASK = ((1<<attr_size)-1);
static const uint32_t BITS = 8;
static const uint32_t GAIN = 20;
int8_t *array;
int32_t cnt;
int note[7]={0,2,4,5,7,9,11};
int stp,ofs,dvs,jmp;
int gate;]]></code.declaration>
         <code.init><![CDATA[count=0;
   ntrig = 0;
   rtrig = 0;
static int8_t _array[attr_poly][LENGTH] __attribute__ ((section (".sdram")));
array = &_array[parent->polyIndex][0];
{ 

  array[0]=0;
  for(i=1;i<LENGTH;i++){
  	int chg=(int32_t)(GenerateRandomNumber()%21);
  	chg+=(chg%7)==0?1:0;
  	array[i]=array[i-1]+chg;
  }
}
stp=(int32_t)GenerateRandomNumber()%14;
stp+=(stp%7)==0?1:0;
dvs=1;]]></code.init>
         <code.krate><![CDATA[outlet_restartbar=0;
outlet_restartbars=0;
int s1,s2,o1,o2;
if(inlet_rnd&&!rnd){
	rnd=1;
	  array[0]=0;   // (int32_t)(GenerateRandomNumber()%21);  set 0 if used as offset from tonic, other value if it sets tonic or offset is wanted
     for(i=1;i<LENGTH;i++){
  	int chg=(int32_t)(GenerateRandomNumber()%21);
  	chg+=(chg%7)==0?1:0;
  	array[i]=array[i-1]+chg;
  }

stp=(int32_t)GenerateRandomNumber()%14;
stp+=(stp%7)==0?1:0;
}
else if(!inlet_rnd){rnd=0;}

if(param_integrate){
	s1=o1=0;
	s2=inlet_semi;
	o2=inlet_oct*7;
}
else{
	s2=o2=0;
	s1=inlet_semi;
	o1=inlet_oct;
}
if ((inlet_trig>0) && !ntrig) {
   count += 1; 
   if(count>=param_bar)
   { ofs=0;
   	count = 0;
   	outlet_restartbar = 1;
   	cnt+=1;
   	stp=((int32_t)GenerateRandomNumber()%4);//sets stepsize towards next note
   	stp+=(stp%7)==0?1:0;
   	jmp=((int32_t)GenerateRandomNumber()%3);
   	dvs=(int32_t)GenerateRandomNumber();//sets division of fill (divides count)
   	dvs=(___SMMUL(dvs,dvs)>>28)+1;
   	if(cnt>=param_bars)
   	{
   		cnt=0;
   		outlet_restartbars=1;
   	}
   	
   }
   ntrig=1;
}
else if (!(inlet_trig>0)) {ntrig=0;}

if ((inlet_r>0) && !rtrig) {count=0; cnt=0;rtrig = 1;outlet_restartbar=1;}
else if (!(inlet_r>0)) {rtrig=0;}
int shft=___SMMUL(__USAT(param_shift+inlet_shift,27),param_bar<<5);
int ct=(count+shft)%param_bar;
start=___SMMUL(param_bar<<5,__USAT(param_start+inlet_start,27));
int left=__USAT((ct-start),28);
ct=cnt;
int tbar=(param_bar-start-left);
int tlft=tbar/dvs*dvs;
if(left>0){
	left=tlft*stp+(tbar/3)*jmp;
	if(shft<3){
	ofs=1;
	}
	else{ofs=0;}
}
else if(count>=param_bar-1){ofs=1;left=stp;}
else if(left<1){ofs=0;}

int mem=(array[ct+ofs&LENGTHMASK]+left);
left=mem+s2+o2;

int oct=left/param_semis;
if((left<0)&&(left>-param_semis)){oct-=1;}
left=left%param_semis;
left+=left<0?param_semis:0;
left*=2;
left+=s1;
left=left%7;
left+=left<0?7:0;

oct=oct%param_octaves;
oct+=(oct<0?param_octaves:0)+o1;
outlet_sum= note[left]+oct*12;
outlet_semi=left;
outlet_oct=oct;


left=mem;
oct=left/param_semis;
if((left<0)&&(left>-param_semis)){oct-=1;}
left=left%param_semis;
left+=left<0?param_semis:0;
left*=2;
left=left%7;
left+=left<0?7:0;
outlet_self=note[left]+oct*12;
gate=0;
if(count<(___SMMUL((start-shft-1)<<1,__USAT(param_gatelength+inlet_gatelength,27)<<4))){
	gate=1;
}
else if(count<(param_bar-shft)){
	gate=inlet_trig&(tbar==tlft);
}
else if(count<((param_bar-shft)+___SMMUL(shft<<1,param_gatelength))){gate=1;}



outlet_gate=(gate||inlet_gate);
outlet_lastpart=(count==(param_bars-1))&&(cnt>start);]]></code.krate>
      </object>
   </patchobj>
   <obj type="ctrl/dial p" uuid="cc5d2846c3d50e425f450c4b9851371b54f4d674" name="velocity_1" x="1022" y="840">
      <params>
         <frac32.u.map name="value" value="30.5"/>
      </params>
      <attribs/>
   </obj>
   <obj type="math/*" uuid="922423f2db9f222aa3e5ba095778288c446da47a" name="*_1" x="1092" y="840">
      <params/>
      <attribs/>
   </obj>
   <obj type="ctrl/dial p" uuid="cc5d2846c3d50e425f450c4b9851371b54f4d674" name="cv_1" x="1148" y="840">
      <params>
         <frac32.u.map name="value" value="30.0"/>
      </params>
      <attribs/>
   </obj>
   <patchobj type="patch/object" uuid="9d1f58bb-bc4b-4a18-8eba-c89a5f0c857f" name="1x note send_1" x="1218" y="840">
      <params/>
      <attribs>
         <spinner attributeName="channel" value="9"/>
      </attribs>
      <object id="patch/object" uuid="9d1f58bb-bc4b-4a18-8eba-c89a5f0c857f">
         <sDescription>add</sDescription>
         <author>Johannes Taelman</author>
         <license>BSD</license>
         <helpPatch>math.axh</helpPatch>
         <inlets>
            <frac32.positive name="gate"/>
            <frac32.bipolar name="note"/>
            <frac32.positive name="cv"/>
         </inlets>
         <outlets>
            <frac32.positive name="out"/>
         </outlets>
         <displays/>
         <params/>
         <attribs>
            <spinner name="channel" MinValue="0" MaxValue="15" DefaultValue="0"/>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[int type=0; // midi note
int trg;
int last;

int32_t prv,i;
uint32_t out;
//channel        4 bits
//messagetype    2 bits
//message index 10 bits
//value		 16 bits]]></code.declaration>
         <code.init><![CDATA[last=64;]]></code.init>
         <code.krate><![CDATA[outlet_out=0;




out=0;
if(inlet_gate&&!prv){
last=inlet_note;
out=attr_channel;
out+=type<<4;
out+=(((inlet_note>>21)+64)&((1<<8)-1))<<6;
out+=((__USAT(inlet_gate,27)>>20)&((1<<8)-1))<<16;
out+=((__USAT(inlet_cv,27)>>20)&((1<<8)-1))<<24;
}
else if(prv&&!inlet_gate){
out=attr_channel;
out+=type<<4;
out+=(((last>>21)+64)&((1<<8)-1))<<6;
out+=0;
out+=((__USAT(inlet_cv,27)>>20)&((1<<8)-1))<<24;
}



outlet_out=out;

prv=inlet_gate;]]></code.krate>
      </object>
   </patchobj>
   <comment type="patch/comment" x="1316" y="868" text="a cv2midi converter"/>
   <comment type="patch/comment" x="1316" y="882" text="use a seperate GPIO for notes, otherwise you&apos;ll experience lag when using the CV controls"/>
   <comment type="patch/comment" x="1316" y="896" text="just check for yourself as currently they&apos;re all going into the same data combiner"/>
   <obj type="ctrl/dial p" uuid="cc5d2846c3d50e425f450c4b9851371b54f4d674" name="velocity_2" x="1022" y="952">
      <params>
         <frac32.u.map name="value" value="39.5"/>
      </params>
      <attribs/>
   </obj>
   <obj type="math/*" uuid="922423f2db9f222aa3e5ba095778288c446da47a" name="*_2" x="1092" y="952">
      <params/>
      <attribs/>
   </obj>
   <obj type="ctrl/dial p" uuid="cc5d2846c3d50e425f450c4b9851371b54f4d674" name="cv_2" x="1148" y="952">
      <params>
         <frac32.u.map name="value" value="21.0"/>
      </params>
      <attribs/>
   </obj>
   <patchobj type="patch/object" uuid="9d1f58bb-bc4b-4a18-8eba-c89a5f0c857f" name="1x note send_2" x="1218" y="952">
      <params/>
      <attribs>
         <spinner attributeName="channel" value="9"/>
      </attribs>
      <object id="patch/object" uuid="9d1f58bb-bc4b-4a18-8eba-c89a5f0c857f">
         <sDescription>add</sDescription>
         <author>Johannes Taelman</author>
         <license>BSD</license>
         <helpPatch>math.axh</helpPatch>
         <inlets>
            <frac32.positive name="gate"/>
            <frac32.bipolar name="note"/>
            <frac32.positive name="cv"/>
         </inlets>
         <outlets>
            <frac32.positive name="out"/>
         </outlets>
         <displays/>
         <params/>
         <attribs>
            <spinner name="channel" MinValue="0" MaxValue="15" DefaultValue="0"/>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[int type=0; // midi note
int trg;
int last;

int32_t prv,i;
uint32_t out;
//channel        4 bits
//messagetype    2 bits
//message index 10 bits
//value		 16 bits]]></code.declaration>
         <code.init><![CDATA[last=64;]]></code.init>
         <code.krate><![CDATA[outlet_out=0;




out=0;
if(inlet_gate&&!prv){
last=inlet_note;
out=attr_channel;
out+=type<<4;
out+=(((inlet_note>>21)+64)&((1<<8)-1))<<6;
out+=((__USAT(inlet_gate,27)>>20)&((1<<8)-1))<<16;
out+=((__USAT(inlet_cv,27)>>20)&((1<<8)-1))<<24;
}
else if(prv&&!inlet_gate){
out=attr_channel;
out+=type<<4;
out+=(((last>>21)+64)&((1<<8)-1))<<6;
out+=0;
out+=((__USAT(inlet_cv,27)>>20)&((1<<8)-1))<<24;
}



outlet_out=out;

prv=inlet_gate;]]></code.krate>
      </object>
   </patchobj>
   <obj type="ctrl/dial p" uuid="cc5d2846c3d50e425f450c4b9851371b54f4d674" name="velocity_3" x="1022" y="1064">
      <params>
         <frac32.u.map name="value" value="22.5"/>
      </params>
      <attribs/>
   </obj>
   <obj type="math/*" uuid="922423f2db9f222aa3e5ba095778288c446da47a" name="*_3" x="1092" y="1064">
      <params/>
      <attribs/>
   </obj>
   <obj type="ctrl/dial p" uuid="cc5d2846c3d50e425f450c4b9851371b54f4d674" name="cv_3" x="1148" y="1064">
      <params>
         <frac32.u.map name="value" value="16.5"/>
      </params>
      <attribs/>
   </obj>
   <patchobj type="patch/object" uuid="9d1f58bb-bc4b-4a18-8eba-c89a5f0c857f" name="1x note send_3" x="1218" y="1064">
      <params/>
      <attribs>
         <spinner attributeName="channel" value="9"/>
      </attribs>
      <object id="patch/object" uuid="9d1f58bb-bc4b-4a18-8eba-c89a5f0c857f">
         <sDescription>add</sDescription>
         <author>Johannes Taelman</author>
         <license>BSD</license>
         <helpPatch>math.axh</helpPatch>
         <inlets>
            <frac32.positive name="gate"/>
            <frac32.bipolar name="note"/>
            <frac32.positive name="cv"/>
         </inlets>
         <outlets>
            <frac32.positive name="out"/>
         </outlets>
         <displays/>
         <params/>
         <attribs>
            <spinner name="channel" MinValue="0" MaxValue="15" DefaultValue="0"/>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[int type=0; // midi note
int trg;
int last;

int32_t prv,i;
uint32_t out;
//channel        4 bits
//messagetype    2 bits
//message index 10 bits
//value		 16 bits]]></code.declaration>
         <code.init><![CDATA[last=64;]]></code.init>
         <code.krate><![CDATA[outlet_out=0;




out=0;
if(inlet_gate&&!prv){
last=inlet_note;
out=attr_channel;
out+=type<<4;
out+=(((inlet_note>>21)+64)&((1<<8)-1))<<6;
out+=((__USAT(inlet_gate,27)>>20)&((1<<8)-1))<<16;
out+=((__USAT(inlet_cv,27)>>20)&((1<<8)-1))<<24;
}
else if(prv&&!inlet_gate){
out=attr_channel;
out+=type<<4;
out+=(((last>>21)+64)&((1<<8)-1))<<6;
out+=0;
out+=((__USAT(inlet_cv,27)>>20)&((1<<8)-1))<<24;
}



outlet_out=out;

prv=inlet_gate;]]></code.krate>
      </object>
   </patchobj>
   <obj type="ctrl/dial p" uuid="cc5d2846c3d50e425f450c4b9851371b54f4d674" name="velocity_4" x="1022" y="1176">
      <params>
         <frac32.u.map name="value" value="38.0"/>
      </params>
      <attribs/>
   </obj>
   <obj type="math/*" uuid="922423f2db9f222aa3e5ba095778288c446da47a" name="*_4" x="1092" y="1176">
      <params/>
      <attribs/>
   </obj>
   <obj type="ctrl/dial p" uuid="cc5d2846c3d50e425f450c4b9851371b54f4d674" name="cv_4" x="1148" y="1176">
      <params>
         <frac32.u.map name="value" value="30.5"/>
      </params>
      <attribs/>
   </obj>
   <patchobj type="patch/object" uuid="9d1f58bb-bc4b-4a18-8eba-c89a5f0c857f" name="1x note send_4" x="1218" y="1176">
      <params/>
      <attribs>
         <spinner attributeName="channel" value="9"/>
      </attribs>
      <object id="patch/object" uuid="9d1f58bb-bc4b-4a18-8eba-c89a5f0c857f">
         <sDescription>add</sDescription>
         <author>Johannes Taelman</author>
         <license>BSD</license>
         <helpPatch>math.axh</helpPatch>
         <inlets>
            <frac32.positive name="gate"/>
            <frac32.bipolar name="note"/>
            <frac32.positive name="cv"/>
         </inlets>
         <outlets>
            <frac32.positive name="out"/>
         </outlets>
         <displays/>
         <params/>
         <attribs>
            <spinner name="channel" MinValue="0" MaxValue="15" DefaultValue="0"/>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[int type=0; // midi note
int trg;
int last;

int32_t prv,i;
uint32_t out;
//channel        4 bits
//messagetype    2 bits
//message index 10 bits
//value		 16 bits]]></code.declaration>
         <code.init><![CDATA[last=64;]]></code.init>
         <code.krate><![CDATA[outlet_out=0;




out=0;
if(inlet_gate&&!prv){
last=inlet_note;
out=attr_channel;
out+=type<<4;
out+=(((inlet_note>>21)+64)&((1<<8)-1))<<6;
out+=((__USAT(inlet_gate,27)>>20)&((1<<8)-1))<<16;
out+=((__USAT(inlet_cv,27)>>20)&((1<<8)-1))<<24;
}
else if(prv&&!inlet_gate){
out=attr_channel;
out+=type<<4;
out+=(((last>>21)+64)&((1<<8)-1))<<6;
out+=0;
out+=((__USAT(inlet_cv,27)>>20)&((1<<8)-1))<<24;
}



outlet_out=out;

prv=inlet_gate;]]></code.krate>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="9d1f58bb-bc4b-4a18-8eba-c89a5f0c857f" name="data combiner_1" x="1358" y="1176">
      <params/>
      <attribs/>
      <object id="patch/object" uuid="9d1f58bb-bc4b-4a18-8eba-c89a5f0c857f">
         <sDescription>add</sDescription>
         <author>Johannes Taelman</author>
         <license>BSD</license>
         <helpPatch>math.axh</helpPatch>
         <inlets>
            <frac32.positive name="i1"/>
            <frac32.positive name="i2"/>
            <frac32.positive name="i3"/>
            <frac32.positive name="i4"/>
            <frac32.positive name="i5"/>
            <frac32.positive name="i6"/>
            <frac32.positive name="i7"/>
            <frac32.positive name="i8"/>
         </inlets>
         <outlets>
            <bool32 name="out"/>
         </outlets>
         <displays/>
         <params/>
         <attribs/>
         <includes/>
         <code.declaration><![CDATA[int type=1; // 1x 16bit control
int busy;
uint32_t bufV[64],in[8];
//int16_t bufP[32];
int32_t prv[8],ctrl[8],i,wp,rp;

//channel        4 bits
//messagetype    2 bits
//message index 10 bits
//value		 16 bits]]></code.declaration>
         <code.init><![CDATA[wp=0;
rp=0;

busy=0;
for(i=0;i<8;i++){
	prv[i]=0;
}
for(i=0;i<64;i++){
	bufV[i]=0;
	//bufP[i]=0;
}]]></code.init>
         <code.krate><![CDATA[in[0]=inlet_i1;
in[1]=inlet_i2;
in[2]=inlet_i3;
in[3]=inlet_i4;
in[4]=inlet_i5;
in[5]=inlet_i6;
in[6]=inlet_i7;
in[7]=inlet_i8;
outlet_out=0;

for(i=0;i<8;i++)
{
	if(!(in[i]==prv[i]))
	{
		bufV[wp]=in[i];
//		bufP[wp]=i;
		wp=(1+wp)&63;
	}	
	prv[i]=in[i];
}


if(busy==0){
if(!(wp==rp)){
busy=33;
}
}


if(busy>0){
if(busy==33){outlet_out=1;}
else if(busy>28){
outlet_out=(bufV[rp]>>(busy-29))&1;
}
else if(busy>26){
outlet_out=(bufV[rp]>>(busy-27)+4)&1;
}
else if(busy>16){
outlet_out=(bufV[rp]>>(busy-17)+6)&1;
}
else{
outlet_out=(bufV[rp]>>(busy-1)+16)&1;
}

busy-=1;
if(busy==0){
	rp=(rp+1)&63;
}
}]]></code.krate>
      </object>
   </patchobj>
   <comment type="patch/comment" x="1442" y="1176" text="combining ONLY the note &quot;commands&quot; into a serial data stream"/>
   <patchobj type="patch/object" uuid="9d1f58bb-bc4b-4a18-8eba-c89a5f0c857f" name="data combiner_2" x="1750" y="1176">
      <params/>
      <attribs/>
      <object id="patch/object" uuid="9d1f58bb-bc4b-4a18-8eba-c89a5f0c857f">
         <sDescription>add</sDescription>
         <author>Johannes Taelman</author>
         <license>BSD</license>
         <helpPatch>math.axh</helpPatch>
         <inlets>
            <frac32.positive name="i1"/>
            <frac32.positive name="i2"/>
            <frac32.positive name="i3"/>
            <frac32.positive name="i4"/>
            <frac32.positive name="i5"/>
            <frac32.positive name="i6"/>
            <frac32.positive name="i7"/>
            <frac32.positive name="i8"/>
         </inlets>
         <outlets>
            <bool32 name="out"/>
         </outlets>
         <displays/>
         <params/>
         <attribs/>
         <includes/>
         <code.declaration><![CDATA[int type=1; // 1x 16bit control
int busy;
uint32_t bufV[64],in[8];
//int16_t bufP[32];
int32_t prv[8],ctrl[8],i,wp,rp;

//channel        4 bits
//messagetype    2 bits
//message index 10 bits
//value		 16 bits]]></code.declaration>
         <code.init><![CDATA[wp=0;
rp=0;

busy=0;
for(i=0;i<8;i++){
	prv[i]=0;
}
for(i=0;i<64;i++){
	bufV[i]=0;
	//bufP[i]=0;
}]]></code.init>
         <code.krate><![CDATA[in[0]=inlet_i1;
in[1]=inlet_i2;
in[2]=inlet_i3;
in[3]=inlet_i4;
in[4]=inlet_i5;
in[5]=inlet_i6;
in[6]=inlet_i7;
in[7]=inlet_i8;
outlet_out=0;

for(i=0;i<8;i++)
{
	if(!(in[i]==prv[i]))
	{
		bufV[wp]=in[i];
//		bufP[wp]=i;
		wp=(1+wp)&63;
	}	
	prv[i]=in[i];
}


if(busy==0){
if(!(wp==rp)){
busy=33;
}
}


if(busy>0){
if(busy==33){outlet_out=1;}
else if(busy>28){
outlet_out=(bufV[rp]>>(busy-29))&1;
}
else if(busy>26){
outlet_out=(bufV[rp]>>(busy-27)+4)&1;
}
else if(busy>16){
outlet_out=(bufV[rp]>>(busy-17)+6)&1;
}
else{
outlet_out=(bufV[rp]>>(busy-1)+16)&1;
}

busy-=1;
if(busy==0){
	rp=(rp+1)&63;
}
}]]></code.krate>
      </object>
   </patchobj>
   <comment type="patch/comment" x="1820" y="1176" text="combining all the control AND note &quot;commands&quot; into a serial data stream"/>
   <patchobj type="patch/object" uuid="9d1f58bb-bc4b-4a18-8eba-c89a5f0c857f" name="data combiner_3" x="2170" y="1176">
      <params/>
      <attribs/>
      <object id="patch/object" uuid="9d1f58bb-bc4b-4a18-8eba-c89a5f0c857f">
         <sDescription>add</sDescription>
         <author>Johannes Taelman</author>
         <license>BSD</license>
         <helpPatch>math.axh</helpPatch>
         <inlets>
            <frac32.positive name="i1"/>
            <frac32.positive name="i2"/>
            <frac32.positive name="i3"/>
            <frac32.positive name="i4"/>
            <frac32.positive name="i5"/>
            <frac32.positive name="i6"/>
            <frac32.positive name="i7"/>
            <frac32.positive name="i8"/>
         </inlets>
         <outlets>
            <bool32 name="out"/>
         </outlets>
         <displays/>
         <params/>
         <attribs/>
         <includes/>
         <code.declaration><![CDATA[int type=1; // 1x 16bit control
int busy;
uint32_t bufV[64],in[8];
//int16_t bufP[32];
int32_t prv[8],ctrl[8],i,wp,rp;

//channel        4 bits
//messagetype    2 bits
//message index 10 bits
//value		 16 bits]]></code.declaration>
         <code.init><![CDATA[wp=0;
rp=0;

busy=0;
for(i=0;i<8;i++){
	prv[i]=0;
}
for(i=0;i<64;i++){
	bufV[i]=0;
	//bufP[i]=0;
}]]></code.init>
         <code.krate><![CDATA[in[0]=inlet_i1;
in[1]=inlet_i2;
in[2]=inlet_i3;
in[3]=inlet_i4;
in[4]=inlet_i5;
in[5]=inlet_i6;
in[6]=inlet_i7;
in[7]=inlet_i8;
outlet_out=0;

for(i=0;i<8;i++)
{
	if(!(in[i]==prv[i]))
	{
		bufV[wp]=in[i];
//		bufP[wp]=i;
		wp=(1+wp)&63;
	}	
	prv[i]=in[i];
}


if(busy==0){
if(!(wp==rp)){
busy=33;
}
}


if(busy>0){
if(busy==33){outlet_out=1;}
else if(busy>28){
outlet_out=(bufV[rp]>>(busy-29))&1;
}
else if(busy>26){
outlet_out=(bufV[rp]>>(busy-27)+4)&1;
}
else if(busy>16){
outlet_out=(bufV[rp]>>(busy-17)+6)&1;
}
else{
outlet_out=(bufV[rp]>>(busy-1)+16)&1;
}

busy-=1;
if(busy==0){
	rp=(rp+1)&63;
}
}]]></code.krate>
      </object>
   </patchobj>
   <comment type="patch/comment" x="2254" y="1176" text="combining ONLY the control &quot;commands&quot; into a serial data stream"/>
   <obj type="ctrl/toggle" uuid="42b8134fa729d54bfc8d62d6ef3fa99498c1de99" name="switch to independent notes and controls" x="1008" y="1372">
      <params>
         <bool32.tgl name="b" value="0"/>
      </params>
      <attribs/>
   </obj>
   <obj type="mux/mux 2" uuid="e1c92bc92f4d191bfadf0efeae4503b458a4e440" name="all/control" x="1204" y="1372">
      <params/>
      <attribs/>
   </obj>
   <comment type="patch/comment" x="1568" y="1372" text="control receive module"/>
   <patchobj type="patch/object" uuid="9d1f58bb-bc4b-4a18-8eba-c89a5f0c857f" name="16bit_1" x="1694" y="1372">
      <params/>
      <attribs>
         <spinner attributeName="channel" value="9"/>
         <spinner attributeName="cc1" value="0"/>
         <spinner attributeName="cc2" value="1"/>
         <spinner attributeName="cc3" value="2"/>
         <spinner attributeName="cc4" value="6"/>
         <spinner attributeName="cc5" value="4"/>
         <spinner attributeName="cc6" value="5"/>
         <spinner attributeName="cc7" value="12"/>
         <spinner attributeName="cc8" value="19"/>
      </attribs>
      <object id="patch/object" uuid="9d1f58bb-bc4b-4a18-8eba-c89a5f0c857f">
         <sDescription>add</sDescription>
         <author>Johannes Taelman</author>
         <license>BSD</license>
         <helpPatch>math.axh</helpPatch>
         <inlets>
            <bool32 name="in"/>
         </inlets>
         <outlets>
            <frac32.positive name="o1"/>
            <frac32.positive name="o2"/>
            <frac32.positive name="o3"/>
            <frac32.positive name="o4"/>
            <frac32.positive name="o5"/>
            <frac32.positive name="o6"/>
            <frac32.positive name="o7"/>
            <frac32.positive name="o8"/>
         </outlets>
         <displays/>
         <params/>
         <attribs>
            <spinner name="channel" MinValue="0" MaxValue="15" DefaultValue="0"/>
            <spinner name="cc1" MinValue="0" MaxValue="1023" DefaultValue="0"/>
            <spinner name="cc2" MinValue="0" MaxValue="1023" DefaultValue="0"/>
            <spinner name="cc3" MinValue="0" MaxValue="1023" DefaultValue="0"/>
            <spinner name="cc4" MinValue="0" MaxValue="1023" DefaultValue="0"/>
            <spinner name="cc5" MinValue="0" MaxValue="1023" DefaultValue="0"/>
            <spinner name="cc6" MinValue="0" MaxValue="1023" DefaultValue="0"/>
            <spinner name="cc7" MinValue="0" MaxValue="1023" DefaultValue="0"/>
            <spinner name="cc8" MinValue="0" MaxValue="1023" DefaultValue="0"/>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[int TYPE=1; // 1x 16bit control (0=note, 2=2x 8bit control, 3=list)
int32_t val[8];
int32_t busy,prv;

int32_t channel,type,cl,vl;
int ctrl[8];
int i;]]></code.declaration>
         <code.init><![CDATA[busy=0;
channel=0;
cl=0;
type=0;

ctrl[0]=attr_cc1;
ctrl[1]=attr_cc2;
ctrl[2]=attr_cc3;
ctrl[3]=attr_cc4;
ctrl[4]=attr_cc5;
ctrl[5]=attr_cc6;
ctrl[6]=attr_cc7;
ctrl[7]=attr_cc8;]]></code.init>
         <code.krate><![CDATA[if(inlet_in&&!(busy>0)){
	busy=1;
	channel=0;
	type=0;
	cl=0;
	vl=0;
}


if(busy>0){
if(busy==1){
}
else if(busy<6){
channel+=inlet_in<<5-busy;	
}
else if(busy<8){
type+=inlet_in<<7-busy;
}
else if(busy<18){
cl+=inlet_in<<17-busy;
}
else{
vl+=inlet_in<<33-busy;
}

busy+=1;
if(busy==34){
busy=0;
if((channel==attr_channel)&&(type==TYPE)){
for(i=0;i<8;i++){
if(cl==ctrl[i]){
	val[i]=vl<<12;
}
}

}
}
}




outlet_o1=val[0];
outlet_o2=val[1];
outlet_o3=val[2];
outlet_o4=val[3];
outlet_o5=val[4];
outlet_o6=val[5];
outlet_o7=val[6];
outlet_o8=val[7];]]></code.krate>
      </object>
   </patchobj>
   <obj type="disp/dial p" uuid="44fd18b562e434b3230441681132dbeabb15cdc5" name="dial_2" x="1792" y="1372">
      <params/>
      <attribs/>
   </obj>
   <obj type="disp/dial p" uuid="44fd18b562e434b3230441681132dbeabb15cdc5" name="dial_10" x="1862" y="1372">
      <params/>
      <attribs/>
   </obj>
   <obj type="disp/dial p" uuid="44fd18b562e434b3230441681132dbeabb15cdc5" name="dial_11" x="1932" y="1372">
      <params/>
      <attribs/>
   </obj>
   <obj type="disp/dial p" uuid="44fd18b562e434b3230441681132dbeabb15cdc5" name="dial_12" x="2002" y="1372">
      <params/>
      <attribs/>
   </obj>
   <patchobj type="patch/object" uuid="9d1f58bb-bc4b-4a18-8eba-c89a5f0c857f" name="16bit_2" x="2072" y="1372">
      <params/>
      <attribs>
         <spinner attributeName="channel" value="7"/>
         <spinner attributeName="cc1" value="0"/>
         <spinner attributeName="cc2" value="1"/>
         <spinner attributeName="cc3" value="2"/>
         <spinner attributeName="cc4" value="6"/>
         <spinner attributeName="cc5" value="4"/>
         <spinner attributeName="cc6" value="5"/>
         <spinner attributeName="cc7" value="12"/>
         <spinner attributeName="cc8" value="19"/>
      </attribs>
      <object id="patch/object" uuid="9d1f58bb-bc4b-4a18-8eba-c89a5f0c857f">
         <sDescription>add</sDescription>
         <author>Johannes Taelman</author>
         <license>BSD</license>
         <helpPatch>math.axh</helpPatch>
         <inlets>
            <bool32 name="in"/>
         </inlets>
         <outlets>
            <frac32.positive name="o1"/>
            <frac32.positive name="o2"/>
            <frac32.positive name="o3"/>
            <frac32.positive name="o4"/>
            <frac32.positive name="o5"/>
            <frac32.positive name="o6"/>
            <frac32.positive name="o7"/>
            <frac32.positive name="o8"/>
         </outlets>
         <displays/>
         <params/>
         <attribs>
            <spinner name="channel" MinValue="0" MaxValue="15" DefaultValue="0"/>
            <spinner name="cc1" MinValue="0" MaxValue="1023" DefaultValue="0"/>
            <spinner name="cc2" MinValue="0" MaxValue="1023" DefaultValue="0"/>
            <spinner name="cc3" MinValue="0" MaxValue="1023" DefaultValue="0"/>
            <spinner name="cc4" MinValue="0" MaxValue="1023" DefaultValue="0"/>
            <spinner name="cc5" MinValue="0" MaxValue="1023" DefaultValue="0"/>
            <spinner name="cc6" MinValue="0" MaxValue="1023" DefaultValue="0"/>
            <spinner name="cc7" MinValue="0" MaxValue="1023" DefaultValue="0"/>
            <spinner name="cc8" MinValue="0" MaxValue="1023" DefaultValue="0"/>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[int TYPE=1; // 1x 16bit control (0=note, 2=2x 8bit control, 3=list)
int32_t val[8];
int32_t busy,prv;

int32_t channel,type,cl,vl;
int ctrl[8];
int i;]]></code.declaration>
         <code.init><![CDATA[busy=0;
channel=0;
cl=0;
type=0;

ctrl[0]=attr_cc1;
ctrl[1]=attr_cc2;
ctrl[2]=attr_cc3;
ctrl[3]=attr_cc4;
ctrl[4]=attr_cc5;
ctrl[5]=attr_cc6;
ctrl[6]=attr_cc7;
ctrl[7]=attr_cc8;]]></code.init>
         <code.krate><![CDATA[if(inlet_in&&!(busy>0)){
	busy=1;
	channel=0;
	type=0;
	cl=0;
	vl=0;
}


if(busy>0){
if(busy==1){
}
else if(busy<6){
channel+=inlet_in<<5-busy;	
}
else if(busy<8){
type+=inlet_in<<7-busy;
}
else if(busy<18){
cl+=inlet_in<<17-busy;
}
else{
vl+=inlet_in<<33-busy;
}

busy+=1;
if(busy==34){
busy=0;
if((channel==attr_channel)&&(type==TYPE)){
for(i=0;i<8;i++){
if(cl==ctrl[i]){
	val[i]=vl<<12;
}
}

}
}
}




outlet_o1=val[0];
outlet_o2=val[1];
outlet_o3=val[2];
outlet_o4=val[3];
outlet_o5=val[4];
outlet_o6=val[5];
outlet_o7=val[6];
outlet_o8=val[7];]]></code.krate>
      </object>
   </patchobj>
   <obj type="disp/dial b" uuid="9ffed04e6a3052d9001eda83bae7024cb6d17037" name="dial_26" x="2170" y="1372">
      <params/>
      <attribs/>
   </obj>
   <obj type="disp/dial p" uuid="44fd18b562e434b3230441681132dbeabb15cdc5" name="dial_27" x="2240" y="1372">
      <params/>
      <attribs/>
   </obj>
   <obj type="disp/dial p" uuid="44fd18b562e434b3230441681132dbeabb15cdc5" name="dial_28" x="2310" y="1372">
      <params/>
      <attribs/>
   </obj>
   <obj type="disp/dial p" uuid="44fd18b562e434b3230441681132dbeabb15cdc5" name="dial_29" x="2380" y="1372">
      <params/>
      <attribs/>
   </obj>
   <obj type="mux/mux 2" uuid="e1c92bc92f4d191bfadf0efeae4503b458a4e440" name="all/note" x="1204" y="1442">
      <params/>
      <attribs/>
   </obj>
   <obj type="disp/dial p" uuid="44fd18b562e434b3230441681132dbeabb15cdc5" name="dial_13" x="1792" y="1456">
      <params/>
      <attribs/>
   </obj>
   <obj type="disp/dial p" uuid="44fd18b562e434b3230441681132dbeabb15cdc5" name="dial_14" x="1862" y="1456">
      <params/>
      <attribs/>
   </obj>
   <obj type="disp/dial p" uuid="44fd18b562e434b3230441681132dbeabb15cdc5" name="dial_15" x="1932" y="1456">
      <params/>
      <attribs/>
   </obj>
   <obj type="disp/dial p" uuid="44fd18b562e434b3230441681132dbeabb15cdc5" name="dial_16" x="2002" y="1456">
      <params/>
      <attribs/>
   </obj>
   <obj type="disp/dial p" uuid="44fd18b562e434b3230441681132dbeabb15cdc5" name="dial_30" x="2170" y="1456">
      <params/>
      <attribs/>
   </obj>
   <obj type="disp/dial p" uuid="44fd18b562e434b3230441681132dbeabb15cdc5" name="dial_31" x="2240" y="1456">
      <params/>
      <attribs/>
   </obj>
   <obj type="disp/dial p" uuid="44fd18b562e434b3230441681132dbeabb15cdc5" name="dial_32" x="2310" y="1456">
      <params/>
      <attribs/>
   </obj>
   <obj type="disp/dial p" uuid="44fd18b562e434b3230441681132dbeabb15cdc5" name="dial_33" x="2380" y="1456">
      <params/>
      <attribs/>
   </obj>
   <comment type="patch/comment" x="1428" y="1512" text="select the right channel to read out the right controls"/>
   <comment type="patch/comment" x="1498" y="1526" text="of course, also select the right controls"/>
   <patchobj type="patch/object" uuid="9d1f58bb-bc4b-4a18-8eba-c89a5f0c857f" name="2x8bit_1" x="1694" y="1680">
      <params/>
      <attribs>
         <spinner attributeName="channel" value="8"/>
         <spinner attributeName="cc1" value="0"/>
         <spinner attributeName="cc2" value="1"/>
         <spinner attributeName="cc3" value="2"/>
         <spinner attributeName="cc4" value="3"/>
      </attribs>
      <object id="patch/object" uuid="9d1f58bb-bc4b-4a18-8eba-c89a5f0c857f">
         <sDescription>add</sDescription>
         <author>Johannes Taelman</author>
         <license>BSD</license>
         <helpPatch>math.axh</helpPatch>
         <inlets>
            <bool32 name="in"/>
         </inlets>
         <outlets>
            <frac32.positive name="o1"/>
            <frac32.positive name="o2"/>
            <frac32.positive name="o3"/>
            <frac32.positive name="o4"/>
            <frac32.positive name="o5"/>
            <frac32.positive name="o6"/>
            <frac32.positive name="o7"/>
            <frac32.positive name="o8"/>
         </outlets>
         <displays/>
         <params/>
         <attribs>
            <spinner name="channel" MinValue="0" MaxValue="15" DefaultValue="0"/>
            <spinner name="cc1" MinValue="0" MaxValue="1023" DefaultValue="0"/>
            <spinner name="cc2" MinValue="0" MaxValue="1023" DefaultValue="0"/>
            <spinner name="cc3" MinValue="0" MaxValue="1023" DefaultValue="0"/>
            <spinner name="cc4" MinValue="0" MaxValue="1023" DefaultValue="0"/>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[int TYPE=2; // 1x 16bit control (0=note, 2=2x 8bit control, 3=list)
int32_t val[8];
int32_t busy,prv;

int32_t channel,type,cl,vl;
int ctrl[8];
int i;]]></code.declaration>
         <code.init><![CDATA[busy=0;
channel=0;
cl=0;
type=0;

ctrl[0]=attr_cc1;
ctrl[1]=attr_cc2;
ctrl[2]=attr_cc3;
ctrl[3]=attr_cc4;]]></code.init>
         <code.krate><![CDATA[if(inlet_in&&!(busy>0)){
	busy=1;
	channel=0;
	type=0;
	cl=0;
	vl=0;
}


if(busy>0){
if(busy==1){
}
else if(busy<6){
channel+=inlet_in<<5-busy;	
}
else if(busy<8){
type+=inlet_in<<7-busy;
}
else if(busy<18){
cl+=inlet_in<<17-busy;
}
else{
vl+=inlet_in<<33-busy;
}

busy+=1;
if(busy==34){
busy=0;
if((channel==attr_channel)&&(type==TYPE)){
for(i=0;i<4;i++){
if(cl==ctrl[i]){
	val[i<<1]=(vl&((1<<8)-1))<<20;
	val[(i<<1)+1]=((vl>>8)&((1<<8)-1))<<20;
}
}

}
}
}




outlet_o1=val[0];
outlet_o2=val[1];
outlet_o3=val[2];
outlet_o4=val[3];
outlet_o5=val[4];
outlet_o6=val[5];
outlet_o7=val[6];
outlet_o8=val[7];]]></code.krate>
      </object>
   </patchobj>
   <obj type="disp/dial p" uuid="44fd18b562e434b3230441681132dbeabb15cdc5" name="dial_41" x="1792" y="1680">
      <params/>
      <attribs/>
   </obj>
   <obj type="disp/dial p" uuid="44fd18b562e434b3230441681132dbeabb15cdc5" name="dial_42" x="1862" y="1680">
      <params/>
      <attribs/>
   </obj>
   <obj type="disp/dial p" uuid="44fd18b562e434b3230441681132dbeabb15cdc5" name="dial_43" x="1932" y="1680">
      <params/>
      <attribs/>
   </obj>
   <obj type="disp/dial p" uuid="44fd18b562e434b3230441681132dbeabb15cdc5" name="dial_44" x="2002" y="1680">
      <params/>
      <attribs/>
   </obj>
   <obj type="disp/dial p" uuid="44fd18b562e434b3230441681132dbeabb15cdc5" name="dial_45" x="1792" y="1764">
      <params/>
      <attribs/>
   </obj>
   <obj type="disp/dial p" uuid="44fd18b562e434b3230441681132dbeabb15cdc5" name="dial_46" x="1862" y="1764">
      <params/>
      <attribs/>
   </obj>
   <obj type="disp/dial p" uuid="44fd18b562e434b3230441681132dbeabb15cdc5" name="dial_47" x="1932" y="1764">
      <params/>
      <attribs/>
   </obj>
   <obj type="disp/dial p" uuid="44fd18b562e434b3230441681132dbeabb15cdc5" name="dial_48" x="2002" y="1764">
      <params/>
      <attribs/>
   </obj>
   <comment type="patch/comment" x="1428" y="1806" text="select the right channel to read out the right controls"/>
   <comment type="patch/comment" x="1386" y="1834" text="note that the controls are being received as pairs on a single CC"/>
   <comment type="patch/comment" x="1554" y="1960" text="this is a mono note receiver"/>
   <patchobj type="patch/object" uuid="9d1f58bb-bc4b-4a18-8eba-c89a5f0c857f" name="1x note out (mono)" x="1694" y="1960">
      <params/>
      <attribs>
         <spinner attributeName="channel" value="9"/>
      </attribs>
      <object id="patch/object" uuid="9d1f58bb-bc4b-4a18-8eba-c89a5f0c857f">
         <sDescription>add</sDescription>
         <author>Johannes Taelman</author>
         <license>BSD</license>
         <helpPatch>math.axh</helpPatch>
         <inlets>
            <bool32 name="in"/>
         </inlets>
         <outlets>
            <frac32.positive name="gate"/>
            <frac32.positive name="note"/>
            <frac32.positive name="cv"/>
         </outlets>
         <displays/>
         <params/>
         <attribs>
            <spinner name="channel" MinValue="0" MaxValue="15" DefaultValue="0"/>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[int TYPE=0; // 1x 16bit control (0=note, 2=2x 8bit control, 3=list)
int32_t val[3];
int32_t busy,prv;

int32_t channel,type,cl,vl;
int i;]]></code.declaration>
         <code.init><![CDATA[busy=0;
channel=0;
cl=0;
type=0;]]></code.init>
         <code.krate><![CDATA[if(inlet_in&&!(busy>0)){
	busy=1;
	channel=0;
	type=0;
	cl=0;
	vl=0;
}


if(busy>0){
if(busy==1){
}
else if(busy<6){
channel+=inlet_in<<5-busy;	
}
else if(busy<8){
type+=inlet_in<<7-busy;
}
else if(busy<18){
cl+=inlet_in<<17-busy;
}
else{
vl+=inlet_in<<33-busy;
}

busy+=1;
if(busy==34){
busy=0;
if((channel==attr_channel)&&(type==TYPE)){
val[1]=cl-64<<21;
val[0]=((vl)&((1<<8)-1))<<20;
val[2]=((vl>>8)&((1<<8)-1))<<20;
}

}
}

outlet_gate=val[0];
outlet_note=val[1];
outlet_cv=val[2];]]></code.krate>
      </object>
   </patchobj>
   <obj type="disp/dial p" uuid="44fd18b562e434b3230441681132dbeabb15cdc5" name="dial_52" x="1792" y="1960">
      <params/>
      <attribs/>
   </obj>
   <obj type="disp/dial b" uuid="9ffed04e6a3052d9001eda83bae7024cb6d17037" name="dial_53" x="1862" y="1960">
      <params/>
      <attribs/>
   </obj>
   <obj type="disp/dial p" uuid="44fd18b562e434b3230441681132dbeabb15cdc5" name="dial_54" x="1932" y="1960">
      <params/>
      <attribs/>
   </obj>
   <comment type="patch/comment" x="1358" y="1974" text="no retrigger, just as simple as can get.. first try getting that note info"/>
   <comment type="patch/comment" x="1428" y="2030" text="select the right channel to read out the right controls"/>
   <comment type="patch/comment" x="1540" y="2072" text="this is a 4 voice note receiver"/>
   <patchobj type="patch/object" uuid="9d1f58bb-bc4b-4a18-8eba-c89a5f0c857f" name="4x note out (poly)" x="1694" y="2072">
      <params/>
      <attribs>
         <spinner attributeName="channel" value="9"/>
      </attribs>
      <object id="patch/object" uuid="9d1f58bb-bc4b-4a18-8eba-c89a5f0c857f">
         <sDescription>add</sDescription>
         <author>Johannes Taelman</author>
         <license>BSD</license>
         <helpPatch>math.axh</helpPatch>
         <inlets>
            <bool32 name="in"/>
         </inlets>
         <outlets>
            <frac32.positive name="gate1"/>
            <frac32.positive name="note1"/>
            <frac32.positive name="cv1"/>
            <frac32 name="gate2"/>
            <frac32 name="note2"/>
            <frac32 name="cv2"/>
            <frac32 name="gate3"/>
            <frac32 name="note3"/>
            <frac32 name="cv3"/>
            <frac32 name="gate4"/>
            <frac32 name="note4"/>
            <frac32 name="cv4"/>
         </outlets>
         <displays/>
         <params/>
         <attribs>
            <spinner name="channel" MinValue="0" MaxValue="15" DefaultValue="0"/>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[int TYPE=0; // 1x 16bit control (0=note, 2=2x 8bit control, 3=list)
int32_t val[3];
int32_t busy,prv;

int32_t channel,type,cl,vl;
int i;
int gate[4],note[4],cv[4];]]></code.declaration>
         <code.init><![CDATA[busy=0;
channel=0;
cl=0;
type=0;]]></code.init>
         <code.krate><![CDATA[if(inlet_in&&!(busy>0)){
	busy=1;
	channel=0;
	type=0;
	cl=0;
	vl=0;
}


if(busy>0){
if(busy==1){
}
else if(busy<6){
channel+=inlet_in<<5-busy;	
}
else if(busy<8){
type+=inlet_in<<7-busy;
}
else if(busy<18){
cl+=inlet_in<<17-busy;
}
else{
vl+=inlet_in<<33-busy;
}

busy+=1;
if(busy==34){
busy=0;
if((channel==attr_channel)&&(type==TYPE)){
val[1]=cl-64<<21;
val[0]=((vl)&((1<<8)-1))<<20;
val[2]=((vl>>8)&((1<<8)-1))<<20;
}
if(val[0]==0){
for(i=0;i<4;i++){
	if(val[1]==note[i]){
		gate[i]=0;
	}
}	
}
else
{
	int there=0;
	for(i=0;i<4;i++){
		if(val[1]==note[i]){
			there=i+1;
			break;
		}
	}
	if(there>0)
	{
		gate[there-1]=val[0];
		cv[there-1]=val[2];
	}
	else
	{	int open=0;
		for(i=0;i<4;i++)
		{
			if(gate[i]==0){
				open=i+1;
				break;
			}
		}
		if(open>0){
			gate[open-1]=val[0];
			note[open-1]=val[1];
			cv[open-1]=val[2];
		}
		else{
			int sel=(int32_t)(GenerateRandomNumber()&3);
			gate[sel]=val[0];
			note[sel]=val[1];
			cv[sel]=val[2];
		}
	
	
	
	
	
	}

}
}
}

outlet_gate1=gate[0];
outlet_note1=note[0];
outlet_cv1=cv[0];
outlet_gate2=gate[1];
outlet_note2=note[1];
outlet_cv2=cv[1];
outlet_gate3=gate[2];
outlet_note3=note[2];
outlet_cv3=cv[2];
outlet_gate4=gate[3];
outlet_note4=note[3];
outlet_cv4=cv[3];]]></code.krate>
      </object>
   </patchobj>
   <obj type="disp/dial p" uuid="44fd18b562e434b3230441681132dbeabb15cdc5" name="dial_64" x="1792" y="2072">
      <params/>
      <attribs/>
   </obj>
   <obj type="disp/dial b" uuid="9ffed04e6a3052d9001eda83bae7024cb6d17037" name="dial_65" x="1862" y="2072">
      <params/>
      <attribs/>
   </obj>
   <obj type="disp/dial p" uuid="44fd18b562e434b3230441681132dbeabb15cdc5" name="dial_66" x="1932" y="2072">
      <params/>
      <attribs/>
   </obj>
   <comment type="patch/comment" x="1414" y="2086" text="always looks for an open voice when new note comes in"/>
   <comment type="patch/comment" x="1190" y="2100" text="note priority is from top to down, so last one (4) gets filled the least and first one (1) is on most of the time"/>
   <comment type="patch/comment" x="1316" y="2114" text="when everything is filled, just randomly chooses one of the 4 voices to change"/>
   <obj type="disp/dial p" uuid="44fd18b562e434b3230441681132dbeabb15cdc5" name="dial_67" x="1792" y="2156">
      <params/>
      <attribs/>
   </obj>
   <obj type="disp/dial b" uuid="9ffed04e6a3052d9001eda83bae7024cb6d17037" name="dial_68" x="1862" y="2156">
      <params/>
      <attribs/>
   </obj>
   <obj type="disp/dial p" uuid="44fd18b562e434b3230441681132dbeabb15cdc5" name="dial_69" x="1932" y="2156">
      <params/>
      <attribs/>
   </obj>
   <obj type="disp/dial p" uuid="44fd18b562e434b3230441681132dbeabb15cdc5" name="dial_70" x="1792" y="2240">
      <params/>
      <attribs/>
   </obj>
   <obj type="disp/dial b" uuid="9ffed04e6a3052d9001eda83bae7024cb6d17037" name="dial_71" x="1862" y="2240">
      <params/>
      <attribs/>
   </obj>
   <obj type="disp/dial p" uuid="44fd18b562e434b3230441681132dbeabb15cdc5" name="dial_72" x="1932" y="2240">
      <params/>
      <attribs/>
   </obj>
   <obj type="disp/dial p" uuid="44fd18b562e434b3230441681132dbeabb15cdc5" name="dial_73" x="1792" y="2324">
      <params/>
      <attribs/>
   </obj>
   <obj type="disp/dial b" uuid="9ffed04e6a3052d9001eda83bae7024cb6d17037" name="dial_74" x="1862" y="2324">
      <params/>
      <attribs/>
   </obj>
   <obj type="disp/dial p" uuid="44fd18b562e434b3230441681132dbeabb15cdc5" name="dial_75" x="1932" y="2324">
      <params/>
      <attribs/>
   </obj>
   <comment type="patch/comment" x="1134" y="2478" text="screw the above &quot;note&quot; shit.. here is an intermediate module, turning all incoming notes into polyphonic midi messages..."/>
   <patchobj type="patch/object" uuid="9d1f58bb-bc4b-4a18-8eba-c89a5f0c857f" name="note2midi" x="1708" y="2478">
      <params/>
      <attribs>
         <spinner attributeName="channel" value="9"/>
         <spinner attributeName="midichannel" value="1"/>
         <combo attributeName="device" selection="internal port 1"/>
      </attribs>
      <object id="patch/object" uuid="9d1f58bb-bc4b-4a18-8eba-c89a5f0c857f">
         <sDescription>add</sDescription>
         <author>Johannes Taelman</author>
         <license>BSD</license>
         <helpPatch>math.axh</helpPatch>
         <inlets>
            <bool32 name="in"/>
         </inlets>
         <outlets/>
         <displays/>
         <params/>
         <attribs>
            <spinner name="channel" MinValue="0" MaxValue="15" DefaultValue="0"/>
            <spinner name="midichannel" MinValue="1" MaxValue="16" DefaultValue="0"/>
            <combo name="device">
               <MenuEntries>
                  <string>din</string>
                  <string>usb host port 1</string>
                  <string>usb host port 2</string>
                  <string>usb host port 3</string>
                  <string>usb host port 4</string>
                  <string>internal port 1</string>
                  <string>internal port 2</string>
                  <string>usb device port 1</string>
               </MenuEntries>
               <CEntries>
                  <string>MIDI_DEVICE_DIN, 1</string>
                  <string>MIDI_DEVICE_USB_HOST, 1</string>
                  <string>MIDI_DEVICE_USB_HOST, 2</string>
                  <string>MIDI_DEVICE_USB_HOST, 3</string>
                  <string>MIDI_DEVICE_USB_HOST, 4</string>
                  <string>MIDI_DEVICE_INTERNAL, 1</string>
                  <string>MIDI_DEVICE_INTERNAL, 2</string>
                  <string>MIDI_DEVICE_USB_DEVICE, 1</string>
               </CEntries>
            </combo>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[int TYPE=0; // 1x 16bit control (0=note, 2=2x 8bit control, 3=list)
int32_t val[3];
int32_t busy,prv;

int32_t channel,type,cl,vl;
int i;
int gate[4],note[4],cv[4];]]></code.declaration>
         <code.init><![CDATA[busy=0;
channel=0;
cl=0;
type=0;]]></code.init>
         <code.krate><![CDATA[if(inlet_in&&!(busy>0)){
	busy=1;
	channel=0;
	type=0;
	cl=0;
	vl=0;
}


if(busy>0){
if(busy==1){
}
else if(busy<6){
channel+=inlet_in<<5-busy;	
}
else if(busy<8){
type+=inlet_in<<7-busy;
}
else if(busy<18){
cl+=inlet_in<<17-busy;
}
else{
vl+=inlet_in<<33-busy;
}

busy+=1;
if(busy==34){
busy=0;
if((channel==attr_channel)&&(type==TYPE)){
val[1]=cl;
val[0]=((vl)&((1<<8)-1));
val[2]=((vl>>8)&((1<<8)-1));
if (val[0]>0) {
MidiSend3((midi_device_t) attr_device, MIDI_NOTE_ON + (attr_midichannel-1),val[1],val[0]);
}
else {MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (attr_midichannel-1),val[1],0);}

}


}
}]]></code.krate>
      </object>
   </patchobj>
   <comment type="patch/comment" x="1176" y="2492" text="This decodes the incoming serial data and encodes it back into normal midi, ready to be send to internal synths"/>
   <comment type="patch/comment" x="1162" y="2632" text="Whatever.. needed something to test the polyphony with"/>
   <patcher type="patch/patcher" uuid="279a70a6-c0e4-4b1b-8ddc-cad3bca54b64" name="patcher_1" x="1442" y="2632">
      <params>
         <frac32.s.map name="adsr_1:a" value="-64.0"/>
         <frac32.s.map name="adsr_1:d" value="5.0"/>
         <frac32.u.map name="adsr_1:s" value="30.0"/>
         <frac32.s.map name="adsr_1:r" value="41.0"/>
         <frac32.s.map name="saw_1" value="-24.0"/>
      </params>
      <attribs>
         <combo attributeName="poly" selection="6"/>
         <combo attributeName="midichannel" selection="1"/>
         <combo attributeName="mididevice" selection="internal"/>
         <combo attributeName="midiport" selection="omni"/>
      </attribs>
      <subpatch appVersion="1.0.12">
         <obj type="midi/in/keyb" uuid="53b04874696932f38aceaa168bd5d9efb743716d" name="keyb_1" x="462" y="308">
            <params/>
            <attribs/>
         </obj>
         <obj type="env/adsr m" uuid="98bd39fb828c392b28126d259cb5175e6f6ea34b" name="adsr_1" x="644" y="322">
            <params>
               <frac32.s.map name="a" onParent="true" value="0.0"/>
               <frac32.s.map name="d" onParent="true" value="0.0"/>
               <frac32.u.map name="s" onParent="true" value="0.0"/>
               <frac32.s.map name="r" onParent="true" value="0.0"/>
            </params>
            <attribs/>
         </obj>
         <obj type="math/*" uuid="922423f2db9f222aa3e5ba095778288c446da47a" name="*_1" x="714" y="322">
            <params/>
            <attribs/>
         </obj>
         <obj type="osc/saw medium" uuid="388a55fef8413cfaf26a2a76ed21a7c28bef4e9d" name="saw_1" x="812" y="448">
            <params>
               <frac32.s.map name="pitch" onParent="true" value="0.0"/>
            </params>
            <attribs/>
         </obj>
         <obj type="gain/vca" uuid="a9f2dcd18043e2f47364e45cb8814f63c2a37c0d" name="vca_1" x="924" y="448">
            <params/>
            <attribs/>
         </obj>
         <obj type="patch/outlet a" uuid="abd8c5fd3b0524a6630f65cad6dc27f6c58e2a3e" name="outlet_1" x="980" y="448">
            <params/>
            <attribs/>
         </obj>
         <nets>
            <net>
               <source obj="adsr_1" outlet="env"/>
               <dest obj="*_1" inlet="a"/>
            </net>
            <net>
               <source obj="keyb_1" outlet="gate"/>
               <dest obj="adsr_1" inlet="gate"/>
            </net>
            <net>
               <source obj="saw_1" outlet="wave"/>
               <dest obj="vca_1" inlet="a"/>
            </net>
            <net>
               <source obj="keyb_1" outlet="note"/>
               <dest obj="saw_1" inlet="pitch"/>
            </net>
            <net>
               <source obj="keyb_1" outlet="velocity"/>
               <dest obj="*_1" inlet="b"/>
            </net>
            <net>
               <source obj="*_1" outlet="result"/>
               <dest obj="vca_1" inlet="v"/>
            </net>
            <net>
               <source obj="vca_1" outlet="o"/>
               <dest obj="outlet_1" inlet="outlet"/>
            </net>
         </nets>
         <settings>
            <subpatchmode>polyphonic</subpatchmode>
            <MidiChannel>1</MidiChannel>
            <HasMidiChannelSelector>true</HasMidiChannelSelector>
            <NPresets>0</NPresets>
            <NPresetEntries>0</NPresetEntries>
            <NModulationSources>0</NModulationSources>
            <NModulationTargetsPerSource>0</NModulationTargetsPerSource>
            <Author></Author>
         </settings>
         <notes><![CDATA[]]></notes>
         <windowPos>
            <x>-8</x>
            <y>-8</y>
            <width>1874</width>
            <height>1096</height>
         </windowPos>
      </subpatch>
   </patcher>
   <obj type="sss/audio/StOutVol" uuid="0ca9cf1e-1ce3-469c-80da-a4a885c21246" name="StOutVol_1" x="1554" y="2632">
      <params>
         <frac32.u.map name="volume" value="17.5"/>
      </params>
      <attribs/>
   </obj>
   <nets>
      <net>
         <source obj="dial_1" outlet="out"/>
         <dest obj="1x16Bctrl" inlet="i1"/>
      </net>
      <net>
         <source obj="dial_3" outlet="out"/>
         <dest obj="1x16Bctrl" inlet="i2"/>
      </net>
      <net>
         <source obj="dial_4" outlet="out"/>
         <dest obj="1x16Bctrl" inlet="i3"/>
      </net>
      <net>
         <source obj="dial_5" outlet="out"/>
         <dest obj="1x16Bctrl" inlet="i4"/>
      </net>
      <net>
         <source obj="dial_6" outlet="out"/>
         <dest obj="1x16Bctrl" inlet="i5"/>
      </net>
      <net>
         <source obj="dial_7" outlet="out"/>
         <dest obj="1x16Bctrl" inlet="i6"/>
      </net>
      <net>
         <source obj="dial_8" outlet="out"/>
         <dest obj="1x16Bctrl" inlet="i7"/>
      </net>
      <net>
         <source obj="dial_9" outlet="out"/>
         <dest obj="1x16Bctrl" inlet="i8"/>
      </net>
      <net>
         <source obj="16bit_1" outlet="o1"/>
         <dest obj="dial_2" inlet="in"/>
      </net>
      <net>
         <source obj="16bit_1" outlet="o2"/>
         <dest obj="dial_10" inlet="in"/>
      </net>
      <net>
         <source obj="16bit_1" outlet="o3"/>
         <dest obj="dial_11" inlet="in"/>
      </net>
      <net>
         <source obj="16bit_1" outlet="o4"/>
         <dest obj="dial_12" inlet="in"/>
      </net>
      <net>
         <source obj="16bit_1" outlet="o5"/>
         <dest obj="dial_13" inlet="in"/>
      </net>
      <net>
         <source obj="16bit_1" outlet="o6"/>
         <dest obj="dial_14" inlet="in"/>
      </net>
      <net>
         <source obj="16bit_1" outlet="o7"/>
         <dest obj="dial_15" inlet="in"/>
      </net>
      <net>
         <source obj="16bit_1" outlet="o8"/>
         <dest obj="dial_16" inlet="in"/>
      </net>
      <net>
         <source obj="data combiner_2" outlet="out"/>
         <dest obj="all/note" inlet="i1"/>
         <dest obj="all/control" inlet="i1"/>
      </net>
      <net>
         <source obj="1x16Bctrl" outlet="out"/>
         <dest obj="data combiner_2" inlet="i1"/>
         <dest obj="data combiner_3" inlet="i1"/>
      </net>
      <net>
         <source obj="dial_17" outlet="out"/>
         <dest obj="2x8Bctrl" inlet="i1x"/>
      </net>
      <net>
         <source obj="dial_18" outlet="out"/>
         <dest obj="2x8Bctrl" inlet="i1y"/>
      </net>
      <net>
         <source obj="dial_19" outlet="out"/>
         <dest obj="2x8Bctrl" inlet="i2x"/>
      </net>
      <net>
         <source obj="dial_20" outlet="out"/>
         <dest obj="2x8Bctrl" inlet="i2y"/>
      </net>
      <net>
         <source obj="dial_21" outlet="out"/>
         <dest obj="2x8Bctrl" inlet="i3x"/>
      </net>
      <net>
         <source obj="dial_22" outlet="out"/>
         <dest obj="2x8Bctrl" inlet="i3y"/>
      </net>
      <net>
         <source obj="dial_23" outlet="out"/>
         <dest obj="2x8Bctrl" inlet="i4x"/>
      </net>
      <net>
         <source obj="dial_24" outlet="out"/>
         <dest obj="2x8Bctrl" inlet="i4y"/>
      </net>
      <net>
         <source obj="dial_25" outlet="out"/>
         <dest obj="1x16Bctrl_" inlet="i1"/>
      </net>
      <net>
         <source obj="dial_34" outlet="out"/>
         <dest obj="1x16Bctrl_" inlet="i2"/>
      </net>
      <net>
         <source obj="dial_35" outlet="out"/>
         <dest obj="1x16Bctrl_" inlet="i3"/>
      </net>
      <net>
         <source obj="dial_36" outlet="out"/>
         <dest obj="1x16Bctrl_" inlet="i4"/>
      </net>
      <net>
         <source obj="dial_37" outlet="out"/>
         <dest obj="1x16Bctrl_" inlet="i5"/>
      </net>
      <net>
         <source obj="dial_38" outlet="out"/>
         <dest obj="1x16Bctrl_" inlet="i6"/>
      </net>
      <net>
         <source obj="dial_39" outlet="out"/>
         <dest obj="1x16Bctrl_" inlet="i7"/>
      </net>
      <net>
         <source obj="dial_40" outlet="out"/>
         <dest obj="1x16Bctrl_" inlet="i8"/>
      </net>
      <net>
         <source obj="1x16Bctrl_" outlet="out"/>
         <dest obj="data combiner_2" inlet="i2"/>
         <dest obj="data combiner_3" inlet="i2"/>
      </net>
      <net>
         <source obj="2x8Bctrl" outlet="out"/>
         <dest obj="data combiner_2" inlet="i3"/>
         <dest obj="data combiner_3" inlet="i3"/>
      </net>
      <net>
         <source obj="16bit_2" outlet="o1"/>
         <dest obj="dial_26" inlet="in"/>
      </net>
      <net>
         <source obj="16bit_2" outlet="o2"/>
         <dest obj="dial_27" inlet="in"/>
      </net>
      <net>
         <source obj="16bit_2" outlet="o3"/>
         <dest obj="dial_28" inlet="in"/>
      </net>
      <net>
         <source obj="16bit_2" outlet="o4"/>
         <dest obj="dial_29" inlet="in"/>
      </net>
      <net>
         <source obj="16bit_2" outlet="o5"/>
         <dest obj="dial_30" inlet="in"/>
      </net>
      <net>
         <source obj="16bit_2" outlet="o6"/>
         <dest obj="dial_31" inlet="in"/>
      </net>
      <net>
         <source obj="16bit_2" outlet="o7"/>
         <dest obj="dial_32" inlet="in"/>
      </net>
      <net>
         <source obj="16bit_2" outlet="o8"/>
         <dest obj="dial_33" inlet="in"/>
      </net>
      <net>
         <source obj="2x8bit_1" outlet="o1"/>
         <dest obj="dial_41" inlet="in"/>
      </net>
      <net>
         <source obj="2x8bit_1" outlet="o2"/>
         <dest obj="dial_42" inlet="in"/>
      </net>
      <net>
         <source obj="2x8bit_1" outlet="o3"/>
         <dest obj="dial_43" inlet="in"/>
      </net>
      <net>
         <source obj="2x8bit_1" outlet="o4"/>
         <dest obj="dial_44" inlet="in"/>
      </net>
      <net>
         <source obj="2x8bit_1" outlet="o5"/>
         <dest obj="dial_45" inlet="in"/>
      </net>
      <net>
         <source obj="2x8bit_1" outlet="o6"/>
         <dest obj="dial_46" inlet="in"/>
      </net>
      <net>
         <source obj="2x8bit_1" outlet="o7"/>
         <dest obj="dial_47" inlet="in"/>
      </net>
      <net>
         <source obj="2x8bit_1" outlet="o8"/>
         <dest obj="dial_48" inlet="in"/>
      </net>
      <net>
         <source obj="1x note send_1" outlet="out"/>
         <dest obj="data combiner_2" inlet="i4"/>
         <dest obj="data combiner_1" inlet="i1"/>
      </net>
      <net>
         <source obj="velocity_1" outlet="out"/>
         <dest obj="*_1" inlet="b"/>
      </net>
      <net>
         <source obj="*_1" outlet="result"/>
         <dest obj="1x note send_1" inlet="gate"/>
      </net>
      <net>
         <source obj="cv_1" outlet="out"/>
         <dest obj="1x note send_1" inlet="cv"/>
      </net>
      <net>
         <source obj="1x note out (mono)" outlet="gate"/>
         <dest obj="dial_52" inlet="in"/>
      </net>
      <net>
         <source obj="1x note out (mono)" outlet="note"/>
         <dest obj="dial_53" inlet="in"/>
      </net>
      <net>
         <source obj="1x note out (mono)" outlet="cv"/>
         <dest obj="dial_54" inlet="in"/>
      </net>
      <net>
         <source obj="square_1" outlet="wave"/>
         <dest obj="counter_29" inlet="trig"/>
         <dest obj="counter_30" inlet="trig"/>
         <dest obj="counter_31" inlet="trig"/>
         <dest obj="counter_28" inlet="trig"/>
      </net>
      <net>
         <source obj="4x note out (poly)" outlet="note1"/>
         <dest obj="dial_65" inlet="in"/>
      </net>
      <net>
         <source obj="4x note out (poly)" outlet="cv1"/>
         <dest obj="dial_66" inlet="in"/>
      </net>
      <net>
         <source obj="velocity_2" outlet="out"/>
         <dest obj="*_2" inlet="b"/>
      </net>
      <net>
         <source obj="*_2" outlet="result"/>
         <dest obj="1x note send_2" inlet="gate"/>
      </net>
      <net>
         <source obj="cv_2" outlet="out"/>
         <dest obj="1x note send_2" inlet="cv"/>
      </net>
      <net>
         <source obj="velocity_3" outlet="out"/>
         <dest obj="*_3" inlet="b"/>
      </net>
      <net>
         <source obj="*_3" outlet="result"/>
         <dest obj="1x note send_3" inlet="gate"/>
      </net>
      <net>
         <source obj="cv_3" outlet="out"/>
         <dest obj="1x note send_3" inlet="cv"/>
      </net>
      <net>
         <source obj="velocity_4" outlet="out"/>
         <dest obj="*_4" inlet="b"/>
      </net>
      <net>
         <source obj="*_4" outlet="result"/>
         <dest obj="1x note send_4" inlet="gate"/>
      </net>
      <net>
         <source obj="cv_4" outlet="out"/>
         <dest obj="1x note send_4" inlet="cv"/>
      </net>
      <net>
         <source obj="1x note send_2" outlet="out"/>
         <dest obj="data combiner_2" inlet="i5"/>
         <dest obj="data combiner_1" inlet="i2"/>
      </net>
      <net>
         <source obj="1x note send_3" outlet="out"/>
         <dest obj="data combiner_2" inlet="i6"/>
         <dest obj="data combiner_1" inlet="i3"/>
      </net>
      <net>
         <source obj="1x note send_4" outlet="out"/>
         <dest obj="data combiner_2" inlet="i7"/>
         <dest obj="data combiner_1" inlet="i4"/>
      </net>
      <net>
         <source obj="4x note out (poly)" outlet="gate1"/>
         <dest obj="dial_64" inlet="in"/>
      </net>
      <net>
         <source obj="4x note out (poly)" outlet="gate2"/>
         <dest obj="dial_67" inlet="in"/>
      </net>
      <net>
         <source obj="4x note out (poly)" outlet="note2"/>
         <dest obj="dial_68" inlet="in"/>
      </net>
      <net>
         <source obj="4x note out (poly)" outlet="cv2"/>
         <dest obj="dial_69" inlet="in"/>
      </net>
      <net>
         <source obj="4x note out (poly)" outlet="gate3"/>
         <dest obj="dial_70" inlet="in"/>
      </net>
      <net>
         <source obj="4x note out (poly)" outlet="note3"/>
         <dest obj="dial_71" inlet="in"/>
      </net>
      <net>
         <source obj="4x note out (poly)" outlet="cv3"/>
         <dest obj="dial_72" inlet="in"/>
      </net>
      <net>
         <source obj="4x note out (poly)" outlet="gate4"/>
         <dest obj="dial_73" inlet="in"/>
      </net>
      <net>
         <source obj="4x note out (poly)" outlet="note4"/>
         <dest obj="dial_74" inlet="in"/>
      </net>
      <net>
         <source obj="4x note out (poly)" outlet="cv4"/>
         <dest obj="dial_75" inlet="in"/>
      </net>
      <net>
         <source obj="patcher_1" outlet="outlet_1"/>
         <dest obj="StOutVol_1" inlet="left"/>
         <dest obj="StOutVol_1" inlet="right"/>
      </net>
      <net>
         <source obj="counter_28" outlet="semi"/>
         <dest obj="counter_29" inlet="semi"/>
      </net>
      <net>
         <source obj="counter_28" outlet="oct"/>
         <dest obj="counter_29" inlet="oct"/>
      </net>
      <net>
         <source obj="counter_28" outlet="restartbar"/>
         <dest obj="counter_29" inlet="rnd"/>
      </net>
      <net>
         <source obj="counter_28" outlet="restartbars"/>
         <dest obj="counter_28" inlet="rnd"/>
      </net>
      <net>
         <source obj="counter_30" outlet="semi"/>
         <dest obj="counter_31" inlet="semi"/>
      </net>
      <net>
         <source obj="counter_30" outlet="oct"/>
         <dest obj="counter_31" inlet="oct"/>
      </net>
      <net>
         <source obj="counter_30" outlet="restartbar"/>
         <dest obj="counter_31" inlet="rnd"/>
      </net>
      <net>
         <source obj="counter_30" outlet="restartbars"/>
         <dest obj="counter_30" inlet="rnd"/>
      </net>
      <net>
         <source obj="counter_28" outlet="sum"/>
         <dest obj="1x note send_1" inlet="note"/>
      </net>
      <net>
         <source obj="counter_29" outlet="sum"/>
         <dest obj="1x note send_2" inlet="note"/>
      </net>
      <net>
         <source obj="counter_30" outlet="sum"/>
         <dest obj="1x note send_3" inlet="note"/>
      </net>
      <net>
         <source obj="counter_31" outlet="sum"/>
         <dest obj="1x note send_4" inlet="note"/>
      </net>
      <net>
         <source obj="counter_29" outlet="semi"/>
         <dest obj="counter_30" inlet="semi"/>
      </net>
      <net>
         <source obj="counter_29" outlet="oct"/>
         <dest obj="counter_30" inlet="oct"/>
      </net>
      <net>
         <source obj="data combiner_1" outlet="out"/>
         <dest obj="all/note" inlet="i2"/>
      </net>
      <net>
         <source obj="all/note" outlet="o"/>
         <dest obj="1x note out (mono)" inlet="in"/>
         <dest obj="4x note out (poly)" inlet="in"/>
         <dest obj="note2midi" inlet="in"/>
      </net>
      <net>
         <source obj="switch to independent notes and controls" outlet="o"/>
         <dest obj="all/note" inlet="s"/>
         <dest obj="all/control" inlet="s"/>
      </net>
      <net>
         <source obj="data combiner_3" outlet="out"/>
         <dest obj="all/control" inlet="i2"/>
      </net>
      <net>
         <source obj="all/control" outlet="o"/>
         <dest obj="16bit_1" inlet="in"/>
         <dest obj="2x8bit_1" inlet="in"/>
         <dest obj="16bit_2" inlet="in"/>
      </net>
      <net>
         <source obj="counter_28" outlet="gate"/>
         <dest obj="*_1" inlet="a"/>
      </net>
      <net>
         <source obj="counter_29" outlet="gate"/>
         <dest obj="*_2" inlet="a"/>
      </net>
      <net>
         <source obj="counter_30" outlet="gate"/>
         <dest obj="*_3" inlet="a"/>
      </net>
      <net>
         <source obj="counter_31" outlet="gate"/>
         <dest obj="*_4" inlet="a"/>
      </net>
   </nets>
   <settings>
      <subpatchmode>no</subpatchmode>
   </settings>
   <notes><![CDATA[]]></notes>
   <windowPos>
      <x>-8</x>
      <y>-8</y>
      <width>1874</width>
      <height>1096</height>
   </windowPos>
</patch-1.0>