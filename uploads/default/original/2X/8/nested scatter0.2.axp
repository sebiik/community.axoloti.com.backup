<patch-1.0 appVersion="1.0.12">
   <obj type="lfo/square" uuid="de6909eb64db13af5b43f979a4c130024b3a4793" name="square_1" x="0" y="0">
      <params>
         <frac32.s.map name="pitch" value="0.0"/>
      </params>
      <attribs/>
   </obj>
   <obj type="lfo/square" uuid="de6909eb64db13af5b43f979a4c130024b3a4793" name="square_2" x="84" y="0">
      <params>
         <frac32.s.map name="pitch" value="12.0"/>
      </params>
      <attribs/>
   </obj>
   <patchobj type="patch/object" uuid="faea3b49-257f-4d72-8148-72d0e8130b24" name="counter_9" x="182" y="0">
      <params>
         <int32 name="maximum" value="1"/>
      </params>
      <attribs/>
      <object id="patch/object" uuid="faea3b49-257f-4d72-8148-72d0e8130b24">
         <sDescription>cyclic up counter</sDescription>
         <author>Johannes Taelman</author>
         <license>BSD</license>
         <helpPatch>counter.axh</helpPatch>
         <inlets>
            <bool32.rising name="trig" description="trigger"/>
            <bool32.rising name="r" description="reset"/>
         </inlets>
         <outlets>
            <int32 name="o" description="output"/>
            <bool32.pulse name="c" description="carry pulse"/>
         </outlets>
         <displays/>
         <params>
            <int32 name="maximum" noLabel="true">
               <MinValue i="0"/>
               <MaxValue i="65536"/>
            </int32>
         </params>
         <attribs/>
         <includes/>
         <code.declaration><![CDATA[   int ntrig;
   int rtrig;
   int count;
]]></code.declaration>
         <code.init><![CDATA[count=-1;
   ntrig = 0;
   rtrig = 0;]]></code.init>
         <code.krate><![CDATA[outlet_c=0;
if ((inlet_trig>0) && !ntrig) {
   count += 1; if (count>=param_maximum) {count = 0; outlet_c = 1;}
   ntrig=1;
}
else if (!(inlet_trig>0)) ntrig=0;
if ((inlet_r>0) && !rtrig) {count=0; rtrig = 1;}
else if (!(inlet_r>0)) rtrig=0;
outlet_o= count;
]]></code.krate>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="faea3b49-257f-4d72-8148-72d0e8130b24" name="counter_7" x="266" y="0">
      <params>
         <int32 name="maximum" value="4"/>
      </params>
      <attribs/>
      <object id="patch/object" uuid="faea3b49-257f-4d72-8148-72d0e8130b24">
         <sDescription>cyclic up counter</sDescription>
         <author>Johannes Taelman</author>
         <license>BSD</license>
         <helpPatch>counter.axh</helpPatch>
         <inlets>
            <bool32.rising name="trig" description="trigger"/>
            <bool32.rising name="r" description="reset"/>
         </inlets>
         <outlets>
            <int32 name="o" description="output"/>
            <bool32.pulse name="c" description="carry pulse"/>
         </outlets>
         <displays/>
         <params>
            <int32 name="maximum" noLabel="true">
               <MinValue i="0"/>
               <MaxValue i="65536"/>
            </int32>
         </params>
         <attribs/>
         <includes/>
         <code.declaration><![CDATA[   int ntrig;
   int rtrig;
   int count;
]]></code.declaration>
         <code.init><![CDATA[count=-1;
   ntrig = 0;
   rtrig = 0;]]></code.init>
         <code.krate><![CDATA[outlet_c=0;
if ((inlet_trig>0) && !ntrig) {
   count += 1; if (count>=param_maximum) {count = 0; outlet_c = 1;}
   ntrig=1;
}
else if (!(inlet_trig>0)) ntrig=0;
if ((inlet_r>0) && !rtrig) {count=0; rtrig = 1;}
else if (!(inlet_r>0)) rtrig=0;
outlet_o= count;
]]></code.krate>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="faea3b49-257f-4d72-8148-72d0e8130b24" name="counter_11" x="350" y="0">
      <params>
         <int32 name="maximum" value="8"/>
      </params>
      <attribs/>
      <object id="patch/object" uuid="faea3b49-257f-4d72-8148-72d0e8130b24">
         <sDescription>cyclic up counter</sDescription>
         <author>Johannes Taelman</author>
         <license>BSD</license>
         <helpPatch>counter.axh</helpPatch>
         <inlets>
            <bool32.rising name="trig" description="trigger"/>
            <bool32.rising name="r" description="reset"/>
         </inlets>
         <outlets>
            <int32 name="o" description="output"/>
            <bool32.pulse name="c" description="carry pulse"/>
         </outlets>
         <displays/>
         <params>
            <int32 name="maximum" noLabel="true">
               <MinValue i="0"/>
               <MaxValue i="65536"/>
            </int32>
         </params>
         <attribs/>
         <includes/>
         <code.declaration><![CDATA[   int ntrig;
   int rtrig;
   int count;
]]></code.declaration>
         <code.init><![CDATA[count=-1;
   ntrig = 0;
   rtrig = 0;]]></code.init>
         <code.krate><![CDATA[outlet_c=0;
if ((inlet_trig>0) && !ntrig) {
   count += 1; if (count>=param_maximum) {count = 0; outlet_c = 1;}
   ntrig=1;
}
else if (!(inlet_trig>0)) ntrig=0;
if ((inlet_r>0) && !rtrig) {count=0; rtrig = 1;}
else if (!(inlet_r>0)) rtrig=0;
outlet_o= count;
]]></code.krate>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="faea3b49-257f-4d72-8148-72d0e8130b24" name="counter_1" x="434" y="0">
      <params>
         <int32 name="maximum" value="16"/>
      </params>
      <attribs/>
      <object id="patch/object" uuid="faea3b49-257f-4d72-8148-72d0e8130b24">
         <sDescription>cyclic up counter</sDescription>
         <author>Johannes Taelman</author>
         <license>BSD</license>
         <helpPatch>counter.axh</helpPatch>
         <inlets>
            <bool32.rising name="trig" description="trigger"/>
            <bool32.rising name="r" description="reset"/>
         </inlets>
         <outlets>
            <int32 name="o" description="output"/>
            <bool32.pulse name="c" description="carry pulse"/>
         </outlets>
         <displays/>
         <params>
            <int32 name="maximum" noLabel="true">
               <MinValue i="0"/>
               <MaxValue i="65536"/>
            </int32>
         </params>
         <attribs/>
         <includes/>
         <code.declaration><![CDATA[   int ntrig;
   int rtrig;
   int count;
]]></code.declaration>
         <code.init><![CDATA[count=-1;
   ntrig = 0;
   rtrig = 0;]]></code.init>
         <code.krate><![CDATA[outlet_c=0;
if ((inlet_trig>0) && !ntrig) {
   count += 1; if (count>=param_maximum) {count = 0; outlet_c = 1;}
   ntrig=1;
}
else if (!(inlet_trig>0)) ntrig=0;
if ((inlet_r>0) && !rtrig) {count=0; rtrig = 1;}
else if (!(inlet_r>0)) rtrig=0;
outlet_o= count;
]]></code.krate>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="57c0b500-d00d-4ddd-a195-538a03ae1704" name="burst generator" x="518" y="0">
      <params>
         <int32 name="length" value="32"/>
         <frac32.u.map name="chance" value="64.0"/>
         <int32 name="max" value="4"/>
         <int32 name="min" value="2"/>
      </params>
      <attribs/>
      <object id="patch/object" uuid="57c0b500-d00d-4ddd-a195-538a03ae1704">
         <sDescription>Gate burst generator
min/max controls set the minimum and maximum trigger length (after how many input-triggers it retriggers).
Minimum is 2 (up and down cost 2 triggers).
So connect this to a clock that&apos;s running twice, tripple or four times the base tempo.</sDescription>
         <author>Remco van der Most</author>
         <license>BSD</license>
         <helpPatch>counter.axh</helpPatch>
         <inlets>
            <bool32.rising name="trig" description="trigger"/>
            <bool32 name="rnd"/>
            <bool32.rising name="r" description="reset"/>
         </inlets>
         <outlets>
            <bool32 name="gate"/>
         </outlets>
         <displays/>
         <params>
            <int32 name="length" noLabel="true">
               <MinValue i="0"/>
               <MaxValue i="65536"/>
            </int32>
            <frac32.u.map name="chance"/>
            <int32 name="max">
               <MinValue i="2"/>
               <MaxValue i="16"/>
            </int32>
            <int32 name="min">
               <MinValue i="2"/>
               <MaxValue i="16"/>
            </int32>
         </params>
         <attribs/>
         <includes/>
         <code.declaration><![CDATA[int ntrig;
   int rtrig,DO=1;
   int count;
int cnt[64],CNT;
int step,rnd;]]></code.declaration>
         <code.init><![CDATA[count=0;
   ntrig = 0;
   rtrig = 0;
   step=1;]]></code.init>
         <code.krate><![CDATA[int RND=inlet_rnd||DO;
if(RND&&!rnd){
	DO=0;
	rnd=1;
	for(int i=0;i<8;i++){
		cnt[i]=(int32_t)(GenerateRandomNumber()>>1);
	}
}
else if(rnd&&!RND){rnd=0;}

if ((inlet_trig>0) && !ntrig) {
if((count%step)<1)
{
	if((GenerateRandomNumber()>>5)<param_chance)
	{	int dif=param_max-param_min;
		int dir=dif>=0?1:-1;
		dif=(dif>0?dif:-dif)+1;
		step=(cnt[CNT]%(dif))*dir+param_min;
		CNT=(CNT+1)&63;
	}
}
count+=1;
count=count>=param_length?0:count;
   ntrig=1;
}
else if (!(inlet_trig>0)) {ntrig=0;}


if ((inlet_r>0) && !rtrig) {
	count=0;
	CNT=0;
	rtrig = 1;}
else if (!(inlet_r>0)) rtrig=0;

if(step&1){
	if(step<5)
	{
		//outlet_gate=(count%step)>(step>>1);
		outlet_gate=((count%step)<(step-1+(1>>1)));
	}
	else
	{
		outlet_gate=!((count%step)>(step>>1));
	}
}
else{
	if(step<5)
	{
	outlet_gate=((count%step)<(step-1+(1>>1)));
	}
	else
	{
		outlet_gate=((count%step)>=(step>>1));
	}
}]]></code.krate>
      </object>
   </patchobj>
   <comment type="patch/comment" x="602" y="0" text="gate-burst generator for creating rhythmic, arpeggio-style/gated variations easily"/>
   <comment type="patch/comment" x="1218" y="70" text="audio-rate modulations to prevent alliasing"/>
   <patchobj type="patch/object" uuid="dec13069-087a-465c-836b-c1577851ac25" name="sine_1" x="910" y="84">
      <params>
         <frac32.s.map name="pitch" value="-64.0"/>
      </params>
      <attribs/>
      <object id="patch/object" uuid="dec13069-087a-465c-836b-c1577851ac25">
         <sDescription>sine wave oscillator</sDescription>
         <author>Johannes Taelman</author>
         <license>BSD</license>
         <helpPatch>osc.axh</helpPatch>
         <inlets>
            <frac32.bipolar name="pitch" description="pitch"/>
            <frac32buffer name="freq" description="frequency"/>
            <frac32buffer name="phase" description="phase"/>
         </inlets>
         <outlets>
            <frac32buffer.bipolar name="wave" description="sine wave"/>
         </outlets>
         <displays/>
         <params>
            <frac32.s.map.pitch name="pitch" noLabel="true"/>
         </params>
         <attribs/>
         <includes/>
         <code.declaration><![CDATA[uint32_t Phase;]]></code.declaration>
         <code.init><![CDATA[Phase = 0;]]></code.init>
         <code.krate><![CDATA[int32_t freq;
   MTOFEXTENDED(param_pitch + inlet_pitch,freq);
freq=freq>>13;]]></code.krate>
         <code.srate><![CDATA[Phase += freq + inlet_freq;
int32_t r;
int32_t p2 = Phase + (inlet_phase<<4);
SINE2TINTERP(p2,r)
outlet_wave= (r>>4);
]]></code.srate>
      </object>
   </patchobj>
   <obj type="math/*c" uuid="7a66f52a9594e7e9eb31328ea725cb3641a80b55" name="*c_2" x="1008" y="84">
      <params>
         <frac32.u.map name="amp" value="0.5849995613098145"/>
      </params>
      <attribs/>
   </obj>
   <obj type="math/inv" uuid="7f4c6cf4dcf79f9b0aa81c2eaf540405875714a3" name="inv_1" x="1106" y="84">
      <params/>
      <attribs/>
   </obj>
   <patchobj type="patch/object" uuid="dec13069-087a-465c-836b-c1577851ac25" name="sine_3" x="1162" y="84">
      <params>
         <frac32.s.map name="pitch" value="-64.0"/>
      </params>
      <attribs/>
      <object id="patch/object" uuid="dec13069-087a-465c-836b-c1577851ac25">
         <sDescription>sine wave oscillator</sDescription>
         <author>Johannes Taelman</author>
         <license>BSD</license>
         <helpPatch>osc.axh</helpPatch>
         <inlets>
            <frac32.bipolar name="pitch" description="pitch"/>
            <frac32buffer name="freq" description="frequency"/>
            <frac32buffer name="phase" description="phase"/>
         </inlets>
         <outlets>
            <frac32buffer.bipolar name="wave" description="sine wave"/>
         </outlets>
         <displays/>
         <params>
            <frac32.s.map.pitch name="pitch" noLabel="true"/>
         </params>
         <attribs/>
         <includes/>
         <code.declaration><![CDATA[uint32_t Phase;]]></code.declaration>
         <code.init><![CDATA[Phase = 0;]]></code.init>
         <code.krate><![CDATA[int32_t freq;
   MTOFEXTENDED(param_pitch + inlet_pitch,freq);
freq=freq>>8;]]></code.krate>
         <code.srate><![CDATA[Phase += freq + inlet_freq;
int32_t r;
int32_t p2 = Phase + (inlet_phase<<4);
SINE2TINTERP(p2,r)
outlet_wave= (r>>4);
]]></code.srate>
      </object>
   </patchobj>
   <obj type="math/*c" uuid="7a66f52a9594e7e9eb31328ea725cb3641a80b55" name="*c_4" x="1260" y="84">
      <params>
         <frac32.u.map name="amp" value="0.6399998664855957"/>
      </params>
      <attribs/>
   </obj>
   <obj type="math/inv" uuid="7f4c6cf4dcf79f9b0aa81c2eaf540405875714a3" name="inv_3" x="1358" y="84">
      <params/>
      <attribs/>
   </obj>
   <patchobj type="patch/object" uuid="dec13069-087a-465c-836b-c1577851ac25" name="sine_5" x="1414" y="84">
      <params>
         <frac32.s.map name="pitch" value="-58.0"/>
      </params>
      <attribs/>
      <object id="patch/object" uuid="dec13069-087a-465c-836b-c1577851ac25">
         <sDescription>sine wave oscillator</sDescription>
         <author>Johannes Taelman</author>
         <license>BSD</license>
         <helpPatch>osc.axh</helpPatch>
         <inlets>
            <frac32.bipolar name="pitch" description="pitch"/>
            <frac32buffer name="freq" description="frequency"/>
            <frac32buffer name="phase" description="phase"/>
         </inlets>
         <outlets>
            <frac32buffer.bipolar name="wave" description="sine wave"/>
         </outlets>
         <displays/>
         <params>
            <frac32.s.map.pitch name="pitch" noLabel="true"/>
         </params>
         <attribs/>
         <includes/>
         <code.declaration><![CDATA[uint32_t Phase;]]></code.declaration>
         <code.init><![CDATA[Phase = 0;]]></code.init>
         <code.krate><![CDATA[int32_t freq;
   MTOFEXTENDED(param_pitch + inlet_pitch,freq);
freq=freq>>8;]]></code.krate>
         <code.srate><![CDATA[Phase += freq + inlet_freq;
int32_t r;
int32_t p2 = Phase + (inlet_phase<<4);
SINE2TINTERP(p2,r)
outlet_wave= (r>>4);
]]></code.srate>
      </object>
   </patchobj>
   <obj type="math/&gt;&gt;" uuid="5d748ad90476b3ecc3970cde6622af97cf3cf4ac" name="&gt;&gt;_1" x="1512" y="84">
      <params/>
      <attribs>
         <spinner attributeName="shift" value="10"/>
      </attribs>
   </obj>
   <obj type="math/*c" uuid="7a66f52a9594e7e9eb31328ea725cb3641a80b55" name="*c_7" x="1596" y="84">
      <params>
         <frac32.u.map name="amp" value="19.5"/>
      </params>
      <attribs/>
   </obj>
   <obj type="math/inv" uuid="7f4c6cf4dcf79f9b0aa81c2eaf540405875714a3" name="inv_6" x="1694" y="84">
      <params/>
      <attribs/>
   </obj>
   <obj type="logic/counter" uuid="7a141ba82230e54e5f5cd12da5dbe5a74ba854a5" name="counter_10" x="182" y="98">
      <params>
         <int32 name="maximum" value="4"/>
      </params>
      <attribs/>
   </obj>
   <obj type="logic/counter" uuid="7a141ba82230e54e5f5cd12da5dbe5a74ba854a5" name="counter_8" x="266" y="98">
      <params>
         <int32 name="maximum" value="4"/>
      </params>
      <attribs/>
   </obj>
   <obj type="logic/counter" uuid="7a141ba82230e54e5f5cd12da5dbe5a74ba854a5" name="counter_12" x="350" y="98">
      <params>
         <int32 name="maximum" value="4"/>
      </params>
      <attribs/>
   </obj>
   <obj type="logic/counter" uuid="7a141ba82230e54e5f5cd12da5dbe5a74ba854a5" name="counter_6" x="434" y="98">
      <params>
         <int32 name="maximum" value="4"/>
      </params>
      <attribs/>
   </obj>
   <comment type="patch/comment" x="0" y="168" text="pattern generator that re-uses old values and value-differences to create new patterns"/>
   <patchobj type="patch/object" uuid="1871c4dc-c217-48a8-9946-feb70a269ef2" name="recycle" x="0" y="182">
      <params>
         <bool32.tgl name="evolve" value="1"/>
         <frac32.u.map name="randomstart" value="0.0"/>
         <frac32.u.map name="update" value="5.5"/>
         <frac32.u.map name="differents" value="64.0"/>
         <frac32.u.map name="movefollow" value="34.0"/>
         <frac32.u.map name="copyformer" value="8.5"/>
         <frac32.u.map name="turn" value="3.5"/>
         <frac32.u.map name="asOffset" value="8.5"/>
         <frac32.u.map name="invert" value="3.5"/>
         <bool32.tgl name="pendulum" value="1"/>
         <frac32.u.map name="maxchange" value="64.0"/>
         <frac32.u.map name="glide" value="10.0"/>
         <frac32.s.map name="rate" value="-8.0"/>
         <int2x16 name="gliderange" value="391867350"/>
         <int2x16 name="countselect" value="-1094895999"/>
         <bool32.mom name="rndg" value="0"/>
         <bool32.mom name="rndc" value="0"/>
      </params>
      <attribs>
         <combo attributeName="size" selection="8"/>
      </attribs>
      <object id="patch/object" uuid="1871c4dc-c217-48a8-9946-feb70a269ef2">
         <sDescription>allocate 16bit table in SDRAM memory, -128.00 .. 127.99</sDescription>
         <author>Johannes Taelman</author>
         <license>BSD</license>
         <helpPatch>table.axh</helpPatch>
         <inlets>
            <int32 name="maincount"/>
            <int32 name="count1"/>
            <int32 name="count2"/>
            <int32 name="count3"/>
            <int32 name="count4"/>
            <bool32 name="rnd"/>
            <bool32 name="shuffle"/>
         </inlets>
         <outlets>
            <frac32 name="o1"/>
            <frac32 name="o2"/>
            <frac32 name="o3"/>
            <frac32 name="o4"/>
            <frac32 name="o5"/>
            <frac32 name="o6"/>
            <frac32 name="o7"/>
            <frac32 name="o8"/>
            <frac32 name="o9"/>
            <frac32 name="o10"/>
            <frac32 name="o11"/>
            <frac32 name="o12"/>
            <frac32 name="o13"/>
            <frac32 name="o14"/>
            <frac32 name="o15"/>
            <frac32 name="o16"/>
         </outlets>
         <displays/>
         <params>
            <bool32.tgl name="evolve"/>
            <frac32.u.map name="randomstart" description="chance that the sequence offset doesn&apos;t start at zero but any other random value"/>
            <frac32.u.map name="update" description="chance that at the change of the counter, the current step is being randomised using the settings below"/>
            <frac32.u.map name="differents" description="amount of steps that may be used to hold different random values, after this the step-values are re-used."/>
            <frac32.u.map name="movefollow" description="chance that the difference between two former steps is re-used to generate the new value from the one before."/>
            <frac32.u.map name="copyformer" description="chance of re-using a formerly generated value"/>
            <frac32.u.map name="turn" description="chance that the move-follow value is inverted (repeating random)"/>
            <frac32.u.map name="asOffset" description="chance that the current step offsets the entire sequence (non-repeating random)"/>
            <frac32.u.map name="invert" description="chance that the sequence swaps low/high (non-repeating random)"/>
            <bool32.tgl name="pendulum" description="wraps the generated sequence as a pendulum instead of a hard high-&gt;low wrap"/>
            <frac32.u.map name="maxchange" description="attenuates the difference with the former step"/>
            <frac32.u.map name="glide" description="chance of gliding the output (dependent on whether mode of the channel is either 1 or 3)"/>
            <frac32.s.map name="rate" description="glide rate"/>
            <int2x16 name="gliderange" description="0=stepped count1, 1=glided count 1, 2=stepped count2, 3=glided count2"/>
            <int2x16 name="countselect"/>
            <bool32.mom name="rndg"/>
            <bool32.mom name="rndc"/>
         </params>
         <attribs>
            <combo name="size">
               <MenuEntries>
                  <string>2</string>
                  <string>4</string>
                  <string>8</string>
                  <string>16</string>
                  <string>32</string>
                  <string>64</string>
                  <string>128</string>
                  <string>256</string>
                  <string>512</string>
                  <string>1024</string>
                  <string>2048</string>
                  <string>4096</string>
                  <string>8192</string>
                  <string>16384</string>
                  <string>32768</string>
                  <string>65536</string>
                  <string>131072</string>
                  <string>262144</string>
                  <string>524288</string>
                  <string>1048576</string>
                  <string>2097152</string>
                  <string>4194304</string>
               </MenuEntries>
               <CEntries>
                  <string>1</string>
                  <string>2</string>
                  <string>3</string>
                  <string>4</string>
                  <string>5</string>
                  <string>6</string>
                  <string>7</string>
                  <string>8</string>
                  <string>9</string>
                  <string>10</string>
                  <string>11</string>
                  <string>12</string>
                  <string>13</string>
                  <string>14</string>
                  <string>15</string>
                  <string>16</string>
                  <string>17</string>
                  <string>18</string>
                  <string>19</string>
                  <string>20</string>
                  <string>21</string>
                  <string>22</string>
               </CEntries>
            </combo>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[static const uint32_t LENGTHPOW = (attr_size);
static const uint32_t LENGTH = (1<<attr_size);
static const uint32_t LENGTHMASK = ((1<<attr_size)-1);
static const uint32_t BITS = 16;
static const uint32_t GAIN = 12;
uint16_t *array,ofs[16];
int rnd,prv[16],INV[16],rg,rc,C[16];
int32_t O[16],P[16];//,goal,former;]]></code.declaration>
         <code.init><![CDATA[static uint16_t _array[attr_poly][LENGTH*16] __attribute__ ((section (".sdram")));
array = &_array[parent->polyIndex][0];
{ 
  int i;
  for(i=0;i<LENGTH*16;i++) array[i]=(uint16_t)(GenerateRandomNumber()>>16);
}]]></code.init>
         <code.krate><![CDATA[int rndc=param_rndc||inlet_shuffle;
int rndg=param_rndg||inlet_shuffle;
if(rndc&&!rc){
	rc=1;
	PExParameterChange(&parent->PExch[PARAM_INDEX_attr_legal_name_countselect],(uint32_t)(GenerateRandomNumber()),0xFFFD);
		
}
else if(!rndc){rc=0;}
if(rndg&&!rg){
	rg=1;
	PExParameterChange(&parent->PExch[PARAM_INDEX_attr_legal_name_gliderange],(uint32_t)(GenerateRandomNumber()),0xFFFD);
}
else if(!rndg){rg=0;}
int cnt=inlet_maincount&LENGTHMASK;
int c[4];
c[0]=inlet_count1&LENGTHMASK;
c[1]=inlet_count2&LENGTHMASK;
c[2]=inlet_count3&LENGTHMASK;
c[3]=inlet_count4&LENGTHMASK;

for(int i=0;i<16;i++){
	C[i]=c[((param_countselect>>(i*2))&3)];
}

int32_t rate;
MTOF(param_rate,rate)
rate=rate>>2;
int diff=___SMMUL(param_differents,LENGTH<<5)+1;
if(inlet_rnd&&!rnd){
	rnd=1;
	for(int j=0;j<16;j++)
	{
		int k=j<<LENGTHPOW;
		int CNT=0,stmp,ctmp;
		for(int i=0;i<LENGTH;i++)
		{
			if(i<diff)
			{
			if((((int32_t)(GenerateRandomNumber()>>5)<param_movefollow)&&(i>1))||(CNT>0))
			{
				if(CNT==0){
				stmp=GenerateRandomNumber()%i;
				ctmp=GenerateRandomNumber()%i;
				CNT=(int32_t)(GenerateRandomNumber());
				CNT=___SMMUL(CNT,CNT)>>27;
				}
				else{CNT-=1;}
				if((int32_t)(GenerateRandomNumber()>>5)<param_copyformer)
				{
					array[i+k]=array[i-1-ctmp+k]+(array[i-stmp+k]-array[i-stmp-1+k])*((int32_t)(GenerateRandomNumber()>>5)<param_turn?-1:1);	
				}
				else
				{
					
					array[i+k]=array[i-1+k]+(array[i-stmp+k]-array[i-stmp-1+k])*((int32_t)(GenerateRandomNumber()>>5)<param_turn?-1:1);
				}
			}
			else
			{
				if(((int32_t)(GenerateRandomNumber()>>5)<param_copyformer)&&(i>1))
				{
					int ctmp=GenerateRandomNumber()%i;
					array[i+k]=array[i-1-ctmp+k];
				}
				else{
				array[i+k]=(uint16_t)(GenerateRandomNumber()>>16);
				}
			}
			}
			else{
				array[i+k]=array[k+(GenerateRandomNumber()%diff)];
			}
		}
	}
}
else if(!inlet_rnd){rnd=0;}



		
for(int j=0;j<16;j++)
{
	if(!(C[j]==prv[j])){
	int i=C[j];
	int k=j<<LENGTHPOW;
	int CNT=0,stmp,ctmp;
	if((int32_t)(GenerateRandomNumber()>>5)<param_asOffset){
		ofs[j]=array[i]-array[(i-1)&LENGTHPOW];
		
	}
	if((int32_t)(GenerateRandomNumber()>>5)<param_invert){
		INV[j]=INV[j]>0?0:1;
		
	}
	if(cnt==0){
		ofs[j]=(int32_t)(GenerateRandomNumber()>>5)<param_randomstart?GenerateRandomNumber():(param_evolve>0?ofs[j]:0);
	}
		if((int32_t)(GenerateRandomNumber()>>5)<param_update){
		
		{
			if(i<diff)
			{
			if((((int32_t)(GenerateRandomNumber()>>5)<param_movefollow)&&(i>1))||(CNT>0))
			{
				if(CNT==0){
				stmp=GenerateRandomNumber()%i;
				ctmp=GenerateRandomNumber()%i;
				CNT=(int32_t)(GenerateRandomNumber());
				CNT=___SMMUL(CNT,CNT)>>27;
				//CNT=CNT>4?4:CNT;
				}
				else{CNT-=1;}
				if((int32_t)(GenerateRandomNumber()>>5)<param_copyformer)
				{
					array[i+k]=array[i-1-ctmp+k]+(array[i-stmp+k]-array[i-stmp-1+k])*((int32_t)(GenerateRandomNumber()>>5)<param_turn?-1:1);	
				}
				else
				{
					
					array[i+k]=array[i-1+k]+(array[i-stmp+k]-array[i-stmp-1+k])*((int32_t)(GenerateRandomNumber()>>5)<param_turn?-1:1);
				}
			}
			else
			{
				if(((int32_t)(GenerateRandomNumber()>>5)<param_copyformer)&&(i>1))
				{
					int ctmp=GenerateRandomNumber()%i;
					array[i+k]=array[i-1-ctmp+k];
				}
				else{
				array[i+k]=(uint16_t)(GenerateRandomNumber()>>16);
				}
			}
			}
			else{
				array[i+k]=array[k+(GenerateRandomNumber()%diff)];
			}
		}
	}
	}
}


for(int i=0;i<16;i++){
if(!(C[i]==prv[i])){
int pos=C[i];
int32_t former=O[i];
int32_t goal=((array[pos+(i<<LENGTHPOW)]+ofs[i])&((1<<16)-1))<<11+param_pendulum;

if(param_pendulum){
goal=(__USAT(goal,27)<<1)-goal;
}
if(INV[i]){
goal=(1<<27)-goal;
}
if(cnt>0){
int32_t df=goal-former;
df=___SMMUL(df<<2,param_maxchange<<3);
goal=former+df;
}
O[i]=goal;

	if(!(((int32_t)(GenerateRandomNumber()>>5)<param_glide)&&((param_gliderange>>(i*2))&3))){
		P[i]=O[i];
	}
	
	}
}
for(int i=0;i<16;i++){
P[i]+=___SMMUL(O[i]-P[i],rate)>>((param_gliderange>>(i*2))&3);
prv[i]=C[i];
}
outlet_o1=P[0];
outlet_o2=P[1];
outlet_o3=P[2];
outlet_o4=P[3];
outlet_o5=P[4];
outlet_o6=P[5];
outlet_o7=P[6];
outlet_o8=P[7];
outlet_o9=P[8];
outlet_o10=P[9];
outlet_o11=P[10];
outlet_o12=P[11];
outlet_o13=P[12];
outlet_o14=P[13];
outlet_o15=P[14];
outlet_o16=P[15];]]></code.krate>
      </object>
   </patchobj>
   <obj type="mix/mix 2 g" uuid="a68d65dda222bc916b36b283cc06d2edd719bf3b" name="mix_3" x="252" y="182">
      <params>
         <frac32.u.map name="gain1" value="12.0"/>
         <frac32.u.map name="gain2" value="21.5"/>
      </params>
      <attribs/>
   </obj>
   <obj type="ctrl/i" uuid="a3786816db6ea5bc6ac4193a5cccdb2c83b83496" name="i_3" x="350" y="182">
      <params>
         <int32 name="value" value="17"/>
      </params>
      <attribs/>
   </obj>
   <obj type="harmony/note scale" uuid="d5343a4fea87a3e4f4dae20287226084550ea8d3" name="note_3" x="406" y="182">
      <params>
         <bin12 name="b12" value="2741"/>
      </params>
      <attribs/>
   </obj>
   <obj type="logic/latch" uuid="14750683752bd43205826430adb7168dae3cc2c" name="latch_2" x="560" y="182">
      <params/>
      <attribs/>
   </obj>
   <obj type="conv/interp" uuid="d68c1a8709d8b55e3de8715d727ec0a2d8569d9a" name="interp_1" x="630" y="182">
      <params/>
      <attribs/>
   </obj>
   <patchobj type="patch/object" uuid="dec13069-087a-465c-836b-c1577851ac25" name="sine_4" x="910" y="210">
      <params>
         <frac32.s.map name="pitch" value="-64.0"/>
      </params>
      <attribs/>
      <object id="patch/object" uuid="dec13069-087a-465c-836b-c1577851ac25">
         <sDescription>sine wave oscillator</sDescription>
         <author>Johannes Taelman</author>
         <license>BSD</license>
         <helpPatch>osc.axh</helpPatch>
         <inlets>
            <frac32.bipolar name="pitch" description="pitch"/>
            <frac32buffer name="freq" description="frequency"/>
            <frac32buffer name="phase" description="phase"/>
         </inlets>
         <outlets>
            <frac32buffer.bipolar name="wave" description="sine wave"/>
         </outlets>
         <displays/>
         <params>
            <frac32.s.map.pitch name="pitch" noLabel="true"/>
         </params>
         <attribs/>
         <includes/>
         <code.declaration><![CDATA[uint32_t Phase;]]></code.declaration>
         <code.init><![CDATA[Phase = 0;]]></code.init>
         <code.krate><![CDATA[int32_t freq;
   MTOFEXTENDED(param_pitch + inlet_pitch,freq);
freq=freq>>11;]]></code.krate>
         <code.srate><![CDATA[Phase += freq + inlet_freq;
int32_t r;
int32_t p2 = Phase + (inlet_phase<<4);
SINE2TINTERP(p2,r)
outlet_wave= (r>>4);
]]></code.srate>
      </object>
   </patchobj>
   <obj type="math/*c" uuid="7a66f52a9594e7e9eb31328ea725cb3641a80b55" name="*c_5" x="1008" y="210">
      <params>
         <frac32.u.map name="amp" value="0.5699996948242188"/>
      </params>
      <attribs/>
   </obj>
   <obj type="math/inv" uuid="7f4c6cf4dcf79f9b0aa81c2eaf540405875714a3" name="inv_4" x="1106" y="210">
      <params/>
      <attribs/>
   </obj>
   <patchobj type="patch/object" uuid="dec13069-087a-465c-836b-c1577851ac25" name="sine_2" x="1162" y="210">
      <params>
         <frac32.s.map name="pitch" value="-64.0"/>
      </params>
      <attribs/>
      <object id="patch/object" uuid="dec13069-087a-465c-836b-c1577851ac25">
         <sDescription>sine wave oscillator</sDescription>
         <author>Johannes Taelman</author>
         <license>BSD</license>
         <helpPatch>osc.axh</helpPatch>
         <inlets>
            <frac32.bipolar name="pitch" description="pitch"/>
            <frac32buffer name="freq" description="frequency"/>
            <frac32buffer name="phase" description="phase"/>
         </inlets>
         <outlets>
            <frac32buffer.bipolar name="wave" description="sine wave"/>
         </outlets>
         <displays/>
         <params>
            <frac32.s.map.pitch name="pitch" noLabel="true"/>
         </params>
         <attribs/>
         <includes/>
         <code.declaration><![CDATA[uint32_t Phase;]]></code.declaration>
         <code.init><![CDATA[Phase = 0;]]></code.init>
         <code.krate><![CDATA[int32_t freq;
   MTOFEXTENDED(param_pitch + inlet_pitch,freq);
freq=freq>>8;]]></code.krate>
         <code.srate><![CDATA[Phase += freq + inlet_freq;
int32_t r;
int32_t p2 = Phase + (inlet_phase<<4);
SINE2TINTERP(p2,r)
outlet_wave= (r>>4);
]]></code.srate>
      </object>
   </patchobj>
   <obj type="math/*c" uuid="7a66f52a9594e7e9eb31328ea725cb3641a80b55" name="*c_3" x="1260" y="210">
      <params>
         <frac32.u.map name="amp" value="0.625"/>
      </params>
      <attribs/>
   </obj>
   <obj type="math/inv" uuid="7f4c6cf4dcf79f9b0aa81c2eaf540405875714a3" name="inv_2" x="1358" y="210">
      <params/>
      <attribs/>
   </obj>
   <patchobj type="patch/object" uuid="dec13069-087a-465c-836b-c1577851ac25" name="sine_7" x="1414" y="224">
      <params>
         <frac32.s.map name="pitch" value="-64.0"/>
      </params>
      <attribs/>
      <object id="patch/object" uuid="dec13069-087a-465c-836b-c1577851ac25">
         <sDescription>sine wave oscillator</sDescription>
         <author>Johannes Taelman</author>
         <license>BSD</license>
         <helpPatch>osc.axh</helpPatch>
         <inlets>
            <frac32.bipolar name="pitch" description="pitch"/>
            <frac32buffer name="freq" description="frequency"/>
            <frac32buffer name="phase" description="phase"/>
         </inlets>
         <outlets>
            <frac32buffer.bipolar name="wave" description="sine wave"/>
         </outlets>
         <displays/>
         <params>
            <frac32.s.map.pitch name="pitch" noLabel="true"/>
         </params>
         <attribs/>
         <includes/>
         <code.declaration><![CDATA[uint32_t Phase;]]></code.declaration>
         <code.init><![CDATA[Phase = 0;]]></code.init>
         <code.krate><![CDATA[int32_t freq;
   MTOFEXTENDED(param_pitch + inlet_pitch,freq);
freq=freq>>8;]]></code.krate>
         <code.srate><![CDATA[Phase += freq + inlet_freq;
int32_t r;
int32_t p2 = Phase + (inlet_phase<<4);
SINE2TINTERP(p2,r)
outlet_wave= (r>>4);
]]></code.srate>
      </object>
   </patchobj>
   <obj type="math/&gt;&gt;" uuid="5d748ad90476b3ecc3970cde6622af97cf3cf4ac" name="&gt;&gt;_2" x="1512" y="224">
      <params/>
      <attribs>
         <spinner attributeName="shift" value="9"/>
      </attribs>
   </obj>
   <obj type="math/*c" uuid="7a66f52a9594e7e9eb31328ea725cb3641a80b55" name="*c_8" x="1596" y="224">
      <params>
         <frac32.u.map name="amp" value="25.0"/>
      </params>
      <attribs/>
   </obj>
   <obj type="math/inv" uuid="7f4c6cf4dcf79f9b0aa81c2eaf540405875714a3" name="inv_5" x="1694" y="224">
      <params/>
      <attribs/>
   </obj>
   <comment type="patch/comment" x="546" y="308" text="voice"/>
   <patchobj type="patch/object" uuid="065a1f22-0c8e-4800-9f93-8204bc28bbeb" name="envelope" x="364" y="322">
      <params>
         <frac32.s.map name="a" value="-64.0"/>
         <frac32.s.map name="d" value="-9.0"/>
         <frac32.s.map name="skew" value="-20.0"/>
         <frac32.u.map name="shift" value="23.0"/>
         <frac32.u.map name="expo" value="32.0"/>
      </params>
      <attribs/>
      <object id="patch/object" uuid="065a1f22-0c8e-4800-9f93-8204bc28bbeb">
         <sDescription>Attack/decay envelope, linear attack, linear to exponential decay with skew and shift function for start-mid-end decay rate for different tail shapes.</sDescription>
         <author>Remco van der Most</author>
         <license>BSD</license>
         <helpPatch>env.axh</helpPatch>
         <inlets>
            <bool32.rising name="trig" description="trigger"/>
            <frac32 name="a"/>
            <frac32 name="d"/>
            <frac32 name="skew"/>
            <frac32 name="shift"/>
            <frac32 name="expo"/>
         </inlets>
         <outlets>
            <frac32buffer name="env"/>
         </outlets>
         <displays/>
         <params>
            <frac32.s.map.klineartime.exp name="a"/>
            <frac32.s.map.klineartime.exp name="d"/>
            <frac32.s.map name="skew"/>
            <frac32.u.map name="shift"/>
            <frac32.u.map name="expo"/>
         </params>
         <attribs/>
         <includes/>
         <code.declaration><![CDATA[int8_t stage;
int ntrig;
int32_t val;]]></code.declaration>
         <code.init><![CDATA[ntrig = 0;
val = 0;]]></code.init>
         <code.srate><![CDATA[if ((inlet_trig>0) && !ntrig)
{
	ntrig = 1;
	stage = 1;
} 
else if (!(inlet_trig>0))
{
	ntrig = 0;
}
if (stage == 0)
{
	int32_t t,d,D1,D2,D3,shift,skew;
	shift=__USAT(param_shift+inlet_shift,27);
	skew=__SSAT(param_skew+inlet_skew,28);
	d=__SSAT(param_d+inlet_d,28);
	
	D1=d+skew-(___SMMUL(shift<<1,skew)<<5);
	D2=d+(___SMMUL(__USAT(shift<<1,27),skew)<<5);
	D3=d-skew;
	
	D1=D2+___SMMUL(D1-D2<<1,val);
	D2=D3+___SMMUL(D2-D3<<1,val);
	D1=D2+___SMMUL(D1-D2<<1,val);
	
	MTOF(-(D1),t);
	d=t>>4;
	t=t>>6;
	t+=___SMMUL((___SMMUL(val,d))-t,param_expo)<<5;
	
	val = __USAT(val-t,31);
} 
else 
{
	int32_t t,a;
	MTOF(-param_a,t);
	a=t>>4;
	t=t>>6;
	
	a=___SMMUL((___SMMUL(((1<<31)-1)-val,a))-t,__USAT(param_expo+inlet_expo,27))<<5;
	t+=a-(a>>8);
	
	val = val + t;
	
	if(val<0)
	{
		val =0x7FFFFFFF;
		stage = 0;
	}
	
}

outlet_env = val>>4;]]></code.srate>
      </object>
   </patchobj>
   <obj type="filter/lp1 m" uuid="18b561d14f9175f5380e6a1d9d55ca41e0e61974" name="lp1_1" x="462" y="322">
      <params>
         <frac32.u.map name="freq" value="0.0"/>
      </params>
      <attribs/>
   </obj>
   <patchobj type="patch/object" uuid="6c5df040-d406-487c-b662-6a36d833f286" name="sine_6" x="532" y="322">
      <params>
         <frac32.s.map name="pitch" value="-36.0"/>
      </params>
      <attribs/>
      <object id="patch/object" uuid="6c5df040-d406-487c-b662-6a36d833f286">
         <sDescription>sine wave oscillator</sDescription>
         <author>Johannes Taelman</author>
         <license>BSD</license>
         <helpPatch>osc.axh</helpPatch>
         <inlets>
            <frac32buffer name="pitch"/>
            <frac32buffer name="freq" description="frequency"/>
            <frac32buffer name="phase" description="phase"/>
         </inlets>
         <outlets>
            <frac32buffer.bipolar name="wave" description="sine wave"/>
         </outlets>
         <displays/>
         <params>
            <frac32.s.map.pitch name="pitch" noLabel="true"/>
         </params>
         <attribs/>
         <includes/>
         <code.declaration><![CDATA[uint32_t Phase;]]></code.declaration>
         <code.init><![CDATA[Phase = 0;]]></code.init>
         <code.srate><![CDATA[int32_t freq;
   MTOFEXTENDED(param_pitch + inlet_pitch,freq);

Phase += freq + inlet_freq;
int32_t r;
int32_t p2 = Phase + (inlet_phase<<4);
SINE2TINTERP(p2,r)
outlet_wave= (r>>4);]]></code.srate>
      </object>
   </patchobj>
   <obj type="math/*" uuid="dc7fbdd46e5e6d4b8de62ee63fd6321639b2f167" name="*_1" x="630" y="322">
      <params/>
      <attribs/>
   </obj>
   <obj type="math/*c" uuid="7a66f52a9594e7e9eb31328ea725cb3641a80b55" name="volume" x="686" y="322">
      <params>
         <frac32.u.map name="amp" value="6.5"/>
      </params>
      <attribs/>
   </obj>
   <comment type="patch/comment" x="784" y="434" text="readout from delay buffer for feedback path"/>
   <comment type="patch/comment" x="1022" y="434" text="bit of filtering (alliasing is caused by 16bit buffer)"/>
   <comment type="patch/comment" x="1302" y="434" text="feedback amount for delay"/>
   <comment type="patch/comment" x="1484" y="434" text="main delay buffer (stereo pingpong with readouts)"/>
   <patchobj type="patch/object" uuid="5622932a-a3fb-45da-927f-d2650b884e1f" name="read_3" x="728" y="448">
      <params>
         <frac32.u.map name="time" value="10.0"/>
      </params>
      <attribs>
         <objref attributeName="delayname" obj="delay_record_right"/>
      </attribs>
      <object id="patch/object" uuid="5622932a-a3fb-45da-927f-d2650b884e1f">
         <sDescription>delay read, linear interpolated</sDescription>
         <author>Johannes Taelman</author>
         <license>BSD</license>
         <helpPatch>delay.axh</helpPatch>
         <inlets>
            <frac32buffer name="time" description="delay time (fraction of total delayline size)"/>
         </inlets>
         <outlets>
            <frac32buffer name="out" description="wave"/>
         </outlets>
         <displays/>
         <params>
            <frac32.u.map name="time" noLabel="true"/>
         </params>
         <attribs>
            <objref name="delayname"/>
         </attribs>
         <includes/>
         <code.krate><![CDATA[int32_t del=param_time>>27-attr_delayname.LENGTHPOW;]]></code.krate>
         <code.srate><![CDATA[uint32_t tmp_d =  __USAT(inlet_time,27);
      uint32_t tmp_di = attr_delayname.writepos - (tmp_d>>(31-attr_delayname.LENGTHPOW)) - BUFSIZE + buffer_index -1-del;
      uint32_t tmp_w1 = (tmp_d<<(attr_delayname.LENGTHPOW-1)) & 0x3FFFFFFF;
      uint32_t tmp_w2 = (1<<30) - tmp_w1;
      int32_t tmp_a1 = attr_delayname.array[tmp_di&attr_delayname.LENGTHMASK]<<16;
      int32_t tmp_a2 = attr_delayname.array[(tmp_di+1)&attr_delayname.LENGTHMASK]<<16;
      int32_t tmp_r = ___SMMUL(tmp_a1,tmp_w1);
      tmp_r = ___SMMLA(tmp_a2,tmp_w2,tmp_r);
      outlet_out= tmp_r;]]></code.srate>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="5622932a-a3fb-45da-927f-d2650b884e1f" name="read_5" x="882" y="448">
      <params>
         <frac32.u.map name="time" value="12.0"/>
      </params>
      <attribs>
         <objref attributeName="delayname" obj="delay_record_right"/>
      </attribs>
      <object id="patch/object" uuid="5622932a-a3fb-45da-927f-d2650b884e1f">
         <sDescription>delay read, linear interpolated</sDescription>
         <author>Johannes Taelman</author>
         <license>BSD</license>
         <helpPatch>delay.axh</helpPatch>
         <inlets>
            <frac32buffer name="time" description="delay time (fraction of total delayline size)"/>
         </inlets>
         <outlets>
            <frac32buffer name="out" description="wave"/>
         </outlets>
         <displays/>
         <params>
            <frac32.u.map name="time" noLabel="true"/>
         </params>
         <attribs>
            <objref name="delayname"/>
         </attribs>
         <includes/>
         <code.krate><![CDATA[int32_t del=param_time>>27-attr_delayname.LENGTHPOW;]]></code.krate>
         <code.srate><![CDATA[uint32_t tmp_d =  __USAT(inlet_time,27);
      uint32_t tmp_di = attr_delayname.writepos - (tmp_d>>(31-attr_delayname.LENGTHPOW)) - BUFSIZE + buffer_index -1-del;
      uint32_t tmp_w1 = (tmp_d<<(attr_delayname.LENGTHPOW-1)) & 0x3FFFFFFF;
      uint32_t tmp_w2 = (1<<30) - tmp_w1;
      int32_t tmp_a1 = attr_delayname.array[tmp_di&attr_delayname.LENGTHMASK]<<16;
      int32_t tmp_a2 = attr_delayname.array[(tmp_di+1)&attr_delayname.LENGTHMASK]<<16;
      int32_t tmp_r = ___SMMUL(tmp_a1,tmp_w1);
      tmp_r = ___SMMLA(tmp_a2,tmp_w2,tmp_r);
      outlet_out= tmp_r;]]></code.srate>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="36b4fb93-9cd5-4f78-9b2b-351ee070a39c" name="lp1_2" x="1050" y="448">
      <params>
         <frac32.s.map name="freq" value="46.0"/>
      </params>
      <attribs/>
      <object id="patch/object" uuid="36b4fb93-9cd5-4f78-9b2b-351ee070a39c">
         <sDescription>1st order lowpass filter</sDescription>
         <author>Johannes Taelman</author>
         <license>BSD</license>
         <helpPatch>filter.axh</helpPatch>
         <inlets>
            <frac32buffer name="in" description="input"/>
         </inlets>
         <outlets>
            <frac32buffer name="out" description="output"/>
         </outlets>
         <displays/>
         <params>
            <frac32.s.map.pitch name="freq" noLabel="true"/>
         </params>
         <attribs/>
         <includes/>
         <code.declaration><![CDATA[int32_t val;
]]></code.declaration>
         <code.init><![CDATA[val = 0;
]]></code.init>
         <code.krate><![CDATA[int32_t f;
   MTOF(param_freq,f);
]]></code.krate>
         <code.srate><![CDATA[val = ___SMMLA((inlet_in-val)<<1,f,val);
   val = ___SMMLA((inlet_in-val)<<1,f,val);
   outlet_out= val;]]></code.srate>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="36b4fb93-9cd5-4f78-9b2b-351ee070a39c" name="lp1_3" x="1148" y="448">
      <params>
         <frac32.s.map name="freq" value="46.0"/>
      </params>
      <attribs/>
      <object id="patch/object" uuid="36b4fb93-9cd5-4f78-9b2b-351ee070a39c">
         <sDescription>1st order lowpass filter</sDescription>
         <author>Johannes Taelman</author>
         <license>BSD</license>
         <helpPatch>filter.axh</helpPatch>
         <inlets>
            <frac32buffer name="in" description="input"/>
         </inlets>
         <outlets>
            <frac32buffer name="out" description="output"/>
         </outlets>
         <displays/>
         <params>
            <frac32.s.map.pitch name="freq" noLabel="true"/>
         </params>
         <attribs/>
         <includes/>
         <code.declaration><![CDATA[int32_t val;
]]></code.declaration>
         <code.init><![CDATA[val = 0;
]]></code.init>
         <code.krate><![CDATA[int32_t f;
   MTOF(param_freq,f);
]]></code.krate>
         <code.srate><![CDATA[val = ___SMMLA((inlet_in-val)<<1,f,val);
   val = ___SMMLA((inlet_in-val)<<1,f,val);
   outlet_out= val;]]></code.srate>
      </object>
   </patchobj>
   <obj type="mix/mix 1 sq" uuid="cf790039775b62697a4b34e7a5389a5a8cc36e30" name="mix_1" x="1274" y="448">
      <params>
         <frac32.u.map name="gain1" value="55.5"/>
      </params>
      <attribs/>
   </obj>
   <obj type="mix/mix 1 sq" uuid="cf790039775b62697a4b34e7a5389a5a8cc36e30" name="mix_2" x="1372" y="448">
      <params>
         <frac32.u.map name="gain1" value="55.5"/>
      </params>
      <attribs/>
   </obj>
   <obj type="delay/write sdram" uuid="5ae03f8d7b815edcfc40585d8bbac2ed48460fba" name="delay_record_left" x="1484" y="448">
      <params/>
      <attribs>
         <combo attributeName="size" selection="131072 (2.73s)"/>
      </attribs>
   </obj>
   <obj type="delay/write sdram" uuid="5ae03f8d7b815edcfc40585d8bbac2ed48460fba" name="delay_record_right" x="1596" y="448">
      <params/>
      <attribs>
         <combo attributeName="size" selection="131072 (2.73s)"/>
      </attribs>
   </obj>
   <comment type="patch/comment" x="1274" y="560" text="mix amount of delay with dry signal"/>
   <comment type="patch/comment" x="798" y="574" text="readout from delay buffer for output path"/>
   <obj type="mix/mix 1 sq" uuid="cf790039775b62697a4b34e7a5389a5a8cc36e30" name="mix_4" x="1274" y="574">
      <params>
         <frac32.u.map name="gain1" value="46.5"/>
      </params>
      <attribs/>
   </obj>
   <obj type="mix/mix 1 sq" uuid="cf790039775b62697a4b34e7a5389a5a8cc36e30" name="mix_5" x="1372" y="574">
      <params>
         <frac32.u.map name="gain1" value="46.5"/>
      </params>
      <attribs/>
   </obj>
   <obj type="audio/out stereo" uuid="a1ca7a567f535acc21055669829101d3ee7f0189" name="out_1" x="1512" y="574">
      <params/>
      <attribs/>
   </obj>
   <obj type="delay/read interp" uuid="e3d8b8823ab551c588659520bf6cc25c630466c7" name="read_1" x="728" y="588">
      <params>
         <frac32.u.map name="time" value="18.0"/>
      </params>
      <attribs>
         <objref attributeName="delayname" obj="delay_record_right"/>
      </attribs>
   </obj>
   <obj type="delay/read interp" uuid="e3d8b8823ab551c588659520bf6cc25c630466c7" name="read_2" x="882" y="588">
      <params>
         <frac32.u.map name="time" value="18.0"/>
      </params>
      <attribs>
         <objref attributeName="delayname" obj="delay_record_left"/>
      </attribs>
   </obj>
   <comment type="patch/comment" x="294" y="686" text="adding early reflections to delay buffer from audio input"/>
   <patchobj type="patch/object" uuid="52770f49-321b-44ba-9ef5-bdab934b7067" name="early reflections" x="308" y="700">
      <params>
         <frac32.u.map name="spread" value="36.5"/>
         <frac32.s.map name="expo" value="-18.0"/>
         <frac32.s.map name="curve" value="-27.0"/>
         <frac32.s.map name="damp" value="26.0"/>
         <frac32.s.map name="vol" value="33.0"/>
      </params>
      <attribs>
         <combo attributeName="size" selection="32768 (682ms)"/>
         <objref attributeName="delay" obj="delay_record_left"/>
      </attribs>
      <object id="patch/object" uuid="52770f49-321b-44ba-9ef5-bdab934b7067">
         <sDescription>delayline definition, read it with &quot;delay/read&quot; objects referencing the instance name of this object</sDescription>
         <author>Johannes Taelman</author>
         <license>BSD</license>
         <helpPatch>delay.axh</helpPatch>
         <inlets>
            <frac32buffer name="in" description="wave input"/>
         </inlets>
         <outlets/>
         <displays/>
         <params>
            <frac32.u.map name="spread" description="main spread size of delaytimes"/>
            <frac32.s.map name="expo" description="exponential spreading of delaytimes"/>
            <frac32.s.map name="curve" description="S-curve/inv-S-curve spreading of delaytimes"/>
            <frac32.s.map name="damp" description="volume shape of early reflections"/>
            <frac32.s.map name="vol" description="main volume reflections"/>
         </params>
         <attribs>
            <combo name="size">
               <MenuEntries>
                  <string>256 (5.33ms)</string>
                  <string>512 (10.66ms)</string>
                  <string>1024 (21.33ms)</string>
                  <string>2048 (42.66ms)</string>
                  <string>4096 (85.33ms)</string>
                  <string>8192 (170ms)</string>
                  <string>16384 (341ms)</string>
                  <string>32768 (682ms)</string>
                  <string>65536 (1.36s)</string>
                  <string>131072 (2.73s)</string>
                  <string>262144 (5.46s)</string>
                  <string>524288 (10.9s)</string>
                  <string>1048576 (21.8s)</string>
                  <string>2097152 (43.7s)</string>
               </MenuEntries>
               <CEntries>
                  <string>8</string>
                  <string>9</string>
                  <string>10</string>
                  <string>11</string>
                  <string>12</string>
                  <string>13</string>
                  <string>14</string>
                  <string>15</string>
                  <string>16</string>
                  <string>17</string>
                  <string>18</string>
                  <string>19</string>
                  <string>20</string>
                  <string>21</string>
               </CEntries>
            </combo>
            <objref name="delay"/>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[static const uint32_t LENGTHPOW = (attr_size);
static const uint32_t LENGTH = (1<<attr_size);
static const uint32_t LENGTHMASK = ((1<<attr_size)-1);
int16_t *array;
uint32_t writepos;]]></code.declaration>
         <code.init><![CDATA[static int16_t _array[attr_poly][1<<attr_size]  __attribute__ ((section (".sdram")));
array = &_array[parent->polyIndex][0];
   int i;
   writepos = 0;
   for(i=0;i<LENGTH;i++) array[i] = 0;]]></code.init>
         <code.krate><![CDATA[int32_t d[3],t[3];
for(int i=0;i<3;i++)
{
	
	int32_t T=(1<<25)*(1+i);
	T=T+((i-1)*param_curve>>2);
	if(param_expo>0)
	{
		T+=___SMMUL((1<<27)-T,param_expo)<<5;
	}
	else
	{
		T-=___SMMUL(T,-param_expo)<<5;
	}

	t[i]=___SMMUL(param_spread,T)>>22-LENGTHPOW;

	int32_t D=param_vol;
	if(i==0)
	{
		D-=___SMMUL(D,param_damp+(1<<27))<<3;
	}
	else if(i==1)
	{
		D=___SMMUL(D,(1<<28)-((param_damp>0?param_damp:-param_damp)>>1))<<4;
	}
	else
	{
		D-=___SMMUL(D,-param_damp+(1<<27))<<3;
	}
	d[i]=D;
}

int32_t POS=attr_delay.writepos-BUFSIZE-2;]]></code.krate>
         <code.srate><![CDATA[array[writepos] = __SSAT(inlet_in>>14,16);


attr_delay.array[(POS)&attr_delay.LENGTHMASK]=__SSAT((___SMMUL(array[(writepos-t[0])&LENGTHMASK]<<5,d[0])+___SMMUL(array[(writepos-t[1])&LENGTHMASK]<<5,d[1])+___SMMUL(array[(writepos-t[2])&LENGTHMASK]<<5,d[2]))+attr_delay.array[(POS)&attr_delay.LENGTHMASK],16);
POS=(POS+1)&attr_delay.LENGTHMASK;writepos = (writepos + 1)&LENGTHMASK;]]></code.srate>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="52770f49-321b-44ba-9ef5-bdab934b7067" name="early reflections__" x="448" y="700">
      <params>
         <frac32.u.map name="spread" value="35.5"/>
         <frac32.s.map name="expo" value="-14.0"/>
         <frac32.s.map name="curve" value="-21.0"/>
         <frac32.s.map name="damp" value="26.0"/>
         <frac32.s.map name="vol" value="33.0"/>
      </params>
      <attribs>
         <combo attributeName="size" selection="32768 (682ms)"/>
         <objref attributeName="delay" obj="delay_record_right"/>
      </attribs>
      <object id="patch/object" uuid="52770f49-321b-44ba-9ef5-bdab934b7067">
         <sDescription>delayline definition, read it with &quot;delay/read&quot; objects referencing the instance name of this object</sDescription>
         <author>Johannes Taelman</author>
         <license>BSD</license>
         <helpPatch>delay.axh</helpPatch>
         <inlets>
            <frac32buffer name="in" description="wave input"/>
         </inlets>
         <outlets/>
         <displays/>
         <params>
            <frac32.u.map name="spread" description="main spread size of delaytimes"/>
            <frac32.s.map name="expo" description="exponential spreading of delaytimes"/>
            <frac32.s.map name="curve" description="S-curve/inv-S-curve spreading of delaytimes"/>
            <frac32.s.map name="damp" description="volume shape of early reflections"/>
            <frac32.s.map name="vol" description="main volume reflections"/>
         </params>
         <attribs>
            <combo name="size">
               <MenuEntries>
                  <string>256 (5.33ms)</string>
                  <string>512 (10.66ms)</string>
                  <string>1024 (21.33ms)</string>
                  <string>2048 (42.66ms)</string>
                  <string>4096 (85.33ms)</string>
                  <string>8192 (170ms)</string>
                  <string>16384 (341ms)</string>
                  <string>32768 (682ms)</string>
                  <string>65536 (1.36s)</string>
                  <string>131072 (2.73s)</string>
                  <string>262144 (5.46s)</string>
                  <string>524288 (10.9s)</string>
                  <string>1048576 (21.8s)</string>
                  <string>2097152 (43.7s)</string>
               </MenuEntries>
               <CEntries>
                  <string>8</string>
                  <string>9</string>
                  <string>10</string>
                  <string>11</string>
                  <string>12</string>
                  <string>13</string>
                  <string>14</string>
                  <string>15</string>
                  <string>16</string>
                  <string>17</string>
                  <string>18</string>
                  <string>19</string>
                  <string>20</string>
                  <string>21</string>
               </CEntries>
            </combo>
            <objref name="delay"/>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[static const uint32_t LENGTHPOW = (attr_size);
static const uint32_t LENGTH = (1<<attr_size);
static const uint32_t LENGTHMASK = ((1<<attr_size)-1);
int16_t *array;
uint32_t writepos;]]></code.declaration>
         <code.init><![CDATA[static int16_t _array[attr_poly][1<<attr_size]  __attribute__ ((section (".sdram")));
array = &_array[parent->polyIndex][0];
   int i;
   writepos = 0;
   for(i=0;i<LENGTH;i++) array[i] = 0;]]></code.init>
         <code.krate><![CDATA[int32_t d[3],t[3];
for(int i=0;i<3;i++)
{
	
	int32_t T=(1<<25)*(1+i);
	T=T+((i-1)*param_curve>>2);
	if(param_expo>0)
	{
		T+=___SMMUL((1<<27)-T,param_expo)<<5;
	}
	else
	{
		T-=___SMMUL(T,-param_expo)<<5;
	}

	t[i]=___SMMUL(param_spread,T)>>22-LENGTHPOW;

	int32_t D=param_vol;
	if(i==0)
	{
		D-=___SMMUL(D,param_damp+(1<<27))<<3;
	}
	else if(i==1)
	{
		D=___SMMUL(D,(1<<28)-((param_damp>0?param_damp:-param_damp)>>1))<<4;
	}
	else
	{
		D-=___SMMUL(D,-param_damp+(1<<27))<<3;
	}
	d[i]=D;
}

int32_t POS=attr_delay.writepos-BUFSIZE-2;]]></code.krate>
         <code.srate><![CDATA[array[writepos] = __SSAT(inlet_in>>14,16);


attr_delay.array[(POS)&attr_delay.LENGTHMASK]=__SSAT((___SMMUL(array[(writepos-t[0])&LENGTHMASK]<<5,d[0])+___SMMUL(array[(writepos-t[1])&LENGTHMASK]<<5,d[1])+___SMMUL(array[(writepos-t[2])&LENGTHMASK]<<5,d[2]))+attr_delay.array[(POS)&attr_delay.LENGTHMASK],16);
POS=(POS+1)&attr_delay.LENGTHMASK;writepos = (writepos + 1)&LENGTHMASK;]]></code.srate>
      </object>
   </patchobj>
   <comment type="patch/comment" x="994" y="728" text="nested scatter/allpass delays (read from and write to main delay buffer for adding reverb and reflections)"/>
   <patchobj type="patch/object" uuid="2b6e9d3e-762f-48b8-befd-28527c74cded" name="nested_1" x="616" y="742">
      <params>
         <frac32.u.map name="scatter" value="46.5"/>
         <frac32.u.map name="size" value="39.94499969482422"/>
         <int32.hradio name="mode" value="2"/>
      </params>
      <attribs>
         <combo attributeName="size" selection="16384 (341ms)"/>
         <objref attributeName="delayname" obj="delay_record_left"/>
      </attribs>
      <object id="patch/object" uuid="2b6e9d3e-762f-48b8-befd-28527c74cded">
         <sDescription>modulatable nested scatter/allpass function for delaylines.
Can be used with the factory delayline module to add diffusion to a delay</sDescription>
         <author>Remco van der Most</author>
         <license>BSD</license>
         <helpPatch>delay.axh</helpPatch>
         <inlets>
            <frac32buffer name="size"/>
         </inlets>
         <outlets/>
         <displays/>
         <params>
            <frac32.u.map name="scatter"/>
            <frac32.u.map name="size"/>
            <int32.hradio name="mode" description="off,scatter,allpass">
               <MaxValue i="3"/>
            </int32.hradio>
         </params>
         <attribs>
            <combo name="size">
               <MenuEntries>
                  <string>256 (5.33ms)</string>
                  <string>512 (10.66ms)</string>
                  <string>1024 (21.33ms)</string>
                  <string>2048 (42.66ms)</string>
                  <string>4096 (85.33ms)</string>
                  <string>8192 (170ms)</string>
                  <string>16384 (341ms)</string>
                  <string>32768 (682ms)</string>
                  <string>65536 (1.36s)</string>
                  <string>131072 (2.73s)</string>
                  <string>262144 (5.46s)</string>
                  <string>524288 (10.9s)</string>
                  <string>1048576 (21.8s)</string>
                  <string>2097152 (43.7s)</string>
               </MenuEntries>
               <CEntries>
                  <string>8</string>
                  <string>9</string>
                  <string>10</string>
                  <string>11</string>
                  <string>12</string>
                  <string>13</string>
                  <string>14</string>
                  <string>15</string>
                  <string>16</string>
                  <string>17</string>
                  <string>18</string>
                  <string>19</string>
                  <string>20</string>
                  <string>21</string>
               </CEntries>
            </combo>
            <objref name="delayname"/>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[static const uint32_t LENGTHPOW = (attr_size);
static const uint32_t LENGTH = (1<<attr_size);
static const uint32_t LENGTHMASK = ((1<<attr_size)-1);
int16_t *array;
uint32_t writepos;]]></code.declaration>
         <code.init><![CDATA[static int16_t _array[attr_poly][1<<attr_size]  __attribute__ ((section (".sdram")));
array = &_array[parent->polyIndex][0];
   int i;
   writepos = 0;
   for(i=0;i<LENGTH;i++) array[i] = 0;]]></code.init>
         <code.krate><![CDATA[int32_t scatter=__USAT(param_scatter,27)<<4;
int32_t wp=0;

int32_t POS=attr_delayname.writepos-BUFSIZE-1-1;]]></code.krate>
         <code.srate><![CDATA[if(param_mode>0){
int32_t sz=__USAT(param_size+inlet_size,27);
int32_t size=sz>>27-LENGTHPOW;
int32_t mix=((uint32_t)sz<<5+LENGTHPOW)>>1;

int32_t in=attr_delayname.array[POS]<<14;
int32_t t1,t2,t3;
t2=___SMMUL(in,scatter)<<1;
t3=array[(writepos-size)&LENGTHMASK]<<14;
t3+=___SMMUL((array[(writepos-size)&LENGTHMASK]<<14)-t3,mix)<<1;
t1=___SMMUL(t3,scatter)<<1;

array[writepos] = __SSAT(in+(param_mode>1?0:t2)-t1>>14,16);
if(param_mode==1){
attr_delayname.array[POS] = __SSAT(t2+t3-t1>>14,16);
}
else{
attr_delayname.array[POS]=__SSAT(___SMMUL(in-t1<<1,scatter)+t3>>14,16);
}

writepos = (writepos + 1)&LENGTHMASK;
POS=(POS+1)&attr_delayname.LENGTHMASK;
}]]></code.srate>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="2b6e9d3e-762f-48b8-befd-28527c74cded" name="nested_2" x="770" y="742">
      <params>
         <frac32.u.map name="scatter" value="45.5"/>
         <frac32.u.map name="size" value="33.10499954223633"/>
         <int32.hradio name="mode" value="2"/>
      </params>
      <attribs>
         <combo attributeName="size" selection="16384 (341ms)"/>
         <objref attributeName="delayname" obj="delay_record_right"/>
      </attribs>
      <object id="patch/object" uuid="2b6e9d3e-762f-48b8-befd-28527c74cded">
         <sDescription>modulatable nested scatter/allpass function for delaylines.
Can be used with the factory delayline module to add diffusion to a delay</sDescription>
         <author>Remco van der Most</author>
         <license>BSD</license>
         <helpPatch>delay.axh</helpPatch>
         <inlets>
            <frac32buffer name="size"/>
         </inlets>
         <outlets/>
         <displays/>
         <params>
            <frac32.u.map name="scatter"/>
            <frac32.u.map name="size"/>
            <int32.hradio name="mode" description="off,scatter,allpass">
               <MaxValue i="3"/>
            </int32.hradio>
         </params>
         <attribs>
            <combo name="size">
               <MenuEntries>
                  <string>256 (5.33ms)</string>
                  <string>512 (10.66ms)</string>
                  <string>1024 (21.33ms)</string>
                  <string>2048 (42.66ms)</string>
                  <string>4096 (85.33ms)</string>
                  <string>8192 (170ms)</string>
                  <string>16384 (341ms)</string>
                  <string>32768 (682ms)</string>
                  <string>65536 (1.36s)</string>
                  <string>131072 (2.73s)</string>
                  <string>262144 (5.46s)</string>
                  <string>524288 (10.9s)</string>
                  <string>1048576 (21.8s)</string>
                  <string>2097152 (43.7s)</string>
               </MenuEntries>
               <CEntries>
                  <string>8</string>
                  <string>9</string>
                  <string>10</string>
                  <string>11</string>
                  <string>12</string>
                  <string>13</string>
                  <string>14</string>
                  <string>15</string>
                  <string>16</string>
                  <string>17</string>
                  <string>18</string>
                  <string>19</string>
                  <string>20</string>
                  <string>21</string>
               </CEntries>
            </combo>
            <objref name="delayname"/>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[static const uint32_t LENGTHPOW = (attr_size);
static const uint32_t LENGTH = (1<<attr_size);
static const uint32_t LENGTHMASK = ((1<<attr_size)-1);
int16_t *array;
uint32_t writepos;]]></code.declaration>
         <code.init><![CDATA[static int16_t _array[attr_poly][1<<attr_size]  __attribute__ ((section (".sdram")));
array = &_array[parent->polyIndex][0];
   int i;
   writepos = 0;
   for(i=0;i<LENGTH;i++) array[i] = 0;]]></code.init>
         <code.krate><![CDATA[int32_t scatter=__USAT(param_scatter,27)<<4;
int32_t wp=0;

int32_t POS=attr_delayname.writepos-BUFSIZE-1-1;]]></code.krate>
         <code.srate><![CDATA[if(param_mode>0){
int32_t sz=__USAT(param_size+inlet_size,27);
int32_t size=sz>>27-LENGTHPOW;
int32_t mix=((uint32_t)sz<<5+LENGTHPOW)>>1;

int32_t in=attr_delayname.array[POS]<<14;
int32_t t1,t2,t3;
t2=___SMMUL(in,scatter)<<1;
t3=array[(writepos-size)&LENGTHMASK]<<14;
t3+=___SMMUL((array[(writepos-size)&LENGTHMASK]<<14)-t3,mix)<<1;
t1=___SMMUL(t3,scatter)<<1;

array[writepos] = __SSAT(in+(param_mode>1?0:t2)-t1>>14,16);
if(param_mode==1){
attr_delayname.array[POS] = __SSAT(t2+t3-t1>>14,16);
}
else{
attr_delayname.array[POS]=__SSAT(___SMMUL(in-t1<<1,scatter)+t3>>14,16);
}

writepos = (writepos + 1)&LENGTHMASK;
POS=(POS+1)&attr_delayname.LENGTHMASK;
}]]></code.srate>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="2b6e9d3e-762f-48b8-befd-28527c74cded" name="nested_3" x="924" y="742">
      <params>
         <frac32.u.map name="scatter" value="48.0"/>
         <frac32.u.map name="size" value="36.05999994277954"/>
         <int32.hradio name="mode" value="2"/>
         <int32.hradio name="select" value="0"/>
      </params>
      <attribs>
         <combo attributeName="size" selection="4096 (85.33ms)"/>
         <objref attributeName="del1" obj="delay_record_left"/>
         <objref attributeName="del2" obj="nested_1"/>
      </attribs>
      <object id="patch/object" uuid="2b6e9d3e-762f-48b8-befd-28527c74cded">
         <sDescription>modulatable nested scatter/allpass function for delaylines.
Can be used with the factory delayline module to add diffusion to a delay</sDescription>
         <author>Remco van der Most</author>
         <license>BSD</license>
         <helpPatch>delay.axh</helpPatch>
         <inlets>
            <frac32buffer name="size"/>
         </inlets>
         <outlets/>
         <displays/>
         <params>
            <frac32.u.map name="scatter"/>
            <frac32.u.map name="size"/>
            <int32.hradio name="mode" description="off,scatter,allpass">
               <MaxValue i="3"/>
            </int32.hradio>
            <int32.hradio name="select">
               <MaxValue i="2"/>
            </int32.hradio>
         </params>
         <attribs>
            <combo name="size">
               <MenuEntries>
                  <string>256 (5.33ms)</string>
                  <string>512 (10.66ms)</string>
                  <string>1024 (21.33ms)</string>
                  <string>2048 (42.66ms)</string>
                  <string>4096 (85.33ms)</string>
                  <string>8192 (170ms)</string>
                  <string>16384 (341ms)</string>
                  <string>32768 (682ms)</string>
                  <string>65536 (1.36s)</string>
                  <string>131072 (2.73s)</string>
                  <string>262144 (5.46s)</string>
                  <string>524288 (10.9s)</string>
                  <string>1048576 (21.8s)</string>
                  <string>2097152 (43.7s)</string>
               </MenuEntries>
               <CEntries>
                  <string>8</string>
                  <string>9</string>
                  <string>10</string>
                  <string>11</string>
                  <string>12</string>
                  <string>13</string>
                  <string>14</string>
                  <string>15</string>
                  <string>16</string>
                  <string>17</string>
                  <string>18</string>
                  <string>19</string>
                  <string>20</string>
                  <string>21</string>
               </CEntries>
            </combo>
            <objref name="del1"/>
            <objref name="del2"/>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[static const uint32_t LENGTHPOW = (attr_size);
static const uint32_t LENGTH = (1<<attr_size);
static const uint32_t LENGTHMASK = ((1<<attr_size)-1);
int16_t *array;
uint32_t writepos;]]></code.declaration>
         <code.init><![CDATA[static int16_t _array[attr_poly][1<<attr_size]  __attribute__ ((section (".sdram")));
array = &_array[parent->polyIndex][0];
   int i;
   writepos = 0;
   for(i=0;i<LENGTH;i++) array[i] = 0;]]></code.init>
         <code.krate><![CDATA[int32_t scatter=__USAT(param_scatter,27)<<4;
int32_t wp=0;

int32_t POS;

switch(param_select)
{
	case 0: POS=attr_del1.writepos-BUFSIZE-1-1; break;
	case 1: POS=attr_del2.writepos-BUFSIZE-1-1; break;
}]]></code.krate>
         <code.srate><![CDATA[if(param_mode>0){
int32_t sz=__USAT(param_size+inlet_size,27);
int32_t size=sz>>27-LENGTHPOW;
int32_t mix=((uint32_t)sz<<5+LENGTHPOW)>>1;

int32_t in;
switch(param_select)
{
	case 0:	in=attr_del1.array[POS]<<14;break;
	case 1:	in=attr_del2.array[POS]<<14;break;

}
int32_t t1,t2,t3;
t2=___SMMUL(in,scatter)<<1;
t3=array[(writepos-size)&LENGTHMASK]<<14;
t3+=___SMMUL((array[(writepos-size)&LENGTHMASK]<<14)-t3,mix)<<1;
t1=___SMMUL(t3,scatter)<<1;

array[writepos] = __SSAT(in+(param_mode>1?0:t2)-t1>>14,16);
int32_t out;
if(param_mode==1){
	out = __SSAT(t2+t3-t1>>14,16);
}
else{
	out=__SSAT(___SMMUL(in-t1<<1,scatter)+t3>>14,16);
}

switch(param_select)
{
	case 0: attr_del1.array[POS]=out; break;
	case 1: attr_del2.array[POS]=out; break;

}

writepos = (writepos + 1)&LENGTHMASK;
switch(param_select)
{
	case 0: POS=(POS+1)&attr_del1.LENGTHMASK; break;
	case 1: POS=(POS+1)&attr_del2.LENGTHMASK; break;


}
}]]></code.srate>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="2b6e9d3e-762f-48b8-befd-28527c74cded" name="nested_4" x="1050" y="742">
      <params>
         <frac32.u.map name="scatter" value="48.0"/>
         <frac32.u.map name="size" value="40.5"/>
         <int32.hradio name="mode" value="2"/>
         <int32.hradio name="select" value="0"/>
      </params>
      <attribs>
         <combo attributeName="size" selection="4096 (85.33ms)"/>
         <objref attributeName="del1" obj="delay_record_right"/>
         <objref attributeName="del2" obj="nested_2"/>
      </attribs>
      <object id="patch/object" uuid="2b6e9d3e-762f-48b8-befd-28527c74cded">
         <sDescription>modulatable nested scatter/allpass function for delaylines.
Can be used with the factory delayline module to add diffusion to a delay</sDescription>
         <author>Remco van der Most</author>
         <license>BSD</license>
         <helpPatch>delay.axh</helpPatch>
         <inlets>
            <frac32buffer name="size"/>
         </inlets>
         <outlets/>
         <displays/>
         <params>
            <frac32.u.map name="scatter"/>
            <frac32.u.map name="size"/>
            <int32.hradio name="mode" description="off,scatter,allpass">
               <MaxValue i="3"/>
            </int32.hradio>
            <int32.hradio name="select">
               <MaxValue i="2"/>
            </int32.hradio>
         </params>
         <attribs>
            <combo name="size">
               <MenuEntries>
                  <string>256 (5.33ms)</string>
                  <string>512 (10.66ms)</string>
                  <string>1024 (21.33ms)</string>
                  <string>2048 (42.66ms)</string>
                  <string>4096 (85.33ms)</string>
                  <string>8192 (170ms)</string>
                  <string>16384 (341ms)</string>
                  <string>32768 (682ms)</string>
                  <string>65536 (1.36s)</string>
                  <string>131072 (2.73s)</string>
                  <string>262144 (5.46s)</string>
                  <string>524288 (10.9s)</string>
                  <string>1048576 (21.8s)</string>
                  <string>2097152 (43.7s)</string>
               </MenuEntries>
               <CEntries>
                  <string>8</string>
                  <string>9</string>
                  <string>10</string>
                  <string>11</string>
                  <string>12</string>
                  <string>13</string>
                  <string>14</string>
                  <string>15</string>
                  <string>16</string>
                  <string>17</string>
                  <string>18</string>
                  <string>19</string>
                  <string>20</string>
                  <string>21</string>
               </CEntries>
            </combo>
            <objref name="del1"/>
            <objref name="del2"/>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[static const uint32_t LENGTHPOW = (attr_size);
static const uint32_t LENGTH = (1<<attr_size);
static const uint32_t LENGTHMASK = ((1<<attr_size)-1);
int16_t *array;
uint32_t writepos;]]></code.declaration>
         <code.init><![CDATA[static int16_t _array[attr_poly][1<<attr_size]  __attribute__ ((section (".sdram")));
array = &_array[parent->polyIndex][0];
   int i;
   writepos = 0;
   for(i=0;i<LENGTH;i++) array[i] = 0;]]></code.init>
         <code.krate><![CDATA[int32_t scatter=__USAT(param_scatter,27)<<4;
int32_t wp=0;

int32_t POS;

switch(param_select)
{
	case 0: POS=attr_del1.writepos-BUFSIZE-1-1; break;
	case 1: POS=attr_del2.writepos-BUFSIZE-1-1; break;
}]]></code.krate>
         <code.srate><![CDATA[if(param_mode>0){
int32_t sz=__USAT(param_size+inlet_size,27);
int32_t size=sz>>27-LENGTHPOW;
int32_t mix=((uint32_t)sz<<5+LENGTHPOW)>>1;

int32_t in;
switch(param_select)
{
	case 0:	in=attr_del1.array[POS]<<14;break;
	case 1:	in=attr_del2.array[POS]<<14;break;

}
int32_t t1,t2,t3;
t2=___SMMUL(in,scatter)<<1;
t3=array[(writepos-size)&LENGTHMASK]<<14;
t3+=___SMMUL((array[(writepos-size)&LENGTHMASK]<<14)-t3,mix)<<1;
t1=___SMMUL(t3,scatter)<<1;

array[writepos] = __SSAT(in+(param_mode>1?0:t2)-t1>>14,16);
int32_t out;
if(param_mode==1){
	out = __SSAT(t2+t3-t1>>14,16);
}
else{
	out=__SSAT(___SMMUL(in-t1<<1,scatter)+t3>>14,16);
}

switch(param_select)
{
	case 0: attr_del1.array[POS]=out; break;
	case 1: attr_del2.array[POS]=out; break;

}

writepos = (writepos + 1)&LENGTHMASK;
switch(param_select)
{
	case 0: POS=(POS+1)&attr_del1.LENGTHMASK; break;
	case 1: POS=(POS+1)&attr_del2.LENGTHMASK; break;


}
}]]></code.srate>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="2b6e9d3e-762f-48b8-befd-28527c74cded" name="nested_5" x="1176" y="742">
      <params>
         <frac32.u.map name="scatter" value="58.0"/>
         <frac32.u.map name="size" value="24.864999771118164"/>
         <int32.hradio name="mode" value="2"/>
         <int32.hradio name="select" value="0"/>
      </params>
      <attribs>
         <combo attributeName="size" selection="2048 (42.66ms)"/>
         <objref attributeName="del1" obj="delay_record_left"/>
         <objref attributeName="del2" obj="nested_1"/>
         <objref attributeName="del3" obj="nested_3"/>
      </attribs>
      <object id="patch/object" uuid="2b6e9d3e-762f-48b8-befd-28527c74cded">
         <sDescription>modulatable nested scatter/allpass function for delaylines.
Can be used with the factory delayline module to add diffusion to a delay</sDescription>
         <author>Remco van der Most</author>
         <license>BSD</license>
         <helpPatch>delay.axh</helpPatch>
         <inlets>
            <frac32buffer name="size"/>
         </inlets>
         <outlets/>
         <displays/>
         <params>
            <frac32.u.map name="scatter"/>
            <frac32.u.map name="size"/>
            <int32.hradio name="mode" description="off,scatter,allpass">
               <MaxValue i="3"/>
            </int32.hradio>
            <int32.hradio name="select">
               <MaxValue i="3"/>
            </int32.hradio>
         </params>
         <attribs>
            <combo name="size">
               <MenuEntries>
                  <string>256 (5.33ms)</string>
                  <string>512 (10.66ms)</string>
                  <string>1024 (21.33ms)</string>
                  <string>2048 (42.66ms)</string>
                  <string>4096 (85.33ms)</string>
                  <string>8192 (170ms)</string>
                  <string>16384 (341ms)</string>
                  <string>32768 (682ms)</string>
                  <string>65536 (1.36s)</string>
                  <string>131072 (2.73s)</string>
                  <string>262144 (5.46s)</string>
                  <string>524288 (10.9s)</string>
                  <string>1048576 (21.8s)</string>
                  <string>2097152 (43.7s)</string>
               </MenuEntries>
               <CEntries>
                  <string>8</string>
                  <string>9</string>
                  <string>10</string>
                  <string>11</string>
                  <string>12</string>
                  <string>13</string>
                  <string>14</string>
                  <string>15</string>
                  <string>16</string>
                  <string>17</string>
                  <string>18</string>
                  <string>19</string>
                  <string>20</string>
                  <string>21</string>
               </CEntries>
            </combo>
            <objref name="del1"/>
            <objref name="del2"/>
            <objref name="del3"/>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[static const uint32_t LENGTHPOW = (attr_size);
static const uint32_t LENGTH = (1<<attr_size);
static const uint32_t LENGTHMASK = ((1<<attr_size)-1);
int16_t *array;
uint32_t writepos;]]></code.declaration>
         <code.init><![CDATA[static int16_t _array[attr_poly][1<<attr_size]  __attribute__ ((section (".sdram")));
array = &_array[parent->polyIndex][0];
   int i;
   writepos = 0;
   for(i=0;i<LENGTH;i++) array[i] = 0;]]></code.init>
         <code.krate><![CDATA[int32_t scatter=__USAT(param_scatter,27)<<4;
int32_t wp=0;

int32_t POS;

switch(param_select)
{
	case 0: POS=attr_del1.writepos-BUFSIZE-1-1; break;
	case 1: POS=attr_del2.writepos-BUFSIZE-1-1; break;
	case 2: POS=attr_del3.writepos-BUFSIZE-1-1; break;
}]]></code.krate>
         <code.srate><![CDATA[if(param_mode>0){
int32_t sz=__USAT(param_size+inlet_size,27);
int32_t size=sz>>27-LENGTHPOW;
int32_t mix=((uint32_t)sz<<5+LENGTHPOW)>>1;

int32_t in;
switch(param_select)
{
	case 0:	in=attr_del1.array[POS]<<14;break;
	case 1:	in=attr_del2.array[POS]<<14;break;
	case 2:	in=attr_del3.array[POS]<<14;break;
}
int32_t t1,t2,t3;
t2=___SMMUL(in,scatter)<<1;
t3=array[(writepos-size)&LENGTHMASK]<<14;
t3+=___SMMUL((array[(writepos-size)&LENGTHMASK]<<14)-t3,mix)<<1;
t1=___SMMUL(t3,scatter)<<1;

array[writepos] = __SSAT(in+(param_mode>1?0:t2)-t1>>14,16);
int32_t out;
if(param_mode==1){
	out = __SSAT(t2+t3-t1>>14,16);
}
else{
	out=__SSAT(___SMMUL(in-t1<<1,scatter)+t3>>14,16);
}

switch(param_select)
{
	case 0: attr_del1.array[POS]=out; break;
	case 1: attr_del2.array[POS]=out; break;
	case 2: attr_del3.array[POS]=out; break;
}

writepos = (writepos + 1)&LENGTHMASK;
switch(param_select)
{
	case 0: POS=(POS+1)&attr_del1.LENGTHMASK; break;
	case 1: POS=(POS+1)&attr_del2.LENGTHMASK; break;
	case 2: POS=(POS+1)&attr_del3.LENGTHMASK; break;
}
}]]></code.srate>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="2b6e9d3e-762f-48b8-befd-28527c74cded" name="nested_6" x="1302" y="742">
      <params>
         <frac32.u.map name="scatter" value="58.0"/>
         <frac32.u.map name="size" value="25.199999809265137"/>
         <int32.hradio name="mode" value="2"/>
         <int32.hradio name="select" value="0"/>
      </params>
      <attribs>
         <combo attributeName="size" selection="2048 (42.66ms)"/>
         <objref attributeName="del1" obj="delay_record_right"/>
         <objref attributeName="del2" obj="nested_2"/>
         <objref attributeName="del3" obj="nested_4"/>
      </attribs>
      <object id="patch/object" uuid="2b6e9d3e-762f-48b8-befd-28527c74cded">
         <sDescription>modulatable nested scatter/allpass function for delaylines.
Can be used with the factory delayline module to add diffusion to a delay</sDescription>
         <author>Remco van der Most</author>
         <license>BSD</license>
         <helpPatch>delay.axh</helpPatch>
         <inlets>
            <frac32buffer name="size"/>
         </inlets>
         <outlets/>
         <displays/>
         <params>
            <frac32.u.map name="scatter"/>
            <frac32.u.map name="size"/>
            <int32.hradio name="mode" description="off,scatter,allpass">
               <MaxValue i="3"/>
            </int32.hradio>
            <int32.hradio name="select">
               <MaxValue i="3"/>
            </int32.hradio>
         </params>
         <attribs>
            <combo name="size">
               <MenuEntries>
                  <string>256 (5.33ms)</string>
                  <string>512 (10.66ms)</string>
                  <string>1024 (21.33ms)</string>
                  <string>2048 (42.66ms)</string>
                  <string>4096 (85.33ms)</string>
                  <string>8192 (170ms)</string>
                  <string>16384 (341ms)</string>
                  <string>32768 (682ms)</string>
                  <string>65536 (1.36s)</string>
                  <string>131072 (2.73s)</string>
                  <string>262144 (5.46s)</string>
                  <string>524288 (10.9s)</string>
                  <string>1048576 (21.8s)</string>
                  <string>2097152 (43.7s)</string>
               </MenuEntries>
               <CEntries>
                  <string>8</string>
                  <string>9</string>
                  <string>10</string>
                  <string>11</string>
                  <string>12</string>
                  <string>13</string>
                  <string>14</string>
                  <string>15</string>
                  <string>16</string>
                  <string>17</string>
                  <string>18</string>
                  <string>19</string>
                  <string>20</string>
                  <string>21</string>
               </CEntries>
            </combo>
            <objref name="del1"/>
            <objref name="del2"/>
            <objref name="del3"/>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[static const uint32_t LENGTHPOW = (attr_size);
static const uint32_t LENGTH = (1<<attr_size);
static const uint32_t LENGTHMASK = ((1<<attr_size)-1);
int16_t *array;
uint32_t writepos;]]></code.declaration>
         <code.init><![CDATA[static int16_t _array[attr_poly][1<<attr_size]  __attribute__ ((section (".sdram")));
array = &_array[parent->polyIndex][0];
   int i;
   writepos = 0;
   for(i=0;i<LENGTH;i++) array[i] = 0;]]></code.init>
         <code.krate><![CDATA[int32_t scatter=__USAT(param_scatter,27)<<4;
int32_t wp=0;

int32_t POS;

switch(param_select)
{
	case 0: POS=attr_del1.writepos-BUFSIZE-1-1; break;
	case 1: POS=attr_del2.writepos-BUFSIZE-1-1; break;
	case 2: POS=attr_del3.writepos-BUFSIZE-1-1; break;
}]]></code.krate>
         <code.srate><![CDATA[if(param_mode>0){
int32_t sz=__USAT(param_size+inlet_size,27);
int32_t size=sz>>27-LENGTHPOW;
int32_t mix=((uint32_t)sz<<5+LENGTHPOW)>>1;

int32_t in;
switch(param_select)
{
	case 0:	in=attr_del1.array[POS]<<14;break;
	case 1:	in=attr_del2.array[POS]<<14;break;
	case 2:	in=attr_del3.array[POS]<<14;break;
}
int32_t t1,t2,t3;
t2=___SMMUL(in,scatter)<<1;
t3=array[(writepos-size)&LENGTHMASK]<<14;
t3+=___SMMUL((array[(writepos-size)&LENGTHMASK]<<14)-t3,mix)<<1;
t1=___SMMUL(t3,scatter)<<1;

array[writepos] = __SSAT(in+(param_mode>1?0:t2)-t1>>14,16);
int32_t out;
if(param_mode==1){
	out = __SSAT(t2+t3-t1>>14,16);
}
else{
	out=__SSAT(___SMMUL(in-t1<<1,scatter)+t3>>14,16);
}

switch(param_select)
{
	case 0: attr_del1.array[POS]=out; break;
	case 1: attr_del2.array[POS]=out; break;
	case 2: attr_del3.array[POS]=out; break;
}

writepos = (writepos + 1)&LENGTHMASK;
switch(param_select)
{
	case 0: POS=(POS+1)&attr_del1.LENGTHMASK; break;
	case 1: POS=(POS+1)&attr_del2.LENGTHMASK; break;
	case 2: POS=(POS+1)&attr_del3.LENGTHMASK; break;
}
}]]></code.srate>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="2b6e9d3e-762f-48b8-befd-28527c74cded" name="nested_7" x="1428" y="742">
      <params>
         <frac32.u.map name="scatter" value="48.0"/>
         <frac32.u.map name="size" value="22.044999599456787"/>
         <int32.hradio name="mode" value="2"/>
         <int32.hradio name="select" value="3"/>
      </params>
      <attribs>
         <combo attributeName="size" selection="16384 (341ms)"/>
         <objref attributeName="del1" obj="delay_record_left"/>
         <objref attributeName="del2" obj="nested_1"/>
         <objref attributeName="del3" obj="nested_3"/>
         <objref attributeName="del4" obj="delay_record_left"/>
      </attribs>
      <object id="patch/object" uuid="2b6e9d3e-762f-48b8-befd-28527c74cded">
         <sDescription>modulatable nested scatter/allpass function for delaylines.
Can be used with the factory delayline module to add diffusion to a delay</sDescription>
         <author>Remco van der Most</author>
         <license>BSD</license>
         <helpPatch>delay.axh</helpPatch>
         <inlets>
            <frac32buffer name="size"/>
         </inlets>
         <outlets/>
         <displays/>
         <params>
            <frac32.u.map name="scatter"/>
            <frac32.u.map name="size"/>
            <int32.hradio name="mode" description="off,scatter,allpass">
               <MaxValue i="3"/>
            </int32.hradio>
            <int32.hradio name="select">
               <MaxValue i="4"/>
            </int32.hradio>
         </params>
         <attribs>
            <combo name="size">
               <MenuEntries>
                  <string>256 (5.33ms)</string>
                  <string>512 (10.66ms)</string>
                  <string>1024 (21.33ms)</string>
                  <string>2048 (42.66ms)</string>
                  <string>4096 (85.33ms)</string>
                  <string>8192 (170ms)</string>
                  <string>16384 (341ms)</string>
                  <string>32768 (682ms)</string>
                  <string>65536 (1.36s)</string>
                  <string>131072 (2.73s)</string>
                  <string>262144 (5.46s)</string>
                  <string>524288 (10.9s)</string>
                  <string>1048576 (21.8s)</string>
                  <string>2097152 (43.7s)</string>
               </MenuEntries>
               <CEntries>
                  <string>8</string>
                  <string>9</string>
                  <string>10</string>
                  <string>11</string>
                  <string>12</string>
                  <string>13</string>
                  <string>14</string>
                  <string>15</string>
                  <string>16</string>
                  <string>17</string>
                  <string>18</string>
                  <string>19</string>
                  <string>20</string>
                  <string>21</string>
               </CEntries>
            </combo>
            <objref name="del1"/>
            <objref name="del2"/>
            <objref name="del3"/>
            <objref name="del4"/>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[static const uint32_t LENGTHPOW = (attr_size);
static const uint32_t LENGTH = (1<<attr_size);
static const uint32_t LENGTHMASK = ((1<<attr_size)-1);
int16_t *array;
uint32_t writepos;]]></code.declaration>
         <code.init><![CDATA[static int16_t _array[attr_poly][1<<attr_size]  __attribute__ ((section (".sdram")));
array = &_array[parent->polyIndex][0];
   int i;
   writepos = 0;
   for(i=0;i<LENGTH;i++) array[i] = 0;]]></code.init>
         <code.krate><![CDATA[int32_t scatter=__USAT(param_scatter,27)<<4;
int32_t wp=0;

int32_t POS;

switch(param_select)
{
	case 0: POS=attr_del1.writepos-BUFSIZE-1-1; break;
	case 1: POS=attr_del2.writepos-BUFSIZE-1-1; break;
	case 2: POS=attr_del3.writepos-BUFSIZE-1-1; break;
	case 3: POS=attr_del4.writepos-BUFSIZE-1-1; break;
}]]></code.krate>
         <code.srate><![CDATA[if(param_mode>0){
int32_t sz=__USAT(param_size+inlet_size,27);
int32_t size=sz>>27-LENGTHPOW;
int32_t mix=((uint32_t)sz<<5+LENGTHPOW)>>1;

int32_t in;
switch(param_select)
{
	case 0:	in=attr_del1.array[POS]<<14;break;
	case 1:	in=attr_del2.array[POS]<<14;break;
	case 2:	in=attr_del3.array[POS]<<14;break;
	case 3:	in=attr_del4.array[POS]<<14;break;
}
int32_t t1,t2,t3;
t2=___SMMUL(in,scatter)<<1;
t3=array[(writepos-size)&LENGTHMASK]<<14;
t3+=___SMMUL((array[(writepos-size)&LENGTHMASK]<<14)-t3,mix)<<1;
t1=___SMMUL(t3,scatter)<<1;

array[writepos] = __SSAT(in+(param_mode>1?0:t2)-t1>>14,16);
int32_t out;
if(param_mode==1){
	out = __SSAT(t2+t3-t1>>14,16);
}
else{
	out=__SSAT(___SMMUL(in-t1<<1,scatter)+t3>>14,16);
}

switch(param_select)
{
	case 0: attr_del1.array[POS]=out; break;
	case 1: attr_del2.array[POS]=out; break;
	case 2: attr_del3.array[POS]=out; break;
	case 3: attr_del4.array[POS]=out; break;
}

writepos = (writepos + 1)&LENGTHMASK;
switch(param_select)
{
	case 0: POS=(POS+1)&attr_del1.LENGTHMASK; break;
	case 1: POS=(POS+1)&attr_del2.LENGTHMASK; break;
	case 2: POS=(POS+1)&attr_del3.LENGTHMASK; break;
	case 3: POS=(POS+1)&attr_del4.LENGTHMASK; break;
}
}]]></code.srate>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="2b6e9d3e-762f-48b8-befd-28527c74cded" name="nested_8" x="1554" y="742">
      <params>
         <frac32.u.map name="scatter" value="50.5"/>
         <frac32.u.map name="size" value="23.8149995803833"/>
         <int32.hradio name="mode" value="2"/>
         <int32.hradio name="select" value="3"/>
      </params>
      <attribs>
         <combo attributeName="size" selection="16384 (341ms)"/>
         <objref attributeName="del1" obj="delay_record_right"/>
         <objref attributeName="del2" obj="nested_2"/>
         <objref attributeName="del3" obj="nested_4"/>
         <objref attributeName="del4" obj="delay_record_right"/>
      </attribs>
      <object id="patch/object" uuid="2b6e9d3e-762f-48b8-befd-28527c74cded">
         <sDescription>modulatable nested scatter/allpass function for delaylines.
Can be used with the factory delayline module to add diffusion to a delay</sDescription>
         <author>Remco van der Most</author>
         <license>BSD</license>
         <helpPatch>delay.axh</helpPatch>
         <inlets>
            <frac32buffer name="size"/>
         </inlets>
         <outlets/>
         <displays/>
         <params>
            <frac32.u.map name="scatter"/>
            <frac32.u.map name="size"/>
            <int32.hradio name="mode" description="off,scatter,allpass">
               <MaxValue i="3"/>
            </int32.hradio>
            <int32.hradio name="select">
               <MaxValue i="4"/>
            </int32.hradio>
         </params>
         <attribs>
            <combo name="size">
               <MenuEntries>
                  <string>256 (5.33ms)</string>
                  <string>512 (10.66ms)</string>
                  <string>1024 (21.33ms)</string>
                  <string>2048 (42.66ms)</string>
                  <string>4096 (85.33ms)</string>
                  <string>8192 (170ms)</string>
                  <string>16384 (341ms)</string>
                  <string>32768 (682ms)</string>
                  <string>65536 (1.36s)</string>
                  <string>131072 (2.73s)</string>
                  <string>262144 (5.46s)</string>
                  <string>524288 (10.9s)</string>
                  <string>1048576 (21.8s)</string>
                  <string>2097152 (43.7s)</string>
               </MenuEntries>
               <CEntries>
                  <string>8</string>
                  <string>9</string>
                  <string>10</string>
                  <string>11</string>
                  <string>12</string>
                  <string>13</string>
                  <string>14</string>
                  <string>15</string>
                  <string>16</string>
                  <string>17</string>
                  <string>18</string>
                  <string>19</string>
                  <string>20</string>
                  <string>21</string>
               </CEntries>
            </combo>
            <objref name="del1"/>
            <objref name="del2"/>
            <objref name="del3"/>
            <objref name="del4"/>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[static const uint32_t LENGTHPOW = (attr_size);
static const uint32_t LENGTH = (1<<attr_size);
static const uint32_t LENGTHMASK = ((1<<attr_size)-1);
int16_t *array;
uint32_t writepos;]]></code.declaration>
         <code.init><![CDATA[static int16_t _array[attr_poly][1<<attr_size]  __attribute__ ((section (".sdram")));
array = &_array[parent->polyIndex][0];
   int i;
   writepos = 0;
   for(i=0;i<LENGTH;i++) array[i] = 0;]]></code.init>
         <code.krate><![CDATA[int32_t scatter=__USAT(param_scatter,27)<<4;
int32_t wp=0;

int32_t POS;

switch(param_select)
{
	case 0: POS=attr_del1.writepos-BUFSIZE-1-1; break;
	case 1: POS=attr_del2.writepos-BUFSIZE-1-1; break;
	case 2: POS=attr_del3.writepos-BUFSIZE-1-1; break;
	case 3: POS=attr_del4.writepos-BUFSIZE-1-1; break;
}]]></code.krate>
         <code.srate><![CDATA[if(param_mode>0){
int32_t sz=__USAT(param_size+inlet_size,27);
int32_t size=sz>>27-LENGTHPOW;
int32_t mix=((uint32_t)sz<<5+LENGTHPOW)>>1;

int32_t in;
switch(param_select)
{
	case 0:	in=attr_del1.array[POS]<<14;break;
	case 1:	in=attr_del2.array[POS]<<14;break;
	case 2:	in=attr_del3.array[POS]<<14;break;
	case 3:	in=attr_del4.array[POS]<<14;break;
}
int32_t t1,t2,t3;
t2=___SMMUL(in,scatter)<<1;
t3=array[(writepos-size)&LENGTHMASK]<<14;
t3+=___SMMUL((array[(writepos-size)&LENGTHMASK]<<14)-t3,mix)<<1;
t1=___SMMUL(t3,scatter)<<1;

array[writepos] = __SSAT(in+(param_mode>1?0:t2)-t1>>14,16);
int32_t out;
if(param_mode==1){
	out = __SSAT(t2+t3-t1>>14,16);
}
else{
	out=__SSAT(___SMMUL(in-t1<<1,scatter)+t3>>14,16);
}

switch(param_select)
{
	case 0: attr_del1.array[POS]=out; break;
	case 1: attr_del2.array[POS]=out; break;
	case 2: attr_del3.array[POS]=out; break;
	case 3: attr_del4.array[POS]=out; break;
}

writepos = (writepos + 1)&LENGTHMASK;
switch(param_select)
{
	case 0: POS=(POS+1)&attr_del1.LENGTHMASK; break;
	case 1: POS=(POS+1)&attr_del2.LENGTHMASK; break;
	case 2: POS=(POS+1)&attr_del3.LENGTHMASK; break;
	case 3: POS=(POS+1)&attr_del4.LENGTHMASK; break;
}
}]]></code.srate>
      </object>
   </patchobj>
   <nets>
      <net>
         <source obj="square_1" outlet="wave"/>
         <dest obj="counter_7" inlet="trig"/>
         <dest obj="counter_9" inlet="trig"/>
         <dest obj="counter_11" inlet="trig"/>
         <dest obj="counter_1" inlet="trig"/>
         <dest obj="square_2" inlet="reset"/>
      </net>
      <net>
         <source obj="counter_1" outlet="o"/>
         <dest obj="recycle" inlet="maincount"/>
      </net>
      <net>
         <source obj="counter_1" outlet="c"/>
         <dest obj="counter_6" inlet="trig"/>
         <dest obj="burst generator" inlet="r"/>
      </net>
      <net>
         <source obj="counter_7" outlet="c"/>
         <dest obj="counter_8" inlet="trig"/>
      </net>
      <net>
         <source obj="counter_9" outlet="c"/>
         <dest obj="counter_10" inlet="trig"/>
      </net>
      <net>
         <source obj="counter_11" outlet="c"/>
         <dest obj="counter_12" inlet="trig"/>
      </net>
      <net>
         <source obj="counter_10" outlet="o"/>
         <dest obj="recycle" inlet="count1"/>
      </net>
      <net>
         <source obj="counter_8" outlet="o"/>
         <dest obj="recycle" inlet="count2"/>
      </net>
      <net>
         <source obj="counter_12" outlet="o"/>
         <dest obj="recycle" inlet="count3"/>
      </net>
      <net>
         <source obj="counter_6" outlet="o"/>
         <dest obj="recycle" inlet="count4"/>
      </net>
      <net>
         <source obj="i_3" outlet="out"/>
         <dest obj="note_3" inlet="offset"/>
      </net>
      <net>
         <source obj="mix_3" outlet="out"/>
         <dest obj="note_3" inlet="note"/>
      </net>
      <net>
         <source obj="note_3" outlet="note"/>
         <dest obj="latch_2" inlet="i"/>
      </net>
      <net>
         <source obj="recycle" outlet="o1"/>
         <dest obj="mix_3" inlet="in1"/>
      </net>
      <net>
         <source obj="recycle" outlet="o2"/>
         <dest obj="mix_3" inlet="in2"/>
      </net>
      <net>
         <source obj="latch_2" outlet="o"/>
         <dest obj="interp_1" inlet="i"/>
      </net>
      <net>
         <source obj="volume" outlet="out"/>
         <dest obj="mix_2" inlet="bus_in"/>
         <dest obj="mix_4" inlet="bus_in"/>
         <dest obj="mix_5" inlet="bus_in"/>
         <dest obj="mix_1" inlet="bus_in"/>
         <dest obj="early reflections" inlet="in"/>
         <dest obj="early reflections__" inlet="in"/>
      </net>
      <net>
         <source obj="mix_1" outlet="out"/>
         <dest obj="delay_record_left" inlet="in"/>
      </net>
      <net>
         <source obj="mix_2" outlet="out"/>
         <dest obj="delay_record_right" inlet="in"/>
      </net>
      <net>
         <source obj="sine_1" outlet="wave"/>
         <dest obj="*c_2" inlet="in"/>
      </net>
      <net>
         <source obj="*c_2" outlet="out"/>
         <dest obj="inv_1" inlet="in"/>
         <dest obj="nested_1" inlet="size"/>
      </net>
      <net>
         <source obj="sine_2" outlet="wave"/>
         <dest obj="*c_3" inlet="in"/>
      </net>
      <net>
         <source obj="*c_3" outlet="out"/>
         <dest obj="inv_2" inlet="in"/>
         <dest obj="nested_7" inlet="size"/>
      </net>
      <net>
         <source obj="sine_3" outlet="wave"/>
         <dest obj="*c_4" inlet="in"/>
      </net>
      <net>
         <source obj="inv_1" outlet="out"/>
         <dest obj="nested_2" inlet="size"/>
      </net>
      <net>
         <source obj="inv_2" outlet="out"/>
         <dest obj="nested_8" inlet="size"/>
      </net>
      <net>
         <source obj="*c_4" outlet="out"/>
         <dest obj="inv_3" inlet="in"/>
         <dest obj="nested_5" inlet="size"/>
      </net>
      <net>
         <source obj="inv_3" outlet="out"/>
         <dest obj="nested_6" inlet="size"/>
      </net>
      <net>
         <source obj="sine_4" outlet="wave"/>
         <dest obj="*c_5" inlet="in"/>
      </net>
      <net>
         <source obj="*c_5" outlet="out"/>
         <dest obj="inv_4" inlet="in"/>
         <dest obj="nested_3" inlet="size"/>
      </net>
      <net>
         <source obj="inv_4" outlet="out"/>
         <dest obj="nested_4" inlet="size"/>
      </net>
      <net>
         <source obj="burst generator" outlet="gate"/>
         <dest obj="latch_2" inlet="trig"/>
         <dest obj="envelope" inlet="trig"/>
      </net>
      <net>
         <source obj="counter_6" outlet="c"/>
         <dest obj="burst generator" inlet="rnd"/>
      </net>
      <net>
         <source obj="square_2" outlet="wave"/>
         <dest obj="burst generator" inlet="trig"/>
      </net>
      <net>
         <source obj="envelope" outlet="env"/>
         <dest obj="*_1" inlet="a"/>
      </net>
      <net>
         <source obj="recycle" outlet="o8"/>
         <dest obj="envelope" inlet="a"/>
      </net>
      <net>
         <source obj="recycle" outlet="o9"/>
         <dest obj="envelope" inlet="d"/>
      </net>
      <net>
         <source obj="recycle" outlet="o10"/>
         <dest obj="envelope" inlet="skew"/>
      </net>
      <net>
         <source obj="recycle" outlet="o11"/>
         <dest obj="envelope" inlet="shift"/>
      </net>
      <net>
         <source obj="recycle" outlet="o12"/>
         <dest obj="envelope" inlet="expo"/>
      </net>
      <net>
         <source obj="read_1" outlet="out"/>
         <dest obj="mix_4" inlet="in1"/>
      </net>
      <net>
         <source obj="read_2" outlet="out"/>
         <dest obj="mix_5" inlet="in1"/>
      </net>
      <net>
         <source obj="mix_4" outlet="out"/>
         <dest obj="out_1" inlet="left"/>
      </net>
      <net>
         <source obj="mix_5" outlet="out"/>
         <dest obj="out_1" inlet="right"/>
      </net>
      <net>
         <source obj="sine_5" outlet="wave"/>
         <dest obj="&gt;&gt;_1" inlet="a"/>
      </net>
      <net>
         <source obj="*c_7" outlet="out"/>
         <dest obj="inv_6" inlet="in"/>
         <dest obj="read_1" inlet="time"/>
      </net>
      <net>
         <source obj="inv_6" outlet="out"/>
         <dest obj="read_2" inlet="time"/>
      </net>
      <net>
         <source obj="&gt;&gt;_1" outlet="result"/>
         <dest obj="*c_7" inlet="in"/>
      </net>
      <net>
         <source obj="sine_6" outlet="wave"/>
         <dest obj="*_1" inlet="b"/>
      </net>
      <net>
         <source obj="sine_7" outlet="wave"/>
         <dest obj="&gt;&gt;_2" inlet="a"/>
      </net>
      <net>
         <source obj="&gt;&gt;_2" outlet="result"/>
         <dest obj="*c_8" inlet="in"/>
      </net>
      <net>
         <source obj="inv_5" outlet="out"/>
         <dest obj="read_5" inlet="time"/>
      </net>
      <net>
         <source obj="read_3" outlet="out"/>
         <dest obj="lp1_2" inlet="in"/>
      </net>
      <net>
         <source obj="*c_8" outlet="out"/>
         <dest obj="inv_5" inlet="in"/>
         <dest obj="read_3" inlet="time"/>
      </net>
      <net>
         <source obj="interp_1" outlet="o"/>
         <dest obj="lp1_1" inlet="in"/>
      </net>
      <net>
         <source obj="lp1_1" outlet="out"/>
         <dest obj="sine_6" inlet="pitch"/>
      </net>
      <net>
         <source obj="*_1" outlet="result"/>
         <dest obj="volume" inlet="in"/>
      </net>
      <net>
         <source obj="recycle" outlet="o13"/>
         <dest obj="lp1_1" inlet="freq"/>
      </net>
      <net>
         <source obj="read_5" outlet="out"/>
         <dest obj="lp1_3" inlet="in"/>
      </net>
      <net>
         <source obj="lp1_2" outlet="out"/>
         <dest obj="mix_1" inlet="in1"/>
      </net>
      <net>
         <source obj="lp1_3" outlet="out"/>
         <dest obj="mix_2" inlet="in1"/>
      </net>
      <net>
         <source obj="recycle" outlet="o3"/>
         <dest obj="sine_1" inlet="pitch"/>
      </net>
      <net>
         <source obj="recycle" outlet="o4"/>
         <dest obj="sine_4" inlet="pitch"/>
      </net>
      <net>
         <source obj="recycle" outlet="o5"/>
         <dest obj="sine_3" inlet="pitch"/>
      </net>
      <net>
         <source obj="recycle" outlet="o6"/>
         <dest obj="sine_2" inlet="pitch"/>
      </net>
      <net>
         <source obj="recycle" outlet="o7"/>
         <dest obj="sine_5" inlet="pitch"/>
      </net>
      <net>
         <source obj="recycle" outlet="o14"/>
         <dest obj="sine_7" inlet="pitch"/>
      </net>
   </nets>
   <settings>
      <subpatchmode>no</subpatchmode>
   </settings>
   <notes><![CDATA[]]></notes>
   <windowPos>
      <x>-8</x>
      <y>-8</y>
      <width>1857</width>
      <height>1096</height>
   </windowPos>
</patch-1.0>