<patch-1.0 appVersion="1.0.12">
   <obj type="lfo/square" uuid="de6909eb64db13af5b43f979a4c130024b3a4793" name="square_1" x="42" y="0">
      <params>
         <frac32.s.map name="pitch" value="8.0"/>
      </params>
      <attribs/>
   </obj>
   <patchobj type="patch/object" uuid="5b8f4143-0cd6-4160-8b43-037752ab4167" name="counter_1" x="140" y="0">
      <params>
         <int32 name="maximum" value="16"/>
      </params>
      <attribs/>
      <object id="patch/object" uuid="5b8f4143-0cd6-4160-8b43-037752ab4167">
         <sDescription>cyclic up counter</sDescription>
         <author>Johannes Taelman</author>
         <license>BSD</license>
         <helpPatch>counter.axh</helpPatch>
         <inlets>
            <bool32.rising name="trig" description="trigger"/>
            <bool32.rising name="r" description="reset"/>
         </inlets>
         <outlets>
            <int32 name="o" description="output"/>
            <bool32.pulse name="c" description="carry pulse"/>
         </outlets>
         <displays/>
         <params>
            <int32 name="maximum" noLabel="true">
               <MinValue i="0"/>
               <MaxValue i="65536"/>
            </int32>
         </params>
         <attribs/>
         <includes/>
         <code.declaration><![CDATA[   int ntrig;
   int rtrig;
   int count;
]]></code.declaration>
         <code.init><![CDATA[count=-1;
   ntrig = 0;
   rtrig = 0;]]></code.init>
         <code.krate><![CDATA[outlet_c=0;
if ((inlet_trig>0) && !ntrig) {
   count += 1; if (count>=param_maximum) {count = 0; outlet_c = 1;}
   ntrig=1;
}
else if (!(inlet_trig>0)) ntrig=0;
if ((inlet_r>0) && !rtrig) {count=0; rtrig = 1;}
else if (!(inlet_r>0)) rtrig=0;
outlet_o= count;
]]></code.krate>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="5b8f4143-0cd6-4160-8b43-037752ab4167" name="counter_4" x="266" y="14">
      <params>
         <int32 name="maximum" value="2"/>
      </params>
      <attribs/>
      <object id="patch/object" uuid="5b8f4143-0cd6-4160-8b43-037752ab4167">
         <sDescription>cyclic up counter</sDescription>
         <author>Johannes Taelman</author>
         <license>BSD</license>
         <helpPatch>counter.axh</helpPatch>
         <inlets>
            <bool32.rising name="trig" description="trigger"/>
            <bool32.rising name="r" description="reset"/>
         </inlets>
         <outlets>
            <int32 name="o" description="output"/>
            <bool32.pulse name="c" description="carry pulse"/>
         </outlets>
         <displays/>
         <params>
            <int32 name="maximum" noLabel="true">
               <MinValue i="0"/>
               <MaxValue i="65536"/>
            </int32>
         </params>
         <attribs/>
         <includes/>
         <code.declaration><![CDATA[   int ntrig;
   int rtrig;
   int count;
]]></code.declaration>
         <code.init><![CDATA[count=-1;
   ntrig = 0;
   rtrig = 0;]]></code.init>
         <code.krate><![CDATA[outlet_c=0;
if ((inlet_trig>0) && !ntrig) {
   count += 1; if (count>=param_maximum) {count = 0; outlet_c = 1;}
   ntrig=1;
}
else if (!(inlet_trig>0)) ntrig=0;
if ((inlet_r>0) && !rtrig) {count=0; rtrig = 1;}
else if (!(inlet_r>0)) rtrig=0;
outlet_o= count;
]]></code.krate>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="5b8f4143-0cd6-4160-8b43-037752ab4167" name="counter_3" x="350" y="14">
      <params>
         <int32 name="maximum" value="16"/>
      </params>
      <attribs/>
      <object id="patch/object" uuid="5b8f4143-0cd6-4160-8b43-037752ab4167">
         <sDescription>cyclic up counter</sDescription>
         <author>Johannes Taelman</author>
         <license>BSD</license>
         <helpPatch>counter.axh</helpPatch>
         <inlets>
            <bool32.rising name="trig" description="trigger"/>
            <bool32.rising name="r" description="reset"/>
         </inlets>
         <outlets>
            <int32 name="o" description="output"/>
            <bool32.pulse name="c" description="carry pulse"/>
         </outlets>
         <displays/>
         <params>
            <int32 name="maximum" noLabel="true">
               <MinValue i="0"/>
               <MaxValue i="65536"/>
            </int32>
         </params>
         <attribs/>
         <includes/>
         <code.declaration><![CDATA[   int ntrig;
   int rtrig;
   int count;
]]></code.declaration>
         <code.init><![CDATA[count=-1;
   ntrig = 0;
   rtrig = 0;]]></code.init>
         <code.krate><![CDATA[outlet_c=0;
if ((inlet_trig>0) && !ntrig) {
   count += 1; if (count>=param_maximum) {count = 0; outlet_c = 1;}
   ntrig=1;
}
else if (!(inlet_trig>0)) ntrig=0;
if ((inlet_r>0) && !rtrig) {count=0; rtrig = 1;}
else if (!(inlet_r>0)) rtrig=0;
outlet_o= count;
]]></code.krate>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="5b8f4143-0cd6-4160-8b43-037752ab4167" name="counter_2" x="434" y="14">
      <params>
         <int32 name="maximum" value="4"/>
      </params>
      <attribs/>
      <object id="patch/object" uuid="5b8f4143-0cd6-4160-8b43-037752ab4167">
         <sDescription>cyclic up counter</sDescription>
         <author>Johannes Taelman</author>
         <license>BSD</license>
         <helpPatch>counter.axh</helpPatch>
         <inlets>
            <bool32.rising name="trig" description="trigger"/>
            <bool32.rising name="r" description="reset"/>
         </inlets>
         <outlets>
            <int32 name="o" description="output"/>
            <bool32.pulse name="c" description="carry pulse"/>
         </outlets>
         <displays/>
         <params>
            <int32 name="maximum" noLabel="true">
               <MinValue i="0"/>
               <MaxValue i="65536"/>
            </int32>
         </params>
         <attribs/>
         <includes/>
         <code.declaration><![CDATA[   int ntrig;
   int rtrig;
   int count;
]]></code.declaration>
         <code.init><![CDATA[count=-1;
   ntrig = 0;
   rtrig = 0;]]></code.init>
         <code.krate><![CDATA[outlet_c=0;
if ((inlet_trig>0) && !ntrig) {
   count += 1; if (count>=param_maximum) {count = 0; outlet_c = 1;}
   ntrig=1;
}
else if (!(inlet_trig>0)) ntrig=0;
if ((inlet_r>0) && !rtrig) {count=0; rtrig = 1;}
else if (!(inlet_r>0)) rtrig=0;
outlet_o= count;
]]></code.krate>
      </object>
   </patchobj>
   <obj type="sss/patt/basePatt" uuid="ecfda10d-6ec1-4a2f-9df8-8ee81763ce5b" name="basePatt_3 fast_" x="350" y="196">
      <params>
         <frac32.u.map name="length" value="64.0"/>
         <frac32.u.map name="base" value="0.0"/>
         <frac32.u.map name="diffchance" value="64.0"/>
         <frac32.u.map name="differents" value="64.0"/>
         <frac32.u.map name="diffsize" value="64.0"/>
         <bool32.tgl name="nonseed" value="1"/>
      </params>
      <attribs>
         <spinner attributeName="max" value="14"/>
      </attribs>
   </obj>
   <patchobj type="patch/object" uuid="b4422a2a-0489-46b7-8824-861864b26824" name="gate pattern" x="574" y="210">
      <params>
         <bin16 name="p1" value="14326"/>
         <bin16 name="p2" value="40454"/>
         <bin16 name="p3" value="50192"/>
         <bin16 name="p4" value="37084"/>
         <bin16 name="p5" value="61109"/>
         <bin16 name="p6" value="2111"/>
         <bin16 name="p7" value="47184"/>
         <bin16 name="p8" value="11860"/>
      </params>
      <attribs>
         <objref attributeName="seq" obj="ad_1"/>
      </attribs>
      <object id="patch/object" uuid="b4422a2a-0489-46b7-8824-861864b26824">
         <sDescription>constant from 16 flags</sDescription>
         <author>Johannes Taelman</author>
         <license>BSD</license>
         <helpPatch>ctrl.axh</helpPatch>
         <inlets>
            <int32 name="count"/>
            <bool32 name="rnd"/>
         </inlets>
         <outlets>
            <frac32buffer name="gates"/>
            <bool32 name="gate"/>
         </outlets>
         <displays/>
         <params>
            <bin16 name="p1"/>
            <bin16 name="p2"/>
            <bin16 name="p3"/>
            <bin16 name="p4"/>
            <bin16 name="p5"/>
            <bin16 name="p6"/>
            <bin16 name="p7"/>
            <bin16 name="p8"/>
         </params>
         <attribs>
            <objref name="seq"/>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[int rnd;]]></code.declaration>
         <code.krate><![CDATA[if(inlet_rnd&&!rnd)
{
	rnd=1;
	int32_t tmp=(GenerateRandomNumber()&((1<<16)-1));
	for(int i=0;i<8;i++)
	{
		tmp=(tmp+(GenerateRandomNumber()&((1<<16)-1))+487946947)&((1<<16)-1);
		PExParameterChange(&parent->PExch[PARAM_INDEX_attr_legal_name_p1+i],tmp,0xFFFD);
	}
}
else if(!inlet_rnd){rnd=0;}
int cnt=inlet_count&15;
uint16_t S[8]={param_p1,param_p2,param_p3,param_p4,param_p5,param_p6,param_p7,param_p8};
int gate=0;
for(int i=0;i<8;i++)
{
	int G=(S[i]>>cnt)&1;
	outlet_gates[i]=G;
	gate=G||gate;
}
outlet_gate=gate;]]></code.krate>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="7c2ac2e9-acda-4c32-8d01-4c217232605e" name="ad_1" x="784" y="210">
      <params>
         <frac32.s.map name="from_a" value="-64.0"/>
         <frac32.s.map name="to_a" value="-30.0"/>
         <frac32.s.map name="from_d" value="-28.0"/>
         <frac32.s.map name="to_d" value="25.0"/>
         <bool32.tgl name="retrig" value="0"/>
      </params>
      <attribs/>
      <object id="patch/object" uuid="7c2ac2e9-acda-4c32-8d01-4c217232605e">
         <sDescription>Attack/decay envelope, linear attack, exponential decay</sDescription>
         <author>Johannes Taelman</author>
         <license>BSD</license>
         <helpPatch>env.axh</helpPatch>
         <inlets>
            <frac32buffer name="gates"/>
            <bool32 name="rnd"/>
         </inlets>
         <outlets>
            <frac32buffer name="env"/>
         </outlets>
         <displays/>
         <params>
            <frac32.s.map.klineartime.exp name="from_a"/>
            <frac32.s.map.kdecaytime.exp name="to_a"/>
            <frac32.s.map.klineartime.exp name="from_d"/>
            <frac32.s.map.klineartime.exp name="to_d"/>
            <bool32.tgl name="retrig"/>
         </params>
         <attribs/>
         <includes/>
         <code.declaration><![CDATA[int8_t stage[8];
int ntrig[8],rnd;
int32_t val[8];
int32_t a[8],d[8];
uint8_t seq[16];]]></code.declaration>
         <code.init><![CDATA[for(int i=0;i<8;i++)
{
a[i]=(GenerateRandomNumber()>>1);
a[i]=___SMMUL(a[i],a[i])<<1;
d[i]=(GenerateRandomNumber()>>1);
d[i]=___SMMUL(d[i],d[i])<<1;
ntrig[i] = 0;
val[i] = 0;
}
for(int i=0;i<16;i++)
{
	seq[i]=GenerateRandomNumber();
}]]></code.init>
         <code.krate><![CDATA[if(inlet_rnd&&!rnd)
{
	rnd=1;
	for(int i=0;i<8;i++)
{

a[i]=(GenerateRandomNumber()>>1);
a[i]=___SMMUL(a[i],a[i])<<1;
d[i]=(GenerateRandomNumber()>>1);
d[i]=___SMMUL(d[i],d[i])<<1;
}
for(int i=0;i<16;i++)
{
	//seq[i]=GenerateRandomNumber();
}
}
else if(!inlet_rnd){rnd=0;}



for(int i=0;i<8;i++)
{
int gate=inlet_gates[i];
if (gate&&((val[i]==0)||param_retrig) && !ntrig[i]) {
   ntrig[i] = 1;
   stage[i] = 1;
} else if (!gate) {
   ntrig[i] = 0;
}
if (stage[i] == 0){
	int32_t t;
	MTOF(-(param_from__d+___SMMUL(d[i],param_to__d-param_from__d<<1)),t)
	//t=___SMMUL(t,t)<<1;
   val[i] = __USAT(val[i]-(t>>3),31);
} else {
int32_t t;
	MTOF(-(param_from__a+___SMMUL(a[i],param_to__a-param_from__a<<1)),t)
	//t=___SMMUL(t,t)<<1;
   val[i] = val[i] + (t>>4);
   if (val[i]<0) {
      val[i] =0x7FFFFFFF;
      stage[i] = 0;
   }
}
outlet_env[i] = val[i]>>4;
}]]></code.krate>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="b4422a2a-0489-46b7-8824-861864b26824" name="gate pattern_" x="882" y="210">
      <params>
         <bin16 name="p1" value="16175"/>
         <bin16 name="p2" value="4783"/>
         <bin16 name="p3" value="59215"/>
         <bin16 name="p4" value="8413"/>
         <bin16 name="p5" value="63409"/>
         <bin16 name="p6" value="48335"/>
         <bin16 name="p7" value="65343"/>
         <bin16 name="p8" value="32488"/>
      </params>
      <attribs>
         <objref attributeName="seq" obj="ad_1"/>
      </attribs>
      <object id="patch/object" uuid="b4422a2a-0489-46b7-8824-861864b26824">
         <sDescription>constant from 16 flags</sDescription>
         <author>Johannes Taelman</author>
         <license>BSD</license>
         <helpPatch>ctrl.axh</helpPatch>
         <inlets>
            <int32 name="count"/>
            <bool32 name="rnd"/>
         </inlets>
         <outlets>
            <frac32buffer name="gates"/>
            <bool32 name="gate"/>
         </outlets>
         <displays/>
         <params>
            <bin16 name="p1"/>
            <bin16 name="p2"/>
            <bin16 name="p3"/>
            <bin16 name="p4"/>
            <bin16 name="p5"/>
            <bin16 name="p6"/>
            <bin16 name="p7"/>
            <bin16 name="p8"/>
         </params>
         <attribs>
            <objref name="seq"/>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[int rnd;]]></code.declaration>
         <code.krate><![CDATA[if(inlet_rnd&&!rnd)
{
	rnd=1;
	int32_t tmp=(GenerateRandomNumber()&((1<<16)-1));
	for(int i=0;i<8;i++)
	{
		tmp=(tmp+(GenerateRandomNumber()&((1<<16)-1))+487946947)&((1<<16)-1);
		PExParameterChange(&parent->PExch[PARAM_INDEX_attr_legal_name_p1+i],tmp,0xFFFD);
	}
}
else if(!inlet_rnd){rnd=0;}
int cnt=inlet_count&15;
uint16_t S[8]={param_p1,param_p2,param_p3,param_p4,param_p5,param_p6,param_p7,param_p8};
int gate=0;
for(int i=0;i<8;i++)
{
	int G=(S[i]>>cnt)&1;
	outlet_gates[i]=G;
	gate=G||gate;
}
outlet_gate=gate;]]></code.krate>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="7c2ac2e9-acda-4c32-8d01-4c217232605e" name="ad_2" x="1092" y="210">
      <params>
         <frac32.s.map name="from_a" value="-64.0"/>
         <frac32.s.map name="to_a" value="-30.0"/>
         <frac32.s.map name="from_d" value="-28.0"/>
         <frac32.s.map name="to_d" value="25.0"/>
         <bool32.tgl name="retrig" value="0"/>
      </params>
      <attribs/>
      <object id="patch/object" uuid="7c2ac2e9-acda-4c32-8d01-4c217232605e">
         <sDescription>Attack/decay envelope, linear attack, exponential decay</sDescription>
         <author>Johannes Taelman</author>
         <license>BSD</license>
         <helpPatch>env.axh</helpPatch>
         <inlets>
            <frac32buffer name="gates"/>
            <bool32 name="rnd"/>
         </inlets>
         <outlets>
            <frac32buffer name="env"/>
         </outlets>
         <displays/>
         <params>
            <frac32.s.map.klineartime.exp name="from_a"/>
            <frac32.s.map.kdecaytime.exp name="to_a"/>
            <frac32.s.map.klineartime.exp name="from_d"/>
            <frac32.s.map.klineartime.exp name="to_d"/>
            <bool32.tgl name="retrig"/>
         </params>
         <attribs/>
         <includes/>
         <code.declaration><![CDATA[int8_t stage[8];
int ntrig[8],rnd;
int32_t val[8];
int32_t a[8],d[8];
uint8_t seq[16];]]></code.declaration>
         <code.init><![CDATA[for(int i=0;i<8;i++)
{
a[i]=(GenerateRandomNumber()>>1);
a[i]=___SMMUL(a[i],a[i])<<1;
d[i]=(GenerateRandomNumber()>>1);
d[i]=___SMMUL(d[i],d[i])<<1;
ntrig[i] = 0;
val[i] = 0;
}
for(int i=0;i<16;i++)
{
	seq[i]=GenerateRandomNumber();
}]]></code.init>
         <code.krate><![CDATA[if(inlet_rnd&&!rnd)
{
	rnd=1;
	for(int i=0;i<8;i++)
{

a[i]=(GenerateRandomNumber()>>1);
a[i]=___SMMUL(a[i],a[i])<<1;
d[i]=(GenerateRandomNumber()>>1);
d[i]=___SMMUL(d[i],d[i])<<1;
}
for(int i=0;i<16;i++)
{
	//seq[i]=GenerateRandomNumber();
}
}
else if(!inlet_rnd){rnd=0;}



for(int i=0;i<8;i++)
{
int gate=inlet_gates[i];
if (gate&&((val[i]==0)||param_retrig) && !ntrig[i]) {
   ntrig[i] = 1;
   stage[i] = 1;
} else if (!gate) {
   ntrig[i] = 0;
}
if (stage[i] == 0){
	int32_t t;
	MTOF(-(param_from__d+___SMMUL(d[i],param_to__d-param_from__d<<1)),t)
	//t=___SMMUL(t,t)<<1;
   val[i] = __USAT(val[i]-(t>>3),31);
} else {
int32_t t;
	MTOF(-(param_from__a+___SMMUL(a[i],param_to__a-param_from__a<<1)),t)
	//t=___SMMUL(t,t)<<1;
   val[i] = val[i] + (t>>4);
   if (val[i]<0) {
      val[i] =0x7FFFFFFF;
      stage[i] = 0;
   }
}
outlet_env[i] = val[i]>>4;
}]]></code.krate>
      </object>
   </patchobj>
   <obj type="lfo/saw" uuid="ef2a162678b533c5e46c4e3c0decba17b1862d85" name="saw_1" x="588" y="504">
      <params>
         <frac32.s.map name="pitch" value="-33.0"/>
      </params>
      <attribs/>
   </obj>
   <obj type="math/*c" uuid="7d5ef61c3bcd571ee6bbd8437ef3612125dfb225" name="*c_1" x="686" y="504">
      <params>
         <frac32.u.map name="amp" value="64.0"/>
      </params>
      <attribs/>
   </obj>
   <obj type="lfo/sine" uuid="75f7330c26a13953215dccc3b7b9008545c9daa9" name="sine_4" x="784" y="504">
      <params>
         <frac32.s.map name="pitch" value="-43.0"/>
      </params>
      <attribs/>
   </obj>
   <obj type="math/*c" uuid="7d5ef61c3bcd571ee6bbd8437ef3612125dfb225" name="*c_2" x="882" y="504">
      <params>
         <frac32.u.map name="amp" value="19.0"/>
      </params>
      <attribs/>
   </obj>
   <patchobj type="patch/object" uuid="ec88ec0f-532f-4f96-93c2-02659df739c7" name="saw_2" x="1036" y="532">
      <params>
         <frac32.s.map name="pitch" value="-26.0"/>
      </params>
      <attribs/>
      <object id="patch/object" uuid="ec88ec0f-532f-4f96-93c2-02659df739c7">
         <sDescription>saw wave LFO, rising slope, pitch input</sDescription>
         <author>Johannes Taelman</author>
         <license>BSD</license>
         <helpPatch>lfo.axh</helpPatch>
         <inlets>
            <frac32.bipolar name="pitch" description="pitch"/>
            <bool32.rising name="reset" description="reset phase"/>
         </inlets>
         <outlets>
            <frac32.positive name="wave" description="saw wave"/>
         </outlets>
         <displays/>
         <params>
            <frac32.s.map.lfopitch name="pitch" noLabel="true"/>
         </params>
         <attribs/>
         <includes/>
         <code.declaration><![CDATA[uint32_t Phase;
uint32_t r;
]]></code.declaration>
         <code.init><![CDATA[Phase = 0;
   r = 1;
]]></code.init>
         <code.krate><![CDATA[{
      if (inlet_reset && r) {
         Phase = 0;
         r = 0;
      } else {
         if (!inlet_reset) r = 1;
         int32_t freq;
         MTOFEXTENDED(param_pitch + inlet_pitch,freq);
         Phase += freq>>2;
      }
      outlet_wave= (Phase)>>4;
   }]]></code.krate>
      </object>
   </patchobj>
   <obj type="osc/sine" uuid="6e094045cca76a9dbf7ebfa72e44e4700d2b3ba" name="sine_3" x="378" y="574">
      <params>
         <frac32.s.map name="pitch" value="-10.049999713897705"/>
      </params>
      <attribs/>
   </obj>
   <obj type="ctrl/dial b" uuid="862e7d7f29093cb1ce4aed72244d118ad4d46692" name="dial_1" x="280" y="588">
      <params>
         <frac32.s.map name="value" value="8.0"/>
      </params>
      <attribs/>
   </obj>
   <obj type="lfo/sine" uuid="75f7330c26a13953215dccc3b7b9008545c9daa9" name="sine_5" x="588" y="588">
      <params>
         <frac32.s.map name="pitch" value="-48.12999963760376"/>
      </params>
      <attribs/>
   </obj>
   <obj type="math/*c" uuid="7d5ef61c3bcd571ee6bbd8437ef3612125dfb225" name="*c_3" x="686" y="588">
      <params>
         <frac32.u.map name="amp" value="16.5"/>
      </params>
      <attribs/>
   </obj>
   <obj type="lfo/sine" uuid="75f7330c26a13953215dccc3b7b9008545c9daa9" name="sine_6" x="784" y="588">
      <params>
         <frac32.s.map name="pitch" value="-47.0"/>
      </params>
      <attribs/>
   </obj>
   <obj type="math/*c" uuid="7d5ef61c3bcd571ee6bbd8437ef3612125dfb225" name="*c_4" x="882" y="588">
      <params>
         <frac32.u.map name="amp" value="16.5"/>
      </params>
      <attribs/>
   </obj>
   <obj type="ctrl/dial b" uuid="862e7d7f29093cb1ce4aed72244d118ad4d46692" name="dial_2" x="504" y="602">
      <params>
         <frac32.s.map name="value" value="-14.0"/>
      </params>
      <attribs/>
   </obj>
   <obj type="math/*" uuid="c16a625a661f40e4b359db604dcd00b3befcdbe3" name="*_3" x="532" y="686">
      <params/>
      <attribs/>
   </obj>
   <patchobj type="patch/object" uuid="5f7b2c07-90cb-42fd-a6a5-30af7aadfe6a" name="sine_2" x="308" y="756">
      <params>
         <frac32.s.map name="pitch" value="-22.010000228881836"/>
         <int32 name="order" value="3"/>
         <frac32.s.map name="tilt" value="-26.0"/>
         <frac32.u.map name="hrm" value="17.0"/>
         <bool32.tgl name="qnt" value="1"/>
         <frac32.s.map name="rate" value="-39.0"/>
         <frac32.s.map name="am" value="16.0"/>
         <int32 name="skew" value="2"/>
         <int32 name="skip" value="1"/>
         <frac32.s.map name="mod" value="14.0"/>
      </params>
      <attribs/>
      <object id="patch/object" uuid="5f7b2c07-90cb-42fd-a6a5-30af7aadfe6a">
         <sDescription>sine wave oscillator</sDescription>
         <author>Johannes Taelman</author>
         <license>BSD</license>
         <helpPatch>osc.axh</helpPatch>
         <inlets>
            <frac32.bipolar name="pitch" description="pitch"/>
            <frac32buffer name="freq" description="frequency"/>
            <frac32buffer name="phase" description="phase"/>
         </inlets>
         <outlets>
            <frac32buffer.bipolar name="s" description="sine wave"/>
            <frac32buffer.bipolar name="c"/>
         </outlets>
         <displays/>
         <params>
            <frac32.s.map.pitch name="pitch" noLabel="true"/>
            <int32 name="order">
               <MinValue i="2"/>
               <MaxValue i="36"/>
            </int32>
            <frac32.s.map name="tilt"/>
            <frac32.u.map.gain16 name="hrm"/>
            <bool32.tgl name="qnt"/>
            <frac32.s.map.lfopitch name="rate"/>
            <frac32.s.map name="am"/>
            <int32 name="skew">
               <MinValue i="0"/>
               <MaxValue i="6"/>
            </int32>
            <int32 name="skip">
               <MinValue i="1"/>
               <MaxValue i="32"/>
            </int32>
            <frac32.s.map name="mod"/>
         </params>
         <attribs/>
         <includes/>
         <code.declaration><![CDATA[uint32_t Phase,morph;]]></code.declaration>
         <code.init><![CDATA[Phase = 0;]]></code.init>
         <code.krate><![CDATA[int32_t freq,rate;
MTOFEXTENDED(param_pitch + inlet_pitch,freq);
MTOFEXTENDED(param_rate + inlet_pitch,rate);
rate=rate>>11;
uint32_t skp=((uint64_t)1<<32)/param_order;
int skip=((param_skip>>1)<<1)+(!(param_order&1));

int Hrm=(param_hrm>>28);
int32_t mh=param_qnt>0?0:(((uint32_t)param_hrm<<1+3)>>1);]]></code.krate>
         <code.srate><![CDATA[Phase += freq + (___SMMUL(inlet_freq,freq)<<8);
morph+=rate;
int s1,s2;
int32_t mix;
uint32_t phs=Phase+Phase*Hrm+(___SMMUL(Phase>>1,mh)<<2)+(inlet_phase<<4);//(___SMMUL(Phase>>1,hrm)<<5);
s1=(uint64_t)phs*param_order>>32;
s2=(s1+1)%param_order;
s1*=param_skip;
s2*=param_skip;
s1*=skp;
s2*=skp;

mix=((uint32_t)phs*param_order)>>1;

int32_t a;
SINE2TINTERP(mix,a)
int32_t b;
SINE2TINTERP((1<<30)+(___SMMUL(mix,param_mod)<<9),b)
b=___SMMUL(a,___SMMUL(param_mod,b)<<5)<<1;
int32_t tlt;
tlt=(uint32_t)mix<<1;
tlt=(tlt>>1)+(tlt>>1+param_skew);
int32_t max=__SSAT(tlt,31);
tlt=max+(max-tlt<<param_skew)>>2;


int32_t r1,r2;
SINE2TINTERP(s1+morph+b,r1)
SINE2TINTERP(s2+morph+b,r2)
r1=r1>>5;
r2=r2>>5;
r1+=___SMMUL(r2-r1,mix)<<1;
r1+=___SMMUL(r1,___SMMUL(param_tilt,tlt)<<4)<<5;
r1+=___SMMUL(r1,___SMMUL(param_am,a)<<5)<<2;
outlet_s= (r1)>>1;

SINE2TINTERP(s1+(1<<30)+morph+b,r1)
SINE2TINTERP(s2+(1<<30)+morph+b,r2)
r1=r1>>5;
r2=r2>>5;
r1+=___SMMUL(r2-r1,mix)<<1;
r1+=___SMMUL(r1,___SMMUL(param_tilt,tlt)<<4)<<5;
r1+=___SMMUL(r1,___SMMUL(param_am,a)<<5)<<2;
outlet_c= (r1)>>1;]]></code.srate>
      </object>
   </patchobj>
   <obj type="math/*" uuid="c16a625a661f40e4b359db604dcd00b3befcdbe3" name="*_1" x="406" y="756">
      <params/>
      <attribs/>
   </obj>
   <obj type="math/*" uuid="c16a625a661f40e4b359db604dcd00b3befcdbe3" name="*_2" x="462" y="756">
      <params/>
      <attribs/>
   </obj>
   <patchobj type="patch/object" uuid="5f7b2c07-90cb-42fd-a6a5-30af7aadfe6a" name="stereo image osc" x="518" y="756">
      <params>
         <frac32.s.map name="pitch" value="-34.0"/>
         <frac32.s.map name="rate" value="-50.0"/>
         <int32 name="order" value="5"/>
         <frac32.s.map name="tilt" value="0.0"/>
         <frac32.u.map name="hrm" value="0.0"/>
         <bool32.tgl name="qnt" value="1"/>
         <frac32.s.map name="am" value="0.0"/>
         <int32 name="skew" value="1"/>
         <int32 name="skip" value="1"/>
         <frac32.s.map name="mod" value="-15.0"/>
      </params>
      <attribs/>
      <object id="patch/object" uuid="5f7b2c07-90cb-42fd-a6a5-30af7aadfe6a">
         <sDescription>sine wave oscillator</sDescription>
         <author>Johannes Taelman</author>
         <license>BSD</license>
         <helpPatch>osc.axh</helpPatch>
         <inlets>
            <frac32.bipolar name="pitch" description="pitch"/>
            <frac32 name="rate"/>
            <frac32 name="hrm"/>
            <frac32 name="tilt"/>
            <frac32 name="am"/>
            <frac32 name="mod"/>
            <int32 name="skew"/>
            <int32 name="skip"/>
            <frac32buffer name="freq" description="frequency"/>
            <frac32buffer name="phases" description="phase"/>
            <frac32buffer name="phasec"/>
         </inlets>
         <outlets>
            <frac32buffer.bipolar name="s" description="sine wave"/>
            <frac32buffer.bipolar name="c"/>
         </outlets>
         <displays/>
         <params>
            <frac32.s.map.pitch name="pitch" noLabel="true"/>
            <frac32.s.map.lfopitch name="rate"/>
            <int32 name="order">
               <MinValue i="2"/>
               <MaxValue i="36"/>
            </int32>
            <frac32.s.map name="tilt"/>
            <frac32.u.map name="hrm"/>
            <bool32.tgl name="qnt"/>
            <frac32.s.map name="am"/>
            <int32 name="skew">
               <MinValue i="0"/>
               <MaxValue i="6"/>
            </int32>
            <int32 name="skip">
               <MinValue i="1"/>
               <MaxValue i="32"/>
            </int32>
            <frac32.s.map name="mod"/>
         </params>
         <attribs/>
         <includes/>
         <code.declaration><![CDATA[uint32_t Phase,morph;]]></code.declaration>
         <code.init><![CDATA[Phase = 0;]]></code.init>
         <code.krate><![CDATA[int32_t freq,rate;
MTOFEXTENDED(param_pitch + inlet_pitch,freq);
MTOFEXTENDED(param_rate + inlet_rate,rate);
rate=rate>>11;
uint32_t skp=((uint64_t)1<<32)/param_order;
int Skip=__USAT(param_skip+inlet_skip,8);
int skip=((Skip>>1)<<1)+(!(param_order&1));
int32_t harm=__USAT(param_hrm+inlet_hrm,27)<<4;
int Hrm=(harm>>28);
int32_t mh=param_qnt>0?0:(((uint32_t)harm<<1+3)>>1);
int32_t tilt=__SSAT(inlet_tilt+param_tilt,28);
int32_t AM=__SSAT(param_am+inlet_am,28);
int skew=__USAT(param_skew+inlet_skew,3);
int32_t mod=__SSAT(param_mod+inlet_mod,28);]]></code.krate>
         <code.srate><![CDATA[Phase += freq + (___SMMUL(inlet_freq,freq)<<8);
morph+=rate;
int s1,s2;
int32_t mix;
uint32_t phs=Phase+Phase*Hrm+(___SMMUL(Phase>>1,mh)<<2);//(___SMMUL(Phase>>1,hrm)<<5);
s1=(uint64_t)phs*param_order>>32;
s2=(s1+1)%param_order;
s1*=Skip;
s2*=Skip;
s1*=skp;
s2*=skp;

mix=((uint32_t)phs*param_order)>>1;

int32_t a;
SINE2TINTERP(mix,a)
int32_t b;
SINE2TINTERP((1<<30)+(___SMMUL(mix,mod)<<9),b)
b=___SMMUL(a,___SMMUL(mod,b)<<5)<<1;
int32_t tlt;
tlt=(uint32_t)mix<<1;
tlt=(tlt>>1)+(tlt>>1+skew);
int32_t max=__SSAT(tlt,31);
tlt=max+(max-tlt<<skew)>>2;


int32_t r1,r2;
SINE2TINTERP(s1+morph+b+(inlet_phases<<7),r1)
SINE2TINTERP(s2+morph+b+(inlet_phases<<7),r2)
r1=r1>>5;
r2=r2>>5;
r1+=___SMMUL(r2-r1,mix)<<1;
r1+=___SMMUL(r1,___SMMUL(tilt,tlt)<<4)<<5;
r1+=___SMMUL(r1,___SMMUL(AM,a)<<5)<<2;
outlet_s= (r1)>>1;

SINE2TINTERP(s1+(1<<30)+morph+b+(inlet_phasec<<7),r1)
SINE2TINTERP(s2+(1<<30)+morph+b+(inlet_phasec<<7),r2)
r1=r1>>5;
r2=r2>>5;
r1+=___SMMUL(r2-r1,mix)<<1;
r1+=___SMMUL(r1,___SMMUL(tilt,tlt)<<4)<<5;
r1+=___SMMUL(r1,___SMMUL(AM,a)<<5)<<2;
outlet_c= (r1)>>1;]]></code.srate>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="52a44fed-cfa6-40fd-82f3-5cb55ac44f70" name="lp_10" x="630" y="756">
      <params>
         <frac32.s.map name="from_cut" value="-24.0"/>
         <frac32.s.map name="to_cut" value="64.0"/>
         <frac32.u.map name="from_res" value="59.65499973297119"/>
         <frac32.u.map name="to_res" value="63.42999982833862"/>
         <frac32.s.map name="from_mode" value="64.0"/>
         <frac32.s.map name="to_mode" value="-64.0"/>
         <frac32.u.map name="from_gain" value="50.0"/>
         <frac32.u.map name="to_gain" value="42.5"/>
         <frac32.s.map name="from_pan" value="64.0"/>
         <frac32.s.map name="to_pan" value="-64.0"/>
         <int32 name="bands" value="8"/>
         <frac32.u.map name="variation" value="64.0"/>
         <frac32.s.map name="glide" value="-35.0"/>
         <int32 name="first" value="5"/>
      </params>
      <attribs/>
      <object id="patch/object" uuid="52a44fed-cfa6-40fd-82f3-5cb55ac44f70">
         <sDescription>Low pass filter, state-variable type</sDescription>
         <author>Johannes Taelman</author>
         <license>BSD</license>
         <helpPatch>filter.axh</helpPatch>
         <inlets>
            <frac32buffer name="in" description="filter input"/>
            <frac32buffer name="pass_l"/>
            <frac32buffer name="pass_r"/>
            <int32 name="pst"/>
            <bool32 name="rnd"/>
            <frac32 name="glide"/>
            <frac32buffer name="envelopes"/>
            <frac32.bipolar name="pan"/>
         </inlets>
         <outlets>
            <frac32buffer name="reject"/>
            <frac32buffer name="pass_l" description="filter output"/>
            <frac32buffer name="pass_r"/>
         </outlets>
         <displays/>
         <params>
            <frac32.s.map.pitch name="from_cut"/>
            <frac32.s.map.pitch name="to_cut"/>
            <frac32.u.map.filterq name="from_res"/>
            <frac32.u.map.filterq name="to_res"/>
            <frac32.s.map name="from_mode"/>
            <frac32.s.map name="to_mode"/>
            <frac32.u.map name="from_gain"/>
            <frac32.u.map name="to_gain"/>
            <frac32.s.map name="from_pan"/>
            <frac32.s.map name="to_pan"/>
            <int32 name="bands">
               <MinValue i="1"/>
               <MaxValue i="8"/>
            </int32>
            <frac32.u.map name="variation"/>
            <frac32.s.map name="glide"/>
            <int32 name="first">
               <MinValue i="0"/>
               <MaxValue i="7"/>
            </int32>
         </params>
         <attribs/>
         <includes/>
         <code.declaration><![CDATA[int rnd;
int32_t low[16];
int32_t band[16];
int32_t passl,passr,reject;
int32_t P[16][8];
int32_t R[16][8];
int32_t M[16][8];
int32_t G[16][8];
int32_t S[16][8];
int32_t freq[8];
int32_t damp[8];
int32_t amp[8];
int32_t pan[8];
int32_t mode[8];
int32_t gain[8];
int32_t prv[8];
int32_t RS[8];
int ppst,cnt;
int32_t filter(int32_t in,int32_t f,int32_t r,int32_t a,int32_t pl,int32_t pr,int32_t g,int32_t m,int index)
{
int32_t notch = in - (___SMMUL(r,band[index])<<1);
low[index] = low[index] + (___SMMUL(f,band[index])<<1);
int32_t high  = notch - low[index];
band[index] += (___SMMUL(f,high)<<1);
int32_t bnd=band[index];
int32_t lw=low[index];
int32_t out1,out2;
if(m>=0)
{
	out1=bnd+(___SMMUL(high-bnd,m)<<5);
}
else
{
	out1=bnd+(___SMMUL(lw-bnd,-m)<<5);
}

out1 = ___SMMUL(a,out1)<<1;
reject=in-out1;
passl+=(___SMMUL(out1<<1,___SMMUL(pl,g)<<5)<<3);
passr+=(___SMMUL(out1<<1,___SMMUL(pr,g)<<5)<<3);
}

int32_t SQRT(int32_t in)
{
	int32_t ai = in>0?in:-in;
float aif = ai;
aif *= (1<<27);
aif = _VSQRTF(aif);
return in= (int)aif;

}]]></code.declaration>
         <code.init><![CDATA[for(int i=0;i<16;i++)
{
	for(int j=0;j<8;j++)
	{
		P[i][j]=(GenerateRandomNumber()>>1);
		R[i][j]=(GenerateRandomNumber()>>1);
		M[i][j]=(GenerateRandomNumber()>>1);
		G[i][j]=(GenerateRandomNumber()>>1);
		S[i][j]=(GenerateRandomNumber()>>1);
	}
}

for(int i=0;i<16;i++)
	{
		int32_t max=0;
		int32_t tres=(1<<31)-1;
		int32_t tP[8];
		int pos=0;
		for(int j=0;j<8;j++)
		{
			max=0;
			for(int k=0;k<8;k++)
			{
				if((P[i][k]<tres)&&(P[i][k]>max))
				{
					max=P[i][k];
				}
			}
			tP[j]=max;
			tres=max;
		}
		for(int j=0;j<8;j++)
		{
			P[i][j]=tP[j];
		}
	}

cnt=0;]]></code.init>
         <code.krate><![CDATA[if(inlet_rnd&&!rnd)
{
	rnd=1;
	for(int i=0;i<16;i++)
{
	if(i>0)
	{
		for(int j=0;j<param_bands;j++)
	{
		P[i][j]=(GenerateRandomNumber()>>5)<param_variation?(GenerateRandomNumber()>>1):P[i-1][j];
		R[i][j]=(GenerateRandomNumber()>>5)<param_variation?(GenerateRandomNumber()>>1):R[i-1][j];
		M[i][j]=(GenerateRandomNumber()>>5)<param_variation?(GenerateRandomNumber()>>1):M[i-1][j];
		G[i][j]=(GenerateRandomNumber()>>5)<param_variation?(GenerateRandomNumber()>>1):G[i-1][j];
		S[i][j]=(GenerateRandomNumber()>>5)<param_variation?(GenerateRandomNumber()>>1):G[i-1][j];
	}
	}
	else
	{
	for(int j=0;j<param_bands;j++)
	{
		P[i][j]=(GenerateRandomNumber()>>1);
		R[i][j]=(GenerateRandomNumber()>>1);
		M[i][j]=(GenerateRandomNumber()>>1);
		G[i][j]=(GenerateRandomNumber()>>1);
		S[i][j]=(GenerateRandomNumber()>>1);
	}
	}
	
	for(int i=0;i<16;i++)
	{
		int32_t max=0;
		int32_t tres=(1<<31)-1;
		int32_t tP[8];
		int pos=0;
		for(int j=0;j<param_bands;j++)
		{
			max=0;
			for(int k=0;k<param_bands;k++)
			{
				if((P[i][k]<tres)&&(P[i][k]>max))
				{
					max=P[i][k];
				}
			}
			tP[j]=max;
			tres=max;
		}
		for(int j=0;j<param_bands;j++)
		{
			P[i][j]=tP[j];
		}
	}
}
}
else if(!inlet_rnd){rnd=0;}
int pst=inlet_pst&15;
int32_t alpha;

int32_t glide;
MTOF(-param_glide-inlet_glide,glide)
//glide=glide;
//if(cnt==0)
//{
int32_t env[8],pal[8],par[8];
int32_t stp[8];
for(int i=0;i<param_bands;i++)
{
	int k=(i+param_first)%param_bands;
	int32_t ptch=param_from__cut+___SMMUL(param_to__cut-param_from__cut<<1,P[pst][k]);
	MTOFEXTENDED(ptch,alpha);
	SINE2TINTERP(alpha,alpha);
	freq[i]+=___SMMUL(alpha-freq[i],glide);
	int32_t rs=param_from__res+___SMMUL(param_to__res-param_from__res<<1,R[pst][k]);
	RS[i]+=___SMMUL(rs-(rs>>5)+(1<<21)-RS[i]<<1,glide);
	damp[i] = (0x80<<24) - (RS[i]<<4);
	amp[i]=(1<<31)-1-(RS[i]-(RS[i]>>10)<<4);
	mode[i]+=___SMMUL(param_from__mode+___SMMUL(param_to__mode-param_from__mode<<1,M[pst][k])-mode[i],glide);
	pan[i]+=___SMMUL(param_from__pan+___SMMUL(param_to__pan-param_from__pan<<1,S[pst][k])-pan[i],glide);
	int32_t sn;
	SINE2TINTERP((pan[i]+inlet_pan<<4),sn)
	sn=sn>>4;
	pal[i]=SQRT((1<<27)+sn>>1);
	par[i]=SQRT((1<<27)-sn>>1);
	gain[i]+=___SMMUL((param_from__gain+___SMMUL(param_to__gain-param_from__gain<<1,G[pst][k])<<4)-gain[i],glide);
	int32_t tmp=___SMMUL(gain[i],inlet_envelopes[k])<<5;
	stp[i]=tmp-prv[i]>>4;
	env[i]=prv[i];
	prv[i]=tmp;
}
//}
//cnt=(cnt+1)&3;
ppst=pst;]]></code.krate>
         <code.srate><![CDATA[passl=0;//inlet_pass;
passr=0;
reject=inlet_in;

for(int i=0;i<param_bands;i++)
{
	filter(reject,freq[i],damp[i],amp[i],pal[i],par[i],env[i],mode[i],i);
	env[i]+=stp[i];
}

outlet_reject=reject;
outlet_pass__l=passl+inlet_pass__l;
outlet_pass__r=passr+inlet_pass__r;]]></code.srate>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="52a44fed-cfa6-40fd-82f3-5cb55ac44f70" name="lp_11" x="770" y="756">
      <params>
         <frac32.s.map name="from_cut" value="-24.0"/>
         <frac32.s.map name="to_cut" value="64.0"/>
         <frac32.u.map name="from_res" value="59.15499973297119"/>
         <frac32.u.map name="to_res" value="63.42999982833862"/>
         <frac32.s.map name="from_mode" value="64.0"/>
         <frac32.s.map name="to_mode" value="-64.0"/>
         <frac32.u.map name="from_gain" value="50.0"/>
         <frac32.u.map name="to_gain" value="42.0"/>
         <frac32.s.map name="from_pan" value="-64.0"/>
         <frac32.s.map name="to_pan" value="64.0"/>
         <int32 name="bands" value="8"/>
         <frac32.u.map name="variation" value="64.0"/>
         <frac32.s.map name="glide" value="-35.0"/>
         <int32 name="first" value="5"/>
      </params>
      <attribs/>
      <object id="patch/object" uuid="52a44fed-cfa6-40fd-82f3-5cb55ac44f70">
         <sDescription>Low pass filter, state-variable type</sDescription>
         <author>Johannes Taelman</author>
         <license>BSD</license>
         <helpPatch>filter.axh</helpPatch>
         <inlets>
            <frac32buffer name="in" description="filter input"/>
            <frac32buffer name="pass_l"/>
            <frac32buffer name="pass_r"/>
            <int32 name="pst"/>
            <bool32 name="rnd"/>
            <frac32 name="glide"/>
            <frac32buffer name="envelopes"/>
            <frac32.bipolar name="pan"/>
         </inlets>
         <outlets>
            <frac32buffer name="reject"/>
            <frac32buffer name="pass_l" description="filter output"/>
            <frac32buffer name="pass_r"/>
         </outlets>
         <displays/>
         <params>
            <frac32.s.map.pitch name="from_cut"/>
            <frac32.s.map.pitch name="to_cut"/>
            <frac32.u.map.filterq name="from_res"/>
            <frac32.u.map.filterq name="to_res"/>
            <frac32.s.map name="from_mode"/>
            <frac32.s.map name="to_mode"/>
            <frac32.u.map name="from_gain"/>
            <frac32.u.map name="to_gain"/>
            <frac32.s.map name="from_pan"/>
            <frac32.s.map name="to_pan"/>
            <int32 name="bands">
               <MinValue i="1"/>
               <MaxValue i="8"/>
            </int32>
            <frac32.u.map name="variation"/>
            <frac32.s.map name="glide"/>
            <int32 name="first">
               <MinValue i="0"/>
               <MaxValue i="7"/>
            </int32>
         </params>
         <attribs/>
         <includes/>
         <code.declaration><![CDATA[int rnd;
int32_t low[16];
int32_t band[16];
int32_t passl,passr,reject;
int32_t P[16][8];
int32_t R[16][8];
int32_t M[16][8];
int32_t G[16][8];
int32_t S[16][8];
int32_t freq[8];
int32_t damp[8];
int32_t amp[8];
int32_t pan[8];
int32_t mode[8];
int32_t gain[8];
int32_t prv[8];
int32_t RS[8];
int ppst,cnt;
int32_t filter(int32_t in,int32_t f,int32_t r,int32_t a,int32_t pl,int32_t pr,int32_t g,int32_t m,int index)
{
int32_t notch = in - (___SMMUL(r,band[index])<<1);
low[index] = low[index] + (___SMMUL(f,band[index])<<1);
int32_t high  = notch - low[index];
band[index] += (___SMMUL(f,high)<<1);
int32_t bnd=band[index];
int32_t lw=low[index];
int32_t out1,out2;
if(m>=0)
{
	out1=bnd+(___SMMUL(high-bnd,m)<<5);
}
else
{
	out1=bnd+(___SMMUL(lw-bnd,-m)<<5);
}

out1 = ___SMMUL(a,out1)<<1;
reject=in-out1;
passl+=(___SMMUL(out1<<1,___SMMUL(pl,g)<<5)<<3);
passr+=(___SMMUL(out1<<1,___SMMUL(pr,g)<<5)<<3);
}

int32_t SQRT(int32_t in)
{
	int32_t ai = in>0?in:-in;
float aif = ai;
aif *= (1<<27);
aif = _VSQRTF(aif);
return in= (int)aif;

}]]></code.declaration>
         <code.init><![CDATA[for(int i=0;i<16;i++)
{
	for(int j=0;j<8;j++)
	{
		P[i][j]=(GenerateRandomNumber()>>1);
		R[i][j]=(GenerateRandomNumber()>>1);
		M[i][j]=(GenerateRandomNumber()>>1);
		G[i][j]=(GenerateRandomNumber()>>1);
		S[i][j]=(GenerateRandomNumber()>>1);
	}
}

for(int i=0;i<16;i++)
	{
		int32_t max=0;
		int32_t tres=(1<<31)-1;
		int32_t tP[8];
		int pos=0;
		for(int j=0;j<8;j++)
		{
			max=0;
			for(int k=0;k<8;k++)
			{
				if((P[i][k]<tres)&&(P[i][k]>max))
				{
					max=P[i][k];
				}
			}
			tP[j]=max;
			tres=max;
		}
		for(int j=0;j<8;j++)
		{
			P[i][j]=tP[j];
		}
	}

cnt=0;]]></code.init>
         <code.krate><![CDATA[if(inlet_rnd&&!rnd)
{
	rnd=1;
	for(int i=0;i<16;i++)
{
	if(i>0)
	{
		for(int j=0;j<param_bands;j++)
	{
		P[i][j]=(GenerateRandomNumber()>>5)<param_variation?(GenerateRandomNumber()>>1):P[i-1][j];
		R[i][j]=(GenerateRandomNumber()>>5)<param_variation?(GenerateRandomNumber()>>1):R[i-1][j];
		M[i][j]=(GenerateRandomNumber()>>5)<param_variation?(GenerateRandomNumber()>>1):M[i-1][j];
		G[i][j]=(GenerateRandomNumber()>>5)<param_variation?(GenerateRandomNumber()>>1):G[i-1][j];
		S[i][j]=(GenerateRandomNumber()>>5)<param_variation?(GenerateRandomNumber()>>1):G[i-1][j];
	}
	}
	else
	{
	for(int j=0;j<param_bands;j++)
	{
		P[i][j]=(GenerateRandomNumber()>>1);
		R[i][j]=(GenerateRandomNumber()>>1);
		M[i][j]=(GenerateRandomNumber()>>1);
		G[i][j]=(GenerateRandomNumber()>>1);
		S[i][j]=(GenerateRandomNumber()>>1);
	}
	}
	
	for(int i=0;i<16;i++)
	{
		int32_t max=0;
		int32_t tres=(1<<31)-1;
		int32_t tP[8];
		int pos=0;
		for(int j=0;j<param_bands;j++)
		{
			max=0;
			for(int k=0;k<param_bands;k++)
			{
				if((P[i][k]<tres)&&(P[i][k]>max))
				{
					max=P[i][k];
				}
			}
			tP[j]=max;
			tres=max;
		}
		for(int j=0;j<param_bands;j++)
		{
			P[i][j]=tP[j];
		}
	}
}
}
else if(!inlet_rnd){rnd=0;}
int pst=inlet_pst&15;
int32_t alpha;

int32_t glide;
MTOF(-param_glide-inlet_glide,glide)
//glide=glide;
//if(cnt==0)
//{
int32_t env[8],pal[8],par[8];
int32_t stp[8];
for(int i=0;i<param_bands;i++)
{
	int k=(i+param_first)%param_bands;
	int32_t ptch=param_from__cut+___SMMUL(param_to__cut-param_from__cut<<1,P[pst][k]);
	MTOFEXTENDED(ptch,alpha);
	SINE2TINTERP(alpha,alpha);
	freq[i]+=___SMMUL(alpha-freq[i],glide);
	int32_t rs=param_from__res+___SMMUL(param_to__res-param_from__res<<1,R[pst][k]);
	RS[i]+=___SMMUL(rs-(rs>>5)+(1<<21)-RS[i]<<1,glide);
	damp[i] = (0x80<<24) - (RS[i]<<4);
	amp[i]=(1<<31)-1-(RS[i]-(RS[i]>>10)<<4);
	mode[i]+=___SMMUL(param_from__mode+___SMMUL(param_to__mode-param_from__mode<<1,M[pst][k])-mode[i],glide);
	pan[i]+=___SMMUL(param_from__pan+___SMMUL(param_to__pan-param_from__pan<<1,S[pst][k])-pan[i],glide);
	int32_t sn;
	SINE2TINTERP((pan[i]+inlet_pan<<4),sn)
	sn=sn>>4;
	pal[i]=SQRT((1<<27)+sn>>1);
	par[i]=SQRT((1<<27)-sn>>1);
	gain[i]+=___SMMUL((param_from__gain+___SMMUL(param_to__gain-param_from__gain<<1,G[pst][k])<<4)-gain[i],glide);
	int32_t tmp=___SMMUL(gain[i],inlet_envelopes[k])<<5;
	stp[i]=tmp-prv[i]>>4;
	env[i]=prv[i];
	prv[i]=tmp;
}
//}
//cnt=(cnt+1)&3;
ppst=pst;]]></code.krate>
         <code.srate><![CDATA[passl=0;//inlet_pass;
passr=0;
reject=inlet_in;

for(int i=0;i<param_bands;i++)
{
	filter(reject,freq[i],damp[i],amp[i],pal[i],par[i],env[i],mode[i],i);
	env[i]+=stp[i];
}

outlet_reject=reject;
outlet_pass__l=passl+inlet_pass__l;
outlet_pass__r=passr+inlet_pass__r;]]></code.srate>
      </object>
   </patchobj>
   <obj type="sss/audio/StOutVol" uuid="0ca9cf1e-1ce3-469c-80da-a4a885c21246" name="StOutVol_1" x="1120" y="812">
      <params>
         <frac32.u.map name="volume" value="50.0"/>
      </params>
      <attribs/>
   </obj>
   <obj type="disp/scope 128 b trig" uuid="11747dcd1dc9afe4919f537c861fb18b80b4e4e" name="scope_1" x="938" y="952">
      <params/>
      <attribs/>
   </obj>
   <obj type="disp/scope 128 b trig" uuid="11747dcd1dc9afe4919f537c861fb18b80b4e4e" name="scope_2" x="1078" y="952">
      <params/>
      <attribs/>
   </obj>
   <obj type="disp/scope 128 b trig" uuid="11747dcd1dc9afe4919f537c861fb18b80b4e4e" name="scope_3" x="938" y="1148">
      <params/>
      <attribs/>
   </obj>
   <obj type="disp/scope 128 b trig" uuid="11747dcd1dc9afe4919f537c861fb18b80b4e4e" name="scope_4" x="1078" y="1148">
      <params/>
      <attribs/>
   </obj>
   <nets>
      <net>
         <source obj="stereo image osc" outlet="s"/>
         <dest obj="scope_1" inlet="in"/>
         <dest obj="lp_10" inlet="in"/>
      </net>
      <net>
         <source obj="sine_2" outlet="s"/>
         <dest obj="*_1" inlet="a"/>
      </net>
      <net>
         <source obj="sine_2" outlet="c"/>
         <dest obj="*_2" inlet="a"/>
      </net>
      <net>
         <source obj="*_2" outlet="result"/>
         <dest obj="stereo image osc" inlet="phasec"/>
      </net>
      <net>
         <source obj="*_1" outlet="result"/>
         <dest obj="stereo image osc" inlet="phases"/>
      </net>
      <net>
         <source obj="*_3" outlet="result"/>
         <dest obj="stereo image osc" inlet="freq"/>
      </net>
      <net>
         <source obj="dial_1" outlet="out"/>
         <dest obj="*_1" inlet="b"/>
         <dest obj="*_2" inlet="b"/>
      </net>
      <net>
         <source obj="dial_2" outlet="out"/>
         <dest obj="*_3" inlet="b"/>
      </net>
      <net>
         <source obj="sine_3" outlet="wave"/>
         <dest obj="*_3" inlet="a"/>
      </net>
      <net>
         <source obj="counter_1" outlet="o"/>
         <dest obj="gate pattern" inlet="count"/>
         <dest obj="gate pattern_" inlet="count"/>
      </net>
      <net>
         <source obj="square_1" outlet="wave"/>
         <dest obj="counter_1" inlet="trig"/>
         <dest obj="counter_4" inlet="trig"/>
      </net>
      <net>
         <source obj="stereo image osc" outlet="c"/>
         <dest obj="scope_2" inlet="in"/>
         <dest obj="lp_11" inlet="in"/>
      </net>
      <net>
         <source obj="counter_2" outlet="c"/>
         <dest obj="gate pattern" inlet="rnd"/>
         <dest obj="ad_1" inlet="rnd"/>
         <dest obj="gate pattern_" inlet="rnd"/>
         <dest obj="ad_2" inlet="rnd"/>
         <dest obj="basePatt_3 fast_" inlet="rnd"/>
         <dest obj="lp_10" inlet="rnd"/>
         <dest obj="lp_11" inlet="rnd"/>
      </net>
      <net>
         <source obj="gate pattern" outlet="gates"/>
         <dest obj="ad_1" inlet="gates"/>
      </net>
      <net>
         <source obj="basePatt_3 fast_" outlet="index"/>
         <dest obj="lp_10" inlet="pst"/>
         <dest obj="lp_11" inlet="pst"/>
      </net>
      <net>
         <source obj="gate pattern_" outlet="gates"/>
         <dest obj="ad_2" inlet="gates"/>
      </net>
      <net>
         <source obj="ad_1" outlet="env"/>
         <dest obj="lp_10" inlet="envelopes"/>
      </net>
      <net>
         <source obj="ad_2" outlet="env"/>
         <dest obj="lp_11" inlet="envelopes"/>
      </net>
      <net>
         <source obj="lp_11" outlet="pass_r"/>
         <dest obj="StOutVol_1" inlet="right"/>
         <dest obj="scope_4" inlet="in"/>
      </net>
      <net>
         <source obj="lp_10" outlet="pass_l"/>
         <dest obj="lp_11" inlet="pass_l"/>
      </net>
      <net>
         <source obj="lp_10" outlet="pass_r"/>
         <dest obj="lp_11" inlet="pass_r"/>
      </net>
      <net>
         <source obj="lp_11" outlet="pass_l"/>
         <dest obj="StOutVol_1" inlet="left"/>
         <dest obj="scope_3" inlet="in"/>
      </net>
      <net>
         <source obj="saw_1" outlet="wave"/>
         <dest obj="*c_1" inlet="in"/>
      </net>
      <net>
         <source obj="sine_4" outlet="wave"/>
         <dest obj="*c_2" inlet="in"/>
      </net>
      <net>
         <source obj="*c_1" outlet="out"/>
         <dest obj="stereo image osc" inlet="hrm"/>
      </net>
      <net>
         <source obj="*c_2" outlet="out"/>
         <dest obj="stereo image osc" inlet="tilt"/>
      </net>
      <net>
         <source obj="sine_5" outlet="wave"/>
         <dest obj="*c_3" inlet="in"/>
      </net>
      <net>
         <source obj="sine_6" outlet="wave"/>
         <dest obj="*c_4" inlet="in"/>
      </net>
      <net>
         <source obj="*c_3" outlet="out"/>
         <dest obj="stereo image osc" inlet="am"/>
      </net>
      <net>
         <source obj="*c_4" outlet="out"/>
         <dest obj="stereo image osc" inlet="mod"/>
      </net>
      <net>
         <source obj="saw_2" outlet="wave"/>
         <dest obj="lp_10" inlet="pan"/>
         <dest obj="lp_11" inlet="pan"/>
      </net>
      <net>
         <source obj="counter_3" outlet="o"/>
         <dest obj="basePatt_3 fast_" inlet="count"/>
      </net>
      <net>
         <source obj="counter_4" outlet="c"/>
         <dest obj="counter_3" inlet="trig"/>
      </net>
      <net>
         <source obj="counter_3" outlet="c"/>
         <dest obj="counter_2" inlet="trig"/>
      </net>
   </nets>
   <settings>
      <subpatchmode>no</subpatchmode>
   </settings>
   <notes><![CDATA[]]></notes>
   <windowPos>
      <x>0</x>
      <y>0</y>
      <width>1391</width>
      <height>1080</height>
   </windowPos>
</patch-1.0>