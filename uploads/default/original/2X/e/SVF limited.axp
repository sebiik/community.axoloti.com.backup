<patch-1.0 appVersion="1.0.12">
   <obj type="lfo/square" uuid="de6909eb64db13af5b43f979a4c130024b3a4793" name="square_1" x="182" y="14">
      <params>
         <frac32.s.map name="pitch" value="10.0"/>
      </params>
      <attribs/>
   </obj>
   <obj type="logic/counter" uuid="7a141ba82230e54e5f5cd12da5dbe5a74ba854a5" name="counter_1" x="280" y="14">
      <params>
         <int32 name="maximum" value="8"/>
      </params>
      <attribs/>
   </obj>
   <obj type="logic/counter" uuid="7a141ba82230e54e5f5cd12da5dbe5a74ba854a5" name="counter_2" x="364" y="14">
      <params>
         <int32 name="maximum" value="4"/>
      </params>
      <attribs/>
   </obj>
   <obj type="env/ad" uuid="255cb0cd67470c7498f9c33b820facd26aa629ce" name="ad_2" x="490" y="28">
      <params>
         <frac32.s.map name="a" value="-64.0"/>
         <frac32.s.map name="d" value="27.0"/>
      </params>
      <attribs/>
   </obj>
   <obj type="env/ad" uuid="255cb0cd67470c7498f9c33b820facd26aa629ce" name="ad_1" x="658" y="28">
      <params>
         <frac32.s.map name="a" value="-64.0"/>
         <frac32.s.map name="d" value="0.0"/>
      </params>
      <attribs/>
   </obj>
   <obj type="math/*" uuid="922423f2db9f222aa3e5ba095778288c446da47a" name="*_1" x="756" y="28">
      <params/>
      <attribs/>
   </obj>
   <obj type="env/ad" uuid="255cb0cd67470c7498f9c33b820facd26aa629ce" name="ad_4" x="938" y="28">
      <params>
         <frac32.s.map name="a" value="-64.0"/>
         <frac32.s.map name="d" value="-17.0"/>
      </params>
      <attribs/>
   </obj>
   <obj type="math/*" uuid="922423f2db9f222aa3e5ba095778288c446da47a" name="*_3" x="1036" y="28">
      <params/>
      <attribs/>
   </obj>
   <obj type="logic/counter" uuid="7a141ba82230e54e5f5cd12da5dbe5a74ba854a5" name="counter_3" x="280" y="84">
      <params>
         <int32 name="maximum" value="4"/>
      </params>
      <attribs/>
   </obj>
   <obj type="env/ad" uuid="255cb0cd67470c7498f9c33b820facd26aa629ce" name="ad_3" x="364" y="84">
      <params>
         <frac32.s.map name="a" value="-64.0"/>
         <frac32.s.map name="d" value="15.0"/>
      </params>
      <attribs/>
   </obj>
   <patchobj type="patch/object" uuid="f255950f-5b3e-4a80-99a5-e73f715a4ed8" name="sine_1" x="616" y="154">
      <params>
         <frac32.s.map name="pitch" value="-43.0"/>
      </params>
      <attribs/>
      <object id="patch/object" uuid="f255950f-5b3e-4a80-99a5-e73f715a4ed8">
         <sDescription>sine wave LFO, linear interpolated table, pitch input</sDescription>
         <author>Johannes Taelman</author>
         <license>BSD</license>
         <helpPatch>lfo.axh</helpPatch>
         <inlets>
            <frac32.bipolar name="pitch" description="pitch"/>
         </inlets>
         <outlets>
            <frac32.bipolar name="wave" description="sine wave"/>
         </outlets>
         <displays/>
         <params>
            <frac32.s.map.lfopitch name="pitch" noLabel="true"/>
         </params>
         <attribs/>
         <includes/>
         <code.declaration><![CDATA[uint32_t Phase;]]></code.declaration>
         <code.init><![CDATA[Phase = 0;]]></code.init>
         <code.krate><![CDATA[{      int32_t freq;
      MTOFEXTENDED(param_pitch + inlet_pitch,freq);
      Phase += freq>>6;
      int32_t r;
      SINE2TINTERP(Phase,r)
      outlet_wave= (r>>4);
   }]]></code.krate>
      </object>
   </patchobj>
   <obj type="mix/mix 2 sq" uuid="a4fab7491bfa49bda00b333e2d4a4b81f11e77b8" name="mix_1" x="714" y="154">
      <params>
         <frac32.u.map name="gain1" value="43.0"/>
         <frac32.u.map name="gain2" value="31.5"/>
      </params>
      <attribs/>
   </obj>
   <patchobj type="patch/object" uuid="f255950f-5b3e-4a80-99a5-e73f715a4ed8" name="sine_2" x="896" y="154">
      <params>
         <frac32.s.map name="pitch" value="2.0"/>
      </params>
      <attribs/>
      <object id="patch/object" uuid="f255950f-5b3e-4a80-99a5-e73f715a4ed8">
         <sDescription>sine wave LFO, linear interpolated table, pitch input</sDescription>
         <author>Johannes Taelman</author>
         <license>BSD</license>
         <helpPatch>lfo.axh</helpPatch>
         <inlets>
            <frac32.bipolar name="pitch" description="pitch"/>
         </inlets>
         <outlets>
            <frac32.bipolar name="wave" description="sine wave"/>
         </outlets>
         <displays/>
         <params>
            <frac32.s.map.lfopitch name="pitch" noLabel="true"/>
         </params>
         <attribs/>
         <includes/>
         <code.declaration><![CDATA[uint32_t Phase;]]></code.declaration>
         <code.init><![CDATA[Phase = 0;]]></code.init>
         <code.krate><![CDATA[{      int32_t freq;
      MTOFEXTENDED(param_pitch + inlet_pitch,freq);
      Phase += freq>>6;
      int32_t r;
      SINE2TINTERP(Phase,r)
      outlet_wave= (r>>4);
   }]]></code.krate>
      </object>
   </patchobj>
   <obj type="mix/mix 2 sq" uuid="a4fab7491bfa49bda00b333e2d4a4b81f11e77b8" name="mix_3" x="994" y="154">
      <params>
         <frac32.u.map name="gain1" value="17.0"/>
         <frac32.u.map name="gain2" value="26.0"/>
      </params>
      <attribs/>
   </obj>
   <obj type="logic/counter" uuid="7a141ba82230e54e5f5cd12da5dbe5a74ba854a5" name="counter_4" x="280" y="182">
      <params>
         <int32 name="maximum" value="16"/>
      </params>
      <attribs/>
   </obj>
   <obj type="math/*" uuid="922423f2db9f222aa3e5ba095778288c446da47a" name="*_2" x="392" y="196">
      <params/>
      <attribs/>
   </obj>
   <obj type="mix/mix 2 sq" uuid="a4fab7491bfa49bda00b333e2d4a4b81f11e77b8" name="mix_4" x="1134" y="210">
      <params>
         <frac32.u.map name="gain1" value="61.5"/>
         <frac32.u.map name="gain2" value="56.5"/>
      </params>
      <attribs/>
   </obj>
   <obj type="osc/saw" uuid="739ecc36017ef3249479b8f01716b8bbfba9abc1" name="saw_1" x="14" y="350">
      <params>
         <frac32.s.map name="pitch" value="-27.0"/>
      </params>
      <attribs/>
   </obj>
   <patchobj type="patch/object" uuid="3cda8273-db3a-4c13-a8fe-21ea735ec580" name="saw_2" x="112" y="350">
      <params>
         <frac32.s.map name="pitch" value="-27.0"/>
         <frac32.u.map name="detune" value="1.0"/>
      </params>
      <attribs/>
      <object id="patch/object" uuid="3cda8273-db3a-4c13-a8fe-21ea735ec580">
         <sDescription>saw wave oscillator
Bandwith limited</sDescription>
         <author>Johannes Taelman</author>
         <license>BSD</license>
         <helpPatch>osc.axh</helpPatch>
         <inlets>
            <frac32.bipolar name="pitch" description="pitch"/>
         </inlets>
         <outlets>
            <frac32buffer.bipolar name="wave" description="saw wave, anti-aliased"/>
         </outlets>
         <displays/>
         <params>
            <frac32.s.map.pitch name="pitch" noLabel="true"/>
            <frac32.u.map name="detune"/>
         </params>
         <attribs/>
         <includes/>
         <code.declaration><![CDATA[int32_t osc_p;
  static const int blepvoices = 4;
  int16_t *oscp[blepvoices];
  uint32_t nextvoice;]]></code.declaration>
         <code.init><![CDATA[int j;
    for(j=0;j<blepvoices;j++)
      oscp[j] = &blept[BLEPSIZE-1];   nextvoice = 0;]]></code.init>
         <code.krate><![CDATA[int32_t freq;
      MTOFEXTENDED(param_pitch + inlet_pitch+(param_detune>>7),freq);
  int j;
  int16_t *lastblep = &blept[BLEPSIZE-1];
  for(j=0;j<BUFSIZE;j++){
    int i;
    int p;
    p = osc_p;
    osc_p = p+freq;
    if ((osc_p>0)&&!(p>0)){   // dispatch
      nextvoice = (nextvoice+1)&(blepvoices-1);
      int32_t x = osc_p/(freq>>6);
      oscp[nextvoice] = &blept[x];
    }
    int32_t sum=0;
    for(i=0;i<blepvoices;i++){ // sample
      int16_t *t = oscp[i];
      sum+=*t;
      t+=64;
      if (t>=lastblep) t=lastblep;
      oscp[i]=t;
    }
    sum = (16384*blepvoices)-sum - 8192;
    uint32_t g = osc_p;
    sum=(g>>5) + (sum<<13);
    outlet_wave[j]=sum;
  }]]></code.krate>
      </object>
   </patchobj>
   <obj type="mix/mix 2 sq" uuid="9b03da12a01f39ecd48d16285e7d10acb8e1267c" name="mix_2" x="210" y="350">
      <params>
         <frac32.u.map name="gain1" value="52.0"/>
         <frac32.u.map name="gain2" value="52.0"/>
      </params>
      <attribs/>
   </obj>
   <obj type="gain/vca" uuid="a9f2dcd18043e2f47364e45cb8814f63c2a37c0d" name="vca_1" x="322" y="350">
      <params/>
      <attribs/>
   </obj>
   <patchobj type="patch/object" uuid="baa42ea4-0e0a-41dc-8e35-908917a1eaa6" name="basePatt_2" x="406" y="350">
      <params>
         <frac32.u.map name="length" value="64.0"/>
         <frac32.u.map name="base" value="0.0"/>
         <frac32.u.map name="diffchance" value="45.5"/>
         <frac32.u.map name="differents" value="64.0"/>
         <frac32.u.map name="diffsize" value="64.0"/>
         <bool32.tgl name="nonseed" value="0"/>
      </params>
      <attribs>
         <spinner attributeName="max" value="15"/>
      </attribs>
      <object id="patch/object" uuid="baa42ea4-0e0a-41dc-8e35-908917a1eaa6">
         <sDescription>Pattern generator that normally outputs the &quot;base&quot; value and having a chance that it&apos;s randomly changed. This can be either as a random-pattern (count input) or ongoing randomly generated.
Amount of different random values can be set as well as a difference size (offset from base).
Checking the &quot;nonseed&quot; box will use non-repeating random values instead the randomised pattern, basically setting the &quot;differents&quot; to unlimited.</sDescription>
         <author>Remco van der Most</author>
         <license>BSD</license>
         <helpPatch>table.axh</helpPatch>
         <inlets>
            <int32 name="count"/>
            <bool32 name="rnd"/>
            <frac32 name="base"/>
            <frac32 name="diffchance"/>
         </inlets>
         <outlets>
            <int32 name="index"/>
         </outlets>
         <displays/>
         <params>
            <frac32.u.map name="length"/>
            <frac32.u.map name="base"/>
            <frac32.u.map name="diffchance"/>
            <frac32.u.map name="differents"/>
            <frac32.u.map name="diffsize"/>
            <bool32.tgl name="nonseed"/>
         </params>
         <attribs>
            <spinner name="max" MinValue="0" MaxValue="8192" DefaultValue="0"/>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[static const uint32_t LENGTHPOW = (6);
static const uint32_t LENGTH = (1<<6);
static const uint32_t LENGTHMASK = ((1<<6)-1);
static const uint32_t BITS = 8;
static const uint32_t GAIN = 20;
int sz=attr_max+1;
uint8_t *a1,*a2;
uint16_t *a3;
int val,i,pos,prv;
bool rnd;]]></code.declaration>
         <code.init><![CDATA[static uint8_t _a1[LENGTH] __attribute__ ((section (".sdram")));
a1 = &_a1[0];
static uint8_t _a2[LENGTH] __attribute__ ((section (".sdram")));
a2 = &_a2[0];
static uint16_t _a3[LENGTH] __attribute__ ((section (".sdram")));
a3 = &_a3[0];
{ 
  int i;
  for(i=0;i<LENGTH;i++){
  	a1[i]=(uint8_t)GenerateRandomNumber();
  	a2[i]=(uint8_t)GenerateRandomNumber();
  	a3[i]=(uint16_t)GenerateRandomNumber();
  }
}]]></code.init>
         <code.krate><![CDATA[if((inlet_rnd>0)&&!rnd){
	rnd=1;
	for(i=0;i<LENGTH;i++){
	a1[i]=(uint8_t)GenerateRandomNumber();
  	a2[i]=(uint8_t)GenerateRandomNumber();
  	a3[i]=(uint16_t)GenerateRandomNumber();
	}
}
else if(inlet_rnd<1){rnd=0;}

if(!(inlet_count==prv)){
int length=param_length>>21;
length=length>0?length:1;
int cnt=inlet_count;
cnt=cnt-cnt/length*length;
cnt+=cnt<0?length:0;
cnt=cnt&63;
int base=___SMMUL(__USAT(param_base+inlet_base,27)<<4,sz-1<<1);
val=base;

if((param_nonseed<1?a2[cnt]:(uint8_t)(GenerateRandomNumber()))<(__USAT(param_diffchance+inlet_diffchance,27)>>19)){
val+=___SMMUL(___SMMUL((int32_t)a3[___SMMUL((param_nonseed<1?a1[cnt]:(uint8_t)(GenerateRandomNumber())<<1),param_differents<<2)]<<13,param_diffsize)<<5,sz<<3)+1;
}
val=val-val/sz*sz;
val+=(val<0?sz:0);
}
outlet_index=val;
prv=inlet_count;]]></code.krate>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="2b0224c3-0a81-4d1d-8c23-789e8891cbdb" name="5x rnd bandpass" x="518" y="350">
      <params>
         <bool32.tgl name="OS" value="0"/>
         <frac32.s.map name="mix" value="64.0"/>
         <frac32.s.map name="fromC" value="46.0"/>
         <frac32.s.map name="toC" value="-8.0"/>
         <frac32.u.map name="fromR" value="61.5"/>
         <frac32.u.map name="toR" value="50.5"/>
      </params>
      <attribs/>
      <object id="patch/object" uuid="2b0224c3-0a81-4d1d-8c23-789e8891cbdb">
         <sDescription>1st order lowpass filter</sDescription>
         <author>Johannes Taelman</author>
         <license>BSD</license>
         <helpPatch>filter.axh</helpPatch>
         <inlets>
            <frac32buffer name="in" description="input"/>
            <int32 name="pst"/>
            <bool32 name="rnd"/>
         </inlets>
         <outlets>
            <frac32buffer name="out" description="output"/>
         </outlets>
         <displays/>
         <params>
            <bool32.tgl name="OS"/>
            <frac32.s.map name="mix"/>
            <frac32.s.map name="fromC"/>
            <frac32.s.map name="toC"/>
            <frac32.u.map name="fromR"/>
            <frac32.u.map name="toR"/>
         </params>
         <attribs/>
         <includes/>
         <code.declaration><![CDATA[int32_t band[5],low[5];
int32_t pitch[16][5];
int32_t reso[16][5];
int rnd;
int note[7]={0,2,4,5,7,9,11};
int32_t BP(int32_t in,int32_t F,int32_t res,int sel)
{
low[sel]+=___SMMUL(band[sel],F)-___SMMUL(low[sel],res);
band[sel]+=(___SMMUL(-low[sel],F)<<1)-(___SMMUL(band[sel],res)<<1)+in;
}]]></code.declaration>
         <code.init><![CDATA[for(int i=0;i<16;i++)
{
	for(int j=0;j<5;j++)
	{
		pitch[i][j]=(GenerateRandomNumber()>>1);
		int32_t rs=(int32_t)(GenerateRandomNumber()>>1);
   		reso[i][j]=rs;
	}
}]]></code.init>
         <code.krate><![CDATA[if(inlet_rnd&&!rnd)
{
	rnd=1;
	for(int i=0;i<16;i++)
{
	for(int j=0;j<5;j++)
	{
		pitch[i][j]=(GenerateRandomNumber()>>1);
		int32_t rs=(int32_t)(GenerateRandomNumber()>>1);
   		reso[i][j]=rs;
	}
}
}
else if(!inlet_rnd){rnd=0;}
int32_t F[5],R[5],L[5];
int pst=inlet_pst&15;

for(int i=0;i<5;i++)
{
	int32_t ptch=param_fromC+(___SMMUL(param_toC-param_fromC,pitch[pst][i])<<1);
   MTOF(ptch+(1<<24),F[i]);
   int32_t rs=param_fromR+(___SMMUL(param_toR-param_fromR,reso[pst][i])<<1)<<4;
   rs=__USAT((uint32_t)(1<<31)-(1<<25)-rs,31);
   rs=___SMMUL(rs,rs)<<1;

   R[i]=rs;
	int32_t left=(1<<31)-1-R[i];
   left-=left>>6;
   left=(1<<31)-1-left;
   L[i]=___SMMUL(F[i],left)<<1;
}
int OS=param_OS+1;]]></code.krate>
         <code.srate><![CDATA[int32_t sum=0;
for(int j=0;j<5;j++)
{
	int32_t in=___SMMUL(inlet_in,L[j])<<1;
	for(int i=0;i<OS;i++)
	{
	
		BP(in,F[j],R[j],j);
	}
	sum+=band[j];
}


outlet_out=inlet_in+___SMMUL(sum-(param_mix>0?inlet_in:-inlet_in)<<1,param_mix<<4);]]></code.srate>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="eedfe6fa-0afa-492c-a133-e6fbbcccd9f5" name="soft booster" x="602" y="350">
      <params>
         <frac32.u.map name="amp" value="49.0"/>
         <frac32.u.map name="tres" value="14.5"/>
         <frac32.u.map name="max" value="58.5"/>
      </params>
      <attribs/>
      <object id="patch/object" uuid="eedfe6fa-0afa-492c-a133-e6fbbcccd9f5">
         <sDescription>Multiply (attenuate) with a constant value</sDescription>
         <author>Johannes Taelman</author>
         <license>BSD</license>
         <helpPatch>math.axh</helpPatch>
         <inlets>
            <frac32buffer name="in" description="input"/>
         </inlets>
         <outlets>
            <frac32buffer name="out" description="output"/>
         </outlets>
         <displays/>
         <params>
            <frac32.u.map.gain name="amp" noLabel="true"/>
            <frac32.u.map name="tres"/>
            <frac32.u.map name="max"/>
         </params>
         <attribs/>
         <includes/>
         <code.declaration><![CDATA[int32_t SAT(int32_t in,int32_t trs,int32_t mx)
{
	int32_t norm=in;
	norm=norm>trs?trs:(norm<-trs?-trs:norm);
	int32_t left=in-norm;
	float32_t ratio=(float32_t)mx/(mx+(left>0?left:-left));
	return left=left*ratio+norm;
}]]></code.declaration>
         <code.krate><![CDATA[int32_t max=___SMMUL(param_max<<4,(1<<27)-param_tres<<1)+1;]]></code.krate>
         <code.srate><![CDATA[int32_t in=inlet_in;
for(int i=0;i<2;i++)
{
	in+=(__SSAT(___SMMUL(in,param_amp),27)<<4);
	in=SAT(in,param_tres,max);
}
outlet_out=in;]]></code.srate>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="baa42ea4-0e0a-41dc-8e35-908917a1eaa6" name="basePatt_1" x="700" y="350">
      <params>
         <frac32.u.map name="length" value="64.0"/>
         <frac32.u.map name="base" value="0.0"/>
         <frac32.u.map name="diffchance" value="41.5"/>
         <frac32.u.map name="differents" value="23.5"/>
         <frac32.u.map name="diffsize" value="64.0"/>
         <bool32.tgl name="nonseed" value="0"/>
      </params>
      <attribs>
         <spinner attributeName="max" value="12"/>
      </attribs>
      <object id="patch/object" uuid="baa42ea4-0e0a-41dc-8e35-908917a1eaa6">
         <sDescription>Pattern generator that normally outputs the &quot;base&quot; value and having a chance that it&apos;s randomly changed. This can be either as a random-pattern (count input) or ongoing randomly generated.
Amount of different random values can be set as well as a difference size (offset from base).
Checking the &quot;nonseed&quot; box will use non-repeating random values instead the randomised pattern, basically setting the &quot;differents&quot; to unlimited.</sDescription>
         <author>Remco van der Most</author>
         <license>BSD</license>
         <helpPatch>table.axh</helpPatch>
         <inlets>
            <int32 name="count"/>
            <bool32 name="rnd"/>
            <frac32 name="base"/>
            <frac32 name="diffchance"/>
         </inlets>
         <outlets>
            <int32 name="index"/>
         </outlets>
         <displays/>
         <params>
            <frac32.u.map name="length"/>
            <frac32.u.map name="base"/>
            <frac32.u.map name="diffchance"/>
            <frac32.u.map name="differents"/>
            <frac32.u.map name="diffsize"/>
            <bool32.tgl name="nonseed"/>
         </params>
         <attribs>
            <spinner name="max" MinValue="0" MaxValue="8192" DefaultValue="0"/>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[static const uint32_t LENGTHPOW = (6);
static const uint32_t LENGTH = (1<<6);
static const uint32_t LENGTHMASK = ((1<<6)-1);
static const uint32_t BITS = 8;
static const uint32_t GAIN = 20;
int sz=attr_max+1;
uint8_t *a1,*a2;
uint16_t *a3;
int val,i,pos,prv;
bool rnd;]]></code.declaration>
         <code.init><![CDATA[static uint8_t _a1[LENGTH] __attribute__ ((section (".sdram")));
a1 = &_a1[0];
static uint8_t _a2[LENGTH] __attribute__ ((section (".sdram")));
a2 = &_a2[0];
static uint16_t _a3[LENGTH] __attribute__ ((section (".sdram")));
a3 = &_a3[0];
{ 
  int i;
  for(i=0;i<LENGTH;i++){
  	a1[i]=(uint8_t)GenerateRandomNumber();
  	a2[i]=(uint8_t)GenerateRandomNumber();
  	a3[i]=(uint16_t)GenerateRandomNumber();
  }
}]]></code.init>
         <code.krate><![CDATA[if((inlet_rnd>0)&&!rnd){
	rnd=1;
	for(i=0;i<LENGTH;i++){
	a1[i]=(uint8_t)GenerateRandomNumber();
  	a2[i]=(uint8_t)GenerateRandomNumber();
  	a3[i]=(uint16_t)GenerateRandomNumber();
	}
}
else if(inlet_rnd<1){rnd=0;}

if(!(inlet_count==prv)){
int length=param_length>>21;
length=length>0?length:1;
int cnt=inlet_count;
cnt=cnt-cnt/length*length;
cnt+=cnt<0?length:0;
cnt=cnt&63;
int base=___SMMUL(__USAT(param_base+inlet_base,27)<<4,sz-1<<1);
val=base;

if((param_nonseed<1?a2[cnt]:(uint8_t)(GenerateRandomNumber()))<(__USAT(param_diffchance+inlet_diffchance,27)>>19)){
val+=___SMMUL(___SMMUL((int32_t)a3[___SMMUL((param_nonseed<1?a1[cnt]:(uint8_t)(GenerateRandomNumber())<<1),param_differents<<2)]<<13,param_diffsize)<<5,sz<<3)+1;
}
val=val-val/sz*sz;
val+=(val<0?sz:0);
}
outlet_index=val;
prv=inlet_count;]]></code.krate>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="baa42ea4-0e0a-41dc-8e35-908917a1eaa6" name="basePatt_3" x="798" y="350">
      <params>
         <frac32.u.map name="length" value="64.0"/>
         <frac32.u.map name="base" value="0.0"/>
         <frac32.u.map name="diffchance" value="44.0"/>
         <frac32.u.map name="differents" value="19.0"/>
         <frac32.u.map name="diffsize" value="64.0"/>
         <bool32.tgl name="nonseed" value="0"/>
      </params>
      <attribs>
         <spinner attributeName="max" value="12"/>
      </attribs>
      <object id="patch/object" uuid="baa42ea4-0e0a-41dc-8e35-908917a1eaa6">
         <sDescription>Pattern generator that normally outputs the &quot;base&quot; value and having a chance that it&apos;s randomly changed. This can be either as a random-pattern (count input) or ongoing randomly generated.
Amount of different random values can be set as well as a difference size (offset from base).
Checking the &quot;nonseed&quot; box will use non-repeating random values instead the randomised pattern, basically setting the &quot;differents&quot; to unlimited.</sDescription>
         <author>Remco van der Most</author>
         <license>BSD</license>
         <helpPatch>table.axh</helpPatch>
         <inlets>
            <int32 name="count"/>
            <bool32 name="rnd"/>
            <frac32 name="base"/>
            <frac32 name="diffchance"/>
         </inlets>
         <outlets>
            <int32 name="index"/>
         </outlets>
         <displays/>
         <params>
            <frac32.u.map name="length"/>
            <frac32.u.map name="base"/>
            <frac32.u.map name="diffchance"/>
            <frac32.u.map name="differents"/>
            <frac32.u.map name="diffsize"/>
            <bool32.tgl name="nonseed"/>
         </params>
         <attribs>
            <spinner name="max" MinValue="0" MaxValue="8192" DefaultValue="0"/>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[static const uint32_t LENGTHPOW = (6);
static const uint32_t LENGTH = (1<<6);
static const uint32_t LENGTHMASK = ((1<<6)-1);
static const uint32_t BITS = 8;
static const uint32_t GAIN = 20;
int sz=attr_max+1;
uint8_t *a1,*a2;
uint16_t *a3;
int val,i,pos,prv;
bool rnd;]]></code.declaration>
         <code.init><![CDATA[static uint8_t _a1[LENGTH] __attribute__ ((section (".sdram")));
a1 = &_a1[0];
static uint8_t _a2[LENGTH] __attribute__ ((section (".sdram")));
a2 = &_a2[0];
static uint16_t _a3[LENGTH] __attribute__ ((section (".sdram")));
a3 = &_a3[0];
{ 
  int i;
  for(i=0;i<LENGTH;i++){
  	a1[i]=(uint8_t)GenerateRandomNumber();
  	a2[i]=(uint8_t)GenerateRandomNumber();
  	a3[i]=(uint16_t)GenerateRandomNumber();
  }
}]]></code.init>
         <code.krate><![CDATA[if((inlet_rnd>0)&&!rnd){
	rnd=1;
	for(i=0;i<LENGTH;i++){
	a1[i]=(uint8_t)GenerateRandomNumber();
  	a2[i]=(uint8_t)GenerateRandomNumber();
  	a3[i]=(uint16_t)GenerateRandomNumber();
	}
}
else if(inlet_rnd<1){rnd=0;}

if(!(inlet_count==prv)){
int length=param_length>>21;
length=length>0?length:1;
int cnt=inlet_count;
cnt=cnt-cnt/length*length;
cnt+=cnt<0?length:0;
cnt=cnt&63;
int base=___SMMUL(__USAT(param_base+inlet_base,27)<<4,sz-1<<1);
val=base;

if((param_nonseed<1?a2[cnt]:(uint8_t)(GenerateRandomNumber()))<(__USAT(param_diffchance+inlet_diffchance,27)>>19)){
val+=___SMMUL(___SMMUL((int32_t)a3[___SMMUL((param_nonseed<1?a1[cnt]:(uint8_t)(GenerateRandomNumber())<<1),param_differents<<2)]<<13,param_diffsize)<<5,sz<<3)+1;
}
val=val-val/sz*sz;
val+=(val<0?sz:0);
}
outlet_index=val;
prv=inlet_count;]]></code.krate>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="d7ad8a80-cf67-42e0-b005-ad4d5d976336" name="filter_1" x="910" y="350">
      <params>
         <frac32.s.map name="pitch" value="7.0"/>
         <frac32.u.map name="res" value="40.0"/>
         <frac32.u.map name="FILTER_tres" value="12.0"/>
         <frac32.u.map name="FILTER_room" value="48.0"/>
         <frac32.s.map name="FILTER_asym" value="-18.0"/>
         <int32.hradio name="filtertype" value="0"/>
         <int32.hradio name="clipmode" value="3"/>
         <frac32.u.map name="wet" value="64.0"/>
         <frac32.u.map name="OUTPUT_tres" value="50.0"/>
         <frac32.u.map name="OUTPUT_room" value="12.5"/>
         <frac32.s.map name="OUTPUT_asym" value="12.0"/>
      </params>
      <attribs/>
      <object id="patch/object" uuid="d7ad8a80-cf67-42e0-b005-ad4d5d976336">
         <sDescription>Low pass filter, state-variable type</sDescription>
         <author>Johannes Taelman</author>
         <license>BSD</license>
         <helpPatch>filter.axh</helpPatch>
         <inlets>
            <frac32buffer name="in" description="filter input"/>
            <frac32 name="pitch"/>
            <frac32 name="res"/>
            <int32 name="filtertype"/>
         </inlets>
         <outlets>
            <frac32buffer name="out" description="filter output"/>
         </outlets>
         <displays/>
         <params>
            <frac32.s.map.pitch name="pitch"/>
            <frac32.u.map.filterq name="res"/>
            <frac32.u.map name="FILTER_tres"/>
            <frac32.u.map name="FILTER_room"/>
            <frac32.s.map name="FILTER_asym"/>
            <int32.hradio name="filtertype">
               <MaxValue i="13"/>
            </int32.hradio>
            <int32.hradio name="clipmode">
               <MaxValue i="4"/>
            </int32.hradio>
            <frac32.u.map name="wet"/>
            <frac32.u.map name="OUTPUT_tres"/>
            <frac32.u.map name="OUTPUT_room"/>
            <frac32.s.map name="OUTPUT_asym"/>
         </params>
         <attribs/>
         <includes/>
         <code.declaration><![CDATA[int32_t band,low;
int32_t SAT(int32_t in,int32_t trs,int32_t mx)
{
	int32_t norm=in;
	norm=norm>trs?trs:(norm<-trs?-trs:norm);
	int32_t left=in-norm;
	float32_t ratio=(float32_t)mx/(mx+(left>0?left:-left));
	return left=left*ratio+norm;
}]]></code.declaration>
         <code.init><![CDATA[low = 0;
band = 0;]]></code.init>
         <code.krate><![CDATA[int32_t damp = (0x80<<24) - (__USAT(param_res+inlet_res,27)<<4);
damp = ___SMMUL(damp,damp);
int32_t alpha;
int32_t freq;
MTOFEXTENDED(param_pitch+inlet_pitch,alpha);
SINE2TINTERP(alpha,freq);
int32_t maxF=___SMMUL(param_FILTER__room<<4,(1<<28)-param_FILTER__tres<<1)+1;
int32_t maxO=___SMMUL(param_OUTPUT__room<<4,(1<<28)-param_OUTPUT__tres<<1)+1;
int mode=(param_filtertype+inlet_filtertype+1300)%13;]]></code.krate>
         <code.srate><![CDATA[int32_t in1 = inlet_in;
//create bandreject
int32_t bnd=(___SMMUL(damp,band)<<1);
int32_t notch = inlet_in - bnd;
//integrate lowpass
low = low + (___SMMUL(freq,band)<<1);
//create highpass
int32_t high  = notch - low;
//integrate bandpass
band = (___SMMUL(freq,high)<<1) + band;
//soft-clip none, bandpass,lowpass or band&lowpass integrators
switch(param_clipmode)
{
	case 1: 	band=SAT(band,__SSAT(param_FILTER__tres+___SMMUL(band,param_FILTER__asym<<3),28),maxF);break;
	case 2: 	low=SAT(low,__SSAT(param_FILTER__tres+___SMMUL(low,-param_FILTER__asym<<3),28),maxF);break;
	case 3: 	band=SAT(band,__SSAT(param_FILTER__tres+___SMMUL(band,param_FILTER__asym<<3),28),maxF);
			low=SAT(low,__SSAT(param_FILTER__tres+___SMMUL(low,-param_FILTER__asym<<3),28),maxF);
	break;
}

//select filter type output
int32_t out;
switch(mode)
{
	case 0: out=low;break;//normal lowpass
	case 1: out=low-band;break;//lowpass-bandpass difference
	case 2: out=low+band;break;//lowpass with bandpass
	
	case 3: out=band;break;//normal bandpass
	
	case 4: out=high+band;break;//highpass with bandpass
	case 5: out=high-band;break;//highpass-bandpass difference
	case 6: out=high;break;//normal high
	
	case 7: out=notch;break;//normal bandreject

	case 8: out=notch-bnd;break;//allpass ripple
	
	case 9: out=inlet_in+band;break;//peak
	case 10: out=notch-band;break;//peak ripple1
	case 11: out=notch+band;break;//peak ripple2
	case 12: out=low-high;break;//peak ripple3
}
out=inlet_in+(___SMMUL(out-inlet_in,param_wet<<4)<<1);
out = SAT(out,__SSAT(param_OUTPUT__tres+___SMMUL(out,param_OUTPUT__asym<<4),28),maxO);;
outlet_out = out;]]></code.srate>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="d7ad8a80-cf67-42e0-b005-ad4d5d976336" name="filter_2" x="1120" y="350">
      <params>
         <frac32.s.map name="pitch" value="5.0"/>
         <frac32.u.map name="res" value="39.0"/>
         <frac32.u.map name="FILTER_tres" value="13.5"/>
         <frac32.u.map name="FILTER_room" value="48.5"/>
         <frac32.s.map name="FILTER_asym" value="14.0"/>
         <int32.hradio name="filtertype" value="7"/>
         <int32.hradio name="clipmode" value="3"/>
         <frac32.u.map name="wet" value="64.0"/>
         <frac32.u.map name="OUTPUT_tres" value="48.5"/>
         <frac32.u.map name="OUTPUT_room" value="14.0"/>
         <frac32.s.map name="OUTPUT_asym" value="12.0"/>
      </params>
      <attribs/>
      <object id="patch/object" uuid="d7ad8a80-cf67-42e0-b005-ad4d5d976336">
         <sDescription>Low pass filter, state-variable type</sDescription>
         <author>Johannes Taelman</author>
         <license>BSD</license>
         <helpPatch>filter.axh</helpPatch>
         <inlets>
            <frac32buffer name="in" description="filter input"/>
            <frac32 name="pitch"/>
            <frac32 name="res"/>
            <int32 name="filtertype"/>
         </inlets>
         <outlets>
            <frac32buffer name="out" description="filter output"/>
         </outlets>
         <displays/>
         <params>
            <frac32.s.map.pitch name="pitch"/>
            <frac32.u.map.filterq name="res"/>
            <frac32.u.map name="FILTER_tres"/>
            <frac32.u.map name="FILTER_room"/>
            <frac32.s.map name="FILTER_asym"/>
            <int32.hradio name="filtertype">
               <MaxValue i="13"/>
            </int32.hradio>
            <int32.hradio name="clipmode">
               <MaxValue i="4"/>
            </int32.hradio>
            <frac32.u.map name="wet"/>
            <frac32.u.map name="OUTPUT_tres"/>
            <frac32.u.map name="OUTPUT_room"/>
            <frac32.s.map name="OUTPUT_asym"/>
         </params>
         <attribs/>
         <includes/>
         <code.declaration><![CDATA[int32_t band,low;
int32_t SAT(int32_t in,int32_t trs,int32_t mx)
{
	int32_t norm=in;
	norm=norm>trs?trs:(norm<-trs?-trs:norm);
	int32_t left=in-norm;
	float32_t ratio=(float32_t)mx/(mx+(left>0?left:-left));
	return left=left*ratio+norm;
}]]></code.declaration>
         <code.init><![CDATA[low = 0;
band = 0;]]></code.init>
         <code.krate><![CDATA[int32_t damp = (0x80<<24) - (__USAT(param_res+inlet_res,27)<<4);
damp = ___SMMUL(damp,damp);
int32_t alpha;
int32_t freq;
MTOFEXTENDED(param_pitch+inlet_pitch,alpha);
SINE2TINTERP(alpha,freq);
int32_t maxF=___SMMUL(param_FILTER__room<<4,(1<<28)-param_FILTER__tres<<1)+1;
int32_t maxO=___SMMUL(param_OUTPUT__room<<4,(1<<28)-param_OUTPUT__tres<<1)+1;
int mode=(param_filtertype+inlet_filtertype+1300)%13;]]></code.krate>
         <code.srate><![CDATA[int32_t in1 = inlet_in;
//create bandreject
int32_t bnd=(___SMMUL(damp,band)<<1);
int32_t notch = inlet_in - bnd;
//integrate lowpass
low = low + (___SMMUL(freq,band)<<1);
//create highpass
int32_t high  = notch - low;
//integrate bandpass
band = (___SMMUL(freq,high)<<1) + band;
//soft-clip none, bandpass,lowpass or band&lowpass integrators
switch(param_clipmode)
{
	case 1: 	band=SAT(band,__SSAT(param_FILTER__tres+___SMMUL(band,param_FILTER__asym<<3),28),maxF);break;
	case 2: 	low=SAT(low,__SSAT(param_FILTER__tres+___SMMUL(low,-param_FILTER__asym<<3),28),maxF);break;
	case 3: 	band=SAT(band,__SSAT(param_FILTER__tres+___SMMUL(band,param_FILTER__asym<<3),28),maxF);
			low=SAT(low,__SSAT(param_FILTER__tres+___SMMUL(low,-param_FILTER__asym<<3),28),maxF);
	break;
}

//select filter type output
int32_t out;
switch(mode)
{
	case 0: out=low;break;//normal lowpass
	case 1: out=low-band;break;//lowpass-bandpass difference
	case 2: out=low+band;break;//lowpass with bandpass
	
	case 3: out=band;break;//normal bandpass
	
	case 4: out=high+band;break;//highpass with bandpass
	case 5: out=high-band;break;//highpass-bandpass difference
	case 6: out=high;break;//normal high
	
	case 7: out=notch;break;//normal bandreject

	case 8: out=notch-bnd;break;//allpass ripple
	
	case 9: out=inlet_in+band;break;//peak
	case 10: out=notch-band;break;//peak ripple1
	case 11: out=notch+band;break;//peak ripple2
	case 12: out=low-high;break;//peak ripple3
}
out=inlet_in+(___SMMUL(out-inlet_in,param_wet<<4)<<1);
out = SAT(out,__SSAT(param_OUTPUT__tres+___SMMUL(out,param_OUTPUT__asym<<4),28),maxO);;
outlet_out = out;]]></code.srate>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="d7ad8a80-cf67-42e0-b005-ad4d5d976336" name="bass boost using highpass filter" x="1330" y="350">
      <params>
         <frac32.s.map name="pitch" value="-26.0"/>
         <frac32.u.map name="res" value="23.0"/>
         <frac32.u.map name="FILTER_tres" value="14.5"/>
         <frac32.u.map name="FILTER_room" value="49.5"/>
         <frac32.s.map name="FILTER_asym" value="-23.0"/>
         <int32.hradio name="filtertype" value="5"/>
         <int32.hradio name="clipmode" value="3"/>
         <frac32.u.map name="wet" value="64.0"/>
         <frac32.u.map name="OUTPUT_tres" value="52.0"/>
         <frac32.u.map name="OUTPUT_room" value="28.0"/>
         <frac32.s.map name="OUTPUT_asym" value="-43.0"/>
      </params>
      <attribs/>
      <object id="patch/object" uuid="d7ad8a80-cf67-42e0-b005-ad4d5d976336">
         <sDescription>Low pass filter, state-variable type</sDescription>
         <author>Johannes Taelman</author>
         <license>BSD</license>
         <helpPatch>filter.axh</helpPatch>
         <inlets>
            <frac32buffer name="in" description="filter input"/>
            <frac32 name="pitch"/>
            <frac32 name="res"/>
            <int32 name="filtertype"/>
         </inlets>
         <outlets>
            <frac32buffer name="out" description="filter output"/>
         </outlets>
         <displays/>
         <params>
            <frac32.s.map.pitch name="pitch"/>
            <frac32.u.map.filterq name="res"/>
            <frac32.u.map name="FILTER_tres"/>
            <frac32.u.map name="FILTER_room"/>
            <frac32.s.map name="FILTER_asym"/>
            <int32.hradio name="filtertype">
               <MaxValue i="13"/>
            </int32.hradio>
            <int32.hradio name="clipmode">
               <MaxValue i="4"/>
            </int32.hradio>
            <frac32.u.map name="wet"/>
            <frac32.u.map name="OUTPUT_tres"/>
            <frac32.u.map name="OUTPUT_room"/>
            <frac32.s.map name="OUTPUT_asym"/>
         </params>
         <attribs/>
         <includes/>
         <code.declaration><![CDATA[int32_t band,low;
int32_t SAT(int32_t in,int32_t trs,int32_t mx)
{
	int32_t norm=in;
	norm=norm>trs?trs:(norm<-trs?-trs:norm);
	int32_t left=in-norm;
	float32_t ratio=(float32_t)mx/(mx+(left>0?left:-left));
	return left=left*ratio+norm;
}]]></code.declaration>
         <code.init><![CDATA[low = 0;
band = 0;]]></code.init>
         <code.krate><![CDATA[int32_t damp = (0x80<<24) - (__USAT(param_res+inlet_res,27)<<4);
damp = ___SMMUL(damp,damp);
int32_t alpha;
int32_t freq;
MTOFEXTENDED(param_pitch+inlet_pitch,alpha);
SINE2TINTERP(alpha,freq);
int32_t maxF=___SMMUL(param_FILTER__room<<4,(1<<28)-param_FILTER__tres<<1)+1;
int32_t maxO=___SMMUL(param_OUTPUT__room<<4,(1<<28)-param_OUTPUT__tres<<1)+1;
int mode=(param_filtertype+inlet_filtertype+1300)%13;]]></code.krate>
         <code.srate><![CDATA[int32_t in1 = inlet_in;
//create bandreject
int32_t bnd=(___SMMUL(damp,band)<<1);
int32_t notch = inlet_in - bnd;
//integrate lowpass
low = low + (___SMMUL(freq,band)<<1);
//create highpass
int32_t high  = notch - low;
//integrate bandpass
band = (___SMMUL(freq,high)<<1) + band;
//soft-clip none, bandpass,lowpass or band&lowpass integrators
switch(param_clipmode)
{
	case 1: 	band=SAT(band,__SSAT(param_FILTER__tres+___SMMUL(band,param_FILTER__asym<<3),28),maxF);break;
	case 2: 	low=SAT(low,__SSAT(param_FILTER__tres+___SMMUL(low,-param_FILTER__asym<<3),28),maxF);break;
	case 3: 	band=SAT(band,__SSAT(param_FILTER__tres+___SMMUL(band,param_FILTER__asym<<3),28),maxF);
			low=SAT(low,__SSAT(param_FILTER__tres+___SMMUL(low,-param_FILTER__asym<<3),28),maxF);
	break;
}

//select filter type output
int32_t out;
switch(mode)
{
	case 0: out=low;break;//normal lowpass
	case 1: out=low-band;break;//lowpass-bandpass difference
	case 2: out=low+band;break;//lowpass with bandpass
	
	case 3: out=band;break;//normal bandpass
	
	case 4: out=high+band;break;//highpass with bandpass
	case 5: out=high-band;break;//highpass-bandpass difference
	case 6: out=high;break;//normal high
	
	case 7: out=notch;break;//normal bandreject

	case 8: out=notch-bnd;break;//allpass ripple
	
	case 9: out=inlet_in+band;break;//peak
	case 10: out=notch-band;break;//peak ripple1
	case 11: out=notch+band;break;//peak ripple2
	case 12: out=low-high;break;//peak ripple3
}
out=inlet_in+(___SMMUL(out-inlet_in,param_wet<<4)<<1);
out = SAT(out,__SSAT(param_OUTPUT__tres+___SMMUL(out,param_OUTPUT__asym<<4),28),maxO);;
outlet_out = out;]]></code.srate>
      </object>
   </patchobj>
   <obj type="gain/vca" uuid="a9f2dcd18043e2f47364e45cb8814f63c2a37c0d" name="vca_2" x="1540" y="350">
      <params/>
      <attribs/>
   </obj>
   <obj type="fx/rngs/reverb" uuid="bb0fb9e0-aafe-4501-ba83-897f2530751d" name="reverb_1" x="994" y="868">
      <params>
         <frac32.u.map name="amount" value="13.5"/>
         <frac32.u.map name="time" value="50.0"/>
         <frac32.u.map name="diffusion" value="49.5"/>
         <frac32.u.map name="gain" value="20.5"/>
         <frac32.u.map name="lowpass" value="36.0"/>
      </params>
      <attribs/>
   </obj>
   <obj type="sss/audio/StOutVol" uuid="0ca9cf1e-1ce3-469c-80da-a4a885c21246" name="StOutVol_1" x="1344" y="896">
      <params>
         <frac32.u.map name="volume" value="35.0"/>
      </params>
      <attribs/>
   </obj>
   <nets>
      <net>
         <source obj="square_1" outlet="wave"/>
         <dest obj="counter_1" inlet="trig"/>
         <dest obj="ad_1" inlet="trig"/>
         <dest obj="counter_3" inlet="trig"/>
         <dest obj="counter_4" inlet="trig"/>
         <dest obj="ad_4" inlet="trig"/>
      </net>
      <net>
         <source obj="counter_1" outlet="o"/>
         <dest obj="basePatt_2" inlet="count"/>
      </net>
      <net>
         <source obj="counter_1" outlet="c"/>
         <dest obj="counter_2" inlet="trig"/>
         <dest obj="ad_2" inlet="trig"/>
      </net>
      <net>
         <source obj="5x rnd bandpass" outlet="out"/>
         <dest obj="soft booster" inlet="in"/>
      </net>
      <net>
         <source obj="filter_1" outlet="out"/>
         <dest obj="filter_2" inlet="in"/>
      </net>
      <net>
         <source obj="ad_1" outlet="env"/>
         <dest obj="*_1" inlet="b"/>
         <dest obj="*_2" inlet="b"/>
      </net>
      <net>
         <source obj="mix_1" outlet="out"/>
         <dest obj="filter_1" inlet="pitch"/>
      </net>
      <net>
         <source obj="ad_2" outlet="env"/>
         <dest obj="*_1" inlet="a"/>
         <dest obj="*_3" inlet="a"/>
      </net>
      <net>
         <source obj="soft booster" outlet="out"/>
         <dest obj="filter_1" inlet="in"/>
      </net>
      <net>
         <source obj="sine_1" outlet="wave"/>
         <dest obj="mix_1" inlet="in2"/>
      </net>
      <net>
         <source obj="*_1" outlet="result"/>
         <dest obj="mix_1" inlet="in1"/>
      </net>
      <net>
         <source obj="basePatt_1" outlet="index"/>
         <dest obj="filter_1" inlet="filtertype"/>
      </net>
      <net>
         <source obj="counter_2" outlet="c"/>
         <dest obj="basePatt_2" inlet="rnd"/>
         <dest obj="5x rnd bandpass" inlet="rnd"/>
         <dest obj="basePatt_1" inlet="rnd"/>
         <dest obj="basePatt_3" inlet="rnd"/>
      </net>
      <net>
         <source obj="mix_2" outlet="out"/>
         <dest obj="vca_1" inlet="a"/>
      </net>
      <net>
         <source obj="saw_1" outlet="wave"/>
         <dest obj="mix_2" inlet="in1"/>
      </net>
      <net>
         <source obj="saw_2" outlet="wave"/>
         <dest obj="mix_2" inlet="in2"/>
      </net>
      <net>
         <source obj="basePatt_2" outlet="index"/>
         <dest obj="5x rnd bandpass" inlet="pst"/>
      </net>
      <net>
         <source obj="vca_1" outlet="o"/>
         <dest obj="5x rnd bandpass" inlet="in"/>
      </net>
      <net>
         <source obj="counter_3" outlet="c"/>
         <dest obj="ad_3" inlet="trig"/>
      </net>
      <net>
         <source obj="ad_3" outlet="env"/>
         <dest obj="*_2" inlet="a"/>
      </net>
      <net>
         <source obj="*_2" outlet="result"/>
         <dest obj="vca_1" inlet="v"/>
         <dest obj="mix_4" inlet="in1"/>
         <dest obj="vca_2" inlet="v"/>
      </net>
      <net>
         <source obj="counter_4" outlet="o"/>
         <dest obj="basePatt_1" inlet="count"/>
         <dest obj="basePatt_3" inlet="count"/>
      </net>
      <net>
         <source obj="filter_2" outlet="out"/>
         <dest obj="bass boost using highpass filter" inlet="in"/>
      </net>
      <net>
         <source obj="basePatt_3" outlet="index"/>
         <dest obj="filter_2" inlet="filtertype"/>
      </net>
      <net>
         <source obj="sine_2" outlet="wave"/>
         <dest obj="mix_3" inlet="in2"/>
      </net>
      <net>
         <source obj="mix_3" outlet="out"/>
         <dest obj="filter_2" inlet="pitch"/>
      </net>
      <net>
         <source obj="ad_4" outlet="env"/>
         <dest obj="*_3" inlet="b"/>
      </net>
      <net>
         <source obj="*_3" outlet="result"/>
         <dest obj="mix_3" inlet="in1"/>
         <dest obj="mix_4" inlet="in2"/>
      </net>
      <net>
         <source obj="vca_2" outlet="o"/>
         <dest obj="reverb_1" inlet="l"/>
         <dest obj="reverb_1" inlet="r"/>
      </net>
      <net>
         <source obj="mix_4" outlet="out"/>
         <dest obj="bass boost using highpass filter" inlet="res"/>
      </net>
      <net>
         <source obj="reverb_1" outlet="l"/>
         <dest obj="StOutVol_1" inlet="left"/>
      </net>
      <net>
         <source obj="reverb_1" outlet="r"/>
         <dest obj="StOutVol_1" inlet="right"/>
      </net>
      <net>
         <source obj="bass boost using highpass filter" outlet="out"/>
         <dest obj="vca_2" inlet="a"/>
      </net>
   </nets>
   <settings>
      <subpatchmode>no</subpatchmode>
   </settings>
   <notes><![CDATA[]]></notes>
   <windowPos>
      <x>-8</x>
      <y>-8</y>
      <width>1874</width>
      <height>1096</height>
   </windowPos>
</patch-1.0>