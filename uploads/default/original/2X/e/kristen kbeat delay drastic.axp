<patch-1.0 appVersion="1.0.12">
   <comment type="patch/comment" x="588" y="0" text="DELAY                                                                              "/>
   <comment type="patch/comment" x="322" y="14" text="bypass"/>
   <comment type="patch/comment" x="420" y="14" text="dry/wet"/>
   <comment type="patch/comment" x="588" y="14" text="division/speed"/>
   <comment type="patch/comment" x="686" y="14" text="feedback"/>
   <comment type="patch/comment" x="784" y="14" text="low pass filter"/>
   <comment type="patch/comment" x="980" y="14" text="MODULATION                                                                                      "/>
   <comment type="patch/comment" x="1414" y="14" text="sample and hold division"/>
   <comment type="patch/comment" x="28" y="28" text="CLOCK                                                                   "/>
   <obj type="ctrl/toggle" uuid="42b8134fa729d54bfc8d62d6ef3fa99498c1de99" name="toggle_1" x="322" y="28">
      <params>
         <bool32.tgl name="b" value="0"/>
      </params>
      <attribs/>
   </obj>
   <obj type="ctrl/dial p" uuid="cc5d2846c3d50e425f450c4b9851371b54f4d674" name="dial_3" x="420" y="28">
      <params>
         <frac32.u.map name="value" value="33.5"/>
      </params>
      <attribs/>
   </obj>
   <obj type="ctrl/dial p" uuid="cc5d2846c3d50e425f450c4b9851371b54f4d674" name="dial_2" x="588" y="28">
      <params>
         <frac32.u.map name="value" value="33.5"/>
      </params>
      <attribs/>
   </obj>
   <obj type="ctrl/dial p" uuid="cc5d2846c3d50e425f450c4b9851371b54f4d674" name="dial_1" x="686" y="28">
      <params>
         <frac32.u.map name="value" value="48.5"/>
      </params>
      <attribs/>
   </obj>
   <obj type="ctrl/dial p" uuid="cc5d2846c3d50e425f450c4b9851371b54f4d674" name="dial_10" x="784" y="28">
      <params>
         <frac32.u.map name="value" value="54.5"/>
      </params>
      <attribs/>
   </obj>
   <comment type="patch/comment" x="980" y="28" text="increase mod depth"/>
   <comment type="patch/comment" x="1106" y="28" text="mod division/speed"/>
   <comment type="patch/comment" x="1232" y="28" text="mod depth"/>
   <comment type="patch/comment" x="1344" y="28" text="pulsewidth"/>
   <comment type="patch/comment" x="1442" y="28" text="0=off"/>
   <comment type="patch/comment" x="28" y="42" text="tap"/>
   <comment type="patch/comment" x="98" y="42" text="tap tempo on"/>
   <comment type="patch/comment" x="224" y="42" text="unsync"/>
   <obj type="ctrl/i radio 4 h" uuid="f87ae81e3162014f3bdca0f56dbbdf9322e69dfd" name="i_2" x="994" y="42">
      <params>
         <int32.hradio name="value" value="3"/>
      </params>
      <attribs/>
   </obj>
   <obj type="ctrl/dial p" uuid="cc5d2846c3d50e425f450c4b9851371b54f4d674" name="dial_4" x="1120" y="42">
      <params>
         <frac32.u.map name="value" value="22.5"/>
      </params>
      <attribs/>
   </obj>
   <obj type="ctrl/dial b" uuid="862e7d7f29093cb1ce4aed72244d118ad4d46692" name="dial_5" x="1232" y="42">
      <params>
         <frac32.s.map name="value" value="-64.0"/>
      </params>
      <attribs/>
   </obj>
   <obj type="ctrl/dial p" uuid="cc5d2846c3d50e425f450c4b9851371b54f4d674" name="dial_7" x="1344" y="42">
      <params>
         <frac32.u.map name="value" value="32.0"/>
      </params>
      <attribs/>
   </obj>
   <obj type="ctrl/dial p" uuid="cc5d2846c3d50e425f450c4b9851371b54f4d674" name="dial_9" x="1442" y="42">
      <params>
         <frac32.u.map name="value" value="33.0"/>
      </params>
      <attribs/>
   </obj>
   <obj type="ctrl/button" uuid="ef3d13774349df85aa9bfecf30dbc91ab8488b3f" name="button_1" x="28" y="56">
      <params>
         <bool32.mom name="b" value="0"/>
      </params>
      <attribs/>
   </obj>
   <obj type="ctrl/toggle" uuid="42b8134fa729d54bfc8d62d6ef3fa99498c1de99" name="toggle_3" x="98" y="56">
      <params>
         <bool32.tgl name="b" value="0"/>
      </params>
      <attribs/>
   </obj>
   <obj type="ctrl/toggle" uuid="42b8134fa729d54bfc8d62d6ef3fa99498c1de99" name="toggle_2" x="224" y="56">
      <params>
         <bool32.tgl name="b" value="0"/>
      </params>
      <attribs/>
   </obj>
   <comment type="patch/comment" x="504" y="126" text="NOTES                                   "/>
   <comment type="patch/comment" x="1008" y="140" text="SUPERMOD!!!"/>
   <comment type="patch/comment" x="420" y="154" text="*** NEEDS A MIDI CLOCK TO START, OR PRESS THE UNSYNC TOGGLES, OR TURN TAP TEMPO ON &amp; TAP ***"/>
   <obj type="ctrl/toggle" uuid="42b8134fa729d54bfc8d62d6ef3fa99498c1de99" name="toggle_6" x="1008" y="154">
      <params>
         <bool32.tgl name="b" value="1"/>
      </params>
      <attribs/>
   </obj>
   <comment type="patch/comment" x="1330" y="168" text="modulate  time or division"/>
   <comment type="patch/comment" x="392" y="182" text="* MIDI SYNC delay time and modulation time are midi synced by default,  division/speed knobs will cycle through divisions."/>
   <comment type="patch/comment" x="1106" y="182" text="modulation wave"/>
   <comment type="patch/comment" x="1302" y="182" text="(if on LFO will be sent to synced division "/>
   <comment type="patch/comment" x="392" y="196" text="    delay time starts at 1bar and goes through dotted and straight rythms, so 1bar, *1/2, 1/2, *1/4, 14, *1/8, etc."/>
   <comment type="patch/comment" x="1092" y="196" text="(triangle,sine,square,saw)"/>
   <comment type="patch/comment" x="1316" y="196" text="insted of directly top delay time"/>
   <comment type="patch/comment" x="406" y="210" text="The modulation division/speed knob does the same thing, but starts much slower. Both ranges can be adjusted "/>
   <obj type="ctrl/i radio 4 h" uuid="f87ae81e3162014f3bdca0f56dbbdf9322e69dfd" name="i_1" x="1120" y="210">
      <params>
         <int32.hradio name="value" value="3"/>
      </params>
      <attribs/>
   </obj>
   <obj type="ctrl/toggle" uuid="42b8134fa729d54bfc8d62d6ef3fa99498c1de99" name="toggle_5" x="1358" y="210">
      <params>
         <bool32.tgl name="b" value="0"/>
      </params>
      <attribs/>
   </obj>
   <comment type="patch/comment" x="406" y="224" text="in the divider objects below. Both can be unsynced, using the relevant toggle, and then  the division speed knob "/>
   <comment type="patch/comment" x="1008" y="224" text="Reset mod LFO"/>
   <comment type="patch/comment" x="406" y="238" text="will control the speed unsynced, undivided."/>
   <comment type="patch/comment" x="1008" y="238" text="phase"/>
   <obj type="ctrl/button" uuid="ef3d13774349df85aa9bfecf30dbc91ab8488b3f" name="button_2" x="1008" y="252">
      <params>
         <bool32.mom name="b" value="0"/>
      </params>
      <attribs/>
   </obj>
   <comment type="patch/comment" x="392" y="266" text="*TAP TEMPO if you swith the tap tempo on the delay time will sync to the tap instead of the midi."/>
   <comment type="patch/comment" x="406" y="280" text="If unsync is on the tap tempo is ignored"/>
   <comment type="patch/comment" x="392" y="308" text="*MODULATION the  &quot;increase mod depth&quot; and &quot;super mod&quot; controls change the way the modulation depth control responds."/>
   <comment type="patch/comment" x="406" y="322" text=" if you want subtle  stuff, use the first &quot;increase mod depth&quot;setting. for weirder stuff use a higher setting."/>
   <comment type="patch/comment" x="1232" y="322" text="synced scope showing 2 bars"/>
   <comment type="patch/comment" x="406" y="336" text="If you would be pleased by even more modulation depth, use the &quot;SUPERMOD!!&quot; toggle. this ncreases the strength "/>
   <patchobj type="patch/object" uuid="22a365cb-2367-43ff-84a1-57981a03976c" name="kscope_1" x="1232" y="336">
      <params>
         <int32 name="zoom" value="3"/>
      </params>
      <attribs/>
      <object id="patch/object" uuid="22a365cb-2367-43ff-84a1-57981a03976c">
         <sDescription>slow positive control rate signal oscilloscope (time domain), showing 128 consecutive samples or sub samples.</sDescription>
         <author>Smashed Transistors based on Johannes Taelman</author>
         <license>BSD</license>
         <helpPatch>kscope 128 b sl.axh</helpPatch>
         <rotatedParams>true</rotatedParams>
         <inlets>
            <frac32.positive name="in" description="input"/>
            <int32 name="kbeat"/>
            <int32 name="zoom"/>
            <bool32 name="reset"/>
         </inlets>
         <outlets/>
         <displays>
            <int8array128.vbar name="scope" noLabel="true"/>
         </displays>
         <params>
            <int32 name="zoom" noLabel="true">
               <MinValue i="0"/>
               <MaxValue i="256"/>
            </int32>
         </params>
         <attribs/>
         <includes/>
         <code.declaration><![CDATA[int8_t t[128];
int cpt;
int index;
int prev;
int r;
bool reset;]]></code.declaration>
         <code.init><![CDATA[int i;
for(i=0;i<128;i++) t[i]=0;
index = 0;
cpt=0;]]></code.init>
         <code.krate><![CDATA[cpt++;
if(cpt >= ((inlet_kbeat<<(param_zoom+inlet_zoom))/128)){
	cpt=0;
	disp_scope[index] = t[index] = (uint8_t)(inlet_in>>21);

  
	index++;
	if (index >= 128){
		index = 0;
	}

	/*for(int i = 0; i < 128; i++)
		disp_scope[i] = t[i];*/
  
}
if (inlet_reset&&!r){
	r=1;
	index=0;
	cpt=0;
}
if (!inlet_reset){
	r=0;
}]]></code.krate>
      </object>
   </patchobj>
   <comment type="patch/comment" x="406" y="350" text="in ratio to the other settings. This might not make sense, just try stuff"/>
   <comment type="patch/comment" x="409" y="364" text="****pulse width afects all wave types!**"/>
   <comment type="patch/comment" x="56" y="392" text="CLOCK                                                                "/>
   <comment type="patch/comment" x="392" y="392" text="*SAMPLE &amp; HOLD  - if the sample and hold division knob is 0, S&amp;H is turned off., if you turn it up it starts holding "/>
   <comment type="patch/comment" x="406" y="406" text="the modulation LFO at it&apos;s own timing division. If you turn the modulation speed to maximum, and the Mod speed is "/>
   <comment type="patch/comment" x="252" y="420" text="switch between midi"/>
   <comment type="patch/comment" x="406" y="420" text="synced it will produce noise. So, if you would like random sample &amp; hold, turn up the mod division knob to noise, "/>
   <comment type="patch/comment" x="14" y="434" text="tap tempo module"/>
   <comment type="patch/comment" x="126" y="434" text="midi clock receiver"/>
   <comment type="patch/comment" x="252" y="434" text=" clock and tap tempo"/>
   <comment type="patch/comment" x="406" y="434" text="and turn up the sample and hold division to control the speed"/>
   <patchobj type="patch/object" uuid="00fda506-1c00-4602-81e6-4199b4826421" name="tap_1" x="14" y="448">
      <params/>
      <attribs/>
      <object id="patch/object" uuid="00fda506-1c00-4602-81e6-4199b4826421">
         <license>GPL</license>
         <inlets>
            <bool32 name="tap"/>
         </inlets>
         <outlets>
            <int32 name="kbeat"/>
            <bool32 name="tapping"/>
            <bool32 name="trig"/>
         </outlets>
         <displays/>
         <params/>
         <attribs/>
         <includes/>
         <code.declaration><![CDATA[int tap[4];
int count;
int t;
int avg;
int ntrig;
int counttaken;
int lastcount;
int outcount;
int outrig;
int tapping;
int newtap;
int prevavg;]]></code.declaration>
         <code.init><![CDATA[t=-1;
count=-1;]]></code.init>
         <code.krate><![CDATA[outcount+=1;
if ((outcount>=avg)&&!newtap){
	if (avg>20){
		outrig=1;
	}
	outcount=0;
}
// timer
if (t>=0){
	t+=1;
}
if ((t>=((avg>>1)+avg))&&(avg>20)){
	newtap=0;
	tapping=0;
}

//tap
if (inlet_tap&&!ntrig){
	if (!tapping){
		count=-1;
			outrig=1;
			outcount=0;
			tapping=1;
			newtap=1;
			avg=0x07FFFFFF;
			tap[0]=0;
			tap[1]=0;
			tap[2]=0;
	}
	tapping=1;
	ntrig=1;
//	if ((t>=(avg<<3))&&(avg>20)){
//			count=-1;
//			outrig=1;
//			outcount=0;
//		}
		
	if (count>=0){
		
		tap[count]=t;
		if (newtap){
			outrig=1;
			avg=(tap[0]+tap[1]+tap[2])/(count+1);
		}
		if (!newtap){
		avg=(tap[0]+ tap[1]+tap[2])/3;
		}
	}
	lastcount=count;
	count+=1;

	if (count>=3){
		newtap=0;
		outcount=0;
		outrig=1;
		
		count=-1;
	}

	t=0;
}


if (!inlet_tap){
	ntrig=0;
}
if ((avg!=prevavg)&&(avg!=0X07FFFFFF)){
	prevavg=avg;
}
outlet_kbeat=prevavg;
outlet_trig=outrig;
outlet_tapping=tapping;

outrig=0;]]></code.krate>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="3914464d-774e-4973-b888-9dc1d6e0561e" name="clock_3" x="140" y="448">
      <params/>
      <attribs/>
      <object id="patch/object" uuid="3914464d-774e-4973-b888-9dc1d6e0561e">
         <sDescription>Midi clock slave</sDescription>
         <author>Johannes Taelman</author>
         <license>BSD</license>
         <helpPatch>midi_in.axh</helpPatch>
         <inlets/>
         <outlets>
            <bool32 name="active" description="Song is playing"/>
            <int32 name="kbeat" description="average length of a beat at k rate"/>
            <int32 name="kbeatAVG" description="same as kbeat but updates once per bar"/>
            <bool32.pulse name="start" description="start trigger"/>
            <bool32.pulse name="stop" description="stop trigger"/>
            <bool32.pulse name="1ppq" description="beat trigger, 1ppq"/>
            <int32 name="bpm" description="rough bpm"/>
            <bool32 name="bartrig" description="triggers every bar"/>
         </outlets>
         <displays/>
         <params/>
         <attribs/>
         <includes/>
         <code.declaration><![CDATA[int32_t _active;
int32_t _pos;
int32_t prevpos;
int tap;
int prevtap;
int tapped;
int tapV[24];
int start;
int stop;
int t;
int pos1ppq;
int firsttap;
int secondtap;
int taptotal;
int tapdiv;
int beattotal;
int beatdiv;
int beatavg;
int beatV[4];
int avg;
int beat;
int prevbeat;
int beattrig;
int avgH;
int beatcount;


int prevposbar;
int bartrig;
int posbar;]]></code.declaration>
         <code.init><![CDATA[_active = 0;
_pos = -1;
t=-1;
firsttap=0;
beat=-1;]]></code.init>
         <code.krate><![CDATA[outlet_active = _active;
outlet_start=start;
if (_pos>=0){
pos1ppq = _pos/24;
posbar=_pos/96;
}
else if (_pos<0){
pos1ppq = -1;	
posbar=-1;
}

if (t>=0){
t+=1;
}
if (start){
	tap=-1;
	}
	

if ((_pos!=prevpos)&&(_pos!=(-1))){
	prevpos=_pos;
	if ((t>0)&&(tap>=0)){
		tapV[tap]=t;
		if ((tap>=1)&&!firsttap){
			taptotal=tapV[tap]+tapV[prevtap];
			tapdiv=tap+1;
			avg=(taptotal/tapdiv)*24;
			beatavg=avg<<2;
		}
	}
	prevtap=tap;
	tap+=1;
	if (tap>=24){
	if (!firsttap){
		beat=0;
	}
	firsttap=1;
	tapdiv=24;
	taptotal=tapV[0]+tapV[1]+tapV[2]+tapV[3]+tapV[4]+tapV[5]+tapV[6]+tapV[7]+tapV[8]+tapV[9]+tapV[10]+tapV[11]+tapV[12]+tapV[13]+tapV[14]+tapV[15]+tapV[16]+tapV[17]+tapV[18]+tapV[19]+tapV[20]+tapV[21]+tapV[22]+tapV[23];
	avg=((taptotal*24)/tapdiv);
	
	tap=0;
	tapped=1;	
	
	}
	t=0;
}
if (tapped){
	beatV[beat]=avg;
	if ((beat>=1)&&!secondtap){
			beattotal=beatV[beat]+beatV[prevbeat];
			beatdiv=beat+1;
			beatavg=(beattotal/beatdiv);
			
		}
	
	prevbeat=beat;
	beat+=1;
	if (beat>=4){
		secondtap=1;
		
		beatcount=0;
		beat=0;
		beattotal=beatV[0]+beatV[1]+beatV[2]+beatV[3];
		beatdiv=4;
		beatavg=beattotal/beatdiv;
	}
}

if (start){

	beattrig=1;
	beatcount=0;
}

if ((posbar!=prevposbar)&&(posbar>=0)){
	prevposbar=posbar;
	bartrig=1;
}

//outlet_pos1ppq=pos1ppq;
outlet_stop=stop;
outlet_1ppq=tapped;
outlet_kbeat=avg;
outlet_kbeatAVG=beatavg;
outlet_bartrig=bartrig;
outlet_bpm=180000/avg;

tapped=0;
beattrig=0;
start=0;

stop=0;
bartrig=0;]]></code.krate>
         <code.midihandler><![CDATA[if (status == MIDI_TIMING_CLOCK) {
	if ((_pos==0)&&_active){
  	start=1;
  }
  _pos++;
  
  
} else if (status == MIDI_START) {
  _active = 1;
  _pos = 0;
  
} else if (status == MIDI_STOP) {
  _active = 0;
  stop=1;
  _pos = -1;
  tap=-1;

  
}]]></code.midihandler>
      </object>
   </patchobj>
   <obj type="mux/mux 2" uuid="16f90f81694766b0bc8187bfcba5a021e5701d81" name="mux_1" x="252" y="448">
      <params/>
      <attribs/>
   </obj>
   <comment type="patch/comment" x="350" y="490" text="midi start or"/>
   <comment type="patch/comment" x="350" y="504" text="button reset phase"/>
   <comment type="patch/comment" x="476" y="504" text="sample and hold time divider"/>
   <obj type="logic/or 2" uuid="3805d3c84d30032a44fbdbe42d9a2988a1790a3e" name="or_1" x="350" y="518">
      <params/>
      <attribs/>
   </obj>
   <patchobj type="patch/object" uuid="4b477b45-4662-4add-b185-eed0dbf98612" name="division_2" x="490" y="518">
      <params>
         <int32 name="start" value="10"/>
         <int32 name="end" value="20"/>
         <int32 name="offdiv" value="21"/>
      </params>
      <attribs/>
      <object id="patch/object" uuid="4b477b45-4662-4add-b185-eed0dbf98612">
         <license>GPL</license>
         <inlets>
            <int32 name="baselength"/>
            <bool32 name="retrig"/>
            <bool32 name="reset"/>
            <frac32.positive name="division"/>
         </inlets>
         <outlets>
            <int32 name="length"/>
            <bool32 name="trig"/>
            <bool32 name="off"/>
         </outlets>
         <displays/>
         <params>
            <int32 name="start">
               <MinValue i="0"/>
               <MaxValue i="28"/>
            </int32>
            <int32 name="end">
               <MinValue i="0"/>
               <MaxValue i="28"/>
            </int32>
            <int32 name="offdiv">
               <MinValue i="0"/>
               <MaxValue i="29"/>
            </int32>
         </params>
         <attribs/>
         <includes/>
         <code.declaration><![CDATA[int currentdivision;
int counter;
int baselength;
int division[29];
int INdivision;
int prevd;
int reset;
int resethold;
int divisionIN;
bool rtrig;
bool rrtrig;
bool trig;]]></code.declaration>
         <code.krate><![CDATA[//currentdivision=inlet_baselength<<2;
baselength=inlet_baselength;


divisionIN=(inlet_division/(0x07FFFFFF/(param_end-param_start+1)))+param_start;
if (divisionIN>=param_offdiv){
	outlet_off=1;
	INdivision=29;
}
else {outlet_off=0; INdivision=divisionIN;}


division[0]=baselength<<6;
division[1]=(baselength<<5)+(baselength<<4);
division[2]=baselength<<5;
division[3]=(baselength<<5)-(baselength<<2);
division[4]=(baselength<<4)+(baselength<<3);
division[5]=(baselength<<4)+(baselength<<2);
division[6]=baselength<<4;
division[7]=(baselength<<3)+(baselength<<2);
division[8]=baselength<<3;
division[9]=(baselength<<2)+((baselength<<2)>>1);
division[10]=baselength<<2;
division[11]=(baselength<<1)+(baselength);
division[12]=baselength<<1;
division[13]=baselength+(baselength>>1);
division[14]=baselength;
division[15]=((baselength>>1)+(baselength>>2));
division[16]=(baselength>>1);
division[17]=((baselength>>2)+(baselength>>3));
division[18]=(baselength>>2);
division[19]=((baselength>>3)+(baselength>>4));
division[20]=(baselength>>3);
division[21]=((baselength>>4)+(baselength>>5));
division[22]=(baselength>>4);
division[23]=((baselength>>5)+(baselength>>6));
division[24]=(baselength>>5);
division[25]=((baselength>>6)+(baselength>>7));
division[26]=(baselength>>6);
division[27]=((baselength>>7)+(baselength>>6));
division[28]=(baselength>>7);


//INdivision=inlet_division;
if (INdivision!=prevd){
	prevd=INdivision;
	resethold=1;
	
}


currentdivision=division[INdivision];


if (counter>=0){
	counter+=1;
}
if (inlet_retrig&&!rrtrig){
	rrtrig=1;
	if (resethold){
	reset=1;
	resethold=0;
	}
	
}
if (!inlet_retrig){
	rrtrig=0;
}
if (inlet_reset&&!rtrig){
	rtrig=1;
	reset=1;
	
}
if (!inlet_reset){
	rtrig=0;
}
if (reset){
	reset=0;
	counter=0;
	trig=1;
}
if ((counter>=currentdivision)&&(currentdivision!=0)){
	counter=0;
	trig=1;
}
outlet_length=currentdivision;
outlet_trig=trig;

trig=0;]]></code.krate>
      </object>
   </patchobj>
   <comment type="patch/comment" x="644" y="532" text="invert trigger"/>
   <comment type="patch/comment" x="756" y="532" text="if s&amp;h division knob &gt; 0, "/>
   <obj type="logic/inv" uuid="2bd44b865d3b63ff9b80862242bf5be779e3ad5" name="inv_2" x="644" y="546">
      <params/>
      <attribs/>
   </obj>
   <comment type="patch/comment" x="756" y="546" text="s&amp;h trigger is let through"/>
   <obj type="logic/and 2" uuid="c67031682f552aa0a80b23377495c51ea28a8c9c" name="and_1" x="770" y="560">
      <params/>
      <attribs/>
   </obj>
   <comment type="patch/comment" x="210" y="686" text="modulation/lfo time divider"/>
   <patchobj type="patch/object" uuid="798f1158-5a5a-4093-9379-fb5509f8b5da" name="division_1" x="210" y="700">
      <params>
         <int32 name="start" value="4"/>
         <int32 name="end" value="21"/>
         <int32 name="offdiv" value="21"/>
      </params>
      <attribs/>
      <object id="patch/object" uuid="798f1158-5a5a-4093-9379-fb5509f8b5da">
         <license>GPL</license>
         <inlets>
            <int32 name="baselength"/>
            <bool32 name="retrig"/>
            <bool32 name="reset"/>
            <frac32.positive name="division"/>
         </inlets>
         <outlets>
            <int32 name="length"/>
            <bool32 name="trig"/>
            <bool32 name="off"/>
         </outlets>
         <displays/>
         <params>
            <int32 name="start">
               <MinValue i="0"/>
               <MaxValue i="28"/>
            </int32>
            <int32 name="end">
               <MinValue i="0"/>
               <MaxValue i="28"/>
            </int32>
            <int32 name="offdiv">
               <MinValue i="0"/>
               <MaxValue i="29"/>
            </int32>
         </params>
         <attribs/>
         <includes/>
         <code.declaration><![CDATA[int currentdivision;
int counter;
int baselength;
int division[29];
int INdivision;
int prevd;
int reset;
int resethold;
int divisionIN;
bool rtrig;
bool rrtrig;
bool trig;]]></code.declaration>
         <code.krate><![CDATA[//currentdivision=inlet_baselength<<2;
baselength=inlet_baselength;


divisionIN=(inlet_division/(0x07FFFFFF/(param_end-param_start+1)))+param_start;
if (divisionIN>=param_offdiv){
	outlet_off=1;
	INdivision=29;
}
else {outlet_off=0; INdivision=divisionIN;}


division[0]=baselength<<6;
division[1]=(baselength<<5)+(baselength<<4);
division[2]=baselength<<5;
division[3]=(baselength<<5)-(baselength<<2);
division[4]=(baselength<<4)+(baselength<<3);
division[5]=(baselength<<4)+(baselength<<2);
division[6]=baselength<<4;
division[7]=(baselength<<3)+(baselength<<2);
division[8]=baselength<<3;
division[9]=(baselength<<2)+((baselength<<2)>>1);
division[10]=baselength<<2;
division[11]=(baselength<<1)+(baselength);
division[12]=baselength<<1;
division[13]=baselength+(baselength>>1);
division[14]=baselength;
division[15]=((baselength>>1)+(baselength>>2));
division[16]=(baselength>>1);
division[17]=((baselength>>2)+(baselength>>3));
division[18]=(baselength>>2);
division[19]=((baselength>>3)+(baselength>>4));
division[20]=(baselength>>3);
division[21]=((baselength>>4)+(baselength>>5));
division[22]=(baselength>>4);
division[23]=((baselength>>5)+(baselength>>6));
division[24]=(baselength>>5);
division[25]=((baselength>>6)+(baselength>>7));
division[26]=(baselength>>6);
division[27]=((baselength>>7)+(baselength>>6));
division[28]=(baselength>>7);


//INdivision=inlet_division;
if (INdivision!=prevd){
	prevd=INdivision;
	resethold=1;
	
}


currentdivision=division[INdivision];


if (counter>=0){
	counter+=1;
}
if (inlet_retrig&&!rrtrig){
	rrtrig=1;
	if (resethold){
	reset=1;
	resethold=0;
	}
	
}
if (!inlet_retrig){
	rrtrig=0;
}
if (inlet_reset&&!rtrig){
	rtrig=1;
	reset=1;
	
}
if (!inlet_reset){
	rtrig=0;
}
if (reset){
	reset=0;
	counter=0;
	trig=1;
}
if ((counter>=currentdivision)&&(currentdivision!=0)){
	counter=0;
	trig=1;
}
outlet_length=currentdivision;
outlet_trig=trig;

trig=0;]]></code.krate>
      </object>
   </patchobj>
   <comment type="patch/comment" x="518" y="700" text="modulation                                                                                                                     "/>
   <comment type="patch/comment" x="378" y="714" text="scales division knob"/>
   <comment type="patch/comment" x="1358" y="714" text="switches LFO destination "/>
   <comment type="patch/comment" x="364" y="728" text="for speed when unsynced"/>
   <comment type="patch/comment" x="518" y="728" text="leave these set for this patch"/>
   <comment type="patch/comment" x="686" y="728" text="LFO"/>
   <comment type="patch/comment" x="1120" y="728" text="add a curve to depth knob"/>
   <comment type="patch/comment" x="1288" y="728" text="depth"/>
   <comment type="patch/comment" x="1358" y="728" text="from delay time to delay division"/>
   <obj type="math/*c" uuid="7d5ef61c3bcd571ee6bbd8437ef3612125dfb225" name="*c_1" x="406" y="742">
      <params>
         <frac32.u.map name="amp" value="45.0"/>
      </params>
      <attribs/>
   </obj>
   <obj type="ctrl/dial p" uuid="cc5d2846c3d50e425f450c4b9851371b54f4d674" name="dial_6" x="518" y="742">
      <params>
         <frac32.u.map name="value" value="32.0"/>
      </params>
      <attribs/>
   </obj>
   <obj type="ctrl/dial p" uuid="cc5d2846c3d50e425f450c4b9851371b54f4d674" name="dial_8" x="588" y="742">
      <params>
         <frac32.u.map name="value" value="64.0"/>
      </params>
      <attribs/>
   </obj>
   <patchobj type="patch/object" uuid="1681384b-36c4-40c4-868b-5ca4e654d0e6" name="3_1" x="658" y="742">
      <params>
         <bool32.tgl name="internalclock" value="0"/>
         <frac32.u.map name="speed" value="0.0"/>
         <frac32.u.map name="pulsewidth" value="0.0"/>
         <bool32.tgl name="oneshot" value="0"/>
         <bool32.tgl name="bipolar" value="0"/>
         <bool32.tgl name="fadeloop" value="0"/>
         <bool32.tgl name="fadeEXP" value="1"/>
         <frac32.s.map name="CentreSmooth" value="-41.0"/>
         <frac32.s.map name="envAcurve" value="0.0"/>
         <frac32.s.map name="envDcurve" value="35.0"/>
         <frac32.s.map name="envRcurve" value="41.0"/>
      </params>
      <attribs/>
      <object id="patch/object" uuid="1681384b-36c4-40c4-868b-5ca4e654d0e6">
         <license>GPL</license>
         <inlets>
            <int32 name="samplelength"/>
            <bool32 name="internalclock"/>
            <int32 name="wave"/>
            <frac32.positive name="centre"/>
            <frac32.bipolar name="depth"/>
            <bool32.rising name="trig"/>
            <bool32.risingfalling name="hold"/>
            <bool32 name="fadetrig"/>
            <frac32.positive name="pulsewidth"/>
            <frac32.positive name="smooth"/>
            <frac32.bipolar name="slew"/>
            <frac32.positive name="envA"/>
            <frac32.positive name="envD"/>
            <frac32.positive name="envS"/>
            <frac32.positive name="envR"/>
            <frac32.positive name="fadein"/>
            <frac32.positive name="fadeout"/>
            <frac32.positive name="speed"/>
            <bool32 name="noise"/>
         </inlets>
         <outlets>
            <frac32 name="out"/>
         </outlets>
         <displays/>
         <params>
            <bool32.tgl name="internalclock"/>
            <frac32.u.map name="speed"/>
            <frac32.u.map name="pulsewidth">
               <DefaultValue v="32.0"/>
            </frac32.u.map>
            <bool32.tgl name="oneshot"/>
            <bool32.tgl name="bipolar"/>
            <bool32.tgl name="fadeloop"/>
            <bool32.tgl name="fadeEXP"/>
            <frac32.s.map name="CentreSmooth">
               <DefaultValue v="-40.0"/>
            </frac32.s.map>
            <frac32.s.map name="envAcurve">
               <DefaultValue v="0.0"/>
            </frac32.s.map>
            <frac32.s.map name="envDcurve">
               <DefaultValue v="35.0"/>
            </frac32.s.map>
            <frac32.s.map name="envRcurve">
               <DefaultValue v="40.0"/>
            </frac32.s.map>
         </params>
         <attribs/>
         <includes/>
         <code.declaration><![CDATA[int phase;
int Phase;
int phaseQ;
int phaseB;
int pulsewidthA;
int pulsewidthB;
int pulsewidthC;
int pulsewidthD;
int pulsedivide;
int wave;
int depth;
int fadedepth;
int i;
int ii;
int iii;
int iiii;
int dir;
int dirB;
int dirAD;
int dirR;
int out;
int outB;
int outR;
int outBv;
int outC;
int outCv;
int outD;
int outE;
int outF;
int outAD;
int outADS;
int outQ;
int outQQ;
int holdv;
int phaseD;
int envS;
int centre;
int incentre;
int curve;
int holdAD;
int stage;
int ntrigW;
int fadein;
int fadeout;
int noise;
int random;
int outBB;
int8_t stageW;

int32_t valW;
int32_t val;
int32_t valCentre;
int32_t valB;
int32_t valX;
int32_t expo[3];
int32_t expoB[3];
int32_t expoAD[3];
int32_t expoR[3];
float32_t widthC;
bool ftrig;
bool rtrig;
bool release;
bool xtrig;
bool init;]]></code.declaration>
         <code.init><![CDATA[init=1;
valW = 0;]]></code.init>
         <code.krate><![CDATA[//phase+=(0x07FFFFFF/inlet_samplelength);
//phase+=(0x07FFFFFF/(param_speed>>16));
random=(int32_t)(GenerateRandomNumber())>>4;
//if (param_bipolar){
//	noise = random;
//	}
//else if (!param_bipolar){
	noise = (random>>1)+(1<<26);
	//}


         int32_t freqq;
         MTOFEXTENDED((((param_speed+inlet_speed)-(1<<26))<<1),freqq);
         Phase += freqq>>2;
if (inlet_internalclock || param_internalclock){
	 phase= (Phase>>5)+0x04000000;
}
else if (!inlet_internalclock&&!param_internalclock){
	phase+=(0x07FFFFFF/inlet_samplelength);
}
fadein=(inlet_fadein-(1<<26))<<1;
fadeout=(inlet_fadeout-(1<<26))<<1;

if (init){
	init=0;
	
	if (param_oneshot){
		phase=0x07FFFFFF;
		xtrig=1;
		release=0;
	}
	
	
   	Phase=0;
	stage=0;
	phase=0;
}

if (!param_oneshot){
	if (phase>=0x07FFFFFF){
		phase=0;
		Phase=0;
	}
}
else if (param_oneshot){
	if (phase>=0x07FFFFFF){
		phase=0x07FFFFFF;
	}
}

if (inlet_trig&&!rtrig){
	rtrig=1;
	if (param_oneshot){
		xtrig=1;
		release=0;
	}
	if (!param_oneshot){
	
	
	}
	
   	Phase=0;
	stage=0;
	phase=0;
}
if (!inlet_trig){
rtrig=0;
}

if (inlet_fadetrig&&!ftrig){
	ftrig=1;
	if (inlet_fadein>0){
   	stageW = 1;
   	valW=0;
	}
	if ((inlet_fadein==0)&&(inlet_fadeout>0)){
		stageW=2;
		valW =0x7FFFFFFF;
	}
	
	}

if (!inlet_fadetrig){
	ftrig=0;
}
pulsewidthA=(inlet_pulsewidth+param_pulsewidth);
pulsewidthC=((0x07FFFFFF-(inlet_pulsewidth+param_pulsewidth))-(1<<26))<<1;;
pulsewidthB=0x07FFFFFF-(inlet_pulsewidth+param_pulsewidth);
pulsewidthD=(inlet_pulsewidth+param_pulsewidth)<<1;
phaseB=phase-(inlet_pulsewidth+param_pulsewidth);
wave=inlet_wave+1;
switch( wave )
            {
              default:
              case 1 :
                // Triangle
    {
       if (phase<pulsewidthA){
       	float32_t width1=pulsewidthA;
		float32_t ratio=0x07FFFFFF/width1;
		int32_t in=phase>pulsewidthA?pulsewidthA:phase;

		out=in*ratio;
       	
       }
       else if (phase>=pulsewidthA){
       float32_t width1=pulsewidthB;
    
		float32_t ratio=0x07FFFFFF/width1;
		
		int32_t in=phaseB>pulsewidthB?pulsewidthB:phaseB;

		out=0x07FFFFFF-(in*ratio);
       }
    }
                break;

              case 2 :
              {
                // Sine
                int32_t r;
                SINE2TINTERP( phase<<5, r )
                 
                out= ((r>>4)>>1)+(1<<26);

//			       int32_t r;
//       SINE2TINTERP(inlet_phase<<5,r)
//       outlet_out= (r>>4);
              } 
                break;

              case 3 :
                  // Square
                  {
		if (phase<pulsewidthA){
			out=0x07FFFFFF;
			
		}
		else out=0;
                  }
                break;

              case 4 :
              // Saw rising
              {
               if (phase<pulsewidthD){
               if (pulsewidthA<=0x04000000){
               	widthC=pulsewidthD;
               }
       		else widthC=0x07FFFFFF;
		float32_t ratio=0x07FFFFFF/widthC;
		int32_t in=phase>pulsewidthD?pulsewidthD:phase;
		
				out=in*ratio;
				
		
		
       	
       }
       if (phase>=pulsewidthD){
       	out=0;
       }
              }
                break;

              case 5 :
            // Saw falling
            {
              if (pulsewidthA<0x04000000){
               	widthC=pulsewidthD;
              }
              else widthC=0x7FFFFFF;
               
       	
		float32_t ratio=0x07FFFFFF/widthC;
		int32_t in=phase>pulsewidthD?pulsewidthD:phase;
		
				out=0x07FFFFFF-(in*ratio);
				
		
            }
       	
   
               // out= (0x07FFFFFF) - (phase);
                break;

                case 6 :
				 {
			 phaseD=phase-inlet_envA;
			 envS=0x07FFFFFF-inlet_envS;
			 float32_t width1=inlet_envA;
			 float32_t width2=inlet_envD-inlet_envA;
			 //attack
       if (phase<width1){
       	stage=1;
       	curve=param_envAcurve;
		float32_t ratio=0x07FFFFFF/width1;
		int32_t in=phase>width1?width1:phase;

		out=in*ratio;
       	
       }
       //decay
       else if ((phase>=width1)&&(phase<width1+width2)){
       curve=param_envDcurve;
    		stage=2;
		float32_t ratio=(0x07FFFFFF)/width2;
		
		int32_t inD=phaseD>width2?width2:phaseD;

		out=0x07FFFFFF-(inD*ratio);
       }
      //expo attack decay curves
int32_t inexpoAD=__SSAT(curve,28);
dirAD=inexpoAD>0?1:-1;
inexpoAD=inexpoAD>0?inexpoAD:-inexpoAD;
int32_t invAD=(1<<27)-inexpoAD;
int darAD;
darAD=out>0?1:-1;
int32_t posAD=out>0?out:-out;
if(dirAD>0)
{expoAD[0]=___SMMUL(posAD<<3,(invAD+___SMMUL(inexpoAD<<3,posAD<<2))<<2);}
if(dirAD<0)
{expoAD[0]=___SMMUL(((1<<27)-posAD)<<3,(invAD+___SMMUL(inexpoAD<<3,((1<<27)-posAD)<<2))<<2);}
for(iii=1;iii<=2;iii++)
expoAD[iii]=___SMMUL(expoAD[iii-1]<<3,(invAD+___SMMUL(inexpoAD<<3,expoAD[iii-1]<<2))<<2);
if(dirAD>0)
{outAD=expoAD[2]*darAD;}
if(dirAD<0)
{outAD=((1<<27)-expoAD[2])*darAD;}
if (stage==2){
outADS=(___SMMUL(outAD<<3,(0x07FFFFFF-inlet_envS)<<2)+inlet_envS);
}
else outADS=outAD;
if ((phase>(width1))&&(phase<0x07FFFFFF)){

	
	if (outAD<inlet_envS){
		
		//outADS=inlet_envS;
	}
	
}

				 }

                break;

				
                
            }


if (wave==2){
	int32_t inexpo=__SSAT(pulsewidthC,28);
	dir=inexpo>0?1:-1;
	inexpo=inexpo>0?inexpo:-inexpo;
	int32_t inv=(1<<27)-inexpo;
	int dar;
	dar=out>0?1:-1;
	int32_t pos=out>0?out:-out;
	if(dir>0)
	{expo[0]=___SMMUL(pos<<3,(inv+___SMMUL(inexpo<<3,pos<<2))<<2);}
	if(dir<0)
	{expo[0]=___SMMUL(((1<<27)-pos)<<3,(inv+___SMMUL(inexpo<<3,((1<<27)-pos)<<2))<<2);}
	for(i=1;i<=2;i++)
	expo[i]=___SMMUL(expo[i-1]<<3,(inv+___SMMUL(inexpo<<3,expo[i-1]<<2))<<2);
	if(dir>0)
	{outBv=expo[2]*dar;}
	if(dir<0)
	{outBv=((1<<27)-expo[2])*dar;}
	}
else { if (wave==6){outBv=outADS;} else {outBv=out;}}


if (param_oneshot){
	if ((wave==6)||(wave==4)){
		if (phase>=0x07FFFFFF){
		       	if ((!release)&&xtrig){
		       		valX=outBv;
		       		valB=0x07FFFFFF;
		       		release=1;
		       		stage=3;
		       		xtrig=0;
		       		outADS=0;
				 	outAD=0;
		       	}
		       	if (wave==4){
		       		out=0;
		       		outBv=0;
		       	}
		}
		if (release){
			
				  int32_t t;
				  MTOF(-((inlet_envR-(1<<26))<<1),t);
				  valB -= t>>6;
				  
				  	int32_t inexpoR=__SSAT(param_envRcurve,28);
					dirR=inexpoR>0?1:-1;
					inexpoR=inexpoR>0?inexpoR:-inexpoR;
					int32_t invR=(1<<27)-inexpoR;
					int darR;
					darR=valB>0?1:-1;
					int32_t posR=valB>0?valB:-valB;
					if(dirR>0)
					{expoR[0]=___SMMUL(posR<<3,(invR+___SMMUL(inexpoR<<3,posR<<2))<<2);}
					if(dirR<0)
					{expoR[0]=___SMMUL(((1<<27)-posR)<<3,(invR+___SMMUL(inexpoR<<3,((1<<27)-posR)<<2))<<2);}
					for(iiii=1;iiii<=2;iiii++)
					expoR[iiii]=___SMMUL(expoR[iiii-1]<<3,(invR+___SMMUL(inexpoR<<3,expoR[iiii-1]<<2))<<2);
					if(dirR>0)
					{outR=expoR[2]*darR;}
					if(dirR<0)
					{outR=((1<<27)-expoR[2])*darR;}
				  
				 outCv= ___SMMUL(outR<<3,valX<<2);
				 if (outCv<=0){
				 	valB=0;
				 	outCv=0;
				 	outBv=0;
				 	out=0;
				 	release=0;
				 	outR=0;
				 	outADS=0;
				 	outAD=0;
				 	stage=0;
				 }
				 
		    	
		
		    	
		}
		else if (!release){
			outCv=outBv;
		}
	}
	else outCv=outBv;
}
else if (!param_oneshot){
	outCv=outBv;
}
if (!inlet_noise){
	outBB=outCv;
}
else if (inlet_noise){
	outBB=noise;
}

if (!inlet_hold){
	outB=outBB;
	holdv=outB;
	}
else if (inlet_hold){
	outB=holdv;
}
//smooth
int32_t f;
   MTOF((0x07FFFFFF-inlet_smooth),f);
   val = ___SMMLA((outB-val)<<1,f,val);
   outC= val;
//expo
int32_t inexpoB=__SSAT(inlet_slew,28);
dirB=inexpoB>0?1:-1;
inexpoB=inexpoB>0?inexpoB:-inexpoB;
int32_t invB=(1<<27)-inexpoB;
int darB;
darB=outC>0?1:-1;
int32_t posB=outC>0?outC:-outC;
if(dirB>0)
{expoB[0]=___SMMUL(posB<<3,(invB+___SMMUL(inexpoB<<3,posB<<2))<<2);}
if(dirB<0)
{expoB[0]=___SMMUL(((1<<27)-posB)<<3,(invB+___SMMUL(inexpoB<<3,((1<<27)-posB)<<2))<<2);}
for(ii=1;ii<=2;ii++)
expoB[ii]=___SMMUL(expoB[ii-1]<<3,(invB+___SMMUL(inexpoB<<3,expoB[ii-1]<<2))<<2);
if(dirB>0)
{outD=expoB[2]*darB;}
if(dirB<0)
{outD=((1<<27)-expoB[2])*darB;}
//bipolar?
if (param_bipolar){
outE= (outD-(1<<26))<<1;
}
else outE=outD;


	// centre inlet smoothing
	
	int32_t fCentre;
   MTOF((-param_CentreSmooth),fCentre);
   valCentre = ___SMMLA((inlet_centre-valCentre)<<1,fCentre,valCentre);
   incentre= valCentre;

if (!param_bipolar){
	centre=incentre;
	}
	if (param_bipolar){
		
	centre=(incentre-(1<<26))<<1;
	}
//scale depth if limitsreached
if (!param_bipolar){
	if ((inlet_centre+inlet_depth)>0x07FFFFFF){
		//depth=___SMMUL(inlet_depth<<3,(0x07FFFFFF-inlet_centre)<<2);
		depth=inlet_depth-((inlet_depth+inlet_centre)-0x07FFFFFF);
		}
	else if ((inlet_centre+inlet_depth)<0){
		//depth=___SMMUL(inlet_depth<<3,(0x07FFFFFF-(-inlet_centre))<<2);
		depth=inlet_depth+((-inlet_depth)-inlet_centre);
		}
	else depth=inlet_depth;
	}
else if (param_bipolar){
	if ((centre+inlet_depth)>0x07FFFFFF){
		depth=inlet_depth-((inlet_depth+centre)-0x07FFFFFF);
	}
	else if ((centre+(-inlet_depth))>0x07FFFFFF){
		depth=((centre+(-inlet_depth))-0x07FFFFFF)+inlet_depth;
	}
	else if ((centre+inlet_depth)<(0-0x07FFFFFF)){
		depth=inlet_depth-((centre+inlet_depth)+0x07FFFFFF);
	}
	else if ((centre+(-inlet_depth))<(0-0x07FFFFFF)){
		depth=inlet_depth+((centre+(-inlet_depth))+0x07FFFFFF);
	}
	else {depth=inlet_depth;}
	
			
			
			
		}
//fade env
if ((stageW==1)&&(outQ<0x07FFFFFF)) {
   int32_t tW;
   MTOF(-fadein,tW);
   valW = valW + (tW>>4);
   if (valW<0) {
      valW =0x7FFFFFFF;
      if (inlet_fadeout){
      stageW = 2;
      }
   }
}
 if (stageW==2){


  int32_t tW;
  MTOF(-fadeout,tW);
  valW -= tW>>4;
  if (valW < 0)
    {valW = 0;
    if (!param_fadeloop){
    stageW = 0;
    }
    if (param_fadeloop){
    stageW = 1;
    }
    
    }


}
outQ= valW>>4;
if ((inlet_fadein>0)||(inlet_fadeout>0)){
	if (param_fadeEXP){
		int8_t si = (outQ>>24)+4;
	uint8_t ei = outQ>>16;
	if (si>=0)
	     outQQ = expt[ei]<<si;
	else outQQ= expt[ei]>>(-si);
	}
	else outQQ=outQ;
	}
else outQQ=0x07FFFFFF;


fadedepth= ___SMMUL(depth<<3,outQQ<<2);
   
   //depth and centre
outF=___SMMUL(outE<<3,fadedepth<<2)+centre;


outlet_out=outF;
//outlet_out=phase;]]></code.krate>
      </object>
   </patchobj>
   <obj type="conv/unipolar2bipolar" uuid="efc8ee28c508740c5edf7995eaaa07a6d6818e5e" name="unipolar2bipolar_1" x="770" y="742">
      <params/>
      <attribs/>
   </obj>
   <obj type="math/inv" uuid="565521d3699b36d8095aa1c79b9ad0046fb133ce" name="inv_1" x="896" y="742">
      <params/>
      <attribs/>
   </obj>
   <obj type="math/inv" uuid="565521d3699b36d8095aa1c79b9ad0046fb133ce" name="inv_3" x="1064" y="742">
      <params/>
      <attribs/>
   </obj>
   <obj type="sss/math/expCurveK" uuid="bde45a1d-540b-4c33-b7b5-d733d42a1772" name="expCurveK_1" x="1134" y="742">
      <params>
         <frac32.s.map name="exp" value="41.0"/>
         <int32 name="stack" value="3"/>
      </params>
      <attribs/>
   </obj>
   <obj type="math/*" uuid="922423f2db9f222aa3e5ba095778288c446da47a" name="*_1" x="1288" y="742">
      <params/>
      <attribs/>
   </obj>
   <obj type="demux/demux 2" uuid="49737f48bfddf5d3ad9f98e4752b5b8bd5f566ad" name="demux_1" x="1358" y="742">
      <params/>
      <attribs/>
   </obj>
   <comment type="patch/comment" x="126" y="868" text="wet/dry knob module"/>
   <patchobj type="patch/object" uuid="796fee05-1092-4d4a-a47c-2e9810ac2191" name="wetdry_1" x="126" y="882">
      <params>
         <frac32.u.map name="centregain" value="20.5"/>
         <frac32.s.map name="centrepos" value="0.0"/>
      </params>
      <attribs/>
      <object id="patch/object" uuid="796fee05-1092-4d4a-a47c-2e9810ac2191">
         <sDescription>(inverse) exponential curving module
exp parameter above zero is exponential curve
exp parameter below zero is inverse exponential curve</sDescription>
         <author>Remco van der Most</author>
         <license>BSD</license>
         <inlets>
            <frac32.positive name="wetdry"/>
            <bool32 name="bypass"/>
         </inlets>
         <outlets>
            <frac32.positive name="dry"/>
            <frac32.positive name="wet"/>
            <frac32.positive name="pos"/>
         </outlets>
         <displays/>
         <params>
            <frac32.u.map name="centregain"/>
            <frac32.s.map name="centrepos"/>
         </params>
         <attribs/>
         <includes/>
         <code.declaration><![CDATA[int32_t wet;
int32_t wetB;
int32_t dry;
int32_t dryB;
int32_t xfade;
int32_t expo;
int32_t expoB;
int32_t dir;]]></code.declaration>
         <code.krate><![CDATA[int32_t inexpoWD=__SSAT(-param_centrepos,28);
dir=inexpoWD>0?1:-1;
inexpoWD=inexpoWD>0?inexpoWD:-inexpoWD;
int32_t invWD=(1<<27)-inexpoWD;
int dar;
dar=inlet_wetdry>0?1:-1;
int32_t posWD=inlet_wetdry>0?inlet_wetdry:-inlet_wetdry;
if(dir>0)
{expo=___SMMUL(posWD<<3,(invWD+___SMMUL(inexpoWD<<3,posWD<<2))<<2);}
if(dir<0)
{expo=___SMMUL(((1<<27)-posWD)<<3,(invWD+___SMMUL(inexpoWD<<3,((1<<27)-posWD)<<2))<<2);}
expoB=___SMMUL(expo<<3,(invWD+___SMMUL(inexpoWD<<3,expo<<2))<<2);
if(dir>0)
{xfade=expoB*dar;}
if(dir<0)
{xfade=((1<<27)-expoB)*dar;}




int32_t inexpo=__SSAT(-param_centregain,28);
inexpo=inexpo>0?inexpo:-inexpo;
int32_t inv=(1<<27)-inexpo;

// wet

int32_t pos=xfade>0?xfade:-xfade;


wet=___SMMUL(((1<<27)-pos)<<3,(inv+___SMMUL(inexpo<<3,((1<<27)-pos)<<2))<<2);
wetB= ___SMMUL(wet<<3,(inv+___SMMUL(inexpo<<3,wet<<2))<<2);

//dry
int32_t invertX = (1<<27) - xfade-1;


int32_t posD=invertX>0?invertX:-invertX;
dry=___SMMUL(((1<<27)-posD)<<3,(inv+___SMMUL(inexpo<<3,((1<<27)-posD)<<2))<<2);
dryB= ___SMMUL(dry<<3,(inv+___SMMUL(inexpo<<3,dry<<2))<<2);

if (!inlet_bypass){
	outlet_wet=((1<<27)-wetB);
	
	outlet_dry=((1<<27)-dryB);
	
	outlet_pos=xfade;
	}
else if (inlet_bypass){
	outlet_wet=0x00000000;
	
	outlet_dry=0x07FFFFFF;
	
	outlet_pos=0x00000000;
	}]]></code.krate>
      </object>
   </patchobj>
   <comment type="patch/comment" x="1064" y="1008" text="delay time divider - also scales modulation according to delay time/division"/>
   <obj type="math/+" uuid="44553fdc8628c67ab535845ed1be304ad6c9553b" name="+_3" x="1008" y="1022">
      <params/>
      <attribs/>
   </obj>
   <patchobj type="patch/object" uuid="5f7fc1d5-886c-4e44-8b8a-9ece26f5f475" name="kbeat_1" x="1106" y="1022">
      <params>
         <int32 name="start" value="10"/>
         <int32 name="end" value="20"/>
         <int32 name="offdiv" value="28"/>
         <frac32.u.map name="smoothdelay" value="37.0"/>
      </params>
      <attribs>
         <objref attributeName="delayname" obj="write_3"/>
      </attribs>
      <object id="patch/object" uuid="5f7fc1d5-886c-4e44-8b8a-9ece26f5f475">
         <license>GPL</license>
         <inlets>
            <int32 name="baselength"/>
            <frac32.positive name="division"/>
            <bool32.risingfalling name="unsync"/>
            <bool32.rising name="retrig"/>
            <bool32.rising name="reset"/>
            <frac32.bipolar name="mod"/>
            <int32 name="modextreme"/>
            <bool32 name="supermod"/>
         </inlets>
         <outlets>
            <int32 name="length"/>
            <bool32 name="trig"/>
            <bool32 name="off"/>
            <frac32 name="delaytime"/>
            <int32 name="division"/>
         </outlets>
         <displays/>
         <params>
            <int32 name="start">
               <MinValue i="0"/>
               <MaxValue i="28"/>
            </int32>
            <int32 name="end">
               <MinValue i="0"/>
               <MaxValue i="28"/>
            </int32>
            <int32 name="offdiv">
               <MinValue i="0"/>
               <MaxValue i="29"/>
            </int32>
            <frac32.u.map name="smoothdelay"/>
         </params>
         <attribs>
            <objref name="delayname"/>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[int division[29];
int timearray[13];

int whole;
int l;
int currentdivision;
int counter;
int baselength;
int delaytime;
int INdivision;
int prevd;
int reset;
int resethold;
int divisionIN;
int modshift;
int32_t expo[4];
int32_t val;
int32_t outMOD;
int32_t modextreme;
int32_t inMOD;


bool rtrig;
bool rrtrig;
bool trig;]]></code.declaration>
         <code.init><![CDATA[l=(attr_delayname.LENGTHPOW-16);
if (l<0){
	l=0;
	}
	
timearray[0]=4080;
timearray[1]=7110;
timearray[2]=16380;
timearray[3]=32700;
timearray[4]=65400;
whole=timearray[l];]]></code.init>
         <code.krate><![CDATA[//currentdivision=inlet_baselength<<2;
baselength=inlet_baselength;


divisionIN=(inlet_division/(0x07FFFFFF/(param_end-param_start+1)))+param_start;
if (divisionIN>=param_offdiv){
	outlet_off=1;
	
}
else {outlet_off=0; INdivision=divisionIN;}
outlet_division=INdivision;

division[0]=baselength<<6;
division[1]=(baselength<<5)+(baselength<<4);
division[2]=baselength<<5;
division[3]=(baselength<<5)-(baselength<<2);
division[4]=(baselength<<4)+(baselength<<3);
division[5]=(baselength<<4)+(baselength<<2);
division[6]=baselength<<4;
division[7]=(baselength<<3)+(baselength<<2);
division[8]=baselength<<3;
division[9]=(baselength<<2)+((baselength<<2)>>1);
division[10]=baselength<<2;
division[11]=(baselength<<1)+(baselength);
division[12]=baselength<<1;
division[13]=baselength+(baselength>>1);
division[14]=baselength;
division[15]=((baselength>>1)+(baselength>>2));
division[16]=(baselength>>1);
division[17]=((baselength>>2)+(baselength>>3));
division[18]=(baselength>>2);
division[19]=((baselength>>3)+(baselength>>4));
division[20]=(baselength>>3);
division[21]=((baselength>>4)+(baselength>>5));
division[22]=(baselength>>4);
division[23]=((baselength>>5)+(baselength>>6));
division[24]=(baselength>>5);
division[25]=((baselength>>6)+(baselength>>7));
division[26]=(baselength>>6);
division[27]=((baselength>>7)+(baselength>>6));
division[28]=(baselength>>7);


//INdivision=inlet_division;
if (INdivision!=prevd){
	prevd=INdivision;
	resethold=1;
	
}


currentdivision=division[INdivision];


if (counter>=0){
	counter+=1;
}
if (inlet_retrig&&!rrtrig){
	rrtrig=1;
	if (resethold){
	reset=1;
	resethold=0;
	}
	
}
if (!inlet_retrig){
	rrtrig=0;
}
if (inlet_reset&&!rtrig){
	rtrig=1;
	reset=1;
	
}
if (!inlet_reset){
	rtrig=0;
}
if (reset){
	reset=0;
	counter=0;
	trig=1;
}
if ((counter>=currentdivision)&&(currentdivision!=0)){
	counter=0;
	trig=1;
}
if (!inlet_unsync){
delaytime=((1<<27)/(whole-1))*currentdivision;
}
else if (inlet_unsync){


	

	
int32_t pos=inlet_division;


expo[0]=___SMMUL(((1<<27)-pos)<<3,(1+___SMMUL(0x07FFFFFF<<3,((1<<27)-pos)<<2))<<2);

expo[1]=___SMMUL(expo[0]<<3,(1+___SMMUL(0x07FFFFFF<<3,expo[0]<<2))<<2);
expo[2]=___SMMUL(expo[1]<<3,(1+___SMMUL(0x07FFFFFF<<3,expo[1]<<2))<<2);
expo[3]=___SMMUL(expo[2]<<3,(1+___SMMUL(0x07FFFFFF<<3,expo[2]<<2))<<2);

if (l<2){
		delaytime=inlet_division;
}
if (l>=2){
	
delaytime=0x07FFFFFF-((1<<27)-expo[1]);
}


	
}
if (inlet_supermod){
 inMOD = (inlet_mod + (1<<27)) >> 1;
}
else if (!inlet_supermod){
inMOD = (((inlet_mod>>4)+(inlet_mod>>5)) + (1<<27)) >> 1;
}
if (inlet_modextreme<4){
	modextreme=inlet_modextreme+1;
}
else {modextreme==1;}

if(inMOD >= (1<<27)){
  outMOD = (delaytime<<modextreme);
}
else if(inMOD <= 0){
  outMOD = (delaytime>>modextreme);
}
else{
  int32_t	startMOD=(delaytime>>modextreme);
  
  int32_t	endMOD=(delaytime<<modextreme);
  if (endMOD>(1<<27)){
  	endMOD=1<<27;
  }
  int32_t iMOD = inMOD >> (27-1);              // i [0 2[
  int32_t aMOD = (inMOD & ((1<<(27-1)) - 1));  // a q26
  if(iMOD < 1){ // [0 1[             q27         q26   q21           q27 
  outMOD = ___SMMLA(delaytime- startMOD, aMOD, startMOD>> 6) << 6;
  } else {   // [1 2[
  outMOD = ___SMMLA(endMOD - delaytime, aMOD, delaytime>> 6) << 6;
  }
}


int32_t f;
   MTOF((-param_smoothdelay),f);
   val = ___SMMLA((outMOD-val)<<1,f,val);
   outlet_delaytime= val;

outlet_length=currentdivision;

outlet_trig=trig;


trig=0;]]></code.krate>
      </object>
   </patchobj>
   <comment type="patch/comment" x="378" y="1358" text="wet "/>
   <comment type="patch/comment" x="364" y="1372" text="(first in chain to keep trails "/>
   <comment type="patch/comment" x="266" y="1386" text="dry"/>
   <comment type="patch/comment" x="378" y="1386" text="when bypassed)"/>
   <comment type="patch/comment" x="602" y="1386" text="play back from delay buffer"/>
   <comment type="patch/comment" x="798" y="1386" text="feedback"/>
   <comment type="patch/comment" x="882" y="1386" text="sum input and feedbackloop"/>
   <comment type="patch/comment" x="1134" y="1386" text="filter"/>
   <comment type="patch/comment" x="1274" y="1386" text="record into delay buffer"/>
   <obj type="audio/in left" uuid="d40e60b7641fe75af4d7c91b45bb038aacafc52e" name="in_1" x="140" y="1400">
      <params/>
      <attribs/>
   </obj>
   <obj type="gain/vca" uuid="a9f2dcd18043e2f47364e45cb8814f63c2a37c0d" name="vca_1" x="266" y="1400">
      <params/>
      <attribs/>
   </obj>
   <obj type="gain/vca" uuid="a9f2dcd18043e2f47364e45cb8814f63c2a37c0d" name="vca_2" x="378" y="1400">
      <params/>
      <attribs/>
   </obj>
   <obj type="conv/interp" uuid="d68c1a8709d8b55e3de8715d727ec0a2d8569d9a" name="interp_1" x="518" y="1400">
      <params/>
      <attribs/>
   </obj>
   <obj type="drj/delay/read32_interp_mod" uuid="3d8b55218a3a75659588eb20186cc25ccf0126c7" name="read32_interp_mod_1" x="602" y="1400">
      <params>
         <frac32.u.map name="time" value="0.0"/>
      </params>
      <attribs>
         <objref attributeName="delayname" obj="write_3"/>
      </attribs>
   </obj>
   <obj type="gain/vca" uuid="a9f2dcd18043e2f47364e45cb8814f63c2a37c0d" name="vca_3" x="798" y="1400">
      <params/>
      <attribs/>
   </obj>
   <obj type="math/+" uuid="faedbea4612d9bd3644d6d3bf31946d848a70e19" name="+_2" x="882" y="1400">
      <params/>
      <attribs/>
   </obj>
   <obj type="filter/lp m" uuid="1aa1bc51da479ed92429af700591f9d7b9f45f22" name="lp_1" x="1134" y="1400">
      <params>
         <frac32.s.map name="pitch" value="0.0"/>
         <frac32.u.map name="reso" value="0.0"/>
      </params>
      <attribs/>
   </obj>
   <obj type="jho/delay/write sdram 32b" uuid="8b544d2d29a0485c9a44775aaf36e96c" name="write_3" x="1274" y="1400">
      <params/>
      <attribs>
         <combo attributeName="size" selection="524288 (10.9s)"/>
      </attribs>
   </obj>
   <comment type="patch/comment" x="868" y="1470" text="sum wet&amp;dry"/>
   <obj type="math/+" uuid="faedbea4612d9bd3644d6d3bf31946d848a70e19" name="+_1" x="868" y="1484">
      <params/>
      <attribs/>
   </obj>
   <obj type="audio/out left" uuid="b11a3c09b2fdd575ea8212f2ce7743d5269253b1" name="out_1" x="952" y="1484">
      <params/>
      <attribs/>
   </obj>
   <nets>
      <net>
         <source obj="in_1" outlet="wave"/>
         <dest obj="vca_1" inlet="a"/>
         <dest obj="vca_2" inlet="a"/>
      </net>
      <net>
         <source obj="dial_1" outlet="out"/>
         <dest obj="vca_3" inlet="v"/>
      </net>
      <net>
         <source obj="interp_1" outlet="o"/>
         <dest obj="read32_interp_mod_1" inlet="time"/>
      </net>
      <net>
         <source obj="kbeat_1" outlet="delaytime"/>
         <dest obj="interp_1" inlet="i"/>
      </net>
      <net>
         <source obj="dial_2" outlet="out"/>
         <dest obj="+_3" inlet="in1"/>
      </net>
      <net>
         <source obj="read32_interp_mod_1" outlet="out"/>
         <dest obj="vca_3" inlet="a"/>
         <dest obj="+_1" inlet="in2"/>
      </net>
      <net>
         <source obj="+_2" outlet="out"/>
         <dest obj="lp_1" inlet="in"/>
      </net>
      <net>
         <source obj="vca_3" outlet="o"/>
         <dest obj="+_2" inlet="in2"/>
      </net>
      <net>
         <source obj="vca_2" outlet="o"/>
         <dest obj="+_2" inlet="in1"/>
      </net>
      <net>
         <source obj="wetdry_1" outlet="dry"/>
         <dest obj="vca_1" inlet="v"/>
      </net>
      <net>
         <source obj="wetdry_1" outlet="wet"/>
         <dest obj="vca_2" inlet="v"/>
      </net>
      <net>
         <source obj="toggle_1" outlet="o"/>
         <dest obj="wetdry_1" inlet="bypass"/>
      </net>
      <net>
         <source obj="+_1" outlet="out"/>
         <dest obj="out_1" inlet="wave"/>
      </net>
      <net>
         <source obj="vca_1" outlet="o"/>
         <dest obj="+_1" inlet="in1"/>
      </net>
      <net>
         <source obj="clock_3" outlet="kbeatAVG"/>
         <dest obj="mux_1" inlet="i1"/>
         <dest obj="kscope_1" inlet="kbeat"/>
      </net>
      <net>
         <source obj="toggle_2" outlet="o"/>
         <dest obj="kbeat_1" inlet="unsync"/>
         <dest obj="3_1" inlet="internalclock"/>
      </net>
      <net>
         <source obj="mux_1" outlet="o"/>
         <dest obj="division_2" inlet="baselength"/>
         <dest obj="division_1" inlet="baselength"/>
         <dest obj="kbeat_1" inlet="baselength"/>
      </net>
      <net>
         <source obj="toggle_3" outlet="o"/>
         <dest obj="mux_1" inlet="s"/>
      </net>
      <net>
         <source obj="tap_1" outlet="kbeat"/>
         <dest obj="mux_1" inlet="i2"/>
      </net>
      <net>
         <source obj="button_1" outlet="o"/>
         <dest obj="tap_1" inlet="tap"/>
      </net>
      <net>
         <source obj="or_1" outlet="o"/>
         <dest obj="division_2" inlet="reset"/>
         <dest obj="division_1" inlet="reset"/>
         <dest obj="3_1" inlet="trig"/>
      </net>
      <net>
         <source obj="dial_4" outlet="out"/>
         <dest obj="*c_1" inlet="in"/>
         <dest obj="division_1" inlet="division"/>
      </net>
      <net>
         <source obj="division_1" outlet="length"/>
         <dest obj="3_1" inlet="samplelength"/>
      </net>
      <net>
         <source obj="division_1" outlet="off"/>
         <dest obj="3_1" inlet="noise"/>
      </net>
      <net>
         <source obj="i_1" outlet="out"/>
         <dest obj="3_1" inlet="wave"/>
      </net>
      <net>
         <source obj="dial_5" outlet="out"/>
         <dest obj="inv_3" inlet="in"/>
      </net>
      <net>
         <source obj="dial_6" outlet="out"/>
         <dest obj="3_1" inlet="centre"/>
      </net>
      <net>
         <source obj="3_1" outlet="out"/>
         <dest obj="unipolar2bipolar_1" inlet="i"/>
      </net>
      <net>
         <source obj="unipolar2bipolar_1" outlet="o"/>
         <dest obj="inv_1" inlet="in"/>
      </net>
      <net>
         <source obj="dial_7" outlet="out"/>
         <dest obj="3_1" inlet="pulsewidth"/>
      </net>
      <net>
         <source obj="*_1" outlet="result"/>
         <dest obj="demux_1" inlet="i"/>
         <dest obj="kscope_1" inlet="in"/>
      </net>
      <net>
         <source obj="expCurveK_1" outlet="out"/>
         <dest obj="*_1" inlet="b"/>
      </net>
      <net>
         <source obj="dial_8" outlet="out"/>
         <dest obj="3_1" inlet="depth"/>
      </net>
      <net>
         <source obj="i_2" outlet="out"/>
         <dest obj="kbeat_1" inlet="modextreme"/>
      </net>
      <net>
         <source obj="division_2" outlet="trig"/>
         <dest obj="inv_2" inlet="i"/>
      </net>
      <net>
         <source obj="dial_9" outlet="out"/>
         <dest obj="and_1" inlet="i2"/>
         <dest obj="division_2" inlet="division"/>
      </net>
      <net>
         <source obj="inv_2" outlet="o"/>
         <dest obj="and_1" inlet="i1"/>
      </net>
      <net>
         <source obj="and_1" outlet="o"/>
         <dest obj="3_1" inlet="hold"/>
      </net>
      <net>
         <source obj="*c_1" outlet="out"/>
         <dest obj="3_1" inlet="speed"/>
      </net>
      <net>
         <source obj="demux_1" outlet="o0"/>
         <dest obj="kbeat_1" inlet="mod"/>
      </net>
      <net>
         <source obj="toggle_5" outlet="o"/>
         <dest obj="demux_1" inlet="s"/>
      </net>
      <net>
         <source obj="+_3" outlet="out"/>
         <dest obj="kbeat_1" inlet="division"/>
      </net>
      <net>
         <source obj="demux_1" outlet="o1"/>
         <dest obj="+_3" inlet="in2"/>
      </net>
      <net>
         <source obj="toggle_6" outlet="o"/>
         <dest obj="kbeat_1" inlet="supermod"/>
      </net>
      <net>
         <source obj="dial_3" outlet="out"/>
         <dest obj="wetdry_1" inlet="wetdry"/>
      </net>
      <net>
         <source obj="lp_1" outlet="out"/>
         <dest obj="write_3" inlet="in"/>
      </net>
      <net>
         <source obj="dial_10" outlet="out"/>
         <dest obj="lp_1" inlet="pitch"/>
      </net>
      <net>
         <source obj="clock_3" outlet="start"/>
         <dest obj="or_1" inlet="i1"/>
         <dest obj="kscope_1" inlet="reset"/>
      </net>
      <net>
         <source obj="button_2" outlet="o"/>
         <dest obj="or_1" inlet="i2"/>
      </net>
      <net>
         <source obj="inv_3" outlet="out"/>
         <dest obj="expCurveK_1" inlet="in"/>
      </net>
      <net>
         <source obj="inv_1" outlet="out"/>
         <dest obj="*_1" inlet="a"/>
      </net>
   </nets>
   <settings>
      <subpatchmode>no</subpatchmode>
   </settings>
   <notes><![CDATA[]]></notes>
   <windowPos>
      <x>-8</x>
      <y>0</y>
      <width>1616</width>
      <height>876</height>
   </windowPos>
</patch-1.0>