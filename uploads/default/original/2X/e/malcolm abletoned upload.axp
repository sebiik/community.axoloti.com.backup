<patch-1.0 appVersion="1.0.12">
   <comment type="patch/comment" x="182" y="0" text="clock pulse 4ppq"/>
   <comment type="patch/comment" x="546" y="0" text="start"/>
   <comment type="patch/comment" x="686" y="0" text="stop"/>
   <comment type="patch/comment" x="826" y="0" text="top right button"/>
   <comment type="patch/comment" x="1190" y="0" text=" Launchpad to DIN except tack 3/4"/>
   <comment type="patch/comment" x="1428" y="0" text="DIN back to launchpad for lights"/>
   <comment type="patch/comment" x="1652" y="0" text="song playback to DIN"/>
   <patchobj type="patch/object" uuid="d6b67a55-7ae0-42ef-9276-20fedb0e78b1" name="note_2" x="168" y="14">
      <params/>
      <attribs>
         <spinner attributeName="note" value="0"/>
         <spinner attributeName="channel" value="15"/>
      </attribs>
      <object id="patch/object" uuid="d6b67a55-7ae0-42ef-9276-20fedb0e78b1">
         <sDescription>Monophonic MIDI keyboard note input, gate, velocity and release velocity</sDescription>
         <author>Johannes Taelman</author>
         <license>BSD</license>
         <helpPatch>midi_in.axh</helpPatch>
         <inlets/>
         <outlets>
            <bool32 name="gate" description="key pressed?"/>
         </outlets>
         <displays/>
         <params/>
         <attribs>
            <spinner name="note" MinValue="0" MaxValue="127" DefaultValue="64"/>
            <spinner name="channel" MinValue="1" MaxValue="16" DefaultValue="0"/>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[uint8_t _gate;]]></code.declaration>
         <code.init><![CDATA[_gate = 0;]]></code.init>
         <code.krate><![CDATA[outlet_gate= _gate<<27;]]></code.krate>
         <code.midihandler><![CDATA[if ((status == MIDI_NOTE_ON + (attr_channel-1)) && (data2)) {if (data1 == attr_note) {
   _gate = 1;
}
} else if (((status == MIDI_NOTE_ON + (attr_channel-1)) && (!data2))||          (status == MIDI_NOTE_OFF + (attr_channel-1))) {
  if (data1 == attr_note) {
    _gate = 0;
  }
} else if ((status == (attr_channel-1) + MIDI_CONTROL_CHANGE)&&(data1 == MIDI_C_ALL_NOTES_OFF)) {
  _gate = 0;
}]]></code.midihandler>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="fb3dbbfc-4256-4001-afcb-095e1a73d66d" name="note_3" x="546" y="14">
      <params/>
      <attribs>
         <spinner attributeName="note" value="2"/>
         <spinner attributeName="channel" value="15"/>
      </attribs>
      <object id="patch/object" uuid="fb3dbbfc-4256-4001-afcb-095e1a73d66d">
         <sDescription>Monophonic MIDI keyboard note input, gate, velocity and release velocity</sDescription>
         <author>Johannes Taelman</author>
         <license>BSD</license>
         <helpPatch>midi_in.axh</helpPatch>
         <inlets/>
         <outlets>
            <bool32 name="gate" description="key pressed?"/>
         </outlets>
         <displays/>
         <params/>
         <attribs>
            <spinner name="note" MinValue="0" MaxValue="127" DefaultValue="64"/>
            <spinner name="channel" MinValue="1" MaxValue="16" DefaultValue="0"/>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[uint8_t _gate;]]></code.declaration>
         <code.init><![CDATA[_gate = 0;]]></code.init>
         <code.krate><![CDATA[outlet_gate= _gate<<27;]]></code.krate>
         <code.midihandler><![CDATA[if ((status == MIDI_NOTE_ON + (attr_channel-1)) && (data2)) {if (data1 == attr_note) {
   _gate = 1;
}
} else if (((status == MIDI_NOTE_ON + (attr_channel-1)) && (!data2))||          (status == MIDI_NOTE_OFF + (attr_channel-1))) {
  if (data1 == attr_note) {
    _gate = 0;
  }
} else if ((status == (attr_channel-1) + MIDI_CONTROL_CHANGE)&&(data1 == MIDI_C_ALL_NOTES_OFF)) {
  _gate = 0;
}]]></code.midihandler>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="1cd819cb-800b-4295-8d05-01f8ac8cd92e" name="note_1" x="686" y="14">
      <params/>
      <attribs>
         <spinner attributeName="note" value="3"/>
         <spinner attributeName="channel" value="15"/>
      </attribs>
      <object id="patch/object" uuid="1cd819cb-800b-4295-8d05-01f8ac8cd92e">
         <sDescription>Monophonic MIDI keyboard note input, gate, velocity and release velocity</sDescription>
         <author>Johannes Taelman</author>
         <license>BSD</license>
         <helpPatch>midi_in.axh</helpPatch>
         <inlets/>
         <outlets>
            <bool32 name="gate" description="key pressed?"/>
         </outlets>
         <displays/>
         <params/>
         <attribs>
            <spinner name="note" MinValue="0" MaxValue="127" DefaultValue="64"/>
            <spinner name="channel" MinValue="1" MaxValue="16" DefaultValue="0"/>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[uint8_t _gate;]]></code.declaration>
         <code.init><![CDATA[_gate = 0;]]></code.init>
         <code.krate><![CDATA[outlet_gate= _gate<<27;]]></code.krate>
         <code.midihandler><![CDATA[if ((status == MIDI_NOTE_ON + (attr_channel-1)) && (data2)) {if (data1 == attr_note) {
   _gate = 1;
}
} else if (((status == MIDI_NOTE_ON + (attr_channel-1)) && (!data2))||          (status == MIDI_NOTE_OFF + (attr_channel-1))) {
  if (data1 == attr_note) {
    _gate = 0;
  }
} else if ((status == (attr_channel-1) + MIDI_CONTROL_CHANGE)&&(data1 == MIDI_C_ALL_NOTES_OFF)) {
  _gate = 0;
}]]></code.midihandler>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="9bfcf277-a28b-41d6-b233-8dd0d8b7eab0" name="top_1" x="826" y="14">
      <params/>
      <attribs/>
      <object id="patch/object" uuid="9bfcf277-a28b-41d6-b233-8dd0d8b7eab0">
         <sDescription>outputs the state of the top-row buttons of a &apos;novation launchpad&apos;.
DOES NOT work with the &apos;LP mark 1&apos;.</sDescription>
         <author>Robert Schirmer</author>
         <license>BSD</license>
         <helpPatch>launchpad.axh</helpPatch>
         <inlets/>
         <outlets>
            <bool32 name="t0"/>
            <bool32 name="t1"/>
            <bool32 name="t2"/>
            <bool32 name="t4"/>
            <bool32 name="t5"/>
            <bool32 name="t6"/>
            <bool32 name="t7"/>
            <bool32 name="shift"/>
            <int32 name="mode"/>
            <int32 name="track"/>
         </outlets>
         <displays/>
         <params/>
         <attribs/>
         <includes/>
         <code.declaration><![CDATA[uint8_t cc [128];
int hold;
int track;]]></code.declaration>
         <code.krate><![CDATA[outlet_t0 = cc[104];
outlet_t1 = cc[105];
outlet_t2 = cc[106];
outlet_t4 = cc[108];
outlet_t5 = cc[109];
outlet_t6 = cc[110];
outlet_t7 = cc[111];
if (cc[105]) {outlet_mode=0;hold=0;track=0;}
if (cc[107]) {outlet_mode=1;hold=1;track=1;}
if (cc[109]) {outlet_mode=2;hold=2;track=2;}
if (cc[104]) {outlet_mode=3;hold=3;track=0;}
if (cc[106]) {outlet_mode=4;hold=4;track=1;}
if (cc[108]) {outlet_mode=5;hold=5;track=2;}
outlet_mode=hold;
outlet_track=track;
outlet_shift = (cc[105])||(cc[107])||(cc[109])||(cc[104])||(cc[106])||(cc[108]);]]></code.krate>
         <code.midihandler><![CDATA[if (status == 0 + MIDI_CONTROL_CHANGE) cc[data1] = data2;]]></code.midihandler>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="20be3222-3bef-4153-a3ad-a780a194363a" name="midithru_1" x="1190" y="14">
      <params/>
      <attribs>
         <combo attributeName="input" selection="usb host port 1"/>
         <combo attributeName="output" selection="din"/>
      </attribs>
      <object id="patch/object" uuid="20be3222-3bef-4153-a3ad-a780a194363a">
         <sDescription>an object to forward midi from one device to another
note: does not handle sysex or clock</sDescription>
         <author>Mark Harris</author>
         <license>GPL</license>
         <inlets/>
         <outlets/>
         <displays/>
         <params/>
         <attribs>
            <combo name="input">
               <MenuEntries>
                  <string>omni</string>
                  <string>din</string>
                  <string>usb host port 1</string>
                  <string>usb host port 2</string>
                  <string>usb host port 3</string>
                  <string>usb host port 4</string>
                  <string>internal port 1</string>
                  <string>internal port 2</string>
                  <string>usb device port 1</string>
               </MenuEntries>
               <CEntries>
                  <string>true</string>
                  <string>dev == MIDI_DEVICE_DIN &amp;&amp; port == 1</string>
                  <string>dev == MIDI_DEVICE_USB_HOST &amp;&amp; port == 1</string>
                  <string>dev == MIDI_DEVICE_USB_HOST &amp;&amp; port == 2</string>
                  <string>dev == MIDI_DEVICE_USB_HOST &amp;&amp; port == 3</string>
                  <string>dev == MIDI_DEVICE_USB_HOST &amp;&amp; port == 4</string>
                  <string>dev == MIDI_DEVICE_INTERNAL &amp;&amp; port == 1</string>
                  <string>dev == MIDI_DEVICE_INTERNAL &amp;&amp; port == 2</string>
                  <string>dev == MIDI_DEVICE_USB_DEVICE &amp;&amp; port == 1</string>
               </CEntries>
            </combo>
            <combo name="output">
               <MenuEntries>
                  <string>din</string>
                  <string>usb host port 1</string>
                  <string>usb host port 2</string>
                  <string>usb host port 3</string>
                  <string>usb host port 4</string>
                  <string>internal port 1</string>
                  <string>internal port 2</string>
                  <string>usb device port 1</string>
               </MenuEntries>
               <CEntries>
                  <string>MIDI_DEVICE_DIN, 1</string>
                  <string>MIDI_DEVICE_USB_HOST, 1</string>
                  <string>MIDI_DEVICE_USB_HOST, 2</string>
                  <string>MIDI_DEVICE_USB_HOST, 3</string>
                  <string>MIDI_DEVICE_USB_HOST, 4</string>
                  <string>MIDI_DEVICE_INTERNAL, 1</string>
                  <string>MIDI_DEVICE_INTERNAL, 2</string>
                  <string>MIDI_DEVICE_USB_DEVICE, 1</string>
               </CEntries>
            </combo>
         </attribs>
         <includes/>
         <code.midihandler><![CDATA[if(attr_input) {
        uint8_t status_type = status & 0xF0;
            if ((status_type == MIDI_NOTE_OFF) ||
                (status_type == MIDI_NOTE_ON)) {
                	if ((data1!=2)&&(data1!=3)&&(data1!=18)&&(data1!=19)&&(data1!=34)&&(data1!=35)&&(data1!=50)&&(data1!=51)
                	&&(data1!=66)&&(data1!=67)&&(data1!=82)&&(data1!=83)&&(data1!=98)&&(data1!=99)&&(data1!=114)&&(data1!=115))
                	{
                    MidiSend3((midi_device_t) attr_output,status,data1,data2);
            }
            }
            if ((status_type == MIDI_CONTROL_CHANGE)&&(data1=111)){
            	MidiSend3((midi_device_t) attr_output,status,data1,data2);
            }
        }]]></code.midihandler>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="d989e31b-550b-4ee5-9079-40793b6bb9b7" name="midithru_2" x="1428" y="14">
      <params/>
      <attribs>
         <combo attributeName="input" selection="din"/>
         <combo attributeName="output" selection="usb host port 1"/>
      </attribs>
      <object id="patch/object" uuid="d989e31b-550b-4ee5-9079-40793b6bb9b7">
         <sDescription>an object to forward midi from one device to another
note: does not handle sysex or clock</sDescription>
         <author>Mark Harris</author>
         <license>GPL</license>
         <inlets/>
         <outlets/>
         <displays/>
         <params/>
         <attribs>
            <combo name="input">
               <MenuEntries>
                  <string>omni</string>
                  <string>din</string>
                  <string>usb host port 1</string>
                  <string>usb host port 2</string>
                  <string>usb host port 3</string>
                  <string>usb host port 4</string>
                  <string>internal port 1</string>
                  <string>internal port 2</string>
                  <string>usb device port 1</string>
               </MenuEntries>
               <CEntries>
                  <string>true</string>
                  <string>dev == MIDI_DEVICE_DIN &amp;&amp; port == 1</string>
                  <string>dev == MIDI_DEVICE_USB_HOST &amp;&amp; port == 1</string>
                  <string>dev == MIDI_DEVICE_USB_HOST &amp;&amp; port == 2</string>
                  <string>dev == MIDI_DEVICE_USB_HOST &amp;&amp; port == 3</string>
                  <string>dev == MIDI_DEVICE_USB_HOST &amp;&amp; port == 4</string>
                  <string>dev == MIDI_DEVICE_INTERNAL &amp;&amp; port == 1</string>
                  <string>dev == MIDI_DEVICE_INTERNAL &amp;&amp; port == 2</string>
                  <string>dev == MIDI_DEVICE_USB_DEVICE &amp;&amp; port == 1</string>
               </CEntries>
            </combo>
            <combo name="output">
               <MenuEntries>
                  <string>din</string>
                  <string>usb host port 1</string>
                  <string>usb host port 2</string>
                  <string>usb host port 3</string>
                  <string>usb host port 4</string>
                  <string>internal port 1</string>
                  <string>internal port 2</string>
                  <string>usb device port 1</string>
               </MenuEntries>
               <CEntries>
                  <string>MIDI_DEVICE_DIN, 1</string>
                  <string>MIDI_DEVICE_USB_HOST, 1</string>
                  <string>MIDI_DEVICE_USB_HOST, 2</string>
                  <string>MIDI_DEVICE_USB_HOST, 3</string>
                  <string>MIDI_DEVICE_USB_HOST, 4</string>
                  <string>MIDI_DEVICE_INTERNAL, 1</string>
                  <string>MIDI_DEVICE_INTERNAL, 2</string>
                  <string>MIDI_DEVICE_USB_DEVICE, 1</string>
               </CEntries>
            </combo>
         </attribs>
         <includes/>
         <code.midihandler><![CDATA[if(attr_input) {
        uint8_t status_type = status & 0xF0;
            if (                (status_type == MIDI_NOTE_OFF+0) ||
                (status_type == MIDI_NOTE_ON+0))                
                 {
                    MidiSend3((midi_device_t) attr_output,status,data1,data2);
            } 
        }]]></code.midihandler>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="20be3222-3bef-4153-a3ad-a780a194363a" name="midithru_4" x="1652" y="14">
      <params/>
      <attribs>
         <combo attributeName="input" selection="internal port 1"/>
         <combo attributeName="output" selection="din"/>
      </attribs>
      <object id="patch/object" uuid="20be3222-3bef-4153-a3ad-a780a194363a">
         <sDescription>an object to forward midi from one device to another
note: does not handle sysex or clock</sDescription>
         <author>Mark Harris</author>
         <license>GPL</license>
         <inlets/>
         <outlets/>
         <displays/>
         <params/>
         <attribs>
            <combo name="input">
               <MenuEntries>
                  <string>omni</string>
                  <string>din</string>
                  <string>usb host port 1</string>
                  <string>usb host port 2</string>
                  <string>usb host port 3</string>
                  <string>usb host port 4</string>
                  <string>internal port 1</string>
                  <string>internal port 2</string>
                  <string>usb device port 1</string>
               </MenuEntries>
               <CEntries>
                  <string>true</string>
                  <string>dev == MIDI_DEVICE_DIN &amp;&amp; port == 1</string>
                  <string>dev == MIDI_DEVICE_USB_HOST &amp;&amp; port == 1</string>
                  <string>dev == MIDI_DEVICE_USB_HOST &amp;&amp; port == 2</string>
                  <string>dev == MIDI_DEVICE_USB_HOST &amp;&amp; port == 3</string>
                  <string>dev == MIDI_DEVICE_USB_HOST &amp;&amp; port == 4</string>
                  <string>dev == MIDI_DEVICE_INTERNAL &amp;&amp; port == 1</string>
                  <string>dev == MIDI_DEVICE_INTERNAL &amp;&amp; port == 2</string>
                  <string>dev == MIDI_DEVICE_USB_DEVICE &amp;&amp; port == 1</string>
               </CEntries>
            </combo>
            <combo name="output">
               <MenuEntries>
                  <string>din</string>
                  <string>usb host port 1</string>
                  <string>usb host port 2</string>
                  <string>usb host port 3</string>
                  <string>usb host port 4</string>
                  <string>internal port 1</string>
                  <string>internal port 2</string>
                  <string>usb device port 1</string>
               </MenuEntries>
               <CEntries>
                  <string>MIDI_DEVICE_DIN, 1</string>
                  <string>MIDI_DEVICE_USB_HOST, 1</string>
                  <string>MIDI_DEVICE_USB_HOST, 2</string>
                  <string>MIDI_DEVICE_USB_HOST, 3</string>
                  <string>MIDI_DEVICE_USB_HOST, 4</string>
                  <string>MIDI_DEVICE_INTERNAL, 1</string>
                  <string>MIDI_DEVICE_INTERNAL, 2</string>
                  <string>MIDI_DEVICE_USB_DEVICE, 1</string>
               </CEntries>
            </combo>
         </attribs>
         <includes/>
         <code.midihandler><![CDATA[if(attr_input) {
        uint8_t status_type = status & 0xF0;
            if ((status_type == MIDI_NOTE_OFF) ||
                (status_type == MIDI_NOTE_ON)) {
                	if ((data1!=2)&&(data1!=3)&&(data1!=18)&&(data1!=19)&&(data1!=34)&&(data1!=35)&&(data1!=50)&&(data1!=51)
                	&&(data1!=66)&&(data1!=67)&&(data1!=82)&&(data1!=83)&&(data1!=98)&&(data1!=99)&&(data1!=114)&&(data1!=115))
                	{
                    MidiSend3((midi_device_t) attr_output,status,data1,data2);
            }
            }
            if ((status_type == MIDI_CONTROL_CHANGE)&&(data1=111)){
            	MidiSend3((midi_device_t) attr_output,status,data1,data2);
            }
        }]]></code.midihandler>
      </object>
   </patchobj>
   <comment type="patch/comment" x="994" y="84" text="master play"/>
   <obj type="drj/seq/clk_mul" uuid="1413af5343f97123abeeb627811120af4b3a4793" name="clk_mul_6" x="308" y="98">
      <params>
         <int32 name="clockmul" value="2"/>
      </params>
      <attribs/>
   </obj>
   <obj type="drj/seq/clk_mul" uuid="1413af5343f97123abeeb627811120af4b3a4793" name="clk_mul_2" x="420" y="98">
      <params>
         <int32 name="clockmul" value="32"/>
      </params>
      <attribs/>
   </obj>
   <patchobj type="patch/object" uuid="2402584d-2694-4ed4-8d77-54830ea0fabf" name="toggle_1" x="994" y="98">
      <params/>
      <attribs/>
      <object id="patch/object" uuid="2402584d-2694-4ed4-8d77-54830ea0fabf">
         <sDescription>toggle</sDescription>
         <author>Johannes Taelman</author>
         <license>BSD</license>
         <helpPatch>logic.axh</helpPatch>
         <inlets>
            <bool32.rising name="trig" description="trigger"/>
            <bool32 name="set"/>
            <bool32 name="reset"/>
         </inlets>
         <outlets>
            <bool32 name="o" description="output"/>
            <bool32 name="stop"/>
            <bool32 name="start"/>
         </outlets>
         <displays/>
         <params/>
         <attribs/>
         <includes/>
         <code.declaration><![CDATA[int ntrig;
   int op;
int Mtrig;
int MBtrig;
   int p_set;
   int p_reset;]]></code.declaration>
         <code.init><![CDATA[ntrig = 0;
op = 0;
]]></code.init>
         <code.krate><![CDATA[if ((inlet_trig>0) && !ntrig) {op = !op; ntrig=1;}
if (!(inlet_trig>0)) ntrig=0;
if ((inlet_set>0) && !p_set) {op = 1; p_set=1;}
if ((inlet_reset>0) && !p_reset) {op = 0; p_reset=1;}
if (!(inlet_set>0)) p_set=0;
if (!(inlet_reset>0)) p_reset=0;

outlet_o= op;
if ((!(op>0))&&!Mtrig) {
outlet_stop=1;
	Mtrig=1;
}
else outlet_stop=0;
if ((op>0)&&(!MBtrig)) {
outlet_start=1;
	MBtrig=1;
}
else outlet_start=0;

if (op>0) {Mtrig=0;}
if(!(op>0)) {MBtrig=0;}]]></code.krate>
      </object>
   </patchobj>
   <comment type="patch/comment" x="70" y="154" text="song &amp; maximum bar length data"/>
   <comment type="patch/comment" x="322" y="154" text="clip data"/>
   <obj type="table/alloc 16b sdram load" uuid="e6b85dad3ab43565cda93ea4c43c73b668b1cd43" name="lcxl3" x="70" y="168">
      <params/>
      <attribs>
         <combo attributeName="size" selection="8192"/>
         <file attributeName="filename" file="/abletones"/>
      </attribs>
   </obj>
   <obj type="table/alloc 16b sdram load" uuid="e6b85dad3ab43565cda93ea4c43c73b668b1cd43" name="lcxl2" x="322" y="168">
      <params/>
      <attribs>
         <combo attributeName="size" selection="2097152"/>
         <file attributeName="filename" file="/abletone"/>
      </attribs>
   </obj>
   <comment type="patch/comment" x="742" y="210" text="bar trigger counters"/>
   <comment type="patch/comment" x="546" y="224" text="4ppq half a step early for quantize"/>
   <comment type="patch/comment" x="742" y="224" text="barcount play"/>
   <comment type="patch/comment" x="840" y="224" text="bar count rec"/>
   <obj type="djrm/logic/counter2_init_start" uuid="d5936f238ab92e53ac93d5927c3b43ceef998dc1" name="counter2_init_start_3" x="574" y="238">
      <params>
         <int32 name="maximum" value="1"/>
         <int32 name="init" value="1"/>
      </params>
      <attribs/>
   </obj>
   <obj type="logic/counter" uuid="7a141ba82230e54e5f5cd12da5dbe5a74ba854a5" name="counter_14" x="742" y="238">
      <params>
         <int32 name="maximum" value="16"/>
      </params>
      <attribs/>
   </obj>
   <obj type="logic/counter" uuid="7a141ba82230e54e5f5cd12da5dbe5a74ba854a5" name="counter_15" x="840" y="238">
      <params>
         <int32 name="maximum" value="16"/>
      </params>
      <attribs/>
   </obj>
   <obj type="logic/and 2" uuid="c67031682f552aa0a80b23377495c51ea28a8c9c" name="and_13" x="980" y="238">
      <params/>
      <attribs/>
   </obj>
   <obj type="logic/and 2" uuid="c67031682f552aa0a80b23377495c51ea28a8c9c" name="and_14" x="1120" y="238">
      <params/>
      <attribs/>
   </obj>
   <comment type="patch/comment" x="308" y="322" text="max bar length light"/>
   <obj type="rbrt/patching/loadbang" uuid="45d1f29d-ac62-4e5b-86f8-2201d2f6c689" name="loadbang_1" x="308" y="336">
      <params/>
      <attribs/>
   </obj>
   <patchobj type="patch/object" uuid="27740fce-72af-49dc-ba76-85eeba596efa" name="delayedpulse_1" x="434" y="336">
      <params>
         <frac32.s.map name="delay" value="-25.0"/>
      </params>
      <attribs/>
      <object id="patch/object" uuid="27740fce-72af-49dc-ba76-85eeba596efa">
         <sDescription>Generates a single pulse after a delay after a rising edge on trigger input. A new trigger before the pulse arrives at the output, will cancel the previous trigger. The generated pulse is so small you won&apos;t notice it on a display! Extended range version.</sDescription>
         <author>Johannes Taelman</author>
         <license>BSD</license>
         <helpPatch>timer.axh</helpPatch>
         <inlets>
            <bool32.rising name="trig" description="trigger"/>
         </inlets>
         <outlets>
            <bool32.pulse name="pulse" description="pulse output"/>
         </outlets>
         <displays/>
         <params>
            <frac32.s.map.klineartime.exp name="delay" noLabel="true"/>
         </params>
         <attribs/>
         <includes/>
         <code.declaration><![CDATA[int32_t val;
int ntrig;
]]></code.declaration>
         <code.init><![CDATA[val = 0;
ntrig = 0;
]]></code.init>
         <code.krate><![CDATA[if ((inlet_trig > 0) && !ntrig) {
  val = 1 << 30;
  ntrig = 1;
  outlet_pulse = 0;
}
else {
  if (!(inlet_trig > 0))
    ntrig = 0;
  if (val>0) {
    int32_t t;
    MTOF(-param_delay,t);
     val -= t>>3;
     if (val<=0) outlet_pulse = 1;
     else outlet_pulse = 0;
  } else outlet_pulse = 0;
}
]]></code.krate>
      </object>
   </patchobj>
   <comment type="patch/comment" x="168" y="364" text="max bar recording length"/>
   <comment type="patch/comment" x="644" y="364" text="track 3"/>
   <comment type="patch/comment" x="1218" y="364" text="track 4"/>
   <patchobj type="patch/object" uuid="7adf6824-f78a-4e1a-90e6-9f120b9662c8" name="launch_7" x="70" y="378">
      <params/>
      <attribs>
         <spinner attributeName="channel" value="1"/>
      </attribs>
      <object id="patch/object" uuid="7adf6824-f78a-4e1a-90e6-9f120b9662c8">
         <sDescription>Monophonic MIDI keyboard note input, gate, velocity and release velocity, only responding to a range of notes</sDescription>
         <author>Johannes Taelman</author>
         <license>BSD</license>
         <helpPatch>midi_in.axh</helpPatch>
         <inlets>
            <bool32 name="active"/>
         </inlets>
         <outlets>
            <int32 name="note"/>
            <bool32 name="gate" description="key pressed?"/>
         </outlets>
         <displays/>
         <params/>
         <attribs>
            <spinner name="channel" MinValue="1" MaxValue="16" DefaultValue="9"/>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[int8_t _note;
uint8_t _gate;]]></code.declaration>
         <code.init><![CDATA[_gate = 0;
_note = 0;]]></code.init>
         <code.krate><![CDATA[outlet_note= _note;

outlet_gate= _gate<<27;]]></code.krate>
         <code.midihandler><![CDATA[if ((status == MIDI_NOTE_ON + (attr_channel-1)) && (data2) && (data1 == 6)) {
    _note = 0;
    _gate = 1;
}
if ((status == MIDI_NOTE_ON + (attr_channel-1)) && (data2) && (data1 == 22)) {
    _note = 1;
    _gate = 1;
} 
if ((status == MIDI_NOTE_ON + (attr_channel-1)) && (data2) && (data1 == 38)) {
    _note = 2;
    _gate = 1;
} 
if ((status == MIDI_NOTE_ON + (attr_channel-1)) && (data2) && (data1 == 54)) {
    _note = 3;
    _gate = 1;
} 
if ((status == MIDI_NOTE_ON + (attr_channel-1)) && (data2) && (data1 == 70)) {
    _note = 4;
    _gate = 1;
} 
if ((status == MIDI_NOTE_ON + (attr_channel-1)) && (data2) && (data1 == 86)) {
    _note = 5;
    _gate = 1;
} 
if ((status == MIDI_NOTE_ON + + (attr_channel-1)) && (data2) && (data1 == 102)) {
    _note = 6;
    _gate = 1;
} 
if ((status == MIDI_NOTE_ON + (attr_channel-1)) && (data2) && (data1 == 118)) {
    _note = 7;
    _gate = 1;
} 
if ((status == MIDI_NOTE_ON + (attr_channel-1)) && (data2) && (data1 == 7)) {
    _note = 8;
    _gate = 1;
} 
if ((status == MIDI_NOTE_ON + (attr_channel-1)) && (data2) && (data1 == 23)) {
    _note = 9;
    _gate = 1;
} 
if ((status == MIDI_NOTE_ON + (attr_channel-1)) && (data2) && (data1 == 39)) {
    _note = 10;
    _gate = 1;
} 
if ((status == MIDI_NOTE_ON + (attr_channel-1)) && (data2) && (data1 == 55)) {
    _note = 11;
    _gate = 1;
} 
if ((status == MIDI_NOTE_ON + (attr_channel-1)) && (data2) && (data1 == 71)) {
    _note = 12;
    _gate = 1;
} 
if ((status == MIDI_NOTE_ON + (attr_channel-1)) && (data2) && (data1 == 87)) {
    _note = 13;
    _gate = 1;
} 
if ((status == MIDI_NOTE_ON + (attr_channel-1)) && (data2) && (data1 == 103)) {
    _note = 14;
    _gate = 1;
} 
if ((status == MIDI_NOTE_ON + (attr_channel-1)) && (data2) && (data1 == 119)) {
    _note = 15;
    _gate = 1;
} 
else if (((status == MIDI_NOTE_ON + (attr_channel-1)) && (!data2))||          (status == MIDI_NOTE_OFF + (attr_channel-1))) {
    _gate = 0;
  }]]></code.midihandler>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="e8c7c633-0416-4595-9cf3-ad1b828c06dd" name="tablestore_1" x="168" y="378">
      <params/>
      <attribs>
         <objref attributeName="table" obj="lcxl3"/>
      </attribs>
      <object id="patch/object" uuid="e8c7c633-0416-4595-9cf3-ad1b828c06dd">
         <sDescription>writes and outputs values to a table at position &apos;i&apos; + &apos;offset&apos; at the rising edge of &apos;trig&apos;</sDescription>
         <author>robert schirmer</author>
         <license>who cares</license>
         <inlets>
            <frac32 name="v" description="value to write to a table"/>
            <int32 name="i" description="writes to a table at position i + offset"/>
            <bool32.rising name="trig" description="trigger write"/>
         </inlets>
         <outlets>
            <frac32 name="v" description="out0  +  i"/>
         </outlets>
         <displays/>
         <params/>
         <attribs>
            <objref name="table"/>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[int ntrig;]]></code.declaration>
         <code.init><![CDATA[ntrig = 0;]]></code.init>
         <code.krate><![CDATA[if ((inlet_trig>0) && !ntrig) {
	ntrig = 1;
attr_table.array[inlet_i ]=__SSAT(inlet_v,28)>>attr_table.GAIN;
}
if (!(inlet_trig>0)) ntrig=0;
outlet_v= attr_table.array[__USAT((inlet_i),attr_table.LENGTHPOW)]<<attr_table.GAIN;]]></code.krate>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="c8ce26a1-1552-494a-94aa-26fb839ba19d" name="step_2" x="308" y="378">
      <params/>
      <attribs>
         <combo attributeName="device" selection="usb host port / LP"/>
         <combo attributeName="color" selection="orange W"/>
         <spinner attributeName="column" value="6"/>
      </attribs>
      <object id="patch/object" uuid="c8ce26a1-1552-494a-94aa-26fb839ba19d">
         <sDescription>display a step counter on a novation launchpad</sDescription>
         <author>Robert Schirmer</author>
         <license>BSD</license>
         <helpPatch>launchpad.axh</helpPatch>
         <rotatedParams>true</rotatedParams>
         <inlets>
            <int32 name="step" description="current step"/>
            <bool32 name="active" description="active??"/>
         </inlets>
         <outlets/>
         <displays/>
         <params/>
         <attribs>
            <combo name="device">
               <MenuEntries>
                  <string>usb host port / LP</string>
               </MenuEntries>
               <CEntries>
                  <string>MIDI_DEVICE_USB_HOST, 1</string>
               </CEntries>
            </combo>
            <combo name="color">
               <MenuEntries>
                  <string>off</string>
                  <string>red W</string>
                  <string>red M</string>
                  <string>red S</string>
                  <string>orange W</string>
                  <string>orange S</string>
                  <string>green W</string>
                  <string>green M</string>
                  <string>green S</string>
                  <string>lime 1 W</string>
                  <string>lime 1 S</string>
                  <string>lime 2</string>
                  <string>yellow W</string>
                  <string>yellow M</string>
                  <string>yellow S</string>
               </MenuEntries>
               <CEntries>
                  <string>0</string>
                  <string>1</string>
                  <string>2</string>
                  <string>3</string>
                  <string>18</string>
                  <string>35</string>
                  <string>16</string>
                  <string>32</string>
                  <string>48</string>
                  <string>33</string>
                  <string>50</string>
                  <string>49</string>
                  <string>17</string>
                  <string>34</string>
                  <string>51</string>
               </CEntries>
            </combo>
            <spinner name="column" MinValue="0" MaxValue="7" DefaultValue="0"/>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[int ntrig;
int rtrig;
int prev;
int i;
int32_t map[16];
int32_t v;]]></code.declaration>
         <code.init><![CDATA[{ 
  int i;
  for(i=0;i<16;i++) 

  map[0] = 0+attr_column;
map[1] = 16+attr_column;
map[2] = 32+attr_column;
map[3] = 48+attr_column;
map[4] = 64+attr_column;
map[5] = 80+attr_column;
map[6] = 96+attr_column;
map[7] = 112+attr_column;
  map[8] = 0+attr_column+1;
map[9] = 16+attr_column+1;
map[10] = 32+attr_column+1;
map[11] = 48+attr_column+1;
map[12] = 64+attr_column+1;
map[13] = 80+attr_column+1;
map[14] = 96+attr_column+1;
map[15] = 112+attr_column+1;

}
rtrig=1;]]></code.init>
         <code.krate><![CDATA[if (i < 16){
MidiSend3((midi_device_t) attr_device, MIDI_NOTE_ON ,map[i],17);

i += 1;
  }
  else i = 666;
if (inlet_active){rtrig=1;}

if (rtrig) {MidiSend3((midi_device_t) attr_device, MIDI_NOTE_ON ,map[(inlet_step)],(attr_color));}

if (inlet_step  != prev) {
  MidiSend3((midi_device_t) attr_device, MIDI_NOTE_ON ,map[(inlet_step)],(attr_color));
  MidiSend3((midi_device_t) attr_device, MIDI_NOTE_ON ,map[(prev)],17);
prev = inlet_step;
}




rtrig = 0;]]></code.krate>
      </object>
   </patchobj>
   <comment type="patch/comment" x="644" y="378" text="transport &amp; pattern length rec"/>
   <comment type="patch/comment" x="1218" y="378" text="transport &amp; pattern length rec"/>
   <patchobj type="patch/object" uuid="8385bd19-937d-47af-9b09-08facf287fbb" name="object_3" x="644" y="392">
      <params/>
      <attribs>
         <objref attributeName="table" obj="lcxl2"/>
         <spinner attributeName="buttonoffset" value="0"/>
         <spinner attributeName="total" value="137217"/>
         <spinner attributeName="barcount" value="16"/>
         <spinner attributeName="column" value="3"/>
      </attribs>
      <object id="patch/object" uuid="8385bd19-937d-47af-9b09-08facf287fbb">
         <inlets>
            <bool32 name="shift"/>
            <bool32 name="pulse"/>
            <bool32 name="pulseplay"/>
            <int32 name="barcount"/>
            <bool32 name="start"/>
            <bool32 name="stop"/>
         </inlets>
         <outlets>
            <int32 name="clipslot"/>
            <int32 name="clearslot"/>
            <bool32 name="cliptrigger"/>
            <bool32 name="cleartrigger"/>
            <int32 name="offsetnotes"/>
            <bool32 name="wait"/>
            <bool32 name="rec"/>
            <bool32 name="play"/>
            <bool32 name="nplaytrig"/>
            <bool32 name="nrectrig"/>
         </outlets>
         <displays/>
         <params/>
         <attribs>
            <objref name="table"/>
            <spinner name="buttonoffset" MinValue="0" MaxValue="10000000" DefaultValue="0"/>
            <spinner name="total" MinValue="0" MaxValue="5000000" DefaultValue="0"/>
            <spinner name="barcount" MinValue="0" MaxValue="16" DefaultValue="0"/>
            <spinner name="column" MinValue="1" MaxValue="8" DefaultValue="1"/>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[uint32_t i;
uint32_t ii;
uint32_t src;
uint32_t range;
uint32_t block;
int note;
int trigger;
int clipslot;
int clearslot;
int clear;
int clip;
int clipB;

int cloffset;
int nclear;
int rclear;
int speed;



int pclipslot;
int slotoffset;
int offset;
int full;
int ntrig;
int xtrig;
int prevplay;
int playtrig;
int recordtrig;
int recofftrig;
int wait;
int zwait;
int ztrig;
int record;
int play;
int outletrectrig;
int bar_record;
int maxbar;
int vcount;
int vtrig;
int vrtrig;
int vr2trig;
int ctrig;
int rtrig;
int count;
int prevfull;
int nrectrig;
int nplaytrig;
int prevoffset;]]></code.declaration>
         <code.init><![CDATA[full=attr_table.array[__USAT((0+ attr_buttonoffset),attr_table.LENGTHPOW)]<<attr_table.GAIN;
slotoffset=0;
count=0;
ctrig = 0;
rtrig = 0;
clipslot=6;
clearslot=6;
pclipslot=8;]]></code.init>
         <code.krate><![CDATA[/////
if ((!inlet_shift)&&trigger){
if (note==(0+(attr_column-1))) {clipslot=0;clip=1;clipB=0;}
if (note==(16+(attr_column-1))) {clipslot=1;clip=1;clipB=0;}
if (note==(32+(attr_column-1))) {clipslot=2;clip=1;clipB=0;}
if (note==(48+(attr_column-1))) {clipslot=3;clip=1;clipB=0;}
if (note==(64+(attr_column-1))) {clipslot=4;clip=1;clipB=0;}
if (note==(80+(attr_column-1))) {clipslot=5;clip=1;clipB=0;}
if (note==(96+(attr_column-1))) {clipslot=6;clip=1;clipB=0;}
if ((note==(112+(attr_column-1)))||(note==120)) {clipslot=7;clip=1;}
	if (note==8) {clipslot=0;clipB=1;clip=1;}
	if (note==24) {clipslot=1;clipB=1;clip=1;}
	if (note==40) {clipslot=2;clipB=1;clip=1;}
	if (note==56) {clipslot=3;clipB=1;clip=1;}
	if (note==72) {clipslot=4;clipB=1;clip=1;}
	if (note==88) {clipslot=5;clipB=1;clip=1;}
	if (note==104) {clipslot=6;clipB=1;clip=1;}
	if (note==120) {clipslot=7;clipB=1;clip=1;}
	
}

else if (inlet_shift){
if ((note==(0+(attr_column-1)))&&trigger) {clearslot=0;clear=1;}
if ((note==(16+(attr_column-1)))&&trigger) {clearslot=1;clear=1;}
if ((note==(32+(attr_column-1)))&&trigger) {clearslot=2;clear=1;}
if ((note==(48+(attr_column-1)))&&trigger) {clearslot=3;clear=1;}
if ((note==(64+(attr_column-1)))&&trigger) {clearslot=4;clear=1;}
if ((note==(80+(attr_column-1)))&&trigger) {clearslot=5;clear=1;}
if ((note==(96+(attr_column-1)))&&trigger) {clearslot=6;clear=1;}
if ((note==(112+(attr_column-1)))&&trigger) {clearslot=7;clear=1;}
}




//full=attr_table.array[__USAT((clipslot+ attr_buttonoffset),attr_table.LENGTHPOW)]<<attr_table.GAIN;
//if ((clipB)&&(full>0)){clip=1;clipB=0;}
//if ((clipB)&&(!(full>0))){clip=1;}
       

if (!trigger) {clip=0;clear=0;}



/////

full=attr_table.array[__USAT((clipslot+ attr_buttonoffset),attr_table.LENGTHPOW)]<<attr_table.GAIN;
nrectrig=0;
nplaytrig=0;
offset=8+slotoffset+attr_buttonoffset;
outlet_offsetnotes=offset+1;

if (inlet_start>0){play=prevplay;}
//if ((clipB>0)&&(full)&&!ntrig){	
//	wait=1;
//	zwait=1;	
//	ntrig=1;
//}
if ((clip>0)&&!ntrig){	
	wait=1;
	zwait=1;	
	ntrig=1;
}
if ((wait>0)&&(!(clip>0))&&(inlet_pulse>0)) {xtrig=1;nrectrig=1;wait=0;ntrig=0;}
if ((zwait>0)&&(!(clip>0))&&(inlet_pulseplay>0)) {
	nplaytrig=1;
	zwait=0;
	}

//
if ((clipslot==7)&&xtrig){
	if (record>0){
		attr_table.array[prevfull + attr_buttonoffset]=__SSAT(0,28)>>attr_table.GAIN;
	}
	prevplay=play;
	play=0;
	record=0;
	wait=0;
	ntrig=0;
	xtrig=0;
	clipB=0;
	pclipslot=8;
}
//
if (clipslot<7)
{
if ((clipslot!=pclipslot)&&xtrig){
	if (record>0){
		attr_table.array[offset]=__SSAT((bar_record),28)>>attr_table.GAIN;
	}
	xtrig=0;
	vcount=0;
	count=-1;
	nrectrig=1;
	slotoffset=(attr_total*clipslot);
	offset=8+slotoffset+attr_buttonoffset;
	prevoffset=slotoffset;
	full=attr_table.array[__USAT((clipslot+ attr_buttonoffset),attr_table.LENGTHPOW)]<<attr_table.GAIN;
	if (full>0){
		play=1;
		record=0;
	}
	if (!(full>0)){
		if (!clipB){
		play=0;
		attr_table.array[clipslot + attr_buttonoffset]=__SSAT(0x07FFFFFF,28)>>attr_table.GAIN;
		prevfull=clipslot;
		record=1;
		}
		else if (clipB){
		play=0;
		record=0;
		clipB=0;
		}
	}
	pclipslot=clipslot;
	
}
if (!clipB){
if ((!(full>0))&&xtrig){
	attr_table.array[clipslot + attr_buttonoffset]=__SSAT(0x07FFFFFF,28)>>attr_table.GAIN;
	prevfull=clipslot;
	record=1;
	xtrig=0;
}

if ((full>0)&&(!(play>0))&&xtrig){
	record=0;
	play=1;
	xtrig=0;
}
if ((full>0)&&(play>0)&&xtrig){
	record=0;
	vcount=0;
	play=1;
	xtrig=0;
}
}
else if ((clipB)&&(xtrig)){
	if (!full){
	play=0;
	record=0;
	}
	else if (full){
		play=1;
		record=0;
	}
	clipB=0;
	xtrig=0;
}

}


if (inlet_stop>0){
	prevplay=play;
	play=0;
	record=0;
	wait=0;
	ntrig=0;
	xtrig=0;
	clipB=0;
}


if ((clear>0)&&!ntrig){
	ntrig=1;
	attr_table.array[clearslot + attr_buttonoffset]=__SSAT(0,28)>>attr_table.GAIN;
	if (clipslot==clearslot){
		play=0;
		record=0;
		wait=0;
		zwait=0;
	}
}
else if(!(clear)) {ntrig=0;}



//





outlet_play=play;


outlet_wait=wait;
outlet_rec=record;


//playback
if ((play>0)&&!playtrig){
	playtrig=1;
	vcount=0;
}
if (!(play>0)) {playtrig=0;}
outletrectrig=0;
if ((record>0)&&!recordtrig){
	recordtrig=1;
	outletrectrig=1;
}


if (!(record>0)) {recordtrig=0;}

if ((!(record>0))&&!recofftrig){
	attr_table.array[offset]=__SSAT(bar_record,28)>>attr_table.GAIN;
	zwait=1;
	recofftrig=1;
}

//reset
if (record>0){recofftrig=0;}

//barclocks
if ((inlet_pulse>0) && !ctrig) {
   count += 1; 
   if (count>=attr_barcount) 
   {
   	count = attr_barcount;
   }
   if ((count==(inlet_barcount))&&(record>0)){wait=1;}
   ctrig=1;
}
else if (!(inlet_pulse>0)) ctrig=0;

bar_record=(count+1)<<21;
if ((outletrectrig>0) && !rtrig) {count=0; rtrig = 1;}
else if (!(outletrectrig>0)) rtrig=0;



//barlength=recorded
maxbar=(attr_table.array[__USAT(offset,attr_table.LENGTHPOW)]<<attr_table.GAIN)>>21;
//play bar counter
if ((inlet_pulseplay>0) && !vtrig) {
   vcount += 1; if ((vcount>(maxbar))||(vcount>(16))) {
   	vcount = 1; 
   	if ((play>0)&&(!(record>0))){
   	nplaytrig=1;
   	}
   }
   vtrig=1;
}
else if (!(inlet_pulseplay>0)) vtrig=0;
//start
if ((inlet_start>0) && !vr2trig) {vcount=1; vr2trig = 1; nplaytrig=1; nrectrig=1;}
else if (!(inlet_start>0)) vr2trig=0;
//reset vcount
if (vcount>(maxbar)){vcount=1;}

/////////////
cloffset=(attr_buttonoffset+8)+(attr_total*clearslot);


speed = 16 << 4;
src = cloffset;
range = (attr_total);
block  = (range / speed) * speed;

if ((clear)&& (!nclear)){ nclear= 1;i = 0;rclear = 0;}
if ((i == attr_total) && (!clear)) {nclear= 0;i = 0;}


//copy n chunks of size 'speed'
if (nclear && (i < block)){ 
	{ 
  for(ii=0;ii<speed;ii++)
  attr_table.array[(i + ii + src)]= (( attr_table.array[(i + ii + src)] + (attr_table.array[(i + ii + src)] * 0)) * (0));
  }
  i += speed;	
}

//copy what's left
if (i == block) rclear = 1; 

if ((ntrig && rclear) && (i < (attr_total))){ 
	attr_table.array[(i + src)]= (( attr_table.array[(i + src)] + (attr_table.array[(i + src)] * 0)) * (0));
   i += 1;  
 }
//////////////////////////////


outlet_clipslot=clipslot;
outlet_cliptrigger=clip;
outlet_clearslot=clearslot;
outlet_cleartrigger=clear;


outlet_nrectrig=nrectrig;
outlet_nplaytrig=nplaytrig;]]></code.krate>
         <code.midihandler><![CDATA[if ((status == MIDI_NOTE_ON + 0)&&(data2))
	{
		note=data1;
		trigger=1;
	}
if ((status == MIDI_NOTE_ON + 0)&&(!data2))
	{trigger=0;
	}]]></code.midihandler>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="8385bd19-937d-47af-9b09-08facf287fbb" name="object_4" x="1218" y="392">
      <params/>
      <attribs>
         <objref attributeName="table" obj="lcxl2"/>
         <spinner attributeName="buttonoffset" value="960527"/>
         <spinner attributeName="total" value="137217"/>
         <spinner attributeName="barcount" value="16"/>
         <spinner attributeName="column" value="4"/>
      </attribs>
      <object id="patch/object" uuid="8385bd19-937d-47af-9b09-08facf287fbb">
         <inlets>
            <bool32 name="shift"/>
            <bool32 name="pulse"/>
            <bool32 name="pulseplay"/>
            <int32 name="barcount"/>
            <bool32 name="start"/>
            <bool32 name="stop"/>
         </inlets>
         <outlets>
            <int32 name="clipslot"/>
            <int32 name="clearslot"/>
            <bool32 name="cliptrigger"/>
            <bool32 name="cleartrigger"/>
            <int32 name="offsetnotes"/>
            <bool32 name="wait"/>
            <bool32 name="rec"/>
            <bool32 name="play"/>
            <bool32 name="nplaytrig"/>
            <bool32 name="nrectrig"/>
         </outlets>
         <displays/>
         <params/>
         <attribs>
            <objref name="table"/>
            <spinner name="buttonoffset" MinValue="0" MaxValue="10000000" DefaultValue="0"/>
            <spinner name="total" MinValue="0" MaxValue="5000000" DefaultValue="0"/>
            <spinner name="barcount" MinValue="0" MaxValue="16" DefaultValue="0"/>
            <spinner name="column" MinValue="1" MaxValue="8" DefaultValue="1"/>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[uint32_t i;
uint32_t ii;
uint32_t src;
uint32_t range;
uint32_t block;
int note;
int trigger;
int clipslot;
int clearslot;
int clear;
int clip;
int clipB;

int cloffset;
int nclear;
int rclear;
int speed;



int pclipslot;
int slotoffset;
int offset;
int full;
int ntrig;
int xtrig;
int prevplay;
int playtrig;
int recordtrig;
int recofftrig;
int wait;
int zwait;
int ztrig;
int record;
int play;
int outletrectrig;
int bar_record;
int maxbar;
int vcount;
int vtrig;
int vrtrig;
int vr2trig;
int ctrig;
int rtrig;
int count;
int prevfull;
int nrectrig;
int nplaytrig;
int prevoffset;]]></code.declaration>
         <code.init><![CDATA[full=attr_table.array[__USAT((0+ attr_buttonoffset),attr_table.LENGTHPOW)]<<attr_table.GAIN;
slotoffset=0;
count=0;
ctrig = 0;
rtrig = 0;
clipslot=6;
clearslot=6;
pclipslot=8;]]></code.init>
         <code.krate><![CDATA[/////
if ((!inlet_shift)&&trigger){
if (note==(0+(attr_column-1))) {clipslot=0;clip=1;clipB=0;}
if (note==(16+(attr_column-1))) {clipslot=1;clip=1;clipB=0;}
if (note==(32+(attr_column-1))) {clipslot=2;clip=1;clipB=0;}
if (note==(48+(attr_column-1))) {clipslot=3;clip=1;clipB=0;}
if (note==(64+(attr_column-1))) {clipslot=4;clip=1;clipB=0;}
if (note==(80+(attr_column-1))) {clipslot=5;clip=1;clipB=0;}
if (note==(96+(attr_column-1))) {clipslot=6;clip=1;clipB=0;}
if ((note==(112+(attr_column-1)))||(note==120)) {clipslot=7;clip=1;}
	if (note==8) {clipslot=0;clipB=1;clip=1;}
	if (note==24) {clipslot=1;clipB=1;clip=1;}
	if (note==40) {clipslot=2;clipB=1;clip=1;}
	if (note==56) {clipslot=3;clipB=1;clip=1;}
	if (note==72) {clipslot=4;clipB=1;clip=1;}
	if (note==88) {clipslot=5;clipB=1;clip=1;}
	if (note==104) {clipslot=6;clipB=1;clip=1;}
	if (note==120) {clipslot=7;clipB=1;clip=1;}
	
}

else if (inlet_shift){
if ((note==(0+(attr_column-1)))&&trigger) {clearslot=0;clear=1;}
if ((note==(16+(attr_column-1)))&&trigger) {clearslot=1;clear=1;}
if ((note==(32+(attr_column-1)))&&trigger) {clearslot=2;clear=1;}
if ((note==(48+(attr_column-1)))&&trigger) {clearslot=3;clear=1;}
if ((note==(64+(attr_column-1)))&&trigger) {clearslot=4;clear=1;}
if ((note==(80+(attr_column-1)))&&trigger) {clearslot=5;clear=1;}
if ((note==(96+(attr_column-1)))&&trigger) {clearslot=6;clear=1;}
if ((note==(112+(attr_column-1)))&&trigger) {clearslot=7;clear=1;}
}




//full=attr_table.array[__USAT((clipslot+ attr_buttonoffset),attr_table.LENGTHPOW)]<<attr_table.GAIN;
//if ((clipB)&&(full>0)){clip=1;clipB=0;}
//if ((clipB)&&(!(full>0))){clip=1;}
       

if (!trigger) {clip=0;clear=0;}



/////

full=attr_table.array[__USAT((clipslot+ attr_buttonoffset),attr_table.LENGTHPOW)]<<attr_table.GAIN;
nrectrig=0;
nplaytrig=0;
offset=8+slotoffset+attr_buttonoffset;
outlet_offsetnotes=offset+1;

if (inlet_start>0){play=prevplay;}
//if ((clipB>0)&&(full)&&!ntrig){	
//	wait=1;
//	zwait=1;	
//	ntrig=1;
//}
if ((clip>0)&&!ntrig){	
	wait=1;
	zwait=1;	
	ntrig=1;
}
if ((wait>0)&&(!(clip>0))&&(inlet_pulse>0)) {xtrig=1;nrectrig=1;wait=0;ntrig=0;}
if ((zwait>0)&&(!(clip>0))&&(inlet_pulseplay>0)) {
	nplaytrig=1;
	zwait=0;
	}

//
if ((clipslot==7)&&xtrig){
	if (record>0){
		attr_table.array[prevfull + attr_buttonoffset]=__SSAT(0,28)>>attr_table.GAIN;
	}
	prevplay=play;
	play=0;
	record=0;
	wait=0;
	ntrig=0;
	xtrig=0;
	clipB=0;
	pclipslot=8;
}
//
if (clipslot<7)
{
if ((clipslot!=pclipslot)&&xtrig){
	if (record>0){
		attr_table.array[offset]=__SSAT((bar_record),28)>>attr_table.GAIN;
	}
	xtrig=0;
	vcount=0;
	count=-1;
	nrectrig=1;
	slotoffset=(attr_total*clipslot);
	offset=8+slotoffset+attr_buttonoffset;
	prevoffset=slotoffset;
	full=attr_table.array[__USAT((clipslot+ attr_buttonoffset),attr_table.LENGTHPOW)]<<attr_table.GAIN;
	if (full>0){
		play=1;
		record=0;
	}
	if (!(full>0)){
		if (!clipB){
		play=0;
		attr_table.array[clipslot + attr_buttonoffset]=__SSAT(0x07FFFFFF,28)>>attr_table.GAIN;
		prevfull=clipslot;
		record=1;
		}
		else if (clipB){
		play=0;
		record=0;
		clipB=0;
		}
	}
	pclipslot=clipslot;
	
}
if (!clipB){
if ((!(full>0))&&xtrig){
	attr_table.array[clipslot + attr_buttonoffset]=__SSAT(0x07FFFFFF,28)>>attr_table.GAIN;
	prevfull=clipslot;
	record=1;
	xtrig=0;
}

if ((full>0)&&(!(play>0))&&xtrig){
	record=0;
	play=1;
	xtrig=0;
}
if ((full>0)&&(play>0)&&xtrig){
	record=0;
	vcount=0;
	play=1;
	xtrig=0;
}
}
else if ((clipB)&&(xtrig)){
	if (!full){
	play=0;
	record=0;
	}
	else if (full){
		play=1;
		record=0;
	}
	clipB=0;
	xtrig=0;
}

}


if (inlet_stop>0){
	prevplay=play;
	play=0;
	record=0;
	wait=0;
	ntrig=0;
	xtrig=0;
	clipB=0;
}


if ((clear>0)&&!ntrig){
	ntrig=1;
	attr_table.array[clearslot + attr_buttonoffset]=__SSAT(0,28)>>attr_table.GAIN;
	if (clipslot==clearslot){
		play=0;
		record=0;
		wait=0;
		zwait=0;
	}
}
else if(!(clear)) {ntrig=0;}



//





outlet_play=play;


outlet_wait=wait;
outlet_rec=record;


//playback
if ((play>0)&&!playtrig){
	playtrig=1;
	vcount=0;
}
if (!(play>0)) {playtrig=0;}
outletrectrig=0;
if ((record>0)&&!recordtrig){
	recordtrig=1;
	outletrectrig=1;
}


if (!(record>0)) {recordtrig=0;}

if ((!(record>0))&&!recofftrig){
	attr_table.array[offset]=__SSAT(bar_record,28)>>attr_table.GAIN;
	zwait=1;
	recofftrig=1;
}

//reset
if (record>0){recofftrig=0;}

//barclocks
if ((inlet_pulse>0) && !ctrig) {
   count += 1; 
   if (count>=attr_barcount) 
   {
   	count = attr_barcount;
   }
   if ((count==(inlet_barcount))&&(record>0)){wait=1;}
   ctrig=1;
}
else if (!(inlet_pulse>0)) ctrig=0;

bar_record=(count+1)<<21;
if ((outletrectrig>0) && !rtrig) {count=0; rtrig = 1;}
else if (!(outletrectrig>0)) rtrig=0;



//barlength=recorded
maxbar=(attr_table.array[__USAT(offset,attr_table.LENGTHPOW)]<<attr_table.GAIN)>>21;
//play bar counter
if ((inlet_pulseplay>0) && !vtrig) {
   vcount += 1; if ((vcount>(maxbar))||(vcount>(16))) {
   	vcount = 1; 
   	if ((play>0)&&(!(record>0))){
   	nplaytrig=1;
   	}
   }
   vtrig=1;
}
else if (!(inlet_pulseplay>0)) vtrig=0;
//start
if ((inlet_start>0) && !vr2trig) {vcount=1; vr2trig = 1; nplaytrig=1; nrectrig=1;}
else if (!(inlet_start>0)) vr2trig=0;
//reset vcount
if (vcount>(maxbar)){vcount=1;}

/////////////
cloffset=(attr_buttonoffset+8)+(attr_total*clearslot);


speed = 16 << 4;
src = cloffset;
range = (attr_total);
block  = (range / speed) * speed;

if ((clear)&& (!nclear)){ nclear= 1;i = 0;rclear = 0;}
if ((i == attr_total) && (!clear)) {nclear= 0;i = 0;}


//copy n chunks of size 'speed'
if (nclear && (i < block)){ 
	{ 
  for(ii=0;ii<speed;ii++)
  attr_table.array[(i + ii + src)]= (( attr_table.array[(i + ii + src)] + (attr_table.array[(i + ii + src)] * 0)) * (0));
  }
  i += speed;	
}

//copy what's left
if (i == block) rclear = 1; 

if ((ntrig && rclear) && (i < (attr_total))){ 
	attr_table.array[(i + src)]= (( attr_table.array[(i + src)] + (attr_table.array[(i + src)] * 0)) * (0));
   i += 1;  
 }
//////////////////////////////


outlet_clipslot=clipslot;
outlet_cliptrigger=clip;
outlet_clearslot=clearslot;
outlet_cleartrigger=clear;


outlet_nrectrig=nrectrig;
outlet_nplaytrig=nplaytrig;]]></code.krate>
         <code.midihandler><![CDATA[if ((status == MIDI_NOTE_ON + 0)&&(data2))
	{
		note=data1;
		trigger=1;
	}
if ((status == MIDI_NOTE_ON + 0)&&(!data2))
	{trigger=0;
	}]]></code.midihandler>
      </object>
   </patchobj>
   <comment type="patch/comment" x="644" y="672" text="track 3"/>
   <comment type="patch/comment" x="1218" y="672" text="track 4"/>
   <comment type="patch/comment" x="98" y="686" text="in midi channel 0-15"/>
   <comment type="patch/comment" x="644" y="686" text="note off &amp; cc counter"/>
   <comment type="patch/comment" x="798" y="686" text="note on play counter"/>
   <comment type="patch/comment" x="924" y="686" text="noteoffshift counter"/>
   <comment type="patch/comment" x="1036" y="686" text="note on rec counter"/>
   <comment type="patch/comment" x="1218" y="686" text="note off &amp; cc counter"/>
   <comment type="patch/comment" x="1372" y="686" text="note on play counter"/>
   <comment type="patch/comment" x="1498" y="686" text="noteoffshift counter"/>
   <comment type="patch/comment" x="1610" y="686" text="note on rec counter"/>
   <comment type="patch/comment" x="42" y="700" text="need to set in polysubpatch too"/>
   <comment type="patch/comment" x="266" y="700" text="out  midi channel 0-15"/>
   <obj type="logic/counter" uuid="7a141ba82230e54e5f5cd12da5dbe5a74ba854a5" name="counter_9" x="644" y="700">
      <params>
         <int32 name="maximum" value="8192"/>
      </params>
      <attribs/>
   </obj>
   <obj type="logic/counter" uuid="7a141ba82230e54e5f5cd12da5dbe5a74ba854a5" name="counter_11" x="798" y="700">
      <params>
         <int32 name="maximum" value="256"/>
      </params>
      <attribs/>
   </obj>
   <obj type="logic/counter" uuid="7a141ba82230e54e5f5cd12da5dbe5a74ba854a5" name="counter_13" x="924" y="700">
      <params>
         <int32 name="maximum" value="16"/>
      </params>
      <attribs/>
   </obj>
   <obj type="logic/counter" uuid="7a141ba82230e54e5f5cd12da5dbe5a74ba854a5" name="counter_7" x="1036" y="700">
      <params>
         <int32 name="maximum" value="256"/>
      </params>
      <attribs/>
   </obj>
   <obj type="logic/counter" uuid="7a141ba82230e54e5f5cd12da5dbe5a74ba854a5" name="counter_10" x="1218" y="700">
      <params>
         <int32 name="maximum" value="8192"/>
      </params>
      <attribs/>
   </obj>
   <obj type="logic/counter" uuid="7a141ba82230e54e5f5cd12da5dbe5a74ba854a5" name="counter_12" x="1372" y="700">
      <params>
         <int32 name="maximum" value="256"/>
      </params>
      <attribs/>
   </obj>
   <obj type="logic/counter" uuid="7a141ba82230e54e5f5cd12da5dbe5a74ba854a5" name="counter_16" x="1498" y="700">
      <params>
         <int32 name="maximum" value="16"/>
      </params>
      <attribs/>
   </obj>
   <obj type="logic/counter" uuid="7a141ba82230e54e5f5cd12da5dbe5a74ba854a5" name="counter_8" x="1610" y="700">
      <params>
         <int32 name="maximum" value="256"/>
      </params>
      <attribs/>
   </obj>
   <obj type="ctrl/i" uuid="a3786816db6ea5bc6ac4193a5cccdb2c83b83496" name="i_5" x="98" y="714">
      <params>
         <int32 name="value" value="1"/>
      </params>
      <attribs/>
   </obj>
   <obj type="ctrl/i" uuid="a3786816db6ea5bc6ac4193a5cccdb2c83b83496" name="i_6" x="266" y="714">
      <params>
         <int32 name="value" value="4"/>
      </params>
      <attribs/>
   </obj>
   <comment type="patch/comment" x="98" y="784" text="track 3"/>
   <comment type="patch/comment" x="98" y="798" text="poly recorder"/>
   <comment type="patch/comment" x="224" y="798" text="track 3"/>
   <comment type="patch/comment" x="1162" y="798" text="track 3"/>
   <comment type="patch/comment" x="1302" y="798" text="track 3"/>
   <patcher type="patch/patcher" uuid="1a9a917e-9db4-42f4-bae7-8fa0a58f1ef7" name="patcher_2" x="98" y="812">
      <params/>
      <attribs>
         <combo attributeName="poly" selection="6"/>
         <combo attributeName="midichannel" selection="2"/>
         <combo attributeName="mididevice" selection="omni"/>
         <combo attributeName="midiport" selection="omni"/>
      </attribs>
      <subpatch appVersion="1.0.12">
         <patchobj type="patch/object" uuid="20502dcd-a0bc-49c2-ad5e-e405aac40702" name="polyindex_1" x="56" y="0">
            <params/>
            <attribs/>
            <object id="patch/object" uuid="20502dcd-a0bc-49c2-ad5e-e405aac40702">
               <sDescription>Outputs the voice index number from 0 to n-1. Only works in a polyphonic sub-patch!</sDescription>
               <author>Johannes Taelman</author>
               <license>BSD</license>
               <helpPatch>polyindex.axh</helpPatch>
               <inlets/>
               <outlets>
                  <int32.positive name="index" description="index from 0 to n-1"/>
               </outlets>
               <displays/>
               <params/>
               <attribs/>
               <includes/>
               <code.krate><![CDATA[outlet_index = parent->polyIndex;
]]></code.krate>
            </object>
         </patchobj>
         <obj type="patch/inlet i" uuid="f11927f00c59219df0c50f73056aa19f125540b7" name="channel" x="154" y="0">
            <params/>
            <attribs/>
         </obj>
         <obj type="patch/inlet i" uuid="f11927f00c59219df0c50f73056aa19f125540b7" name="offset" x="252" y="0">
            <params/>
            <attribs/>
         </obj>
         <obj type="patch/inlet b" uuid="3b0d3eacb5bb978cb05d1372aa2714d5a4790844" name="rec" x="364" y="0">
            <params/>
            <attribs/>
         </obj>
         <obj type="patch/inlet i" uuid="f11927f00c59219df0c50f73056aa19f125540b7" name="qstep" x="476" y="0">
            <params/>
            <attribs/>
         </obj>
         <obj type="patch/inlet i" uuid="f11927f00c59219df0c50f73056aa19f125540b7" name="steprec" x="560" y="0">
            <params/>
            <attribs/>
         </obj>
         <obj type="patch/inlet i" uuid="f11927f00c59219df0c50f73056aa19f125540b7" name="step" x="644" y="0">
            <params/>
            <attribs/>
         </obj>
         <obj type="patch/inlet i" uuid="f11927f00c59219df0c50f73056aa19f125540b7" name="stepunQ" x="728" y="0">
            <params/>
            <attribs/>
         </obj>
         <patchobj type="patch/object" uuid="a919ffab-f138-4bb2-9193-1455073b35ac" name="tablestore_7" x="812" y="0">
            <params/>
            <attribs>
               <objref attributeName="table" obj="../lcxl2"/>
               <spinner attributeName="seqlength" value="256"/>
            </attribs>
            <object id="patch/object" uuid="a919ffab-f138-4bb2-9193-1455073b35ac">
               <sDescription>writes and outputs 8 values to a table.</sDescription>
               <author>robert schirmer</author>
               <license>who cares</license>
               <inlets>
                  <int32 name="channel"/>
                  <bool32 name="rec"/>
                  <int32 name="polyphony"/>
                  <int32 name="offset" description="sets an offset for writing to the table"/>
                  <int32 name="steprec"/>
                  <int32 name="step"/>
                  <int32 name="stepunQ"/>
                  <int32 name="Qstep"/>
               </inlets>
               <outlets/>
               <displays/>
               <params/>
               <attribs>
                  <objref name="table"/>
                  <spinner name="seqlength" MinValue="1" MaxValue="10000" DefaultValue="0"/>
               </attribs>
               <includes/>
               <code.declaration><![CDATA[int channel;
int polyphony;
int innote;
int invel;
int inputnote;
int inputvel;
int inputnoteon;
int inputnoteoff;
int ingate;
int ingate2;
int inntrig;
int inytrig;
int op;
int Atrig;
int notecount;
int seqlength;
int seqlengthUNQ;
int off1;
int recoffset1g;
int voiceoffset;
int offset;
int offset1;
int totaloffset;
int offsetg;
int offset1g;
int etrig;
int early;
int earlyshift;
int offsetunQ1;
int offsetunQ1g;
int noteon;
int noteoff;
int ytrig;
int xtrig;
int prevsteprec;
int prevstep;
int prevstepunQ;
int prevx;
int prevy;
int Pnoteoff;
int Poffset;]]></code.declaration>
               <code.init><![CDATA[seqlengthUNQ=(attr_seqlength*32);
seqlength=attr_seqlength;
noteon=0;
notecount=0;
offsetg=offset;]]></code.init>
               <code.krate><![CDATA[off1= !inlet_rec;
channel=inlet_channel;
voiceoffset=seqlength+seqlength+seqlengthUNQ;
totaloffset=voiceoffset+voiceoffset;
offset=inlet_offset+(totaloffset*(inlet_polyphony));



inputnote = innote<<20;
inputvel= invel<<20;

if((ingate2)&&!inntrig){
inputnoteon=ingate2;
inntrig=1;}
else inputnoteon=0;
if (!ingate2){
inntrig=0;
}

if((!ingate)&&!inytrig){
inputnoteoff=64<<20;
inytrig=1;}
else inputnoteoff=0;
if (ingate){
inytrig=0;
}

ingate2=ingate;

if ((inputnoteon>0) && !Atrig) {op = !op; Atrig=1;}
if (!(inputnoteon>0)) Atrig=0;
notecount= op;


if (notecount){offsetg=offset;}
if (!notecount){offsetg=offset+voiceoffset;}


recoffset1g=(offsetg + (inlet_steprec));
offsetunQ1g=(offsetg + inlet_stepunQ);




//1
if (!off1){
if ((inputnoteon>0)&&(!ytrig))
{
attr_table.array[recoffset1g]=__SSAT(inputnote,28)>>attr_table.GAIN;
attr_table.array[recoffset1g + seqlength]=__SSAT(inputvel,28)>>attr_table.GAIN;
Pnoteoff=0;
if ((inlet_steprec!=inlet_step)&&!etrig) {
	
	earlyshift=(16-inlet_Qstep);
	etrig=1;
}
if ((inlet_steprec==inlet_step)&&!etrig) 
{
	
	earlyshift=(0-inlet_Qstep);
	etrig=1;
	//if (inlet_steprec==0)
	//{
	//	early=2;
	//}
}

//if (inlet_steprec==(seqlength-1)){early=2;}
prevy=inlet_steprec;
ytrig=1;
}
else if ((!(inputnoteon>0))&&(inlet_steprec!=prevy)){
	ytrig=0;
	
}


if ((inputnoteoff>0)&&(!xtrig))
{early=earlyshift;
	

		attr_table.array[offsetunQ1g + seqlength + seqlength + earlyshift]=__SSAT(inputnoteoff,28)>>attr_table.GAIN;
		Pnoteoff=1;
		//attr_table.array[recoffset1g]=__SSAT(inputnote,28)>>attr_table.GAIN;
	
etrig=0;
prevx=inlet_stepunQ;
xtrig=1;
}
else if ((!(inputnoteoff>0))&&(inlet_stepunQ!=prevx)){
	xtrig=0;
}


if ((offsetg!=Poffset)&&ingate){
	inputnoteoff=64<<20;
	attr_table.array[Poffset + prevstepunQ + seqlength + seqlength]=__SSAT(inputnoteoff,28)>>attr_table.GAIN;
	}

prevstep=inlet_step;
prevstepunQ=inlet_stepunQ;
prevsteprec=inlet_steprec;
Poffset=offsetg;
}



else if (off1)
{
	if (!Pnoteoff){
	inputnoteoff=64<<20;
	attr_table.array[offsetg + prevstepunQ + seqlength + seqlength + earlyshift]=__SSAT(inputnoteoff,28)>>attr_table.GAIN;Pnoteoff=1;}
inputnoteoff=0;
etrig=0;
ytrig=0;
xtrig=0;
op=0;
prevx=(-1);
prevy=(-1);
}]]></code.krate>
               <code.midihandler><![CDATA[if (status == MIDI_NOTE_ON + (channel)) {
  innote = data1;
  invel = data2;
  ingate=1;
  ingate2=0;
}
if (status == MIDI_NOTE_OFF + (channel)) {
	if (data1==(innote)){
		ingate=0;
	}
}]]></code.midihandler>
            </object>
         </patchobj>
         <nets>
            <net>
               <source obj="rec" outlet="inlet"/>
               <dest obj="tablestore_7" inlet="rec"/>
            </net>
            <net>
               <source obj="steprec" outlet="inlet"/>
               <dest obj="tablestore_7" inlet="steprec"/>
            </net>
            <net>
               <source obj="step" outlet="inlet"/>
               <dest obj="tablestore_7" inlet="step"/>
            </net>
            <net>
               <source obj="stepunQ" outlet="inlet"/>
               <dest obj="tablestore_7" inlet="stepunQ"/>
            </net>
            <net>
               <source obj="qstep" outlet="inlet"/>
               <dest obj="tablestore_7" inlet="Qstep"/>
            </net>
            <net>
               <source obj="offset" outlet="inlet"/>
               <dest obj="tablestore_7" inlet="offset"/>
            </net>
            <net>
               <source obj="polyindex_1" outlet="index"/>
               <dest obj="tablestore_7" inlet="polyphony"/>
            </net>
            <net>
               <source obj="channel" outlet="inlet"/>
               <dest obj="tablestore_7" inlet="channel"/>
            </net>
         </nets>
         <settings>
            <subpatchmode>polyphonic</subpatchmode>
            <MidiChannel>7</MidiChannel>
            <HasMidiChannelSelector>true</HasMidiChannelSelector>
            <NPresets>0</NPresets>
            <NPresetEntries>0</NPresetEntries>
            <NModulationSources>0</NModulationSources>
            <NModulationTargetsPerSource>0</NModulationTargetsPerSource>
         </settings>
         <notes><![CDATA[]]></notes>
         <windowPos>
            <x>-8</x>
            <y>-8</y>
            <width>1616</width>
            <height>876</height>
         </windowPos>
      </subpatch>
   </patcher>
   <comment type="patch/comment" x="224" y="812" text=" noteplay poly 1"/>
   <comment type="patch/comment" x="378" y="812" text=" noteplay poly 2"/>
   <comment type="patch/comment" x="532" y="812" text=" noteplay poly 3"/>
   <comment type="patch/comment" x="672" y="812" text=" noteplay poly 4"/>
   <comment type="patch/comment" x="840" y="812" text=" noteplay poly 5"/>
   <comment type="patch/comment" x="994" y="812" text=" noteplay poly 6"/>
   <comment type="patch/comment" x="1162" y="812" text="bend touch cc recorder"/>
   <comment type="patch/comment" x="1302" y="812" text="bend/touch.CC play"/>
   <patchobj type="patch/object" uuid="a919ffab-f138-4bb2-9193-1455073b35ac" name="tablestore_21" x="224" y="826">
      <params/>
      <attribs>
         <objref attributeName="table" obj="lcxl2"/>
         <spinner attributeName="seqlength" value="256"/>
         <combo attributeName="device" selection="din"/>
      </attribs>
      <object id="patch/object" uuid="a919ffab-f138-4bb2-9193-1455073b35ac">
         <sDescription>writes and outputs 8 values to a table.</sDescription>
         <author>robert schirmer</author>
         <license>who cares</license>
         <inlets>
            <int32 name="channel"/>
            <bool32 name="play"/>
            <int32 name="offset" description="sets an offset for writing to the table"/>
            <int32 name="step"/>
            <int32 name="stepunQ"/>
         </inlets>
         <outlets>
            <int32 name="totaloffset"/>
         </outlets>
         <displays/>
         <params/>
         <attribs>
            <objref name="table"/>
            <spinner name="seqlength" MinValue="1" MaxValue="10000" DefaultValue="0"/>
            <combo name="device">
               <MenuEntries>
                  <string>din</string>
                  <string>usb host port 1</string>
                  <string>usb host port 2</string>
                  <string>usb host port 3</string>
                  <string>usb host port 4</string>
                  <string>internal port 1</string>
                  <string>internal port 2</string>
                  <string>usb device port 1</string>
               </MenuEntries>
               <CEntries>
                  <string>MIDI_DEVICE_DIN, 1</string>
                  <string>MIDI_DEVICE_USB_HOST, 1</string>
                  <string>MIDI_DEVICE_USB_HOST, 2</string>
                  <string>MIDI_DEVICE_USB_HOST, 3</string>
                  <string>MIDI_DEVICE_USB_HOST, 4</string>
                  <string>MIDI_DEVICE_INTERNAL, 1</string>
                  <string>MIDI_DEVICE_INTERNAL, 2</string>
                  <string>MIDI_DEVICE_USB_DEVICE, 1</string>
               </CEntries>
            </combo>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[int prevchannel;
int steptrig;
int TntrigA;
int TntrigB;
int TlastnoteA;
int TlastnoteB;
int seqlength;
int seqlengthUNQ;
int voiceoffset;
int off1;
int offtrig;
int offset1;
int offsetunQ1;
int noteonA;
int noteoffA;
int noteA;
int holdnoteA;
int holdvelA;
int TnoteA;
int TvelA;
int TnoteonA;
int TnoteoffA;
int noteonB;
int noteoffB;
int noteB;
int holdnoteB;
int holdvelB;
int TnoteB;
int TvelB;
int TnoteonB;
int TnoteoffB;
int prevoffset;
int prevstep;
int prevstepunQ;]]></code.declaration>
         <code.init><![CDATA[noteonA=0;
seqlengthUNQ=(attr_seqlength*32);
seqlength=attr_seqlength;]]></code.init>
         <code.krate><![CDATA[off1= inlet_play;
if ((inlet_channel!=prevchannel)||(inlet_offset!=prevoffset)){
	if ((TntrigB>0)&&(TlastnoteB>0)){
	MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (prevchannel),TlastnoteB,__USAT(TvelB,7)); TntrigB=0;}
	if ((TntrigA>0)&&(TlastnoteA>0)){
	MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (prevchannel),TlastnoteA,__USAT(TvelA,7)); TntrigA=0;}
	prevchannel=inlet_channel;
}
//if (inlet_offset!=prevoffset){
//	if ((TntrigB>0)&&(TlastnoteB>0)){
//	MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (inlet_channel),TlastnoteB,__USAT(TvelB,7)); TntrigB=0;}
//	if ((TntrigA>0)&&(TlastnoteA>0)){
//	MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (inlet_channel),TlastnoteA,__USAT(TvelA,7)); TntrigA=0;}
//}

offset1=(inlet_offset + inlet_step);
offsetunQ1=(inlet_offset + inlet_stepunQ);
voiceoffset=(seqlength+seqlength+seqlengthUNQ);



//1
if (!off1){
TnoteA=0;
TvelA=0;
TnoteonA=0;
TnoteB=0;
TvelB=0;
TnoteonB=0;
if (offtrig==0){

if ((TntrigB>0)&&(TlastnoteB>0)){
MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (inlet_channel),TlastnoteB,__USAT(TvelB,7)); TntrigB=0;}
if ((TntrigA>0)&&(TlastnoteA>0)){
MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (inlet_channel),TlastnoteA,__USAT(TvelA,7)); TntrigA=0;}

offtrig=1;
}}





else if (off1)
{



	noteA= attr_table.array[__USAT((offset1),attr_table.LENGTHPOW)]<<attr_table.GAIN;
noteonA=attr_table.array[__USAT((offset1 + seqlength),attr_table.LENGTHPOW)]<<attr_table.GAIN;
noteoffA=attr_table.array[__USAT((offsetunQ1+ seqlength + seqlength),attr_table.LENGTHPOW)]<<attr_table.GAIN;
noteB= attr_table.array[__USAT((voiceoffset+ offset1),attr_table.LENGTHPOW)]<<attr_table.GAIN;
noteonB=attr_table.array[__USAT((voiceoffset+ offset1 + seqlength),attr_table.LENGTHPOW)]<<attr_table.GAIN;
noteoffB=attr_table.array[__USAT((voiceoffset+ offsetunQ1+ seqlength + seqlength),attr_table.LENGTHPOW)]<<attr_table.GAIN;


//voiceA*****************************************
//note
if ((inlet_step != prevstep )&&(noteA > (0) )) { 
     holdnoteA = noteA>>20;
     TnoteA = holdnoteA;
}
else {
	TnoteA = holdnoteA;
}

//vel
if ((inlet_step != prevstep )&&(noteonA> 0 )) { 
     holdvelA = noteonA>>20;
     TvelA = holdvelA;
}
else {
	TvelA = holdvelA;
}


if ((noteoffA>0)&&(inlet_stepunQ!=prevstepunQ)){
	TnoteoffA=1;}
else TnoteoffA=0;

if ((noteonA>0)&&(inlet_step!=prevstep)){
	TnoteonA=1;}
else TnoteonA=0;

//voiceB*****************************************
//note
if ((inlet_step != prevstep )&&(noteB > 0) ) { 
     holdnoteB = noteB>>20;
     TnoteB = holdnoteB;
}
else {
	TnoteB = holdnoteB;
}

//vel
if ((inlet_step != prevstep )&&(noteonB> 0 )) { 
     holdvelB = noteonB>>20;
     TvelB = holdvelB;
}
else {
	TvelB = holdvelB;
}


if ((noteoffB>0)&&(inlet_stepunQ!=prevstepunQ)){
	TnoteoffB=1;}
else TnoteoffB=0;

if ((noteonB>0)&&(inlet_step!=prevstep)){
	TnoteonB=1;}
else TnoteonB=0;


if ((TnoteonA>0) && !TntrigA) {
if ((TlastnoteB>0)&&TntrigB){	
MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (inlet_channel),TlastnoteB,__USAT(TvelB,7)); TntrigB=0;
}
MidiSend3((midi_device_t) attr_device, MIDI_NOTE_ON + (inlet_channel),TnoteA,TvelA);  TntrigA=1;
TlastnoteA = TnoteA;
}
if ((TnoteoffA>0) && TntrigA) {MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (inlet_channel),TlastnoteA,__USAT(TvelA,7)); TntrigA=0;}

if ((TnoteonB>0) && !TntrigB) {
if ((TlastnoteA>0)&&TntrigA){
MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (inlet_channel),TlastnoteA,__USAT(TvelA,7)); TntrigA=0;
}
MidiSend3((midi_device_t) attr_device, MIDI_NOTE_ON + (inlet_channel),TnoteB,TvelB);  TntrigB=1;
TlastnoteB = TnoteB;
}
if ((TnoteoffB>0) && TntrigB) {MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (inlet_channel),TlastnoteB,__USAT(TvelB,7)); TntrigB=0;}




offtrig=0;
}
prevoffset=inlet_offset;
prevstep=inlet_step;
prevstepunQ=inlet_stepunQ;
outlet_totaloffset=inlet_offset+voiceoffset+voiceoffset;]]></code.krate>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="a919ffab-f138-4bb2-9193-1455073b35ac" name="tablestore_22" x="378" y="826">
      <params/>
      <attribs>
         <objref attributeName="table" obj="lcxl2"/>
         <spinner attributeName="seqlength" value="256"/>
         <combo attributeName="device" selection="din"/>
      </attribs>
      <object id="patch/object" uuid="a919ffab-f138-4bb2-9193-1455073b35ac">
         <sDescription>writes and outputs 8 values to a table.</sDescription>
         <author>robert schirmer</author>
         <license>who cares</license>
         <inlets>
            <int32 name="channel"/>
            <bool32 name="play"/>
            <int32 name="offset" description="sets an offset for writing to the table"/>
            <int32 name="step"/>
            <int32 name="stepunQ"/>
         </inlets>
         <outlets>
            <int32 name="totaloffset"/>
         </outlets>
         <displays/>
         <params/>
         <attribs>
            <objref name="table"/>
            <spinner name="seqlength" MinValue="1" MaxValue="10000" DefaultValue="0"/>
            <combo name="device">
               <MenuEntries>
                  <string>din</string>
                  <string>usb host port 1</string>
                  <string>usb host port 2</string>
                  <string>usb host port 3</string>
                  <string>usb host port 4</string>
                  <string>internal port 1</string>
                  <string>internal port 2</string>
                  <string>usb device port 1</string>
               </MenuEntries>
               <CEntries>
                  <string>MIDI_DEVICE_DIN, 1</string>
                  <string>MIDI_DEVICE_USB_HOST, 1</string>
                  <string>MIDI_DEVICE_USB_HOST, 2</string>
                  <string>MIDI_DEVICE_USB_HOST, 3</string>
                  <string>MIDI_DEVICE_USB_HOST, 4</string>
                  <string>MIDI_DEVICE_INTERNAL, 1</string>
                  <string>MIDI_DEVICE_INTERNAL, 2</string>
                  <string>MIDI_DEVICE_USB_DEVICE, 1</string>
               </CEntries>
            </combo>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[int prevchannel;
int steptrig;
int TntrigA;
int TntrigB;
int TlastnoteA;
int TlastnoteB;
int seqlength;
int seqlengthUNQ;
int voiceoffset;
int off1;
int offtrig;
int offset1;
int offsetunQ1;
int noteonA;
int noteoffA;
int noteA;
int holdnoteA;
int holdvelA;
int TnoteA;
int TvelA;
int TnoteonA;
int TnoteoffA;
int noteonB;
int noteoffB;
int noteB;
int holdnoteB;
int holdvelB;
int TnoteB;
int TvelB;
int TnoteonB;
int TnoteoffB;
int prevoffset;
int prevstep;
int prevstepunQ;]]></code.declaration>
         <code.init><![CDATA[noteonA=0;
seqlengthUNQ=(attr_seqlength*32);
seqlength=attr_seqlength;]]></code.init>
         <code.krate><![CDATA[off1= inlet_play;
if ((inlet_channel!=prevchannel)||(inlet_offset!=prevoffset)){
	if ((TntrigB>0)&&(TlastnoteB>0)){
	MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (prevchannel),TlastnoteB,__USAT(TvelB,7)); TntrigB=0;}
	if ((TntrigA>0)&&(TlastnoteA>0)){
	MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (prevchannel),TlastnoteA,__USAT(TvelA,7)); TntrigA=0;}
	prevchannel=inlet_channel;
}
//if (inlet_offset!=prevoffset){
//	if ((TntrigB>0)&&(TlastnoteB>0)){
//	MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (inlet_channel),TlastnoteB,__USAT(TvelB,7)); TntrigB=0;}
//	if ((TntrigA>0)&&(TlastnoteA>0)){
//	MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (inlet_channel),TlastnoteA,__USAT(TvelA,7)); TntrigA=0;}
//}

offset1=(inlet_offset + inlet_step);
offsetunQ1=(inlet_offset + inlet_stepunQ);
voiceoffset=(seqlength+seqlength+seqlengthUNQ);



//1
if (!off1){
TnoteA=0;
TvelA=0;
TnoteonA=0;
TnoteB=0;
TvelB=0;
TnoteonB=0;
if (offtrig==0){

if ((TntrigB>0)&&(TlastnoteB>0)){
MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (inlet_channel),TlastnoteB,__USAT(TvelB,7)); TntrigB=0;}
if ((TntrigA>0)&&(TlastnoteA>0)){
MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (inlet_channel),TlastnoteA,__USAT(TvelA,7)); TntrigA=0;}

offtrig=1;
}}





else if (off1)
{



	noteA= attr_table.array[__USAT((offset1),attr_table.LENGTHPOW)]<<attr_table.GAIN;
noteonA=attr_table.array[__USAT((offset1 + seqlength),attr_table.LENGTHPOW)]<<attr_table.GAIN;
noteoffA=attr_table.array[__USAT((offsetunQ1+ seqlength + seqlength),attr_table.LENGTHPOW)]<<attr_table.GAIN;
noteB= attr_table.array[__USAT((voiceoffset+ offset1),attr_table.LENGTHPOW)]<<attr_table.GAIN;
noteonB=attr_table.array[__USAT((voiceoffset+ offset1 + seqlength),attr_table.LENGTHPOW)]<<attr_table.GAIN;
noteoffB=attr_table.array[__USAT((voiceoffset+ offsetunQ1+ seqlength + seqlength),attr_table.LENGTHPOW)]<<attr_table.GAIN;


//voiceA*****************************************
//note
if ((inlet_step != prevstep )&&(noteA > (0) )) { 
     holdnoteA = noteA>>20;
     TnoteA = holdnoteA;
}
else {
	TnoteA = holdnoteA;
}

//vel
if ((inlet_step != prevstep )&&(noteonA> 0 )) { 
     holdvelA = noteonA>>20;
     TvelA = holdvelA;
}
else {
	TvelA = holdvelA;
}


if ((noteoffA>0)&&(inlet_stepunQ!=prevstepunQ)){
	TnoteoffA=1;}
else TnoteoffA=0;

if ((noteonA>0)&&(inlet_step!=prevstep)){
	TnoteonA=1;}
else TnoteonA=0;

//voiceB*****************************************
//note
if ((inlet_step != prevstep )&&(noteB > 0) ) { 
     holdnoteB = noteB>>20;
     TnoteB = holdnoteB;
}
else {
	TnoteB = holdnoteB;
}

//vel
if ((inlet_step != prevstep )&&(noteonB> 0 )) { 
     holdvelB = noteonB>>20;
     TvelB = holdvelB;
}
else {
	TvelB = holdvelB;
}


if ((noteoffB>0)&&(inlet_stepunQ!=prevstepunQ)){
	TnoteoffB=1;}
else TnoteoffB=0;

if ((noteonB>0)&&(inlet_step!=prevstep)){
	TnoteonB=1;}
else TnoteonB=0;


if ((TnoteonA>0) && !TntrigA) {
if ((TlastnoteB>0)&&TntrigB){	
MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (inlet_channel),TlastnoteB,__USAT(TvelB,7)); TntrigB=0;
}
MidiSend3((midi_device_t) attr_device, MIDI_NOTE_ON + (inlet_channel),TnoteA,TvelA);  TntrigA=1;
TlastnoteA = TnoteA;
}
if ((TnoteoffA>0) && TntrigA) {MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (inlet_channel),TlastnoteA,__USAT(TvelA,7)); TntrigA=0;}

if ((TnoteonB>0) && !TntrigB) {
if ((TlastnoteA>0)&&TntrigA){
MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (inlet_channel),TlastnoteA,__USAT(TvelA,7)); TntrigA=0;
}
MidiSend3((midi_device_t) attr_device, MIDI_NOTE_ON + (inlet_channel),TnoteB,TvelB);  TntrigB=1;
TlastnoteB = TnoteB;
}
if ((TnoteoffB>0) && TntrigB) {MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (inlet_channel),TlastnoteB,__USAT(TvelB,7)); TntrigB=0;}




offtrig=0;
}
prevoffset=inlet_offset;
prevstep=inlet_step;
prevstepunQ=inlet_stepunQ;
outlet_totaloffset=inlet_offset+voiceoffset+voiceoffset;]]></code.krate>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="a919ffab-f138-4bb2-9193-1455073b35ac" name="tablestore_23" x="532" y="826">
      <params/>
      <attribs>
         <objref attributeName="table" obj="lcxl2"/>
         <spinner attributeName="seqlength" value="256"/>
         <combo attributeName="device" selection="din"/>
      </attribs>
      <object id="patch/object" uuid="a919ffab-f138-4bb2-9193-1455073b35ac">
         <sDescription>writes and outputs 8 values to a table.</sDescription>
         <author>robert schirmer</author>
         <license>who cares</license>
         <inlets>
            <int32 name="channel"/>
            <bool32 name="play"/>
            <int32 name="offset" description="sets an offset for writing to the table"/>
            <int32 name="step"/>
            <int32 name="stepunQ"/>
         </inlets>
         <outlets>
            <int32 name="totaloffset"/>
         </outlets>
         <displays/>
         <params/>
         <attribs>
            <objref name="table"/>
            <spinner name="seqlength" MinValue="1" MaxValue="10000" DefaultValue="0"/>
            <combo name="device">
               <MenuEntries>
                  <string>din</string>
                  <string>usb host port 1</string>
                  <string>usb host port 2</string>
                  <string>usb host port 3</string>
                  <string>usb host port 4</string>
                  <string>internal port 1</string>
                  <string>internal port 2</string>
                  <string>usb device port 1</string>
               </MenuEntries>
               <CEntries>
                  <string>MIDI_DEVICE_DIN, 1</string>
                  <string>MIDI_DEVICE_USB_HOST, 1</string>
                  <string>MIDI_DEVICE_USB_HOST, 2</string>
                  <string>MIDI_DEVICE_USB_HOST, 3</string>
                  <string>MIDI_DEVICE_USB_HOST, 4</string>
                  <string>MIDI_DEVICE_INTERNAL, 1</string>
                  <string>MIDI_DEVICE_INTERNAL, 2</string>
                  <string>MIDI_DEVICE_USB_DEVICE, 1</string>
               </CEntries>
            </combo>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[int prevchannel;
int steptrig;
int TntrigA;
int TntrigB;
int TlastnoteA;
int TlastnoteB;
int seqlength;
int seqlengthUNQ;
int voiceoffset;
int off1;
int offtrig;
int offset1;
int offsetunQ1;
int noteonA;
int noteoffA;
int noteA;
int holdnoteA;
int holdvelA;
int TnoteA;
int TvelA;
int TnoteonA;
int TnoteoffA;
int noteonB;
int noteoffB;
int noteB;
int holdnoteB;
int holdvelB;
int TnoteB;
int TvelB;
int TnoteonB;
int TnoteoffB;
int prevoffset;
int prevstep;
int prevstepunQ;]]></code.declaration>
         <code.init><![CDATA[noteonA=0;
seqlengthUNQ=(attr_seqlength*32);
seqlength=attr_seqlength;]]></code.init>
         <code.krate><![CDATA[off1= inlet_play;
if ((inlet_channel!=prevchannel)||(inlet_offset!=prevoffset)){
	if ((TntrigB>0)&&(TlastnoteB>0)){
	MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (prevchannel),TlastnoteB,__USAT(TvelB,7)); TntrigB=0;}
	if ((TntrigA>0)&&(TlastnoteA>0)){
	MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (prevchannel),TlastnoteA,__USAT(TvelA,7)); TntrigA=0;}
	prevchannel=inlet_channel;
}
//if (inlet_offset!=prevoffset){
//	if ((TntrigB>0)&&(TlastnoteB>0)){
//	MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (inlet_channel),TlastnoteB,__USAT(TvelB,7)); TntrigB=0;}
//	if ((TntrigA>0)&&(TlastnoteA>0)){
//	MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (inlet_channel),TlastnoteA,__USAT(TvelA,7)); TntrigA=0;}
//}

offset1=(inlet_offset + inlet_step);
offsetunQ1=(inlet_offset + inlet_stepunQ);
voiceoffset=(seqlength+seqlength+seqlengthUNQ);



//1
if (!off1){
TnoteA=0;
TvelA=0;
TnoteonA=0;
TnoteB=0;
TvelB=0;
TnoteonB=0;
if (offtrig==0){

if ((TntrigB>0)&&(TlastnoteB>0)){
MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (inlet_channel),TlastnoteB,__USAT(TvelB,7)); TntrigB=0;}
if ((TntrigA>0)&&(TlastnoteA>0)){
MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (inlet_channel),TlastnoteA,__USAT(TvelA,7)); TntrigA=0;}

offtrig=1;
}}





else if (off1)
{



	noteA= attr_table.array[__USAT((offset1),attr_table.LENGTHPOW)]<<attr_table.GAIN;
noteonA=attr_table.array[__USAT((offset1 + seqlength),attr_table.LENGTHPOW)]<<attr_table.GAIN;
noteoffA=attr_table.array[__USAT((offsetunQ1+ seqlength + seqlength),attr_table.LENGTHPOW)]<<attr_table.GAIN;
noteB= attr_table.array[__USAT((voiceoffset+ offset1),attr_table.LENGTHPOW)]<<attr_table.GAIN;
noteonB=attr_table.array[__USAT((voiceoffset+ offset1 + seqlength),attr_table.LENGTHPOW)]<<attr_table.GAIN;
noteoffB=attr_table.array[__USAT((voiceoffset+ offsetunQ1+ seqlength + seqlength),attr_table.LENGTHPOW)]<<attr_table.GAIN;


//voiceA*****************************************
//note
if ((inlet_step != prevstep )&&(noteA > (0) )) { 
     holdnoteA = noteA>>20;
     TnoteA = holdnoteA;
}
else {
	TnoteA = holdnoteA;
}

//vel
if ((inlet_step != prevstep )&&(noteonA> 0 )) { 
     holdvelA = noteonA>>20;
     TvelA = holdvelA;
}
else {
	TvelA = holdvelA;
}


if ((noteoffA>0)&&(inlet_stepunQ!=prevstepunQ)){
	TnoteoffA=1;}
else TnoteoffA=0;

if ((noteonA>0)&&(inlet_step!=prevstep)){
	TnoteonA=1;}
else TnoteonA=0;

//voiceB*****************************************
//note
if ((inlet_step != prevstep )&&(noteB > 0) ) { 
     holdnoteB = noteB>>20;
     TnoteB = holdnoteB;
}
else {
	TnoteB = holdnoteB;
}

//vel
if ((inlet_step != prevstep )&&(noteonB> 0 )) { 
     holdvelB = noteonB>>20;
     TvelB = holdvelB;
}
else {
	TvelB = holdvelB;
}


if ((noteoffB>0)&&(inlet_stepunQ!=prevstepunQ)){
	TnoteoffB=1;}
else TnoteoffB=0;

if ((noteonB>0)&&(inlet_step!=prevstep)){
	TnoteonB=1;}
else TnoteonB=0;


if ((TnoteonA>0) && !TntrigA) {
if ((TlastnoteB>0)&&TntrigB){	
MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (inlet_channel),TlastnoteB,__USAT(TvelB,7)); TntrigB=0;
}
MidiSend3((midi_device_t) attr_device, MIDI_NOTE_ON + (inlet_channel),TnoteA,TvelA);  TntrigA=1;
TlastnoteA = TnoteA;
}
if ((TnoteoffA>0) && TntrigA) {MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (inlet_channel),TlastnoteA,__USAT(TvelA,7)); TntrigA=0;}

if ((TnoteonB>0) && !TntrigB) {
if ((TlastnoteA>0)&&TntrigA){
MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (inlet_channel),TlastnoteA,__USAT(TvelA,7)); TntrigA=0;
}
MidiSend3((midi_device_t) attr_device, MIDI_NOTE_ON + (inlet_channel),TnoteB,TvelB);  TntrigB=1;
TlastnoteB = TnoteB;
}
if ((TnoteoffB>0) && TntrigB) {MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (inlet_channel),TlastnoteB,__USAT(TvelB,7)); TntrigB=0;}




offtrig=0;
}
prevoffset=inlet_offset;
prevstep=inlet_step;
prevstepunQ=inlet_stepunQ;
outlet_totaloffset=inlet_offset+voiceoffset+voiceoffset;]]></code.krate>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="a919ffab-f138-4bb2-9193-1455073b35ac" name="tablestore_24" x="672" y="826">
      <params/>
      <attribs>
         <objref attributeName="table" obj="lcxl2"/>
         <spinner attributeName="seqlength" value="256"/>
         <combo attributeName="device" selection="din"/>
      </attribs>
      <object id="patch/object" uuid="a919ffab-f138-4bb2-9193-1455073b35ac">
         <sDescription>writes and outputs 8 values to a table.</sDescription>
         <author>robert schirmer</author>
         <license>who cares</license>
         <inlets>
            <int32 name="channel"/>
            <bool32 name="play"/>
            <int32 name="offset" description="sets an offset for writing to the table"/>
            <int32 name="step"/>
            <int32 name="stepunQ"/>
         </inlets>
         <outlets>
            <int32 name="totaloffset"/>
         </outlets>
         <displays/>
         <params/>
         <attribs>
            <objref name="table"/>
            <spinner name="seqlength" MinValue="1" MaxValue="10000" DefaultValue="0"/>
            <combo name="device">
               <MenuEntries>
                  <string>din</string>
                  <string>usb host port 1</string>
                  <string>usb host port 2</string>
                  <string>usb host port 3</string>
                  <string>usb host port 4</string>
                  <string>internal port 1</string>
                  <string>internal port 2</string>
                  <string>usb device port 1</string>
               </MenuEntries>
               <CEntries>
                  <string>MIDI_DEVICE_DIN, 1</string>
                  <string>MIDI_DEVICE_USB_HOST, 1</string>
                  <string>MIDI_DEVICE_USB_HOST, 2</string>
                  <string>MIDI_DEVICE_USB_HOST, 3</string>
                  <string>MIDI_DEVICE_USB_HOST, 4</string>
                  <string>MIDI_DEVICE_INTERNAL, 1</string>
                  <string>MIDI_DEVICE_INTERNAL, 2</string>
                  <string>MIDI_DEVICE_USB_DEVICE, 1</string>
               </CEntries>
            </combo>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[int prevchannel;
int steptrig;
int TntrigA;
int TntrigB;
int TlastnoteA;
int TlastnoteB;
int seqlength;
int seqlengthUNQ;
int voiceoffset;
int off1;
int offtrig;
int offset1;
int offsetunQ1;
int noteonA;
int noteoffA;
int noteA;
int holdnoteA;
int holdvelA;
int TnoteA;
int TvelA;
int TnoteonA;
int TnoteoffA;
int noteonB;
int noteoffB;
int noteB;
int holdnoteB;
int holdvelB;
int TnoteB;
int TvelB;
int TnoteonB;
int TnoteoffB;
int prevoffset;
int prevstep;
int prevstepunQ;]]></code.declaration>
         <code.init><![CDATA[noteonA=0;
seqlengthUNQ=(attr_seqlength*32);
seqlength=attr_seqlength;]]></code.init>
         <code.krate><![CDATA[off1= inlet_play;
if ((inlet_channel!=prevchannel)||(inlet_offset!=prevoffset)){
	if ((TntrigB>0)&&(TlastnoteB>0)){
	MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (prevchannel),TlastnoteB,__USAT(TvelB,7)); TntrigB=0;}
	if ((TntrigA>0)&&(TlastnoteA>0)){
	MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (prevchannel),TlastnoteA,__USAT(TvelA,7)); TntrigA=0;}
	prevchannel=inlet_channel;
}
//if (inlet_offset!=prevoffset){
//	if ((TntrigB>0)&&(TlastnoteB>0)){
//	MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (inlet_channel),TlastnoteB,__USAT(TvelB,7)); TntrigB=0;}
//	if ((TntrigA>0)&&(TlastnoteA>0)){
//	MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (inlet_channel),TlastnoteA,__USAT(TvelA,7)); TntrigA=0;}
//}

offset1=(inlet_offset + inlet_step);
offsetunQ1=(inlet_offset + inlet_stepunQ);
voiceoffset=(seqlength+seqlength+seqlengthUNQ);



//1
if (!off1){
TnoteA=0;
TvelA=0;
TnoteonA=0;
TnoteB=0;
TvelB=0;
TnoteonB=0;
if (offtrig==0){

if ((TntrigB>0)&&(TlastnoteB>0)){
MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (inlet_channel),TlastnoteB,__USAT(TvelB,7)); TntrigB=0;}
if ((TntrigA>0)&&(TlastnoteA>0)){
MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (inlet_channel),TlastnoteA,__USAT(TvelA,7)); TntrigA=0;}

offtrig=1;
}}





else if (off1)
{



	noteA= attr_table.array[__USAT((offset1),attr_table.LENGTHPOW)]<<attr_table.GAIN;
noteonA=attr_table.array[__USAT((offset1 + seqlength),attr_table.LENGTHPOW)]<<attr_table.GAIN;
noteoffA=attr_table.array[__USAT((offsetunQ1+ seqlength + seqlength),attr_table.LENGTHPOW)]<<attr_table.GAIN;
noteB= attr_table.array[__USAT((voiceoffset+ offset1),attr_table.LENGTHPOW)]<<attr_table.GAIN;
noteonB=attr_table.array[__USAT((voiceoffset+ offset1 + seqlength),attr_table.LENGTHPOW)]<<attr_table.GAIN;
noteoffB=attr_table.array[__USAT((voiceoffset+ offsetunQ1+ seqlength + seqlength),attr_table.LENGTHPOW)]<<attr_table.GAIN;


//voiceA*****************************************
//note
if ((inlet_step != prevstep )&&(noteA > (0) )) { 
     holdnoteA = noteA>>20;
     TnoteA = holdnoteA;
}
else {
	TnoteA = holdnoteA;
}

//vel
if ((inlet_step != prevstep )&&(noteonA> 0 )) { 
     holdvelA = noteonA>>20;
     TvelA = holdvelA;
}
else {
	TvelA = holdvelA;
}


if ((noteoffA>0)&&(inlet_stepunQ!=prevstepunQ)){
	TnoteoffA=1;}
else TnoteoffA=0;

if ((noteonA>0)&&(inlet_step!=prevstep)){
	TnoteonA=1;}
else TnoteonA=0;

//voiceB*****************************************
//note
if ((inlet_step != prevstep )&&(noteB > 0) ) { 
     holdnoteB = noteB>>20;
     TnoteB = holdnoteB;
}
else {
	TnoteB = holdnoteB;
}

//vel
if ((inlet_step != prevstep )&&(noteonB> 0 )) { 
     holdvelB = noteonB>>20;
     TvelB = holdvelB;
}
else {
	TvelB = holdvelB;
}


if ((noteoffB>0)&&(inlet_stepunQ!=prevstepunQ)){
	TnoteoffB=1;}
else TnoteoffB=0;

if ((noteonB>0)&&(inlet_step!=prevstep)){
	TnoteonB=1;}
else TnoteonB=0;


if ((TnoteonA>0) && !TntrigA) {
if ((TlastnoteB>0)&&TntrigB){	
MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (inlet_channel),TlastnoteB,__USAT(TvelB,7)); TntrigB=0;
}
MidiSend3((midi_device_t) attr_device, MIDI_NOTE_ON + (inlet_channel),TnoteA,TvelA);  TntrigA=1;
TlastnoteA = TnoteA;
}
if ((TnoteoffA>0) && TntrigA) {MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (inlet_channel),TlastnoteA,__USAT(TvelA,7)); TntrigA=0;}

if ((TnoteonB>0) && !TntrigB) {
if ((TlastnoteA>0)&&TntrigA){
MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (inlet_channel),TlastnoteA,__USAT(TvelA,7)); TntrigA=0;
}
MidiSend3((midi_device_t) attr_device, MIDI_NOTE_ON + (inlet_channel),TnoteB,TvelB);  TntrigB=1;
TlastnoteB = TnoteB;
}
if ((TnoteoffB>0) && TntrigB) {MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (inlet_channel),TlastnoteB,__USAT(TvelB,7)); TntrigB=0;}




offtrig=0;
}
prevoffset=inlet_offset;
prevstep=inlet_step;
prevstepunQ=inlet_stepunQ;
outlet_totaloffset=inlet_offset+voiceoffset+voiceoffset;]]></code.krate>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="a919ffab-f138-4bb2-9193-1455073b35ac" name="tablestore_25" x="840" y="826">
      <params/>
      <attribs>
         <objref attributeName="table" obj="lcxl2"/>
         <spinner attributeName="seqlength" value="256"/>
         <combo attributeName="device" selection="din"/>
      </attribs>
      <object id="patch/object" uuid="a919ffab-f138-4bb2-9193-1455073b35ac">
         <sDescription>writes and outputs 8 values to a table.</sDescription>
         <author>robert schirmer</author>
         <license>who cares</license>
         <inlets>
            <int32 name="channel"/>
            <bool32 name="play"/>
            <int32 name="offset" description="sets an offset for writing to the table"/>
            <int32 name="step"/>
            <int32 name="stepunQ"/>
         </inlets>
         <outlets>
            <int32 name="totaloffset"/>
         </outlets>
         <displays/>
         <params/>
         <attribs>
            <objref name="table"/>
            <spinner name="seqlength" MinValue="1" MaxValue="10000" DefaultValue="0"/>
            <combo name="device">
               <MenuEntries>
                  <string>din</string>
                  <string>usb host port 1</string>
                  <string>usb host port 2</string>
                  <string>usb host port 3</string>
                  <string>usb host port 4</string>
                  <string>internal port 1</string>
                  <string>internal port 2</string>
                  <string>usb device port 1</string>
               </MenuEntries>
               <CEntries>
                  <string>MIDI_DEVICE_DIN, 1</string>
                  <string>MIDI_DEVICE_USB_HOST, 1</string>
                  <string>MIDI_DEVICE_USB_HOST, 2</string>
                  <string>MIDI_DEVICE_USB_HOST, 3</string>
                  <string>MIDI_DEVICE_USB_HOST, 4</string>
                  <string>MIDI_DEVICE_INTERNAL, 1</string>
                  <string>MIDI_DEVICE_INTERNAL, 2</string>
                  <string>MIDI_DEVICE_USB_DEVICE, 1</string>
               </CEntries>
            </combo>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[int prevchannel;
int steptrig;
int TntrigA;
int TntrigB;
int TlastnoteA;
int TlastnoteB;
int seqlength;
int seqlengthUNQ;
int voiceoffset;
int off1;
int offtrig;
int offset1;
int offsetunQ1;
int noteonA;
int noteoffA;
int noteA;
int holdnoteA;
int holdvelA;
int TnoteA;
int TvelA;
int TnoteonA;
int TnoteoffA;
int noteonB;
int noteoffB;
int noteB;
int holdnoteB;
int holdvelB;
int TnoteB;
int TvelB;
int TnoteonB;
int TnoteoffB;
int prevoffset;
int prevstep;
int prevstepunQ;]]></code.declaration>
         <code.init><![CDATA[noteonA=0;
seqlengthUNQ=(attr_seqlength*32);
seqlength=attr_seqlength;]]></code.init>
         <code.krate><![CDATA[off1= inlet_play;
if ((inlet_channel!=prevchannel)||(inlet_offset!=prevoffset)){
	if ((TntrigB>0)&&(TlastnoteB>0)){
	MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (prevchannel),TlastnoteB,__USAT(TvelB,7)); TntrigB=0;}
	if ((TntrigA>0)&&(TlastnoteA>0)){
	MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (prevchannel),TlastnoteA,__USAT(TvelA,7)); TntrigA=0;}
	prevchannel=inlet_channel;
}
//if (inlet_offset!=prevoffset){
//	if ((TntrigB>0)&&(TlastnoteB>0)){
//	MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (inlet_channel),TlastnoteB,__USAT(TvelB,7)); TntrigB=0;}
//	if ((TntrigA>0)&&(TlastnoteA>0)){
//	MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (inlet_channel),TlastnoteA,__USAT(TvelA,7)); TntrigA=0;}
//}

offset1=(inlet_offset + inlet_step);
offsetunQ1=(inlet_offset + inlet_stepunQ);
voiceoffset=(seqlength+seqlength+seqlengthUNQ);



//1
if (!off1){
TnoteA=0;
TvelA=0;
TnoteonA=0;
TnoteB=0;
TvelB=0;
TnoteonB=0;
if (offtrig==0){

if ((TntrigB>0)&&(TlastnoteB>0)){
MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (inlet_channel),TlastnoteB,__USAT(TvelB,7)); TntrigB=0;}
if ((TntrigA>0)&&(TlastnoteA>0)){
MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (inlet_channel),TlastnoteA,__USAT(TvelA,7)); TntrigA=0;}

offtrig=1;
}}





else if (off1)
{



	noteA= attr_table.array[__USAT((offset1),attr_table.LENGTHPOW)]<<attr_table.GAIN;
noteonA=attr_table.array[__USAT((offset1 + seqlength),attr_table.LENGTHPOW)]<<attr_table.GAIN;
noteoffA=attr_table.array[__USAT((offsetunQ1+ seqlength + seqlength),attr_table.LENGTHPOW)]<<attr_table.GAIN;
noteB= attr_table.array[__USAT((voiceoffset+ offset1),attr_table.LENGTHPOW)]<<attr_table.GAIN;
noteonB=attr_table.array[__USAT((voiceoffset+ offset1 + seqlength),attr_table.LENGTHPOW)]<<attr_table.GAIN;
noteoffB=attr_table.array[__USAT((voiceoffset+ offsetunQ1+ seqlength + seqlength),attr_table.LENGTHPOW)]<<attr_table.GAIN;


//voiceA*****************************************
//note
if ((inlet_step != prevstep )&&(noteA > (0) )) { 
     holdnoteA = noteA>>20;
     TnoteA = holdnoteA;
}
else {
	TnoteA = holdnoteA;
}

//vel
if ((inlet_step != prevstep )&&(noteonA> 0 )) { 
     holdvelA = noteonA>>20;
     TvelA = holdvelA;
}
else {
	TvelA = holdvelA;
}


if ((noteoffA>0)&&(inlet_stepunQ!=prevstepunQ)){
	TnoteoffA=1;}
else TnoteoffA=0;

if ((noteonA>0)&&(inlet_step!=prevstep)){
	TnoteonA=1;}
else TnoteonA=0;

//voiceB*****************************************
//note
if ((inlet_step != prevstep )&&(noteB > 0) ) { 
     holdnoteB = noteB>>20;
     TnoteB = holdnoteB;
}
else {
	TnoteB = holdnoteB;
}

//vel
if ((inlet_step != prevstep )&&(noteonB> 0 )) { 
     holdvelB = noteonB>>20;
     TvelB = holdvelB;
}
else {
	TvelB = holdvelB;
}


if ((noteoffB>0)&&(inlet_stepunQ!=prevstepunQ)){
	TnoteoffB=1;}
else TnoteoffB=0;

if ((noteonB>0)&&(inlet_step!=prevstep)){
	TnoteonB=1;}
else TnoteonB=0;


if ((TnoteonA>0) && !TntrigA) {
if ((TlastnoteB>0)&&TntrigB){	
MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (inlet_channel),TlastnoteB,__USAT(TvelB,7)); TntrigB=0;
}
MidiSend3((midi_device_t) attr_device, MIDI_NOTE_ON + (inlet_channel),TnoteA,TvelA);  TntrigA=1;
TlastnoteA = TnoteA;
}
if ((TnoteoffA>0) && TntrigA) {MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (inlet_channel),TlastnoteA,__USAT(TvelA,7)); TntrigA=0;}

if ((TnoteonB>0) && !TntrigB) {
if ((TlastnoteA>0)&&TntrigA){
MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (inlet_channel),TlastnoteA,__USAT(TvelA,7)); TntrigA=0;
}
MidiSend3((midi_device_t) attr_device, MIDI_NOTE_ON + (inlet_channel),TnoteB,TvelB);  TntrigB=1;
TlastnoteB = TnoteB;
}
if ((TnoteoffB>0) && TntrigB) {MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (inlet_channel),TlastnoteB,__USAT(TvelB,7)); TntrigB=0;}




offtrig=0;
}
prevoffset=inlet_offset;
prevstep=inlet_step;
prevstepunQ=inlet_stepunQ;
outlet_totaloffset=inlet_offset+voiceoffset+voiceoffset;]]></code.krate>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="a919ffab-f138-4bb2-9193-1455073b35ac" name="tablestore_26" x="994" y="826">
      <params/>
      <attribs>
         <objref attributeName="table" obj="lcxl2"/>
         <spinner attributeName="seqlength" value="256"/>
         <combo attributeName="device" selection="din"/>
      </attribs>
      <object id="patch/object" uuid="a919ffab-f138-4bb2-9193-1455073b35ac">
         <sDescription>writes and outputs 8 values to a table.</sDescription>
         <author>robert schirmer</author>
         <license>who cares</license>
         <inlets>
            <int32 name="channel"/>
            <bool32 name="play"/>
            <int32 name="offset" description="sets an offset for writing to the table"/>
            <int32 name="step"/>
            <int32 name="stepunQ"/>
         </inlets>
         <outlets>
            <int32 name="totaloffset"/>
         </outlets>
         <displays/>
         <params/>
         <attribs>
            <objref name="table"/>
            <spinner name="seqlength" MinValue="1" MaxValue="10000" DefaultValue="0"/>
            <combo name="device">
               <MenuEntries>
                  <string>din</string>
                  <string>usb host port 1</string>
                  <string>usb host port 2</string>
                  <string>usb host port 3</string>
                  <string>usb host port 4</string>
                  <string>internal port 1</string>
                  <string>internal port 2</string>
                  <string>usb device port 1</string>
               </MenuEntries>
               <CEntries>
                  <string>MIDI_DEVICE_DIN, 1</string>
                  <string>MIDI_DEVICE_USB_HOST, 1</string>
                  <string>MIDI_DEVICE_USB_HOST, 2</string>
                  <string>MIDI_DEVICE_USB_HOST, 3</string>
                  <string>MIDI_DEVICE_USB_HOST, 4</string>
                  <string>MIDI_DEVICE_INTERNAL, 1</string>
                  <string>MIDI_DEVICE_INTERNAL, 2</string>
                  <string>MIDI_DEVICE_USB_DEVICE, 1</string>
               </CEntries>
            </combo>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[int prevchannel;
int steptrig;
int TntrigA;
int TntrigB;
int TlastnoteA;
int TlastnoteB;
int seqlength;
int seqlengthUNQ;
int voiceoffset;
int off1;
int offtrig;
int offset1;
int offsetunQ1;
int noteonA;
int noteoffA;
int noteA;
int holdnoteA;
int holdvelA;
int TnoteA;
int TvelA;
int TnoteonA;
int TnoteoffA;
int noteonB;
int noteoffB;
int noteB;
int holdnoteB;
int holdvelB;
int TnoteB;
int TvelB;
int TnoteonB;
int TnoteoffB;
int prevoffset;
int prevstep;
int prevstepunQ;]]></code.declaration>
         <code.init><![CDATA[noteonA=0;
seqlengthUNQ=(attr_seqlength*32);
seqlength=attr_seqlength;]]></code.init>
         <code.krate><![CDATA[off1= inlet_play;
if ((inlet_channel!=prevchannel)||(inlet_offset!=prevoffset)){
	if ((TntrigB>0)&&(TlastnoteB>0)){
	MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (prevchannel),TlastnoteB,__USAT(TvelB,7)); TntrigB=0;}
	if ((TntrigA>0)&&(TlastnoteA>0)){
	MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (prevchannel),TlastnoteA,__USAT(TvelA,7)); TntrigA=0;}
	prevchannel=inlet_channel;
}
//if (inlet_offset!=prevoffset){
//	if ((TntrigB>0)&&(TlastnoteB>0)){
//	MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (inlet_channel),TlastnoteB,__USAT(TvelB,7)); TntrigB=0;}
//	if ((TntrigA>0)&&(TlastnoteA>0)){
//	MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (inlet_channel),TlastnoteA,__USAT(TvelA,7)); TntrigA=0;}
//}

offset1=(inlet_offset + inlet_step);
offsetunQ1=(inlet_offset + inlet_stepunQ);
voiceoffset=(seqlength+seqlength+seqlengthUNQ);



//1
if (!off1){
TnoteA=0;
TvelA=0;
TnoteonA=0;
TnoteB=0;
TvelB=0;
TnoteonB=0;
if (offtrig==0){

if ((TntrigB>0)&&(TlastnoteB>0)){
MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (inlet_channel),TlastnoteB,__USAT(TvelB,7)); TntrigB=0;}
if ((TntrigA>0)&&(TlastnoteA>0)){
MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (inlet_channel),TlastnoteA,__USAT(TvelA,7)); TntrigA=0;}

offtrig=1;
}}





else if (off1)
{



	noteA= attr_table.array[__USAT((offset1),attr_table.LENGTHPOW)]<<attr_table.GAIN;
noteonA=attr_table.array[__USAT((offset1 + seqlength),attr_table.LENGTHPOW)]<<attr_table.GAIN;
noteoffA=attr_table.array[__USAT((offsetunQ1+ seqlength + seqlength),attr_table.LENGTHPOW)]<<attr_table.GAIN;
noteB= attr_table.array[__USAT((voiceoffset+ offset1),attr_table.LENGTHPOW)]<<attr_table.GAIN;
noteonB=attr_table.array[__USAT((voiceoffset+ offset1 + seqlength),attr_table.LENGTHPOW)]<<attr_table.GAIN;
noteoffB=attr_table.array[__USAT((voiceoffset+ offsetunQ1+ seqlength + seqlength),attr_table.LENGTHPOW)]<<attr_table.GAIN;


//voiceA*****************************************
//note
if ((inlet_step != prevstep )&&(noteA > (0) )) { 
     holdnoteA = noteA>>20;
     TnoteA = holdnoteA;
}
else {
	TnoteA = holdnoteA;
}

//vel
if ((inlet_step != prevstep )&&(noteonA> 0 )) { 
     holdvelA = noteonA>>20;
     TvelA = holdvelA;
}
else {
	TvelA = holdvelA;
}


if ((noteoffA>0)&&(inlet_stepunQ!=prevstepunQ)){
	TnoteoffA=1;}
else TnoteoffA=0;

if ((noteonA>0)&&(inlet_step!=prevstep)){
	TnoteonA=1;}
else TnoteonA=0;

//voiceB*****************************************
//note
if ((inlet_step != prevstep )&&(noteB > 0) ) { 
     holdnoteB = noteB>>20;
     TnoteB = holdnoteB;
}
else {
	TnoteB = holdnoteB;
}

//vel
if ((inlet_step != prevstep )&&(noteonB> 0 )) { 
     holdvelB = noteonB>>20;
     TvelB = holdvelB;
}
else {
	TvelB = holdvelB;
}


if ((noteoffB>0)&&(inlet_stepunQ!=prevstepunQ)){
	TnoteoffB=1;}
else TnoteoffB=0;

if ((noteonB>0)&&(inlet_step!=prevstep)){
	TnoteonB=1;}
else TnoteonB=0;


if ((TnoteonA>0) && !TntrigA) {
if ((TlastnoteB>0)&&TntrigB){	
MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (inlet_channel),TlastnoteB,__USAT(TvelB,7)); TntrigB=0;
}
MidiSend3((midi_device_t) attr_device, MIDI_NOTE_ON + (inlet_channel),TnoteA,TvelA);  TntrigA=1;
TlastnoteA = TnoteA;
}
if ((TnoteoffA>0) && TntrigA) {MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (inlet_channel),TlastnoteA,__USAT(TvelA,7)); TntrigA=0;}

if ((TnoteonB>0) && !TntrigB) {
if ((TlastnoteA>0)&&TntrigA){
MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (inlet_channel),TlastnoteA,__USAT(TvelA,7)); TntrigA=0;
}
MidiSend3((midi_device_t) attr_device, MIDI_NOTE_ON + (inlet_channel),TnoteB,TvelB);  TntrigB=1;
TlastnoteB = TnoteB;
}
if ((TnoteoffB>0) && TntrigB) {MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (inlet_channel),TlastnoteB,__USAT(TvelB,7)); TntrigB=0;}




offtrig=0;
}
prevoffset=inlet_offset;
prevstep=inlet_step;
prevstepunQ=inlet_stepunQ;
outlet_totaloffset=inlet_offset+voiceoffset+voiceoffset;]]></code.krate>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="a919ffab-f138-4bb2-9193-1455073b35ac" name="tablestore_11" x="1162" y="826">
      <params/>
      <attribs>
         <objref attributeName="table" obj="lcxl2"/>
         <spinner attributeName="seqlength" value="256"/>
      </attribs>
      <object id="patch/object" uuid="a919ffab-f138-4bb2-9193-1455073b35ac">
         <sDescription>writes and outputs 8 values to a table.</sDescription>
         <author>robert schirmer</author>
         <license>who cares</license>
         <inlets>
            <int32 name="channel"/>
            <bool32 name="rec"/>
            <int32 name="offset" description="sets an offset for writing to the table"/>
            <int32 name="stepunQ"/>
         </inlets>
         <outlets>
            <int32 name="offset"/>
         </outlets>
         <displays/>
         <params/>
         <attribs>
            <objref name="table"/>
            <spinner name="seqlength" MinValue="1" MaxValue="10000" DefaultValue="0"/>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[uint32_t i;
uint32_t ii;
int32_t _bend;
int32_t Btrig;
int32_t _press;
int channel;
int cc;
int ccv;
int innote;
int invel;
int inputnote;
int inputvel;
int inputnoteon;
int inputnoteoff;
int ingate;
int ingate2;
int inntrig;
int inytrig;
int op;
int Atrig;
int notecount;
int seqlength;
int seqlengthUNQ;
int splat;
int clear;
int ntrig;
int rtrig;
int speed;
int off1;
int recoffset1g;
int voiceoffset;
int offset;
int offset1;
int totaloffset;
int offsetg;
int offset1g;
int early;
int offsetunQ1;
int offsetunQ1g;
int noteon;
int noteoff;
int ytrig;
int xtrig;
int prevsteprec;
int prevstep;
int prevstepunQ;
int prevx;
int prevy;]]></code.declaration>
         <code.init><![CDATA[seqlengthUNQ=(attr_seqlength*32);
seqlength=attr_seqlength;
_bend=0;
_press=0;]]></code.init>
         <code.krate><![CDATA[off1= !inlet_rec;
channel=inlet_channel;
offset=inlet_offset;

//1
if (!off1){
	if(inlet_stepunQ!=prevstepunQ){
	attr_table.array[offset + inlet_stepunQ]=__SSAT(_bend,28)>>attr_table.GAIN;
	attr_table.array[offset + inlet_stepunQ + seqlengthUNQ]=__SSAT(_press,28)>>attr_table.GAIN;
	attr_table.array[offset + inlet_stepunQ + seqlengthUNQ + seqlengthUNQ]=__SSAT(cc,28)>>attr_table.GAIN;
	attr_table.array[offset + inlet_stepunQ + seqlengthUNQ + seqlengthUNQ + seqlengthUNQ]=__SSAT(ccv,28)>>attr_table.GAIN;
	prevstepunQ=inlet_stepunQ;
	}
}


else if (off1)
{
	_bend=0;
	_press=0;
	cc=0;
	ccv=0;
}

outlet_offset=inlet_offset+seqlengthUNQ+seqlengthUNQ+seqlengthUNQ+seqlengthUNQ;]]></code.krate>
         <code.midihandler><![CDATA[if (status == MIDI_PITCH_BEND + (channel)) {  _bend = ((int)((data2<<7)+data1)-0x2000)<<14;
}
if (status == MIDI_CHANNEL_PRESSURE + (channel)) {  _press = (data1)<<20;
}
if (status == (channel) + MIDI_CONTROL_CHANGE) {
  ccv = data2<<20;
  cc = data1<<20;
}]]></code.midihandler>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="a919ffab-f138-4bb2-9193-1455073b35ac" name="tablestore_12" x="1302" y="826">
      <params/>
      <attribs>
         <objref attributeName="table" obj="lcxl2"/>
         <spinner attributeName="seqlength" value="256"/>
         <combo attributeName="device" selection="din"/>
      </attribs>
      <object id="patch/object" uuid="a919ffab-f138-4bb2-9193-1455073b35ac">
         <sDescription>writes and outputs 8 values to a table.</sDescription>
         <author>robert schirmer</author>
         <license>who cares</license>
         <inlets>
            <int32 name="channel"/>
            <bool32 name="play"/>
            <int32 name="offset" description="sets an offset for writing to the table"/>
            <int32 name="step"/>
            <int32 name="stepunQ"/>
         </inlets>
         <outlets>
            <int32 name="totaloffset"/>
         </outlets>
         <displays/>
         <params/>
         <attribs>
            <objref name="table"/>
            <spinner name="seqlength" MinValue="1" MaxValue="10000" DefaultValue="0"/>
            <combo name="device">
               <MenuEntries>
                  <string>din</string>
                  <string>usb host port 1</string>
                  <string>usb host port 2</string>
                  <string>usb host port 3</string>
                  <string>usb host port 4</string>
                  <string>internal port 1</string>
                  <string>internal port 2</string>
                  <string>usb device port 1</string>
               </MenuEntries>
               <CEntries>
                  <string>MIDI_DEVICE_DIN, 1</string>
                  <string>MIDI_DEVICE_USB_HOST, 1</string>
                  <string>MIDI_DEVICE_USB_HOST, 2</string>
                  <string>MIDI_DEVICE_USB_HOST, 3</string>
                  <string>MIDI_DEVICE_USB_HOST, 4</string>
                  <string>MIDI_DEVICE_INTERNAL, 1</string>
                  <string>MIDI_DEVICE_INTERNAL, 2</string>
                  <string>MIDI_DEVICE_USB_DEVICE, 1</string>
               </CEntries>
            </combo>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[int prevchannel;
int steptrigger;
int seqlength;
int seqlengthUNQ;
int off1;
int offtrig;
int offsetunQ1;
int bend;
int bendA;
int bendB;
int touch;
int cc;
int ccv;
int prevbend;
int prevbendB;
int prevtouch;
int prevcc;
int prevccv;
int prevoffset;
int prevstepunQ;]]></code.declaration>
         <code.init><![CDATA[seqlengthUNQ=(attr_seqlength*32);
seqlength=attr_seqlength;
bendB=64;
bendA=0;
bend=0;
prevbendB=64;]]></code.init>
         <code.krate><![CDATA[off1= inlet_play;
if (inlet_channel!=prevchannel){
	if (prevbendB!=64){
	MidiSend3((midi_device_t) attr_device , MIDI_PITCH_BEND + (inlet_channel),0,64);prevbendB=64;
	}
	if (touch>0){
	MidiSend2((midi_device_t) attr_device, MIDI_CHANNEL_PRESSURE + (inlet_channel),0>>20);
	}
	prevchannel=inlet_channel;
}


offsetunQ1=(inlet_offset + inlet_stepunQ);

if (inlet_offset!=prevoffset){
	if (prevbendB!=64){
MidiSend3((midi_device_t) attr_device , MIDI_PITCH_BEND + (inlet_channel),0,64);prevbendB=64;
}
if (touch>0){
MidiSend2((midi_device_t) attr_device, MIDI_CHANNEL_PRESSURE + (inlet_channel),0>>20);
}
prevoffset=inlet_offset;
}

if (!off1){

if (offtrig==0){
//TnoteoffA=1;
//TnoteoffB=1;
if (prevbendB!=64){
MidiSend3((midi_device_t) attr_device , MIDI_PITCH_BEND + (inlet_channel),0,64);prevbendB=64;
}
if (touch>0){
MidiSend2((midi_device_t) attr_device, MIDI_CHANNEL_PRESSURE + (inlet_channel),0>>20);
}
offtrig=1;
}
bendB=64;
bendA=0;
bend=0;
touch=0;
}





else if (off1)
{
	if ((inlet_stepunQ==0)&&!steptrigger){
	if (prevbendB!=64){
		
	MidiSend3((midi_device_t) attr_device , MIDI_PITCH_BEND + (inlet_channel),0,64);prevbendB=64;}
	if (touch>0){
	MidiSend2((midi_device_t) attr_device, MIDI_CHANNEL_PRESSURE + (inlet_channel),0>>20);touch=0;}
	steptrigger=1;
}
if (inlet_stepunQ>0){
	steptrigger=0;
}
bend=attr_table.array[__USAT((offsetunQ1),attr_table.LENGTHPOW)]<<attr_table.GAIN;
bendA=(bend>>14)&0x7F;
bendB=(bend>>21)+64;
touch=attr_table.array[__USAT((offsetunQ1+ seqlengthUNQ),attr_table.LENGTHPOW)]<<attr_table.GAIN;
cc=attr_table.array[__USAT((offsetunQ1+ seqlengthUNQ+ seqlengthUNQ),attr_table.LENGTHPOW)]<<attr_table.GAIN;
ccv=attr_table.array[__USAT((offsetunQ1+ seqlengthUNQ+ seqlengthUNQ+ seqlengthUNQ),attr_table.LENGTHPOW)]<<attr_table.GAIN;

//pitchbend
if ((inlet_stepunQ!=prevstepunQ)&&(bendB!=prevbendB)){
MidiSend3((midi_device_t) attr_device , MIDI_PITCH_BEND + (inlet_channel),bendA,bendB);
prevbend=bend;
prevbendB=bendB;
}
//aftertouch
if ((touch!=prevtouch)&&(inlet_stepunQ!=prevstepunQ)){
MidiSend2((midi_device_t) attr_device, MIDI_CHANNEL_PRESSURE + (inlet_channel),touch>>20);
prevtouch=touch;
}
if (((ccv!=prevccv)||(cc!=prevcc))&&(inlet_stepunQ!=prevstepunQ)){
	MidiSend3((midi_device_t) attr_device, MIDI_CONTROL_CHANGE + (inlet_channel),(cc>>20),__USAT(ccv>>20,7));
	prevcc=cc;
	prevccv=ccv;
}

}

prevstepunQ=inlet_stepunQ;
outlet_totaloffset=inlet_offset+seqlengthUNQ+seqlengthUNQ+seqlengthUNQ+seqlengthUNQ;]]></code.krate>
      </object>
   </patchobj>
   <comment type="patch/comment" x="98" y="1050" text="track 4"/>
   <comment type="patch/comment" x="98" y="1064" text="poly recorder"/>
   <comment type="patch/comment" x="224" y="1064" text="track 4"/>
   <comment type="patch/comment" x="1162" y="1064" text="track 4"/>
   <comment type="patch/comment" x="1288" y="1064" text="track 4"/>
   <patcher type="patch/patcher" uuid="865a8d9e-a616-4157-b0d5-4fb08d8b4b30" name="patcher_4" x="98" y="1078">
      <params/>
      <attribs>
         <combo attributeName="poly" selection="6"/>
         <combo attributeName="midichannel" selection="2"/>
         <combo attributeName="mididevice" selection="omni"/>
         <combo attributeName="midiport" selection="omni"/>
      </attribs>
      <subpatch appVersion="1.0.12">
         <patchobj type="patch/object" uuid="20502dcd-a0bc-49c2-ad5e-e405aac40702" name="polyindex_1" x="56" y="0">
            <params/>
            <attribs/>
            <object id="patch/object" uuid="20502dcd-a0bc-49c2-ad5e-e405aac40702">
               <sDescription>Outputs the voice index number from 0 to n-1. Only works in a polyphonic sub-patch!</sDescription>
               <author>Johannes Taelman</author>
               <license>BSD</license>
               <helpPatch>polyindex.axh</helpPatch>
               <inlets/>
               <outlets>
                  <int32.positive name="index" description="index from 0 to n-1"/>
               </outlets>
               <displays/>
               <params/>
               <attribs/>
               <includes/>
               <code.krate><![CDATA[outlet_index = parent->polyIndex;
]]></code.krate>
            </object>
         </patchobj>
         <obj type="patch/inlet i" uuid="f11927f00c59219df0c50f73056aa19f125540b7" name="channel" x="154" y="0">
            <params/>
            <attribs/>
         </obj>
         <obj type="patch/inlet i" uuid="f11927f00c59219df0c50f73056aa19f125540b7" name="offset" x="252" y="0">
            <params/>
            <attribs/>
         </obj>
         <obj type="patch/inlet b" uuid="3b0d3eacb5bb978cb05d1372aa2714d5a4790844" name="rec" x="364" y="0">
            <params/>
            <attribs/>
         </obj>
         <obj type="patch/inlet i" uuid="f11927f00c59219df0c50f73056aa19f125540b7" name="qstep" x="476" y="0">
            <params/>
            <attribs/>
         </obj>
         <obj type="patch/inlet i" uuid="f11927f00c59219df0c50f73056aa19f125540b7" name="steprec" x="560" y="0">
            <params/>
            <attribs/>
         </obj>
         <obj type="patch/inlet i" uuid="f11927f00c59219df0c50f73056aa19f125540b7" name="step" x="644" y="0">
            <params/>
            <attribs/>
         </obj>
         <obj type="patch/inlet i" uuid="f11927f00c59219df0c50f73056aa19f125540b7" name="stepunQ" x="728" y="0">
            <params/>
            <attribs/>
         </obj>
         <patchobj type="patch/object" uuid="a919ffab-f138-4bb2-9193-1455073b35ac" name="tablestore_7" x="812" y="0">
            <params/>
            <attribs>
               <objref attributeName="table" obj="../lcxl2"/>
               <spinner attributeName="seqlength" value="256"/>
            </attribs>
            <object id="patch/object" uuid="a919ffab-f138-4bb2-9193-1455073b35ac">
               <sDescription>writes and outputs 8 values to a table.</sDescription>
               <author>robert schirmer</author>
               <license>who cares</license>
               <inlets>
                  <int32 name="channel"/>
                  <bool32 name="rec"/>
                  <int32 name="polyphony"/>
                  <int32 name="offset" description="sets an offset for writing to the table"/>
                  <int32 name="steprec"/>
                  <int32 name="step"/>
                  <int32 name="stepunQ"/>
                  <int32 name="Qstep"/>
               </inlets>
               <outlets/>
               <displays/>
               <params/>
               <attribs>
                  <objref name="table"/>
                  <spinner name="seqlength" MinValue="1" MaxValue="10000" DefaultValue="0"/>
               </attribs>
               <includes/>
               <code.declaration><![CDATA[int channel;
int polyphony;
int innote;
int invel;
int inputnote;
int inputvel;
int inputnoteon;
int inputnoteoff;
int ingate;
int ingate2;
int inntrig;
int inytrig;
int op;
int Atrig;
int notecount;
int seqlength;
int seqlengthUNQ;
int off1;
int recoffset1g;
int voiceoffset;
int offset;
int offset1;
int totaloffset;
int offsetg;
int offset1g;
int etrig;
int early;
int earlyshift;
int offsetunQ1;
int offsetunQ1g;
int noteon;
int noteoff;
int ytrig;
int xtrig;
int prevsteprec;
int prevstep;
int prevstepunQ;
int prevx;
int prevy;
int Pnoteoff;
int Poffset;]]></code.declaration>
               <code.init><![CDATA[seqlengthUNQ=(attr_seqlength*32);
seqlength=attr_seqlength;
noteon=0;
notecount=0;
offsetg=offset;]]></code.init>
               <code.krate><![CDATA[off1= !inlet_rec;
channel=inlet_channel;
voiceoffset=seqlength+seqlength+seqlengthUNQ;
totaloffset=voiceoffset+voiceoffset;
offset=inlet_offset+(totaloffset*(inlet_polyphony));



inputnote = innote<<20;
inputvel= invel<<20;

if((ingate2)&&!inntrig){
inputnoteon=ingate2;
inntrig=1;}
else inputnoteon=0;
if (!ingate2){
inntrig=0;
}

if((!ingate)&&!inytrig){
inputnoteoff=64<<20;
inytrig=1;}
else inputnoteoff=0;
if (ingate){
inytrig=0;
}

ingate2=ingate;

if ((inputnoteon>0) && !Atrig) {op = !op; Atrig=1;}
if (!(inputnoteon>0)) Atrig=0;
notecount= op;


if (notecount){offsetg=offset;}
if (!notecount){offsetg=offset+voiceoffset;}


recoffset1g=(offsetg + (inlet_steprec));
offsetunQ1g=(offsetg + inlet_stepunQ);




//1
if (!off1){
if ((inputnoteon>0)&&(!ytrig))
{
attr_table.array[recoffset1g]=__SSAT(inputnote,28)>>attr_table.GAIN;
attr_table.array[recoffset1g + seqlength]=__SSAT(inputvel,28)>>attr_table.GAIN;
Pnoteoff=0;
if ((inlet_steprec!=inlet_step)&&!etrig) {
	
	earlyshift=(16-inlet_Qstep);
	etrig=1;
}
if ((inlet_steprec==inlet_step)&&!etrig) 
{
	
	earlyshift=(0-inlet_Qstep);
	etrig=1;
	//if (inlet_steprec==0)
	//{
	//	early=2;
	//}
}

//if (inlet_steprec==(seqlength-1)){early=2;}
prevy=inlet_steprec;
ytrig=1;
}
else if ((!(inputnoteon>0))&&(inlet_steprec!=prevy)){
	ytrig=0;
	
}


if ((inputnoteoff>0)&&(!xtrig))
{early=earlyshift;
	

		attr_table.array[offsetunQ1g + seqlength + seqlength + earlyshift]=__SSAT(inputnoteoff,28)>>attr_table.GAIN;
		Pnoteoff=1;
		//attr_table.array[recoffset1g]=__SSAT(inputnote,28)>>attr_table.GAIN;
	
etrig=0;
prevx=inlet_stepunQ;
xtrig=1;
}
else if ((!(inputnoteoff>0))&&(inlet_stepunQ!=prevx)){
	xtrig=0;
}


if ((offsetg!=Poffset)&&ingate){
	inputnoteoff=64<<20;
	attr_table.array[Poffset + prevstepunQ + seqlength + seqlength]=__SSAT(inputnoteoff,28)>>attr_table.GAIN;
	}

prevstep=inlet_step;
prevstepunQ=inlet_stepunQ;
prevsteprec=inlet_steprec;
Poffset=offsetg;
}



else if (off1)
{
	if (!Pnoteoff){
	inputnoteoff=64<<20;
	attr_table.array[offsetg + prevstepunQ + seqlength + seqlength + earlyshift]=__SSAT(inputnoteoff,28)>>attr_table.GAIN;Pnoteoff=1;}
inputnoteoff=0;
etrig=0;
ytrig=0;
xtrig=0;
op=0;
prevx=(-1);
prevy=(-1);
}]]></code.krate>
               <code.midihandler><![CDATA[if (status == MIDI_NOTE_ON + (channel)) {
  innote = data1;
  invel = data2;
  ingate=1;
  ingate2=0;
}
if (status == MIDI_NOTE_OFF + (channel)) {
	if (data1==(innote)){
		ingate=0;
	}
}]]></code.midihandler>
            </object>
         </patchobj>
         <nets>
            <net>
               <source obj="rec" outlet="inlet"/>
               <dest obj="tablestore_7" inlet="rec"/>
            </net>
            <net>
               <source obj="steprec" outlet="inlet"/>
               <dest obj="tablestore_7" inlet="steprec"/>
            </net>
            <net>
               <source obj="step" outlet="inlet"/>
               <dest obj="tablestore_7" inlet="step"/>
            </net>
            <net>
               <source obj="stepunQ" outlet="inlet"/>
               <dest obj="tablestore_7" inlet="stepunQ"/>
            </net>
            <net>
               <source obj="qstep" outlet="inlet"/>
               <dest obj="tablestore_7" inlet="Qstep"/>
            </net>
            <net>
               <source obj="offset" outlet="inlet"/>
               <dest obj="tablestore_7" inlet="offset"/>
            </net>
            <net>
               <source obj="polyindex_1" outlet="index"/>
               <dest obj="tablestore_7" inlet="polyphony"/>
            </net>
            <net>
               <source obj="channel" outlet="inlet"/>
               <dest obj="tablestore_7" inlet="channel"/>
            </net>
         </nets>
         <settings>
            <subpatchmode>polyphonic</subpatchmode>
            <MidiChannel>7</MidiChannel>
            <HasMidiChannelSelector>true</HasMidiChannelSelector>
            <NPresets>0</NPresets>
            <NPresetEntries>0</NPresetEntries>
            <NModulationSources>0</NModulationSources>
            <NModulationTargetsPerSource>0</NModulationTargetsPerSource>
         </settings>
         <notes><![CDATA[]]></notes>
         <windowPos>
            <x>-8</x>
            <y>-8</y>
            <width>1616</width>
            <height>876</height>
         </windowPos>
      </subpatch>
   </patcher>
   <comment type="patch/comment" x="224" y="1078" text=" noteplay poly 1"/>
   <comment type="patch/comment" x="378" y="1078" text=" noteplay poly 2"/>
   <comment type="patch/comment" x="532" y="1078" text=" noteplay poly 3"/>
   <comment type="patch/comment" x="672" y="1078" text=" noteplay poly 4"/>
   <comment type="patch/comment" x="840" y="1078" text=" noteplay poly 5"/>
   <comment type="patch/comment" x="994" y="1078" text=" noteplay poly 6"/>
   <comment type="patch/comment" x="1162" y="1078" text="bend touch cc recorder"/>
   <comment type="patch/comment" x="1288" y="1078" text="bend/touch.CC play"/>
   <patchobj type="patch/object" uuid="a919ffab-f138-4bb2-9193-1455073b35ac" name="tablestore_27" x="224" y="1092">
      <params/>
      <attribs>
         <objref attributeName="table" obj="lcxl2"/>
         <spinner attributeName="seqlength" value="256"/>
         <combo attributeName="device" selection="din"/>
      </attribs>
      <object id="patch/object" uuid="a919ffab-f138-4bb2-9193-1455073b35ac">
         <sDescription>writes and outputs 8 values to a table.</sDescription>
         <author>robert schirmer</author>
         <license>who cares</license>
         <inlets>
            <int32 name="channel"/>
            <bool32 name="play"/>
            <int32 name="offset" description="sets an offset for writing to the table"/>
            <int32 name="step"/>
            <int32 name="stepunQ"/>
         </inlets>
         <outlets>
            <int32 name="totaloffset"/>
         </outlets>
         <displays/>
         <params/>
         <attribs>
            <objref name="table"/>
            <spinner name="seqlength" MinValue="1" MaxValue="10000" DefaultValue="0"/>
            <combo name="device">
               <MenuEntries>
                  <string>din</string>
                  <string>usb host port 1</string>
                  <string>usb host port 2</string>
                  <string>usb host port 3</string>
                  <string>usb host port 4</string>
                  <string>internal port 1</string>
                  <string>internal port 2</string>
                  <string>usb device port 1</string>
               </MenuEntries>
               <CEntries>
                  <string>MIDI_DEVICE_DIN, 1</string>
                  <string>MIDI_DEVICE_USB_HOST, 1</string>
                  <string>MIDI_DEVICE_USB_HOST, 2</string>
                  <string>MIDI_DEVICE_USB_HOST, 3</string>
                  <string>MIDI_DEVICE_USB_HOST, 4</string>
                  <string>MIDI_DEVICE_INTERNAL, 1</string>
                  <string>MIDI_DEVICE_INTERNAL, 2</string>
                  <string>MIDI_DEVICE_USB_DEVICE, 1</string>
               </CEntries>
            </combo>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[int prevchannel;
int steptrig;
int TntrigA;
int TntrigB;
int TlastnoteA;
int TlastnoteB;
int seqlength;
int seqlengthUNQ;
int voiceoffset;
int off1;
int offtrig;
int offset1;
int offsetunQ1;
int noteonA;
int noteoffA;
int noteA;
int holdnoteA;
int holdvelA;
int TnoteA;
int TvelA;
int TnoteonA;
int TnoteoffA;
int noteonB;
int noteoffB;
int noteB;
int holdnoteB;
int holdvelB;
int TnoteB;
int TvelB;
int TnoteonB;
int TnoteoffB;
int prevoffset;
int prevstep;
int prevstepunQ;]]></code.declaration>
         <code.init><![CDATA[noteonA=0;
seqlengthUNQ=(attr_seqlength*32);
seqlength=attr_seqlength;]]></code.init>
         <code.krate><![CDATA[off1= inlet_play;
if ((inlet_channel!=prevchannel)||(inlet_offset!=prevoffset)){
	if ((TntrigB>0)&&(TlastnoteB>0)){
	MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (prevchannel),TlastnoteB,__USAT(TvelB,7)); TntrigB=0;}
	if ((TntrigA>0)&&(TlastnoteA>0)){
	MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (prevchannel),TlastnoteA,__USAT(TvelA,7)); TntrigA=0;}
	prevchannel=inlet_channel;
}
//if (inlet_offset!=prevoffset){
//	if ((TntrigB>0)&&(TlastnoteB>0)){
//	MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (inlet_channel),TlastnoteB,__USAT(TvelB,7)); TntrigB=0;}
//	if ((TntrigA>0)&&(TlastnoteA>0)){
//	MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (inlet_channel),TlastnoteA,__USAT(TvelA,7)); TntrigA=0;}
//}

offset1=(inlet_offset + inlet_step);
offsetunQ1=(inlet_offset + inlet_stepunQ);
voiceoffset=(seqlength+seqlength+seqlengthUNQ);



//1
if (!off1){
TnoteA=0;
TvelA=0;
TnoteonA=0;
TnoteB=0;
TvelB=0;
TnoteonB=0;
if (offtrig==0){

if ((TntrigB>0)&&(TlastnoteB>0)){
MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (inlet_channel),TlastnoteB,__USAT(TvelB,7)); TntrigB=0;}
if ((TntrigA>0)&&(TlastnoteA>0)){
MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (inlet_channel),TlastnoteA,__USAT(TvelA,7)); TntrigA=0;}

offtrig=1;
}}





else if (off1)
{



	noteA= attr_table.array[__USAT((offset1),attr_table.LENGTHPOW)]<<attr_table.GAIN;
noteonA=attr_table.array[__USAT((offset1 + seqlength),attr_table.LENGTHPOW)]<<attr_table.GAIN;
noteoffA=attr_table.array[__USAT((offsetunQ1+ seqlength + seqlength),attr_table.LENGTHPOW)]<<attr_table.GAIN;
noteB= attr_table.array[__USAT((voiceoffset+ offset1),attr_table.LENGTHPOW)]<<attr_table.GAIN;
noteonB=attr_table.array[__USAT((voiceoffset+ offset1 + seqlength),attr_table.LENGTHPOW)]<<attr_table.GAIN;
noteoffB=attr_table.array[__USAT((voiceoffset+ offsetunQ1+ seqlength + seqlength),attr_table.LENGTHPOW)]<<attr_table.GAIN;


//voiceA*****************************************
//note
if ((inlet_step != prevstep )&&(noteA > (0) )) { 
     holdnoteA = noteA>>20;
     TnoteA = holdnoteA;
}
else {
	TnoteA = holdnoteA;
}

//vel
if ((inlet_step != prevstep )&&(noteonA> 0 )) { 
     holdvelA = noteonA>>20;
     TvelA = holdvelA;
}
else {
	TvelA = holdvelA;
}


if ((noteoffA>0)&&(inlet_stepunQ!=prevstepunQ)){
	TnoteoffA=1;}
else TnoteoffA=0;

if ((noteonA>0)&&(inlet_step!=prevstep)){
	TnoteonA=1;}
else TnoteonA=0;

//voiceB*****************************************
//note
if ((inlet_step != prevstep )&&(noteB > 0) ) { 
     holdnoteB = noteB>>20;
     TnoteB = holdnoteB;
}
else {
	TnoteB = holdnoteB;
}

//vel
if ((inlet_step != prevstep )&&(noteonB> 0 )) { 
     holdvelB = noteonB>>20;
     TvelB = holdvelB;
}
else {
	TvelB = holdvelB;
}


if ((noteoffB>0)&&(inlet_stepunQ!=prevstepunQ)){
	TnoteoffB=1;}
else TnoteoffB=0;

if ((noteonB>0)&&(inlet_step!=prevstep)){
	TnoteonB=1;}
else TnoteonB=0;


if ((TnoteonA>0) && !TntrigA) {
if ((TlastnoteB>0)&&TntrigB){	
MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (inlet_channel),TlastnoteB,__USAT(TvelB,7)); TntrigB=0;
}
MidiSend3((midi_device_t) attr_device, MIDI_NOTE_ON + (inlet_channel),TnoteA,TvelA);  TntrigA=1;
TlastnoteA = TnoteA;
}
if ((TnoteoffA>0) && TntrigA) {MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (inlet_channel),TlastnoteA,__USAT(TvelA,7)); TntrigA=0;}

if ((TnoteonB>0) && !TntrigB) {
if ((TlastnoteA>0)&&TntrigA){
MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (inlet_channel),TlastnoteA,__USAT(TvelA,7)); TntrigA=0;
}
MidiSend3((midi_device_t) attr_device, MIDI_NOTE_ON + (inlet_channel),TnoteB,TvelB);  TntrigB=1;
TlastnoteB = TnoteB;
}
if ((TnoteoffB>0) && TntrigB) {MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (inlet_channel),TlastnoteB,__USAT(TvelB,7)); TntrigB=0;}




offtrig=0;
}
prevoffset=inlet_offset;
prevstep=inlet_step;
prevstepunQ=inlet_stepunQ;
outlet_totaloffset=inlet_offset+voiceoffset+voiceoffset;]]></code.krate>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="a919ffab-f138-4bb2-9193-1455073b35ac" name="tablestore_28" x="378" y="1092">
      <params/>
      <attribs>
         <objref attributeName="table" obj="lcxl2"/>
         <spinner attributeName="seqlength" value="256"/>
         <combo attributeName="device" selection="din"/>
      </attribs>
      <object id="patch/object" uuid="a919ffab-f138-4bb2-9193-1455073b35ac">
         <sDescription>writes and outputs 8 values to a table.</sDescription>
         <author>robert schirmer</author>
         <license>who cares</license>
         <inlets>
            <int32 name="channel"/>
            <bool32 name="play"/>
            <int32 name="offset" description="sets an offset for writing to the table"/>
            <int32 name="step"/>
            <int32 name="stepunQ"/>
         </inlets>
         <outlets>
            <int32 name="totaloffset"/>
         </outlets>
         <displays/>
         <params/>
         <attribs>
            <objref name="table"/>
            <spinner name="seqlength" MinValue="1" MaxValue="10000" DefaultValue="0"/>
            <combo name="device">
               <MenuEntries>
                  <string>din</string>
                  <string>usb host port 1</string>
                  <string>usb host port 2</string>
                  <string>usb host port 3</string>
                  <string>usb host port 4</string>
                  <string>internal port 1</string>
                  <string>internal port 2</string>
                  <string>usb device port 1</string>
               </MenuEntries>
               <CEntries>
                  <string>MIDI_DEVICE_DIN, 1</string>
                  <string>MIDI_DEVICE_USB_HOST, 1</string>
                  <string>MIDI_DEVICE_USB_HOST, 2</string>
                  <string>MIDI_DEVICE_USB_HOST, 3</string>
                  <string>MIDI_DEVICE_USB_HOST, 4</string>
                  <string>MIDI_DEVICE_INTERNAL, 1</string>
                  <string>MIDI_DEVICE_INTERNAL, 2</string>
                  <string>MIDI_DEVICE_USB_DEVICE, 1</string>
               </CEntries>
            </combo>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[int prevchannel;
int steptrig;
int TntrigA;
int TntrigB;
int TlastnoteA;
int TlastnoteB;
int seqlength;
int seqlengthUNQ;
int voiceoffset;
int off1;
int offtrig;
int offset1;
int offsetunQ1;
int noteonA;
int noteoffA;
int noteA;
int holdnoteA;
int holdvelA;
int TnoteA;
int TvelA;
int TnoteonA;
int TnoteoffA;
int noteonB;
int noteoffB;
int noteB;
int holdnoteB;
int holdvelB;
int TnoteB;
int TvelB;
int TnoteonB;
int TnoteoffB;
int prevoffset;
int prevstep;
int prevstepunQ;]]></code.declaration>
         <code.init><![CDATA[noteonA=0;
seqlengthUNQ=(attr_seqlength*32);
seqlength=attr_seqlength;]]></code.init>
         <code.krate><![CDATA[off1= inlet_play;
if ((inlet_channel!=prevchannel)||(inlet_offset!=prevoffset)){
	if ((TntrigB>0)&&(TlastnoteB>0)){
	MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (prevchannel),TlastnoteB,__USAT(TvelB,7)); TntrigB=0;}
	if ((TntrigA>0)&&(TlastnoteA>0)){
	MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (prevchannel),TlastnoteA,__USAT(TvelA,7)); TntrigA=0;}
	prevchannel=inlet_channel;
}
//if (inlet_offset!=prevoffset){
//	if ((TntrigB>0)&&(TlastnoteB>0)){
//	MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (inlet_channel),TlastnoteB,__USAT(TvelB,7)); TntrigB=0;}
//	if ((TntrigA>0)&&(TlastnoteA>0)){
//	MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (inlet_channel),TlastnoteA,__USAT(TvelA,7)); TntrigA=0;}
//}

offset1=(inlet_offset + inlet_step);
offsetunQ1=(inlet_offset + inlet_stepunQ);
voiceoffset=(seqlength+seqlength+seqlengthUNQ);



//1
if (!off1){
TnoteA=0;
TvelA=0;
TnoteonA=0;
TnoteB=0;
TvelB=0;
TnoteonB=0;
if (offtrig==0){

if ((TntrigB>0)&&(TlastnoteB>0)){
MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (inlet_channel),TlastnoteB,__USAT(TvelB,7)); TntrigB=0;}
if ((TntrigA>0)&&(TlastnoteA>0)){
MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (inlet_channel),TlastnoteA,__USAT(TvelA,7)); TntrigA=0;}

offtrig=1;
}}





else if (off1)
{



	noteA= attr_table.array[__USAT((offset1),attr_table.LENGTHPOW)]<<attr_table.GAIN;
noteonA=attr_table.array[__USAT((offset1 + seqlength),attr_table.LENGTHPOW)]<<attr_table.GAIN;
noteoffA=attr_table.array[__USAT((offsetunQ1+ seqlength + seqlength),attr_table.LENGTHPOW)]<<attr_table.GAIN;
noteB= attr_table.array[__USAT((voiceoffset+ offset1),attr_table.LENGTHPOW)]<<attr_table.GAIN;
noteonB=attr_table.array[__USAT((voiceoffset+ offset1 + seqlength),attr_table.LENGTHPOW)]<<attr_table.GAIN;
noteoffB=attr_table.array[__USAT((voiceoffset+ offsetunQ1+ seqlength + seqlength),attr_table.LENGTHPOW)]<<attr_table.GAIN;


//voiceA*****************************************
//note
if ((inlet_step != prevstep )&&(noteA > (0) )) { 
     holdnoteA = noteA>>20;
     TnoteA = holdnoteA;
}
else {
	TnoteA = holdnoteA;
}

//vel
if ((inlet_step != prevstep )&&(noteonA> 0 )) { 
     holdvelA = noteonA>>20;
     TvelA = holdvelA;
}
else {
	TvelA = holdvelA;
}


if ((noteoffA>0)&&(inlet_stepunQ!=prevstepunQ)){
	TnoteoffA=1;}
else TnoteoffA=0;

if ((noteonA>0)&&(inlet_step!=prevstep)){
	TnoteonA=1;}
else TnoteonA=0;

//voiceB*****************************************
//note
if ((inlet_step != prevstep )&&(noteB > 0) ) { 
     holdnoteB = noteB>>20;
     TnoteB = holdnoteB;
}
else {
	TnoteB = holdnoteB;
}

//vel
if ((inlet_step != prevstep )&&(noteonB> 0 )) { 
     holdvelB = noteonB>>20;
     TvelB = holdvelB;
}
else {
	TvelB = holdvelB;
}


if ((noteoffB>0)&&(inlet_stepunQ!=prevstepunQ)){
	TnoteoffB=1;}
else TnoteoffB=0;

if ((noteonB>0)&&(inlet_step!=prevstep)){
	TnoteonB=1;}
else TnoteonB=0;


if ((TnoteonA>0) && !TntrigA) {
if ((TlastnoteB>0)&&TntrigB){	
MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (inlet_channel),TlastnoteB,__USAT(TvelB,7)); TntrigB=0;
}
MidiSend3((midi_device_t) attr_device, MIDI_NOTE_ON + (inlet_channel),TnoteA,TvelA);  TntrigA=1;
TlastnoteA = TnoteA;
}
if ((TnoteoffA>0) && TntrigA) {MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (inlet_channel),TlastnoteA,__USAT(TvelA,7)); TntrigA=0;}

if ((TnoteonB>0) && !TntrigB) {
if ((TlastnoteA>0)&&TntrigA){
MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (inlet_channel),TlastnoteA,__USAT(TvelA,7)); TntrigA=0;
}
MidiSend3((midi_device_t) attr_device, MIDI_NOTE_ON + (inlet_channel),TnoteB,TvelB);  TntrigB=1;
TlastnoteB = TnoteB;
}
if ((TnoteoffB>0) && TntrigB) {MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (inlet_channel),TlastnoteB,__USAT(TvelB,7)); TntrigB=0;}




offtrig=0;
}
prevoffset=inlet_offset;
prevstep=inlet_step;
prevstepunQ=inlet_stepunQ;
outlet_totaloffset=inlet_offset+voiceoffset+voiceoffset;]]></code.krate>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="a919ffab-f138-4bb2-9193-1455073b35ac" name="tablestore_29" x="532" y="1092">
      <params/>
      <attribs>
         <objref attributeName="table" obj="lcxl2"/>
         <spinner attributeName="seqlength" value="256"/>
         <combo attributeName="device" selection="din"/>
      </attribs>
      <object id="patch/object" uuid="a919ffab-f138-4bb2-9193-1455073b35ac">
         <sDescription>writes and outputs 8 values to a table.</sDescription>
         <author>robert schirmer</author>
         <license>who cares</license>
         <inlets>
            <int32 name="channel"/>
            <bool32 name="play"/>
            <int32 name="offset" description="sets an offset for writing to the table"/>
            <int32 name="step"/>
            <int32 name="stepunQ"/>
         </inlets>
         <outlets>
            <int32 name="totaloffset"/>
         </outlets>
         <displays/>
         <params/>
         <attribs>
            <objref name="table"/>
            <spinner name="seqlength" MinValue="1" MaxValue="10000" DefaultValue="0"/>
            <combo name="device">
               <MenuEntries>
                  <string>din</string>
                  <string>usb host port 1</string>
                  <string>usb host port 2</string>
                  <string>usb host port 3</string>
                  <string>usb host port 4</string>
                  <string>internal port 1</string>
                  <string>internal port 2</string>
                  <string>usb device port 1</string>
               </MenuEntries>
               <CEntries>
                  <string>MIDI_DEVICE_DIN, 1</string>
                  <string>MIDI_DEVICE_USB_HOST, 1</string>
                  <string>MIDI_DEVICE_USB_HOST, 2</string>
                  <string>MIDI_DEVICE_USB_HOST, 3</string>
                  <string>MIDI_DEVICE_USB_HOST, 4</string>
                  <string>MIDI_DEVICE_INTERNAL, 1</string>
                  <string>MIDI_DEVICE_INTERNAL, 2</string>
                  <string>MIDI_DEVICE_USB_DEVICE, 1</string>
               </CEntries>
            </combo>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[int prevchannel;
int steptrig;
int TntrigA;
int TntrigB;
int TlastnoteA;
int TlastnoteB;
int seqlength;
int seqlengthUNQ;
int voiceoffset;
int off1;
int offtrig;
int offset1;
int offsetunQ1;
int noteonA;
int noteoffA;
int noteA;
int holdnoteA;
int holdvelA;
int TnoteA;
int TvelA;
int TnoteonA;
int TnoteoffA;
int noteonB;
int noteoffB;
int noteB;
int holdnoteB;
int holdvelB;
int TnoteB;
int TvelB;
int TnoteonB;
int TnoteoffB;
int prevoffset;
int prevstep;
int prevstepunQ;]]></code.declaration>
         <code.init><![CDATA[noteonA=0;
seqlengthUNQ=(attr_seqlength*32);
seqlength=attr_seqlength;]]></code.init>
         <code.krate><![CDATA[off1= inlet_play;
if ((inlet_channel!=prevchannel)||(inlet_offset!=prevoffset)){
	if ((TntrigB>0)&&(TlastnoteB>0)){
	MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (prevchannel),TlastnoteB,__USAT(TvelB,7)); TntrigB=0;}
	if ((TntrigA>0)&&(TlastnoteA>0)){
	MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (prevchannel),TlastnoteA,__USAT(TvelA,7)); TntrigA=0;}
	prevchannel=inlet_channel;
}
//if (inlet_offset!=prevoffset){
//	if ((TntrigB>0)&&(TlastnoteB>0)){
//	MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (inlet_channel),TlastnoteB,__USAT(TvelB,7)); TntrigB=0;}
//	if ((TntrigA>0)&&(TlastnoteA>0)){
//	MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (inlet_channel),TlastnoteA,__USAT(TvelA,7)); TntrigA=0;}
//}

offset1=(inlet_offset + inlet_step);
offsetunQ1=(inlet_offset + inlet_stepunQ);
voiceoffset=(seqlength+seqlength+seqlengthUNQ);



//1
if (!off1){
TnoteA=0;
TvelA=0;
TnoteonA=0;
TnoteB=0;
TvelB=0;
TnoteonB=0;
if (offtrig==0){

if ((TntrigB>0)&&(TlastnoteB>0)){
MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (inlet_channel),TlastnoteB,__USAT(TvelB,7)); TntrigB=0;}
if ((TntrigA>0)&&(TlastnoteA>0)){
MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (inlet_channel),TlastnoteA,__USAT(TvelA,7)); TntrigA=0;}

offtrig=1;
}}





else if (off1)
{



	noteA= attr_table.array[__USAT((offset1),attr_table.LENGTHPOW)]<<attr_table.GAIN;
noteonA=attr_table.array[__USAT((offset1 + seqlength),attr_table.LENGTHPOW)]<<attr_table.GAIN;
noteoffA=attr_table.array[__USAT((offsetunQ1+ seqlength + seqlength),attr_table.LENGTHPOW)]<<attr_table.GAIN;
noteB= attr_table.array[__USAT((voiceoffset+ offset1),attr_table.LENGTHPOW)]<<attr_table.GAIN;
noteonB=attr_table.array[__USAT((voiceoffset+ offset1 + seqlength),attr_table.LENGTHPOW)]<<attr_table.GAIN;
noteoffB=attr_table.array[__USAT((voiceoffset+ offsetunQ1+ seqlength + seqlength),attr_table.LENGTHPOW)]<<attr_table.GAIN;


//voiceA*****************************************
//note
if ((inlet_step != prevstep )&&(noteA > (0) )) { 
     holdnoteA = noteA>>20;
     TnoteA = holdnoteA;
}
else {
	TnoteA = holdnoteA;
}

//vel
if ((inlet_step != prevstep )&&(noteonA> 0 )) { 
     holdvelA = noteonA>>20;
     TvelA = holdvelA;
}
else {
	TvelA = holdvelA;
}


if ((noteoffA>0)&&(inlet_stepunQ!=prevstepunQ)){
	TnoteoffA=1;}
else TnoteoffA=0;

if ((noteonA>0)&&(inlet_step!=prevstep)){
	TnoteonA=1;}
else TnoteonA=0;

//voiceB*****************************************
//note
if ((inlet_step != prevstep )&&(noteB > 0) ) { 
     holdnoteB = noteB>>20;
     TnoteB = holdnoteB;
}
else {
	TnoteB = holdnoteB;
}

//vel
if ((inlet_step != prevstep )&&(noteonB> 0 )) { 
     holdvelB = noteonB>>20;
     TvelB = holdvelB;
}
else {
	TvelB = holdvelB;
}


if ((noteoffB>0)&&(inlet_stepunQ!=prevstepunQ)){
	TnoteoffB=1;}
else TnoteoffB=0;

if ((noteonB>0)&&(inlet_step!=prevstep)){
	TnoteonB=1;}
else TnoteonB=0;


if ((TnoteonA>0) && !TntrigA) {
if ((TlastnoteB>0)&&TntrigB){	
MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (inlet_channel),TlastnoteB,__USAT(TvelB,7)); TntrigB=0;
}
MidiSend3((midi_device_t) attr_device, MIDI_NOTE_ON + (inlet_channel),TnoteA,TvelA);  TntrigA=1;
TlastnoteA = TnoteA;
}
if ((TnoteoffA>0) && TntrigA) {MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (inlet_channel),TlastnoteA,__USAT(TvelA,7)); TntrigA=0;}

if ((TnoteonB>0) && !TntrigB) {
if ((TlastnoteA>0)&&TntrigA){
MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (inlet_channel),TlastnoteA,__USAT(TvelA,7)); TntrigA=0;
}
MidiSend3((midi_device_t) attr_device, MIDI_NOTE_ON + (inlet_channel),TnoteB,TvelB);  TntrigB=1;
TlastnoteB = TnoteB;
}
if ((TnoteoffB>0) && TntrigB) {MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (inlet_channel),TlastnoteB,__USAT(TvelB,7)); TntrigB=0;}




offtrig=0;
}
prevoffset=inlet_offset;
prevstep=inlet_step;
prevstepunQ=inlet_stepunQ;
outlet_totaloffset=inlet_offset+voiceoffset+voiceoffset;]]></code.krate>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="a919ffab-f138-4bb2-9193-1455073b35ac" name="tablestore_30" x="672" y="1092">
      <params/>
      <attribs>
         <objref attributeName="table" obj="lcxl2"/>
         <spinner attributeName="seqlength" value="256"/>
         <combo attributeName="device" selection="din"/>
      </attribs>
      <object id="patch/object" uuid="a919ffab-f138-4bb2-9193-1455073b35ac">
         <sDescription>writes and outputs 8 values to a table.</sDescription>
         <author>robert schirmer</author>
         <license>who cares</license>
         <inlets>
            <int32 name="channel"/>
            <bool32 name="play"/>
            <int32 name="offset" description="sets an offset for writing to the table"/>
            <int32 name="step"/>
            <int32 name="stepunQ"/>
         </inlets>
         <outlets>
            <int32 name="totaloffset"/>
         </outlets>
         <displays/>
         <params/>
         <attribs>
            <objref name="table"/>
            <spinner name="seqlength" MinValue="1" MaxValue="10000" DefaultValue="0"/>
            <combo name="device">
               <MenuEntries>
                  <string>din</string>
                  <string>usb host port 1</string>
                  <string>usb host port 2</string>
                  <string>usb host port 3</string>
                  <string>usb host port 4</string>
                  <string>internal port 1</string>
                  <string>internal port 2</string>
                  <string>usb device port 1</string>
               </MenuEntries>
               <CEntries>
                  <string>MIDI_DEVICE_DIN, 1</string>
                  <string>MIDI_DEVICE_USB_HOST, 1</string>
                  <string>MIDI_DEVICE_USB_HOST, 2</string>
                  <string>MIDI_DEVICE_USB_HOST, 3</string>
                  <string>MIDI_DEVICE_USB_HOST, 4</string>
                  <string>MIDI_DEVICE_INTERNAL, 1</string>
                  <string>MIDI_DEVICE_INTERNAL, 2</string>
                  <string>MIDI_DEVICE_USB_DEVICE, 1</string>
               </CEntries>
            </combo>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[int prevchannel;
int steptrig;
int TntrigA;
int TntrigB;
int TlastnoteA;
int TlastnoteB;
int seqlength;
int seqlengthUNQ;
int voiceoffset;
int off1;
int offtrig;
int offset1;
int offsetunQ1;
int noteonA;
int noteoffA;
int noteA;
int holdnoteA;
int holdvelA;
int TnoteA;
int TvelA;
int TnoteonA;
int TnoteoffA;
int noteonB;
int noteoffB;
int noteB;
int holdnoteB;
int holdvelB;
int TnoteB;
int TvelB;
int TnoteonB;
int TnoteoffB;
int prevoffset;
int prevstep;
int prevstepunQ;]]></code.declaration>
         <code.init><![CDATA[noteonA=0;
seqlengthUNQ=(attr_seqlength*32);
seqlength=attr_seqlength;]]></code.init>
         <code.krate><![CDATA[off1= inlet_play;
if ((inlet_channel!=prevchannel)||(inlet_offset!=prevoffset)){
	if ((TntrigB>0)&&(TlastnoteB>0)){
	MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (prevchannel),TlastnoteB,__USAT(TvelB,7)); TntrigB=0;}
	if ((TntrigA>0)&&(TlastnoteA>0)){
	MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (prevchannel),TlastnoteA,__USAT(TvelA,7)); TntrigA=0;}
	prevchannel=inlet_channel;
}
//if (inlet_offset!=prevoffset){
//	if ((TntrigB>0)&&(TlastnoteB>0)){
//	MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (inlet_channel),TlastnoteB,__USAT(TvelB,7)); TntrigB=0;}
//	if ((TntrigA>0)&&(TlastnoteA>0)){
//	MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (inlet_channel),TlastnoteA,__USAT(TvelA,7)); TntrigA=0;}
//}

offset1=(inlet_offset + inlet_step);
offsetunQ1=(inlet_offset + inlet_stepunQ);
voiceoffset=(seqlength+seqlength+seqlengthUNQ);



//1
if (!off1){
TnoteA=0;
TvelA=0;
TnoteonA=0;
TnoteB=0;
TvelB=0;
TnoteonB=0;
if (offtrig==0){

if ((TntrigB>0)&&(TlastnoteB>0)){
MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (inlet_channel),TlastnoteB,__USAT(TvelB,7)); TntrigB=0;}
if ((TntrigA>0)&&(TlastnoteA>0)){
MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (inlet_channel),TlastnoteA,__USAT(TvelA,7)); TntrigA=0;}

offtrig=1;
}}





else if (off1)
{



	noteA= attr_table.array[__USAT((offset1),attr_table.LENGTHPOW)]<<attr_table.GAIN;
noteonA=attr_table.array[__USAT((offset1 + seqlength),attr_table.LENGTHPOW)]<<attr_table.GAIN;
noteoffA=attr_table.array[__USAT((offsetunQ1+ seqlength + seqlength),attr_table.LENGTHPOW)]<<attr_table.GAIN;
noteB= attr_table.array[__USAT((voiceoffset+ offset1),attr_table.LENGTHPOW)]<<attr_table.GAIN;
noteonB=attr_table.array[__USAT((voiceoffset+ offset1 + seqlength),attr_table.LENGTHPOW)]<<attr_table.GAIN;
noteoffB=attr_table.array[__USAT((voiceoffset+ offsetunQ1+ seqlength + seqlength),attr_table.LENGTHPOW)]<<attr_table.GAIN;


//voiceA*****************************************
//note
if ((inlet_step != prevstep )&&(noteA > (0) )) { 
     holdnoteA = noteA>>20;
     TnoteA = holdnoteA;
}
else {
	TnoteA = holdnoteA;
}

//vel
if ((inlet_step != prevstep )&&(noteonA> 0 )) { 
     holdvelA = noteonA>>20;
     TvelA = holdvelA;
}
else {
	TvelA = holdvelA;
}


if ((noteoffA>0)&&(inlet_stepunQ!=prevstepunQ)){
	TnoteoffA=1;}
else TnoteoffA=0;

if ((noteonA>0)&&(inlet_step!=prevstep)){
	TnoteonA=1;}
else TnoteonA=0;

//voiceB*****************************************
//note
if ((inlet_step != prevstep )&&(noteB > 0) ) { 
     holdnoteB = noteB>>20;
     TnoteB = holdnoteB;
}
else {
	TnoteB = holdnoteB;
}

//vel
if ((inlet_step != prevstep )&&(noteonB> 0 )) { 
     holdvelB = noteonB>>20;
     TvelB = holdvelB;
}
else {
	TvelB = holdvelB;
}


if ((noteoffB>0)&&(inlet_stepunQ!=prevstepunQ)){
	TnoteoffB=1;}
else TnoteoffB=0;

if ((noteonB>0)&&(inlet_step!=prevstep)){
	TnoteonB=1;}
else TnoteonB=0;


if ((TnoteonA>0) && !TntrigA) {
if ((TlastnoteB>0)&&TntrigB){	
MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (inlet_channel),TlastnoteB,__USAT(TvelB,7)); TntrigB=0;
}
MidiSend3((midi_device_t) attr_device, MIDI_NOTE_ON + (inlet_channel),TnoteA,TvelA);  TntrigA=1;
TlastnoteA = TnoteA;
}
if ((TnoteoffA>0) && TntrigA) {MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (inlet_channel),TlastnoteA,__USAT(TvelA,7)); TntrigA=0;}

if ((TnoteonB>0) && !TntrigB) {
if ((TlastnoteA>0)&&TntrigA){
MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (inlet_channel),TlastnoteA,__USAT(TvelA,7)); TntrigA=0;
}
MidiSend3((midi_device_t) attr_device, MIDI_NOTE_ON + (inlet_channel),TnoteB,TvelB);  TntrigB=1;
TlastnoteB = TnoteB;
}
if ((TnoteoffB>0) && TntrigB) {MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (inlet_channel),TlastnoteB,__USAT(TvelB,7)); TntrigB=0;}




offtrig=0;
}
prevoffset=inlet_offset;
prevstep=inlet_step;
prevstepunQ=inlet_stepunQ;
outlet_totaloffset=inlet_offset+voiceoffset+voiceoffset;]]></code.krate>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="a919ffab-f138-4bb2-9193-1455073b35ac" name="tablestore_31" x="840" y="1092">
      <params/>
      <attribs>
         <objref attributeName="table" obj="lcxl2"/>
         <spinner attributeName="seqlength" value="256"/>
         <combo attributeName="device" selection="din"/>
      </attribs>
      <object id="patch/object" uuid="a919ffab-f138-4bb2-9193-1455073b35ac">
         <sDescription>writes and outputs 8 values to a table.</sDescription>
         <author>robert schirmer</author>
         <license>who cares</license>
         <inlets>
            <int32 name="channel"/>
            <bool32 name="play"/>
            <int32 name="offset" description="sets an offset for writing to the table"/>
            <int32 name="step"/>
            <int32 name="stepunQ"/>
         </inlets>
         <outlets>
            <int32 name="totaloffset"/>
         </outlets>
         <displays/>
         <params/>
         <attribs>
            <objref name="table"/>
            <spinner name="seqlength" MinValue="1" MaxValue="10000" DefaultValue="0"/>
            <combo name="device">
               <MenuEntries>
                  <string>din</string>
                  <string>usb host port 1</string>
                  <string>usb host port 2</string>
                  <string>usb host port 3</string>
                  <string>usb host port 4</string>
                  <string>internal port 1</string>
                  <string>internal port 2</string>
                  <string>usb device port 1</string>
               </MenuEntries>
               <CEntries>
                  <string>MIDI_DEVICE_DIN, 1</string>
                  <string>MIDI_DEVICE_USB_HOST, 1</string>
                  <string>MIDI_DEVICE_USB_HOST, 2</string>
                  <string>MIDI_DEVICE_USB_HOST, 3</string>
                  <string>MIDI_DEVICE_USB_HOST, 4</string>
                  <string>MIDI_DEVICE_INTERNAL, 1</string>
                  <string>MIDI_DEVICE_INTERNAL, 2</string>
                  <string>MIDI_DEVICE_USB_DEVICE, 1</string>
               </CEntries>
            </combo>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[int prevchannel;
int steptrig;
int TntrigA;
int TntrigB;
int TlastnoteA;
int TlastnoteB;
int seqlength;
int seqlengthUNQ;
int voiceoffset;
int off1;
int offtrig;
int offset1;
int offsetunQ1;
int noteonA;
int noteoffA;
int noteA;
int holdnoteA;
int holdvelA;
int TnoteA;
int TvelA;
int TnoteonA;
int TnoteoffA;
int noteonB;
int noteoffB;
int noteB;
int holdnoteB;
int holdvelB;
int TnoteB;
int TvelB;
int TnoteonB;
int TnoteoffB;
int prevoffset;
int prevstep;
int prevstepunQ;]]></code.declaration>
         <code.init><![CDATA[noteonA=0;
seqlengthUNQ=(attr_seqlength*32);
seqlength=attr_seqlength;]]></code.init>
         <code.krate><![CDATA[off1= inlet_play;
if ((inlet_channel!=prevchannel)||(inlet_offset!=prevoffset)){
	if ((TntrigB>0)&&(TlastnoteB>0)){
	MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (prevchannel),TlastnoteB,__USAT(TvelB,7)); TntrigB=0;}
	if ((TntrigA>0)&&(TlastnoteA>0)){
	MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (prevchannel),TlastnoteA,__USAT(TvelA,7)); TntrigA=0;}
	prevchannel=inlet_channel;
}
//if (inlet_offset!=prevoffset){
//	if ((TntrigB>0)&&(TlastnoteB>0)){
//	MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (inlet_channel),TlastnoteB,__USAT(TvelB,7)); TntrigB=0;}
//	if ((TntrigA>0)&&(TlastnoteA>0)){
//	MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (inlet_channel),TlastnoteA,__USAT(TvelA,7)); TntrigA=0;}
//}

offset1=(inlet_offset + inlet_step);
offsetunQ1=(inlet_offset + inlet_stepunQ);
voiceoffset=(seqlength+seqlength+seqlengthUNQ);



//1
if (!off1){
TnoteA=0;
TvelA=0;
TnoteonA=0;
TnoteB=0;
TvelB=0;
TnoteonB=0;
if (offtrig==0){

if ((TntrigB>0)&&(TlastnoteB>0)){
MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (inlet_channel),TlastnoteB,__USAT(TvelB,7)); TntrigB=0;}
if ((TntrigA>0)&&(TlastnoteA>0)){
MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (inlet_channel),TlastnoteA,__USAT(TvelA,7)); TntrigA=0;}

offtrig=1;
}}





else if (off1)
{



	noteA= attr_table.array[__USAT((offset1),attr_table.LENGTHPOW)]<<attr_table.GAIN;
noteonA=attr_table.array[__USAT((offset1 + seqlength),attr_table.LENGTHPOW)]<<attr_table.GAIN;
noteoffA=attr_table.array[__USAT((offsetunQ1+ seqlength + seqlength),attr_table.LENGTHPOW)]<<attr_table.GAIN;
noteB= attr_table.array[__USAT((voiceoffset+ offset1),attr_table.LENGTHPOW)]<<attr_table.GAIN;
noteonB=attr_table.array[__USAT((voiceoffset+ offset1 + seqlength),attr_table.LENGTHPOW)]<<attr_table.GAIN;
noteoffB=attr_table.array[__USAT((voiceoffset+ offsetunQ1+ seqlength + seqlength),attr_table.LENGTHPOW)]<<attr_table.GAIN;


//voiceA*****************************************
//note
if ((inlet_step != prevstep )&&(noteA > (0) )) { 
     holdnoteA = noteA>>20;
     TnoteA = holdnoteA;
}
else {
	TnoteA = holdnoteA;
}

//vel
if ((inlet_step != prevstep )&&(noteonA> 0 )) { 
     holdvelA = noteonA>>20;
     TvelA = holdvelA;
}
else {
	TvelA = holdvelA;
}


if ((noteoffA>0)&&(inlet_stepunQ!=prevstepunQ)){
	TnoteoffA=1;}
else TnoteoffA=0;

if ((noteonA>0)&&(inlet_step!=prevstep)){
	TnoteonA=1;}
else TnoteonA=0;

//voiceB*****************************************
//note
if ((inlet_step != prevstep )&&(noteB > 0) ) { 
     holdnoteB = noteB>>20;
     TnoteB = holdnoteB;
}
else {
	TnoteB = holdnoteB;
}

//vel
if ((inlet_step != prevstep )&&(noteonB> 0 )) { 
     holdvelB = noteonB>>20;
     TvelB = holdvelB;
}
else {
	TvelB = holdvelB;
}


if ((noteoffB>0)&&(inlet_stepunQ!=prevstepunQ)){
	TnoteoffB=1;}
else TnoteoffB=0;

if ((noteonB>0)&&(inlet_step!=prevstep)){
	TnoteonB=1;}
else TnoteonB=0;


if ((TnoteonA>0) && !TntrigA) {
if ((TlastnoteB>0)&&TntrigB){	
MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (inlet_channel),TlastnoteB,__USAT(TvelB,7)); TntrigB=0;
}
MidiSend3((midi_device_t) attr_device, MIDI_NOTE_ON + (inlet_channel),TnoteA,TvelA);  TntrigA=1;
TlastnoteA = TnoteA;
}
if ((TnoteoffA>0) && TntrigA) {MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (inlet_channel),TlastnoteA,__USAT(TvelA,7)); TntrigA=0;}

if ((TnoteonB>0) && !TntrigB) {
if ((TlastnoteA>0)&&TntrigA){
MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (inlet_channel),TlastnoteA,__USAT(TvelA,7)); TntrigA=0;
}
MidiSend3((midi_device_t) attr_device, MIDI_NOTE_ON + (inlet_channel),TnoteB,TvelB);  TntrigB=1;
TlastnoteB = TnoteB;
}
if ((TnoteoffB>0) && TntrigB) {MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (inlet_channel),TlastnoteB,__USAT(TvelB,7)); TntrigB=0;}




offtrig=0;
}
prevoffset=inlet_offset;
prevstep=inlet_step;
prevstepunQ=inlet_stepunQ;
outlet_totaloffset=inlet_offset+voiceoffset+voiceoffset;]]></code.krate>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="a919ffab-f138-4bb2-9193-1455073b35ac" name="tablestore_32" x="994" y="1092">
      <params/>
      <attribs>
         <objref attributeName="table" obj="lcxl2"/>
         <spinner attributeName="seqlength" value="256"/>
         <combo attributeName="device" selection="din"/>
      </attribs>
      <object id="patch/object" uuid="a919ffab-f138-4bb2-9193-1455073b35ac">
         <sDescription>writes and outputs 8 values to a table.</sDescription>
         <author>robert schirmer</author>
         <license>who cares</license>
         <inlets>
            <int32 name="channel"/>
            <bool32 name="play"/>
            <int32 name="offset" description="sets an offset for writing to the table"/>
            <int32 name="step"/>
            <int32 name="stepunQ"/>
         </inlets>
         <outlets>
            <int32 name="totaloffset"/>
         </outlets>
         <displays/>
         <params/>
         <attribs>
            <objref name="table"/>
            <spinner name="seqlength" MinValue="1" MaxValue="10000" DefaultValue="0"/>
            <combo name="device">
               <MenuEntries>
                  <string>din</string>
                  <string>usb host port 1</string>
                  <string>usb host port 2</string>
                  <string>usb host port 3</string>
                  <string>usb host port 4</string>
                  <string>internal port 1</string>
                  <string>internal port 2</string>
                  <string>usb device port 1</string>
               </MenuEntries>
               <CEntries>
                  <string>MIDI_DEVICE_DIN, 1</string>
                  <string>MIDI_DEVICE_USB_HOST, 1</string>
                  <string>MIDI_DEVICE_USB_HOST, 2</string>
                  <string>MIDI_DEVICE_USB_HOST, 3</string>
                  <string>MIDI_DEVICE_USB_HOST, 4</string>
                  <string>MIDI_DEVICE_INTERNAL, 1</string>
                  <string>MIDI_DEVICE_INTERNAL, 2</string>
                  <string>MIDI_DEVICE_USB_DEVICE, 1</string>
               </CEntries>
            </combo>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[int prevchannel;
int steptrig;
int TntrigA;
int TntrigB;
int TlastnoteA;
int TlastnoteB;
int seqlength;
int seqlengthUNQ;
int voiceoffset;
int off1;
int offtrig;
int offset1;
int offsetunQ1;
int noteonA;
int noteoffA;
int noteA;
int holdnoteA;
int holdvelA;
int TnoteA;
int TvelA;
int TnoteonA;
int TnoteoffA;
int noteonB;
int noteoffB;
int noteB;
int holdnoteB;
int holdvelB;
int TnoteB;
int TvelB;
int TnoteonB;
int TnoteoffB;
int prevoffset;
int prevstep;
int prevstepunQ;]]></code.declaration>
         <code.init><![CDATA[noteonA=0;
seqlengthUNQ=(attr_seqlength*32);
seqlength=attr_seqlength;]]></code.init>
         <code.krate><![CDATA[off1= inlet_play;
if ((inlet_channel!=prevchannel)||(inlet_offset!=prevoffset)){
	if ((TntrigB>0)&&(TlastnoteB>0)){
	MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (prevchannel),TlastnoteB,__USAT(TvelB,7)); TntrigB=0;}
	if ((TntrigA>0)&&(TlastnoteA>0)){
	MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (prevchannel),TlastnoteA,__USAT(TvelA,7)); TntrigA=0;}
	prevchannel=inlet_channel;
}
//if (inlet_offset!=prevoffset){
//	if ((TntrigB>0)&&(TlastnoteB>0)){
//	MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (inlet_channel),TlastnoteB,__USAT(TvelB,7)); TntrigB=0;}
//	if ((TntrigA>0)&&(TlastnoteA>0)){
//	MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (inlet_channel),TlastnoteA,__USAT(TvelA,7)); TntrigA=0;}
//}

offset1=(inlet_offset + inlet_step);
offsetunQ1=(inlet_offset + inlet_stepunQ);
voiceoffset=(seqlength+seqlength+seqlengthUNQ);



//1
if (!off1){
TnoteA=0;
TvelA=0;
TnoteonA=0;
TnoteB=0;
TvelB=0;
TnoteonB=0;
if (offtrig==0){

if ((TntrigB>0)&&(TlastnoteB>0)){
MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (inlet_channel),TlastnoteB,__USAT(TvelB,7)); TntrigB=0;}
if ((TntrigA>0)&&(TlastnoteA>0)){
MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (inlet_channel),TlastnoteA,__USAT(TvelA,7)); TntrigA=0;}

offtrig=1;
}}





else if (off1)
{



	noteA= attr_table.array[__USAT((offset1),attr_table.LENGTHPOW)]<<attr_table.GAIN;
noteonA=attr_table.array[__USAT((offset1 + seqlength),attr_table.LENGTHPOW)]<<attr_table.GAIN;
noteoffA=attr_table.array[__USAT((offsetunQ1+ seqlength + seqlength),attr_table.LENGTHPOW)]<<attr_table.GAIN;
noteB= attr_table.array[__USAT((voiceoffset+ offset1),attr_table.LENGTHPOW)]<<attr_table.GAIN;
noteonB=attr_table.array[__USAT((voiceoffset+ offset1 + seqlength),attr_table.LENGTHPOW)]<<attr_table.GAIN;
noteoffB=attr_table.array[__USAT((voiceoffset+ offsetunQ1+ seqlength + seqlength),attr_table.LENGTHPOW)]<<attr_table.GAIN;


//voiceA*****************************************
//note
if ((inlet_step != prevstep )&&(noteA > (0) )) { 
     holdnoteA = noteA>>20;
     TnoteA = holdnoteA;
}
else {
	TnoteA = holdnoteA;
}

//vel
if ((inlet_step != prevstep )&&(noteonA> 0 )) { 
     holdvelA = noteonA>>20;
     TvelA = holdvelA;
}
else {
	TvelA = holdvelA;
}


if ((noteoffA>0)&&(inlet_stepunQ!=prevstepunQ)){
	TnoteoffA=1;}
else TnoteoffA=0;

if ((noteonA>0)&&(inlet_step!=prevstep)){
	TnoteonA=1;}
else TnoteonA=0;

//voiceB*****************************************
//note
if ((inlet_step != prevstep )&&(noteB > 0) ) { 
     holdnoteB = noteB>>20;
     TnoteB = holdnoteB;
}
else {
	TnoteB = holdnoteB;
}

//vel
if ((inlet_step != prevstep )&&(noteonB> 0 )) { 
     holdvelB = noteonB>>20;
     TvelB = holdvelB;
}
else {
	TvelB = holdvelB;
}


if ((noteoffB>0)&&(inlet_stepunQ!=prevstepunQ)){
	TnoteoffB=1;}
else TnoteoffB=0;

if ((noteonB>0)&&(inlet_step!=prevstep)){
	TnoteonB=1;}
else TnoteonB=0;


if ((TnoteonA>0) && !TntrigA) {
if ((TlastnoteB>0)&&TntrigB){	
MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (inlet_channel),TlastnoteB,__USAT(TvelB,7)); TntrigB=0;
}
MidiSend3((midi_device_t) attr_device, MIDI_NOTE_ON + (inlet_channel),TnoteA,TvelA);  TntrigA=1;
TlastnoteA = TnoteA;
}
if ((TnoteoffA>0) && TntrigA) {MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (inlet_channel),TlastnoteA,__USAT(TvelA,7)); TntrigA=0;}

if ((TnoteonB>0) && !TntrigB) {
if ((TlastnoteA>0)&&TntrigA){
MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (inlet_channel),TlastnoteA,__USAT(TvelA,7)); TntrigA=0;
}
MidiSend3((midi_device_t) attr_device, MIDI_NOTE_ON + (inlet_channel),TnoteB,TvelB);  TntrigB=1;
TlastnoteB = TnoteB;
}
if ((TnoteoffB>0) && TntrigB) {MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (inlet_channel),TlastnoteB,__USAT(TvelB,7)); TntrigB=0;}




offtrig=0;
}
prevoffset=inlet_offset;
prevstep=inlet_step;
prevstepunQ=inlet_stepunQ;
outlet_totaloffset=inlet_offset+voiceoffset+voiceoffset;]]></code.krate>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="a919ffab-f138-4bb2-9193-1455073b35ac" name="tablestore_13" x="1162" y="1092">
      <params/>
      <attribs>
         <objref attributeName="table" obj="lcxl2"/>
         <spinner attributeName="seqlength" value="256"/>
      </attribs>
      <object id="patch/object" uuid="a919ffab-f138-4bb2-9193-1455073b35ac">
         <sDescription>writes and outputs 8 values to a table.</sDescription>
         <author>robert schirmer</author>
         <license>who cares</license>
         <inlets>
            <int32 name="channel"/>
            <bool32 name="rec"/>
            <int32 name="offset" description="sets an offset for writing to the table"/>
            <int32 name="stepunQ"/>
         </inlets>
         <outlets>
            <int32 name="offset"/>
         </outlets>
         <displays/>
         <params/>
         <attribs>
            <objref name="table"/>
            <spinner name="seqlength" MinValue="1" MaxValue="10000" DefaultValue="0"/>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[uint32_t i;
uint32_t ii;
int32_t _bend;
int32_t Btrig;
int32_t _press;
int channel;
int cc;
int ccv;
int innote;
int invel;
int inputnote;
int inputvel;
int inputnoteon;
int inputnoteoff;
int ingate;
int ingate2;
int inntrig;
int inytrig;
int op;
int Atrig;
int notecount;
int seqlength;
int seqlengthUNQ;
int splat;
int clear;
int ntrig;
int rtrig;
int speed;
int off1;
int recoffset1g;
int voiceoffset;
int offset;
int offset1;
int totaloffset;
int offsetg;
int offset1g;
int early;
int offsetunQ1;
int offsetunQ1g;
int noteon;
int noteoff;
int ytrig;
int xtrig;
int prevsteprec;
int prevstep;
int prevstepunQ;
int prevx;
int prevy;]]></code.declaration>
         <code.init><![CDATA[seqlengthUNQ=(attr_seqlength*32);
seqlength=attr_seqlength;
_bend=0;
_press=0;]]></code.init>
         <code.krate><![CDATA[off1= !inlet_rec;
channel=inlet_channel;
offset=inlet_offset;

//1
if (!off1){
	if(inlet_stepunQ!=prevstepunQ){
	attr_table.array[offset + inlet_stepunQ]=__SSAT(_bend,28)>>attr_table.GAIN;
	attr_table.array[offset + inlet_stepunQ + seqlengthUNQ]=__SSAT(_press,28)>>attr_table.GAIN;
	attr_table.array[offset + inlet_stepunQ + seqlengthUNQ + seqlengthUNQ]=__SSAT(cc,28)>>attr_table.GAIN;
	attr_table.array[offset + inlet_stepunQ + seqlengthUNQ + seqlengthUNQ + seqlengthUNQ]=__SSAT(ccv,28)>>attr_table.GAIN;
	prevstepunQ=inlet_stepunQ;
	}
}


else if (off1)
{
	_bend=0;
	_press=0;
	cc=0;
	ccv=0;
}

outlet_offset=inlet_offset+seqlengthUNQ+seqlengthUNQ+seqlengthUNQ+seqlengthUNQ;]]></code.krate>
         <code.midihandler><![CDATA[if (status == MIDI_PITCH_BEND + (channel)) {  _bend = ((int)((data2<<7)+data1)-0x2000)<<14;
}
if (status == MIDI_CHANNEL_PRESSURE + (channel)) {  _press = (data1)<<20;
}
if (status == (channel) + MIDI_CONTROL_CHANGE) {
  ccv = data2<<20;
  cc = data1<<20;
}]]></code.midihandler>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="a919ffab-f138-4bb2-9193-1455073b35ac" name="tablestore_14" x="1288" y="1092">
      <params/>
      <attribs>
         <objref attributeName="table" obj="lcxl2"/>
         <spinner attributeName="seqlength" value="256"/>
         <combo attributeName="device" selection="din"/>
      </attribs>
      <object id="patch/object" uuid="a919ffab-f138-4bb2-9193-1455073b35ac">
         <sDescription>writes and outputs 8 values to a table.</sDescription>
         <author>robert schirmer</author>
         <license>who cares</license>
         <inlets>
            <int32 name="channel"/>
            <bool32 name="play"/>
            <int32 name="offset" description="sets an offset for writing to the table"/>
            <int32 name="step"/>
            <int32 name="stepunQ"/>
         </inlets>
         <outlets>
            <int32 name="totaloffset"/>
         </outlets>
         <displays/>
         <params/>
         <attribs>
            <objref name="table"/>
            <spinner name="seqlength" MinValue="1" MaxValue="10000" DefaultValue="0"/>
            <combo name="device">
               <MenuEntries>
                  <string>din</string>
                  <string>usb host port 1</string>
                  <string>usb host port 2</string>
                  <string>usb host port 3</string>
                  <string>usb host port 4</string>
                  <string>internal port 1</string>
                  <string>internal port 2</string>
                  <string>usb device port 1</string>
               </MenuEntries>
               <CEntries>
                  <string>MIDI_DEVICE_DIN, 1</string>
                  <string>MIDI_DEVICE_USB_HOST, 1</string>
                  <string>MIDI_DEVICE_USB_HOST, 2</string>
                  <string>MIDI_DEVICE_USB_HOST, 3</string>
                  <string>MIDI_DEVICE_USB_HOST, 4</string>
                  <string>MIDI_DEVICE_INTERNAL, 1</string>
                  <string>MIDI_DEVICE_INTERNAL, 2</string>
                  <string>MIDI_DEVICE_USB_DEVICE, 1</string>
               </CEntries>
            </combo>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[int prevchannel;
int steptrigger;
int seqlength;
int seqlengthUNQ;
int off1;
int offtrig;
int offsetunQ1;
int bend;
int bendA;
int bendB;
int touch;
int cc;
int ccv;
int prevbend;
int prevbendB;
int prevtouch;
int prevcc;
int prevccv;
int prevoffset;
int prevstepunQ;]]></code.declaration>
         <code.init><![CDATA[seqlengthUNQ=(attr_seqlength*32);
seqlength=attr_seqlength;
bendB=64;
bendA=0;
bend=0;
prevbendB=64;]]></code.init>
         <code.krate><![CDATA[off1= inlet_play;
if (inlet_channel!=prevchannel){
	if (prevbendB!=64){
	MidiSend3((midi_device_t) attr_device , MIDI_PITCH_BEND + (inlet_channel),0,64);prevbendB=64;
	}
	if (touch>0){
	MidiSend2((midi_device_t) attr_device, MIDI_CHANNEL_PRESSURE + (inlet_channel),0>>20);
	}
	prevchannel=inlet_channel;
}


offsetunQ1=(inlet_offset + inlet_stepunQ);

if (inlet_offset!=prevoffset){
	if (prevbendB!=64){
MidiSend3((midi_device_t) attr_device , MIDI_PITCH_BEND + (inlet_channel),0,64);prevbendB=64;
}
if (touch>0){
MidiSend2((midi_device_t) attr_device, MIDI_CHANNEL_PRESSURE + (inlet_channel),0>>20);
}
prevoffset=inlet_offset;
}

if (!off1){

if (offtrig==0){
//TnoteoffA=1;
//TnoteoffB=1;
if (prevbendB!=64){
MidiSend3((midi_device_t) attr_device , MIDI_PITCH_BEND + (inlet_channel),0,64);prevbendB=64;
}
if (touch>0){
MidiSend2((midi_device_t) attr_device, MIDI_CHANNEL_PRESSURE + (inlet_channel),0>>20);
}
offtrig=1;
}
bendB=64;
bendA=0;
bend=0;
touch=0;
}





else if (off1)
{
	if ((inlet_stepunQ==0)&&!steptrigger){
	if (prevbendB!=64){
		
	MidiSend3((midi_device_t) attr_device , MIDI_PITCH_BEND + (inlet_channel),0,64);prevbendB=64;}
	if (touch>0){
	MidiSend2((midi_device_t) attr_device, MIDI_CHANNEL_PRESSURE + (inlet_channel),0>>20);touch=0;}
	steptrigger=1;
}
if (inlet_stepunQ>0){
	steptrigger=0;
}
bend=attr_table.array[__USAT((offsetunQ1),attr_table.LENGTHPOW)]<<attr_table.GAIN;
bendA=(bend>>14)&0x7F;
bendB=(bend>>21)+64;
touch=attr_table.array[__USAT((offsetunQ1+ seqlengthUNQ),attr_table.LENGTHPOW)]<<attr_table.GAIN;
cc=attr_table.array[__USAT((offsetunQ1+ seqlengthUNQ+ seqlengthUNQ),attr_table.LENGTHPOW)]<<attr_table.GAIN;
ccv=attr_table.array[__USAT((offsetunQ1+ seqlengthUNQ+ seqlengthUNQ+ seqlengthUNQ),attr_table.LENGTHPOW)]<<attr_table.GAIN;

//pitchbend
if ((inlet_stepunQ!=prevstepunQ)&&(bendB!=prevbendB)){
MidiSend3((midi_device_t) attr_device , MIDI_PITCH_BEND + (inlet_channel),bendA,bendB);
prevbend=bend;
prevbendB=bendB;
}
//aftertouch
if ((touch!=prevtouch)&&(inlet_stepunQ!=prevstepunQ)){
MidiSend2((midi_device_t) attr_device, MIDI_CHANNEL_PRESSURE + (inlet_channel),touch>>20);
prevtouch=touch;
}
if (((ccv!=prevccv)||(cc!=prevcc))&&(inlet_stepunQ!=prevstepunQ)){
	MidiSend3((midi_device_t) attr_device, MIDI_CONTROL_CHANGE + (inlet_channel),(cc>>20),__USAT(ccv>>20,7));
	prevcc=cc;
	prevccv=ccv;
}

}

prevstepunQ=inlet_stepunQ;
outlet_totaloffset=inlet_offset+seqlengthUNQ+seqlengthUNQ+seqlengthUNQ+seqlengthUNQ;]]></code.krate>
      </object>
   </patchobj>
   <comment type="patch/comment" x="98" y="1316" text="audio thru"/>
   <obj type="audio/in stereo" uuid="99848ad6d90a8e615e83b2e619cfc806f28e7281" name="in_1" x="98" y="1330">
      <params/>
      <attribs/>
   </obj>
   <obj type="audio/out stereo" uuid="a1ca7a567f535acc21055669829101d3ee7f0189" name="out_1" x="182" y="1330">
      <params/>
      <attribs/>
   </obj>
   <comment type="patch/comment" x="1694" y="1372" text="song record/playback"/>
   <comment type="patch/comment" x="448" y="1386" text="metronom"/>
   <obj type="const/i" uuid="e202f44b2df17ae0b3e663b98ea6b14c8ff00408" name="i_1" x="1722" y="1386">
      <params/>
      <attribs>
         <spinner attributeName="value" value="3"/>
      </attribs>
   </obj>
   <obj type="logic/counter" uuid="7a141ba82230e54e5f5cd12da5dbe5a74ba854a5" name="counter_1" x="448" y="1400">
      <params>
         <int32 name="maximum" value="4"/>
      </params>
      <attribs/>
   </obj>
   <obj type="logic/or 2" uuid="3805d3c84d30032a44fbdbe42d9a2988a1790a3e" name="or_3" x="546" y="1400">
      <params/>
      <attribs/>
   </obj>
   <obj type="logic/counter" uuid="7a141ba82230e54e5f5cd12da5dbe5a74ba854a5" name="counter_3" x="630" y="1400">
      <params>
         <int32 name="maximum" value="4"/>
      </params>
      <attribs/>
   </obj>
   <comment type="patch/comment" x="924" y="1428" text="metronom vol"/>
   <obj type="logic/and 2" uuid="c67031682f552aa0a80b23377495c51ea28a8c9c" name="and_8" x="840" y="1442">
      <params/>
      <attribs/>
   </obj>
   <obj type="wave/flashplay" uuid="595422aa-8767-45a8-ae08-bd8ac0247c61" name="flashplay_1" x="910" y="1442">
      <params/>
      <attribs>
         <combo attributeName="sample" selection="808hatclose"/>
      </attribs>
   </obj>
   <obj type="ctrl/dial p" uuid="cc5d2846c3d50e425f450c4b9851371b54f4d674" name="dial_1" x="1008" y="1442">
      <params>
         <frac32.u.map name="value" value="0.0"/>
      </params>
      <attribs/>
   </obj>
   <obj type="math/*" uuid="3ac307b9f782049739ed62504081b96d580ea336" name="*_1" x="1078" y="1442">
      <params/>
      <attribs/>
   </obj>
   <obj type="audio/out stereo" uuid="a1ca7a567f535acc21055669829101d3ee7f0189" name="out_2" x="1134" y="1442">
      <params/>
      <attribs/>
   </obj>
   <patchobj type="patch/object" uuid="819b4f9b-3a2b-4f9b-a805-306ca4c0e026" name="step_5" x="1694" y="1442">
      <params/>
      <attribs>
         <objref attributeName="table" obj="lcxl3"/>
      </attribs>
      <object id="patch/object" uuid="819b4f9b-3a2b-4f9b-a805-306ca4c0e026">
         <sDescription>set an element inside a table to &apos;value&apos;.if parameter &apos;ifon&apos; is high,the element will only be set to &apos;value&apos; if it&apos;s &gt; 0.</sDescription>
         <author>Robert Schirmer</author>
         <license>BSD</license>
         <helpPatch>step_seq.axh</helpPatch>
         <inlets>
            <bool32 name="trig"/>
            <bool32 name="r"/>
            <bool32 name="pulse"/>
            <int32.positive name="offset" description="offset in the table"/>
         </inlets>
         <outlets/>
         <displays/>
         <params/>
         <attribs>
            <objref name="table"/>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[int8_t _note;
uint8_t cc [128];
int32_t _gate;
uint32_t i;
uint32_t ii;
uint32_t src;
uint32_t dst;
uint32_t range;
uint32_t block;
int maxbar;
int maxBcount;
int prevBcount;
int Ptrig;
int Bcount;
int speed;
int rectrig;
int ctrig;
int ttrig;
int full;
int rec;
int play;
int trig;
int wtrig;
int wait;
int waitB;
int recnote;
int note;
int lastnote;
int count;
int ntrig;
int xtrig;
int ztrig;
int rtrig;
int prev;
int hold;
int prevhold;
int outletvhold;
int outlettrig;
int value;
int valueO;]]></code.declaration>
         <code.krate><![CDATA[full=attr_table.array[__USAT(1,attr_table.LENGTHPOW)]<<attr_table.GAIN;


maxbar=(attr_table.array[__USAT(2,attr_table.LENGTHPOW)]<<attr_table.GAIN)>>21;


//midi in
note= _note<<21;
recnote= (((note>>1)+(1<<26))+(1<<21));

//transport
if ((cc[110])&&(!(cc[111]))){wait=1;MidiSend3((midi_device_t) MIDI_DEVICE_USB_HOST, 1, MIDI_CONTROL_CHANGE, (110), 17);}
if (cc[109]){waitB=1;MidiSend3((midi_device_t) MIDI_DEVICE_USB_HOST, 1, MIDI_CONTROL_CHANGE, (110), 17);}
if ((inlet_pulse)&&(wait)) {trig=1;wait=0;count=0;maxBcount=0;}
if ((inlet_pulse)&&(waitB)) {
		waitB=0;
		play=0;
		rec=0;
		MidiSend3((midi_device_t) MIDI_DEVICE_USB_HOST, 1, MIDI_CONTROL_CHANGE, (110), 16);
}
if (!inlet_pulse){trig=0;}

if ((trig)&&(!full)){
	rec=1;
	rectrig=1;
	Bcount=0;
	attr_table.array[1]=__SSAT(0x07FFFFFF,28)>>attr_table.GAIN;
	MidiSend3((midi_device_t) MIDI_DEVICE_USB_HOST, 1, MIDI_CONTROL_CHANGE, (110), 3);
}
else if ((trig)&&(full)){
	if (rec) {rec=0;play=1;
	attr_table.array[2]=__SSAT(((Bcount)<<21),28)>>attr_table.GAIN;
	Bcount=0;
	MidiSend3((midi_device_t) MIDI_DEVICE_USB_HOST, 1, MIDI_CONTROL_CHANGE, (110), 48);
	}
	else if ((!rec)&&(play)) {play=0;MidiSend3((midi_device_t) MIDI_DEVICE_USB_HOST, 1, MIDI_CONTROL_CHANGE, (110), 16);}
	else if ((!rec)&&(!play)) {play=1;Bcount=0;MidiSend3((midi_device_t) MIDI_DEVICE_USB_HOST, 1, MIDI_CONTROL_CHANGE, (110), 48);}
}


//count
if ((inlet_trig>0) && !ztrig) {
   count += 1; if (count>=7008) {count = 0;}
   ztrig=1;
}
else if (!(inlet_trig>0)) ztrig=0;
if ((inlet_r>0) && !rtrig) {count=0;Bcount=0; rtrig = 1;}
else if (!(inlet_r>0)) rtrig=0;

//barcount
if ((inlet_pulse>0) && !Ptrig) {
   prevBcount=Bcount;
   maxBcount+=1;
   Bcount += 1; 
   if (Bcount>=438) {Bcount=0;}
   if ((maxBcount>=maxbar)&&(!rec)) {maxBcount=0;count=0;}
   Ptrig=1;
}
else if (!(inlet_pulse>0)) Ptrig=0;





//record
if (!(_gate>0)) ntrig=0;

        if ((_gate>0)&&(rec) && !ntrig) {
      ntrig=1;
      attr_table.array[count + inlet_offset]=__SSAT(recnote,28)>>attr_table.GAIN;
   }
   if (!(_gate>0)) ntrig=0;

//play
value= attr_table.array[__USAT((count+ inlet_offset),attr_table.LENGTHPOW)]<<attr_table.GAIN;
valueO= ((value-(1<<21))-(1<<26))<<1;

if ((count != prev ) && (value > 0 )) { 
     hold = valueO;
     outletvhold = hold;	
}else {
	outletvhold = hold;	
}
if ((outletvhold!=prevhold)&&(play)){
	outlettrig=1;
}
else outlettrig=0;

prevhold=outletvhold;
prev = count;

//midi out
if ((outlettrig>0) && !xtrig) {
lastnote = (64+(outletvhold>>21))&0x7F;
MidiSend3((midi_device_t) MIDI_DEVICE_INTERNAL, 1, MIDI_NOTE_ON + 0,lastnote,126);  xtrig=1;
}
if (!(outlettrig>0) && xtrig) {MidiSend3((midi_device_t) MIDI_DEVICE_INTERNAL, 1, MIDI_NOTE_ON + 0,lastnote,0); xtrig=0;}

//clear
speed = 16 << 4;
src = 1;
dst = 1;
range = 7001;

block  = (range / speed) * speed;

if ((cc[110])&&(cc[111])&&(!ctrig)){
ctrig = 1;
i = 0;
ttrig = 0;
play=0;
rec=0;
wait=0;
MidiSend3((midi_device_t) MIDI_DEVICE_USB_HOST, 1, MIDI_CONTROL_CHANGE, (110), 0);
}

if ((i == range) && (!((cc[110])&&(cc[111])))) {ctrig = 0;i = 0;}


//copy n chunks of size 'speed'
if (ctrig && (i < block)){ 
	{ 
  for(ii=0;ii<speed;ii++)
  attr_table.array[(i + ii + dst)]= (( attr_table.array[(i + ii + src)] + (attr_table.array[(i + ii + dst)] * 0)) * (0));
  }
  i += speed;	
}

//copy what's left
if (i == block) ttrig = 1; 

if ((ctrig && ttrig) && (i < (range))){ 
	attr_table.array[(i + dst)]= (( attr_table.array[(i + src)] + (attr_table.array[(i + dst)] * 0)) * (0));
   i += 1;  
 }




rectrig=0;]]></code.krate>
         <code.midihandler><![CDATA[if (dev == MIDI_DEVICE_USB_HOST && port == 1){

if ((status == MIDI_NOTE_ON + 0) && (data2)) {
  _note = data1-64;
  _gate = 1<<27;
} else if (((status == MIDI_NOTE_ON + 0) && (!data2))||
          (status == MIDI_NOTE_OFF + 0)) {
  if (_note == data1-64) {
    _gate = 0;
  }
}
if (status == 0 + MIDI_CONTROL_CHANGE) cc[data1] = data2; 
}]]></code.midihandler>
      </object>
   </patchobj>
   <obj type="const/i" uuid="e202f44b2df17ae0b3e663b98ea6b14c8ff00408" name="i_7" x="434" y="1470">
      <params/>
      <attribs>
         <spinner attributeName="value" value="0"/>
      </attribs>
   </obj>
   <obj type="math/==" uuid="deaf0d36642c57876c4101e86f8a0b6a06021ab2" name="==_2" x="546" y="1470">
      <params/>
      <attribs/>
   </obj>
   <obj type="logic/or 2" uuid="3805d3c84d30032a44fbdbe42d9a2988a1790a3e" name="or_1" x="644" y="1470">
      <params/>
      <attribs/>
   </obj>
   <obj type="timer/pulselength" uuid="ca68725237d8ba8407773340801660a9fd9b0dba" name="pulselength_1" x="714" y="1470">
      <params>
         <frac32.s.map name="delay" value="-11.0"/>
      </params>
      <attribs/>
   </obj>
   <comment type="patch/comment" x="1276" y="1581" text="save all to sd card"/>
   <patchobj type="patch/object" uuid="27a4893e-93bb-4a7c-b41c-0b02da02cbed" name="keyb_2" x="1190" y="1596">
      <params/>
      <attribs/>
      <object id="patch/object" uuid="27a4893e-93bb-4a7c-b41c-0b02da02cbed">
         <sDescription>Monophonic MIDI keyboard note input, gate, velocity and release velocity</sDescription>
         <author>Johannes Taelman</author>
         <license>BSD</license>
         <helpPatch>midi_in.axh</helpPatch>
         <inlets/>
         <outlets>
            <bool32 name="gate" description="key pressed?"/>
         </outlets>
         <displays/>
         <params/>
         <attribs/>
         <includes/>
         <code.declaration><![CDATA[uint8_t _gate;
int ccv;]]></code.declaration>
         <code.init><![CDATA[_gate = 0;
]]></code.init>
         <code.krate><![CDATA[if (ccv&&_gate){
	outlet_gate=1;
}
else outlet_gate=0;]]></code.krate>
         <code.midihandler><![CDATA[if ((status == MIDI_NOTE_ON + 8) && (data2)) {
	if (data1 == 108) {
   _gate = 1;
}
	if (data1 == 107) {
   ccv = 1;
}
}
 else if (((status == MIDI_NOTE_ON + 8) && (!data2))||          (status == MIDI_NOTE_OFF + 8)) {
  
    _gate = 0;
    ccv=0;
  
}]]></code.midihandler>
      </object>
   </patchobj>
   <obj type="string/c" uuid="4aa90a90c435a742ddfa152d232883fc5b2f1b3" name="c_1" x="1274" y="1596">
      <params/>
      <attribs>
         <table attributeName="str" table="/abletone"/>
      </attribs>
   </obj>
   <obj type="table/save" uuid="3e4108b607d56d9e1cd10abb898b58eea11e53b2" name="save_1" x="1428" y="1596">
      <params/>
      <attribs>
         <objref attributeName="table" obj="lcxl2"/>
      </attribs>
   </obj>
   <obj type="string/c" uuid="4aa90a90c435a742ddfa152d232883fc5b2f1b3" name="c_2" x="1568" y="1596">
      <params/>
      <attribs>
         <table attributeName="str" table="/abletones"/>
      </attribs>
   </obj>
   <obj type="table/save" uuid="3e4108b607d56d9e1cd10abb898b58eea11e53b2" name="save_2" x="1722" y="1596">
      <params/>
      <attribs>
         <objref attributeName="table" obj="lcxl3"/>
      </attribs>
   </obj>
   <obj type="logic/or 2" uuid="3805d3c84d30032a44fbdbe42d9a2988a1790a3e" name="or_9" x="364" y="1666">
      <params/>
      <attribs/>
   </obj>
   <obj type="logic/counter" uuid="7a141ba82230e54e5f5cd12da5dbe5a74ba854a5" name="counter_4" x="434" y="1666">
      <params>
         <int32 name="maximum" value="2"/>
      </params>
      <attribs/>
   </obj>
   <obj type="logic/flipflop toggle" uuid="195e489e5fc3d275944b0de56c7a91c8641ea22a" name="flipflop_2" x="546" y="1666">
      <params/>
      <attribs/>
   </obj>
   <comment type="patch/comment" x="938" y="1680" text="send launch pad transport to trevor"/>
   <obj type="timer/delayedpulse" uuid="3f05ee534ca67755fb20c7437f9e4de3d4c2f73d" name="delayedpulse_2" x="742" y="1694">
      <params>
         <frac32.s.map name="delay" value="-29.0"/>
      </params>
      <attribs/>
   </obj>
   <patchobj type="patch/object" uuid="2aae03bf-7545-4913-89b5-403575d14e1e" name="object_7" x="938" y="1694">
      <params/>
      <attribs>
         <spinner attributeName="column" value="5"/>
      </attribs>
      <object id="patch/object" uuid="2aae03bf-7545-4913-89b5-403575d14e1e">
         <inlets>
            <bool32 name="bartrig"/>
            <bool32 name="play"/>
            <bool32 name="pulser"/>
            <bool32 name="pulse"/>
         </inlets>
         <outlets/>
         <displays/>
         <params/>
         <attribs>
            <spinner name="column" MinValue="1" MaxValue="8" DefaultValue="1"/>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[int note;
int trigger;
int clipslot;
int prevclipslot;
int ctrig;
int colour;
int prevcolour;
int ntrig;
int wait;
int wtrig;
int strig;
int play;
int32_t map[8];]]></code.declaration>
         <code.init><![CDATA[clipslot=0;
//prevclipslot=666;
strig=1;
ctrig=0;
{ 
  int i;
  for(i=0;i<8;i++) 

  map[0] = 0+(attr_column-1);
map[1] = 16+(attr_column-1);
map[2] = 32+(attr_column-1);
map[3] = 48+(attr_column-1);
map[4] = 64+(attr_column-1);
map[5] = 80+(attr_column-1);
map[6] = 96+(attr_column-1);
map[7] = 112+(attr_column-1);

}]]></code.init>
         <code.krate><![CDATA[if (((note==(0+(attr_column-1)))||(note==8))&&trigger) {clipslot=0;wait=1;}
if (((note==(16+(attr_column-1)))||(note==24))&&trigger) {clipslot=1;wait=1;}
if (((note==(32+(attr_column-1)))||(note==40))&&trigger) {clipslot=2;wait=1;}
if (((note==(48+(attr_column-1)))||(note==56))&&trigger) {clipslot=3;wait=1;}
if (((note==(64+(attr_column-1)))||(note==72))&&trigger) {clipslot=4;wait=1;}
if (((note==(80+(attr_column-1)))||(note==88))&&trigger) {clipslot=5;wait=1;}
if (((note==(96+(attr_column-1)))||(note==104))&&trigger) {clipslot=6;wait=1;}
if (((note==(112+(attr_column-1)))||(note==120))&&trigger) {clipslot=7;wait=1;}
if (inlet_play){
	strig=0;

	
if ((wait)&&(!wtrig)){
	if (clipslot<7){
	MidiSend3((midi_device_t) MIDI_DEVICE_USB_HOST, 1, MIDI_NOTE_ON + 0 ,map[clipslot],17);
	MidiSend3((midi_device_t) MIDI_DEVICE_USB_HOST, 1, MIDI_NOTE_ON + 0 ,map[prevclipslot],16);
	}
	if (clipslot==7){
	MidiSend3((midi_device_t) MIDI_DEVICE_USB_HOST, 1, MIDI_NOTE_ON + 0 ,map[prevclipslot],17);	
	}
	wtrig=1;
}




if ((!inlet_pulser)&&(inlet_pulse)) {colour=48;}
if ((inlet_pulser)&&(inlet_pulse)) {colour=3;}
else if (!inlet_pulse){colour=16;}

if ((play)&&(clipslot<7)&&(!wait)){
if ((colour!=prevcolour)&&(!ntrig)){
		MidiSend3((midi_device_t) MIDI_DEVICE_USB_HOST, 1, MIDI_NOTE_ON + 0 ,map[clipslot],colour);
		ntrig=1;
		prevcolour=colour;
}
if (!inlet_pulse){ntrig=0;}
}


if ((inlet_bartrig)&&(wait)){
	wait=0;
	wtrig=0;
	if (clipslot<7){
	MidiSend3((midi_device_t) MIDI_DEVICE_DIN, 1, MIDI_NOTE_ON + 5 ,(clipslot+80),127);
	//MidiSend3((midi_device_t) MIDI_DEVICE_USB_HOST, 1, MIDI_NOTE_ON + 0 ,map[clipslot],48);
	MidiSend3((midi_device_t) MIDI_DEVICE_USB_HOST, 1, MIDI_NOTE_ON + 0 ,map[prevclipslot],16);
	prevclipslot=clipslot;
	play=1;
	}
	else if (clipslot==7){
	MidiSend3((midi_device_t) MIDI_DEVICE_DIN, 1, MIDI_NOTE_ON + 5 ,(0),127);
	MidiSend3((midi_device_t) MIDI_DEVICE_USB_HOST, 1, MIDI_NOTE_ON + 0 ,map[prevclipslot],16);
	play=0;
	}
	ctrig=1;
}
else if ((!inlet_bartrig)&&(ctrig==1)){
	if (clipslot<7){
	MidiSend3((midi_device_t) MIDI_DEVICE_DIN, 1, MIDI_NOTE_OFF + 5 ,(clipslot+80),127);
	}
	else if (clipslot==7){
	MidiSend3((midi_device_t) MIDI_DEVICE_DIN, 1, MIDI_NOTE_OFF + 5 ,(0),127);	
	}
	ctrig=0;
}

}


else if ((!inlet_play)&&!strig){
	MidiSend3((midi_device_t) MIDI_DEVICE_USB_HOST, 1, MIDI_NOTE_ON + 0 ,map[prevclipslot],17);
	strig=1;
}]]></code.krate>
         <code.midihandler><![CDATA[if ((status == MIDI_NOTE_ON + 0)&&(data2))
	{
		note=data1;
		trigger=1;
	}
if ((status == MIDI_NOTE_ON + 0)&&(!data2))
	{trigger=0;
	}]]></code.midihandler>
      </object>
   </patchobj>
   <comment type="patch/comment" x="1386" y="1708" text="re load sequences from sd card but keep song"/>
   <obj type="string/c" uuid="4aa90a90c435a742ddfa152d232883fc5b2f1b3" name="c_3" x="1386" y="1722">
      <params/>
      <attribs>
         <table attributeName="str" table="/abletone"/>
      </attribs>
   </obj>
   <obj type="table/load" uuid="600cc22c6734d23a82620da1a14e78782a7e168e" name="load_1" x="1554" y="1722">
      <params/>
      <attribs>
         <objref attributeName="table" obj="lcxl2"/>
      </attribs>
   </obj>
   <comment type="patch/comment" x="308" y="1792" text="track 3 lights"/>
   <comment type="patch/comment" x="672" y="1792" text="track 3 lights"/>
   <obj type="math/==" uuid="deaf0d36642c57876c4101e86f8a0b6a06021ab2" name="==_1" x="56" y="1806">
      <params/>
      <attribs/>
   </obj>
   <obj type="logic/and 2" uuid="c67031682f552aa0a80b23377495c51ea28a8c9c" name="and_5" x="126" y="1806">
      <params/>
      <attribs/>
   </obj>
   <patchobj type="patch/object" uuid="6e6f8527-d9fd-4702-ab54-0f201a36da67" name="b_3" x="196" y="1806">
      <params/>
      <attribs/>
      <object id="patch/object" uuid="6e6f8527-d9fd-4702-ab54-0f201a36da67">
         <sDescription>Generates a single pulse after a rising edge on trigger input. A new trigger before the pulse finishes at the output, extends the pulse.</sDescription>
         <author>Johannes Taelman</author>
         <license>BSD</license>
         <helpPatch>pulselength.axh</helpPatch>
         <inlets>
            <bool32.rising name="trig" description="trigger"/>
         </inlets>
         <outlets>
            <bool32 name="pulse" description="pulse output"/>
         </outlets>
         <displays/>
         <params/>
         <attribs/>
         <includes/>
         <code.declaration><![CDATA[int ntrig;]]></code.declaration>
         <code.init><![CDATA[ntrig = 0;]]></code.init>
         <code.krate><![CDATA[if ((inlet_trig > 0) && !ntrig) {
  ntrig = 1;
  outlet_pulse = 1;
}
else outlet_pulse=0;
if (!(inlet_trig > 0))
{
    ntrig = 0;
  }]]></code.krate>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="410c588c-3f3a-406a-b965-e9f359a10624" name="launch_1" x="308" y="1806">
      <params>
         <int32 name="length" value="7"/>
         <int32 name="start" value="0"/>
         <int32 name="offset" value="0"/>
      </params>
      <attribs>
         <objref attributeName="table" obj="lcxl2"/>
         <combo attributeName="device" selection="usb host port / LP"/>
         <combo attributeName="coloron" selection="green W"/>
         <combo attributeName="coloroff" selection="off"/>
         <spinner attributeName="channel" value="1"/>
         <spinner attributeName="column" value="2"/>
      </attribs>
      <object id="patch/object" uuid="410c588c-3f3a-406a-b965-e9f359a10624">
         <sDescription>visual feedback of table data for midi controllers</sDescription>
         <author>Robert Schirmer</author>
         <license>BSD</license>
         <helpPatch>launchpad.axh</helpPatch>
         <rotatedParams>true</rotatedParams>
         <inlets>
            <int32 name="offset" description="offset in the table to read from"/>
            <int32 name="start" description="display start modulation"/>
            <int32 name="length" description="display length modulation"/>
            <int32 name="coloron" description="color on modulation"/>
            <int32 name="coloroff"/>
            <bool32.rising name="redraw"/>
         </inlets>
         <outlets>
            <int32 name="offset" description="offset through"/>
            <int32 name="start" description="start through"/>
            <int32 name="coloron" description="color on through"/>
            <int32 name="coloroff" description="color off through"/>
            <int32 name="blocksize"/>
         </outlets>
         <displays/>
         <params>
            <int32 name="length" description="length of the area to display">
               <MinValue i="1"/>
               <MaxValue i="127"/>
            </int32>
            <int32 name="start" description="display start on the LP">
               <MinValue i="0"/>
               <MaxValue i="127"/>
            </int32>
            <int32 name="offset">
               <MinValue i="0"/>
               <MaxValue i="10000000"/>
            </int32>
         </params>
         <attribs>
            <objref name="table" description="name of the table to display"/>
            <combo name="device">
               <MenuEntries>
                  <string>usb host port / LP</string>
               </MenuEntries>
               <CEntries>
                  <string>MIDI_DEVICE_USB_HOST, 9</string>
               </CEntries>
            </combo>
            <combo name="coloron">
               <MenuEntries>
                  <string>off</string>
                  <string>red W</string>
                  <string>red M</string>
                  <string>red S</string>
                  <string>orange W</string>
                  <string>orange S</string>
                  <string>green W</string>
                  <string>green M</string>
                  <string>green S</string>
                  <string>lime 1 W</string>
                  <string>lime 1 S</string>
                  <string>lime 2</string>
                  <string>yellow W</string>
                  <string>yellow M</string>
                  <string>yellow S</string>
               </MenuEntries>
               <CEntries>
                  <string>0</string>
                  <string>1</string>
                  <string>2</string>
                  <string>3</string>
                  <string>18</string>
                  <string>35</string>
                  <string>16</string>
                  <string>32</string>
                  <string>48</string>
                  <string>33</string>
                  <string>50</string>
                  <string>49</string>
                  <string>17</string>
                  <string>34</string>
                  <string>51</string>
               </CEntries>
            </combo>
            <combo name="coloroff">
               <MenuEntries>
                  <string>off</string>
                  <string>red W</string>
                  <string>red M</string>
                  <string>red S</string>
                  <string>orange W</string>
                  <string>orange S</string>
                  <string>green W</string>
                  <string>green M</string>
                  <string>green S</string>
                  <string>lime 1 W</string>
                  <string>lime 1 S</string>
                  <string>lime 2</string>
                  <string>yellow W</string>
                  <string>yellow M</string>
                  <string>yellow S</string>
               </MenuEntries>
               <CEntries>
                  <string>0</string>
                  <string>1</string>
                  <string>2</string>
                  <string>3</string>
                  <string>18</string>
                  <string>35</string>
                  <string>16</string>
                  <string>32</string>
                  <string>48</string>
                  <string>33</string>
                  <string>50</string>
                  <string>49</string>
                  <string>17</string>
                  <string>34</string>
                  <string>51</string>
               </CEntries>
            </combo>
            <spinner name="channel" MinValue="1" MaxValue="16" DefaultValue="9"/>
            <spinner name="column" MinValue="0" MaxValue="7" DefaultValue="0"/>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[int ntrig;
int rtrig;
uint8_t map[127];
int i;
int vt;
int trigt;
int prevt[64];
int length;
int plength;

uint8_t coloron;
uint8_t prevcoloron;
uint8_t start;
uint8_t coloroff;
uint8_t prevcoloroff;
uint32_t offset;]]></code.declaration>
         <code.init><![CDATA[{ 
  int i;
  for(i=0;i<7;i++) prevt[i]= -666 ;}

  { 
  int i;
  for(i=0;i<8;i++) 

  map[0] = 0;
map[1] = 16;
map[2] = 32;
map[3] = 48;
map[4] = 64;
map[5] = 80;
map[6] = 96;
//map[7] = 112;
}]]></code.init>
         <code.krate><![CDATA[//coloron = inlet_coloron + attr_coloron;

coloroff = inlet_coloroff + attr_coloroff;prevcoloroff=coloroff;
coloron = inlet_coloron + attr_coloron;prevcoloron=coloron;
offset = param_offset + inlet_offset;
start = inlet_start+ param_start;
length = inlet_length +param_length;

//redraw
if (inlet_redraw > 0)
  { 
  int ii;
  for(ii=0;ii<8;ii++) prevt[ii]= -666 ;}
  
  { 
  int ii;
  for(ii=0;ii<7;ii++) 

  map[0] = 0+attr_column;
map[1] = 16+attr_column;
map[2] = 32+attr_column;
map[3] = 48+attr_column;
map[4] = 64+attr_column;
map[5] = 80+attr_column;
map[6] = 96+attr_column;
//map[7] = 112+attr_column;
}




    
//display steps

{ 
  i += 1;
  if (i == (length)) i = 0; 
  vt = attr_table.array[__USAT((offset + (i)),attr_table.LENGTHPOW)]<<attr_table.GAIN;
if (prevt[i] != vt ) trigt = 0;
prevt[i] = vt;
if (vt && (!trigt)) {
MidiSend3((midi_device_t) attr_device, MIDI_NOTE_ON + (attr_channel-1)   ,map[(i + start)],(coloron));  trigt=1;
}
if ((!vt) && (!trigt)){
MidiSend3((midi_device_t) attr_device, MIDI_NOTE_ON + (attr_channel-1)  ,map[(i + start)],(coloroff));  trigt=1;
}
 }




outlet_coloron = coloron;
outlet_coloroff = coloroff;
outlet_offset = offset;
outlet_start = start;]]></code.krate>
      </object>
   </patchobj>
   <obj type="logic/flipflop" uuid="f9b15363f5ee203152e062c08a8846f0074b0ea5" name="flipflop_5" x="574" y="1806">
      <params/>
      <attribs/>
   </obj>
   <patchobj type="patch/object" uuid="b40a4170-891d-4fc1-a6a6-b93c8206156a" name="launch_5" x="672" y="1806">
      <params/>
      <attribs>
         <objref attributeName="table" obj="lcxl2"/>
         <combo attributeName="device" selection="usb host port / LP"/>
         <combo attributeName="color" selection="green S"/>
         <spinner attributeName="channel" value="1"/>
         <spinner attributeName="column" value="2"/>
      </attribs>
      <object id="patch/object" uuid="b40a4170-891d-4fc1-a6a6-b93c8206156a">
         <sDescription>display a step counter on a midi controller</sDescription>
         <author>Robert Schirmer</author>
         <license>BSD</license>
         <helpPatch>launchpad.axh</helpPatch>
         <rotatedParams>true</rotatedParams>
         <inlets>
            <int32 name="offset" description="offset in the table to read from"/>
            <int32 name="barcount"/>
            <int32 name="start" description="display start on the LP"/>
            <bool32 name="clear"/>
            <bool32 name="wait"/>
            <bool32 name="rec"/>
            <bool32 name="play"/>
            <bool32 name="stop"/>
            <int32 name="coloron" description="color on"/>
            <int32 name="coloroff" description="color off"/>
            <int32 name="color" description="step color modulation"/>
            <int32 name="step" description="current step"/>
            <bool32 name="active" description="active??"/>
            <bool32.rising name="redraw"/>
            <bool32 name="trigger"/>
         </inlets>
         <outlets/>
         <displays/>
         <params/>
         <attribs>
            <objref name="table" description="table to display"/>
            <combo name="device">
               <MenuEntries>
                  <string>usb host port / LP</string>
               </MenuEntries>
               <CEntries>
                  <string>MIDI_DEVICE_USB_HOST, 1</string>
               </CEntries>
            </combo>
            <combo name="color">
               <MenuEntries>
                  <string>off</string>
                  <string>red W</string>
                  <string>red M</string>
                  <string>red S</string>
                  <string>orange W</string>
                  <string>orange S</string>
                  <string>green W</string>
                  <string>green M</string>
                  <string>green S</string>
                  <string>lime 1 W</string>
                  <string>lime 1 S</string>
                  <string>lime 2</string>
                  <string>yellow W</string>
                  <string>yellow M</string>
                  <string>yellow S</string>
               </MenuEntries>
               <CEntries>
                  <string>0</string>
                  <string>1</string>
                  <string>2</string>
                  <string>3</string>
                  <string>18</string>
                  <string>35</string>
                  <string>16</string>
                  <string>32</string>
                  <string>48</string>
                  <string>33</string>
                  <string>50</string>
                  <string>49</string>
                  <string>17</string>
                  <string>34</string>
                  <string>51</string>
               </CEntries>
            </combo>
            <spinner name="channel" MinValue="1" MaxValue="16" DefaultValue="9"/>
            <spinner name="column" MinValue="0" MaxValue="7" DefaultValue="0"/>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[int color;
int strig;
int prevcolor;
int stoptrig;
int ntrig;
int rtrig;
int full;
int prev;
int32_t map[126];
int32_t v;]]></code.declaration>
         <code.init><![CDATA[{ 
  int i;
  for(i=0;i<8;i++) 

  map[0] = 0+attr_column;
map[1] = 16+attr_column;
map[2] = 32+attr_column;
map[3] = 48+attr_column;
map[4] = 64+attr_column;
map[5] = 80+attr_column;
map[6] = 96+attr_column;
map[7] = 112+attr_column;

}
strig=1;]]></code.init>
         <code.krate><![CDATA[if (inlet_wait){color=17;}
if (inlet_barcount==0){
	if (inlet_rec){color=1;}}
else if(inlet_barcount>0){
	if ((inlet_rec)&&(!inlet_wait)){color=1;}	
}
if ((inlet_play)&&(!inlet_wait)) {
	if((inlet_trigger>0)&&(!inlet_clear)){
	color=attr_color;}
	if((inlet_trigger>0)&&(inlet_clear)){
	color=3;}
	else if (!(inlet_trigger>0)){
	color=inlet_coloron;}
}

full = attr_table.array[__USAT((inlet_offset + inlet_step),attr_table.LENGTHPOW)]<<attr_table.GAIN ;
if ((!inlet_wait)&&(!inlet_rec)&&(!inlet_play)){
	if (full){
	color=inlet_coloron;
	}
	else if (!full){
	color=0;
	}
	}




if (inlet_active){ 
	rtrig = 0;

if (((color!=prevcolor)||(inlet_redraw>0))&&!ntrig){
	if (inlet_step<7){
	MidiSend3((midi_device_t) attr_device, MIDI_NOTE_ON + (attr_channel-1) ,map[inlet_step + inlet_start],(color));}
	else if (inlet_step==7){
		if (inlet_wait>0){
		MidiSend3((midi_device_t) attr_device, MIDI_NOTE_ON + (attr_channel-1) ,map[prev + inlet_start],(17));}
		else if (!inlet_wait)
		{
			v = attr_table.array[__USAT((inlet_offset + (prev)),attr_table.LENGTHPOW)]<<attr_table.GAIN ;
			if (v){
			MidiSend3((midi_device_t) attr_device, MIDI_NOTE_ON + (attr_channel-1) ,map[prev + inlet_start],(16));
			}
			else if (!v){
			MidiSend3((midi_device_t) attr_device, MIDI_NOTE_ON + (attr_channel-1) ,map[prev + inlet_start],(0));
			}
		}
	}
	prevcolor=color;
	ntrig=1;
	}

if (!inlet_trigger){ntrig=0;}


if ((inlet_step  != prev)&&(inlet_step<7)) {
  v = attr_table.array[__USAT((inlet_offset + (prev)),attr_table.LENGTHPOW)]<<attr_table.GAIN ;
  if (v) MidiSend3((midi_device_t) attr_device, MIDI_NOTE_ON + (attr_channel-1) ,map[(prev  + inlet_start)],inlet_coloron);
     	else
     	MidiSend3((midi_device_t) attr_device, MIDI_NOTE_ON + (attr_channel-1) ,map[(prev + inlet_start)],inlet_coloroff);
prev = inlet_step;
}

}]]></code.krate>
      </object>
   </patchobj>
   <obj type="const/i" uuid="e202f44b2df17ae0b3e663b98ea6b14c8ff00408" name="i_3" x="1274" y="1806">
      <params/>
      <attribs>
         <spinner attributeName="value" value="960527"/>
      </attribs>
   </obj>
   <comment type="patch/comment" x="1274" y="1876" text="track 4 lights"/>
   <comment type="patch/comment" x="1652" y="1876" text="track 4 lights"/>
   <obj type="math/==" uuid="deaf0d36642c57876c4101e86f8a0b6a06021ab2" name="==_3" x="1008" y="1890">
      <params/>
      <attribs/>
   </obj>
   <obj type="logic/and 2" uuid="c67031682f552aa0a80b23377495c51ea28a8c9c" name="and_6" x="1078" y="1890">
      <params/>
      <attribs/>
   </obj>
   <patchobj type="patch/object" uuid="f997e173-90de-45b4-818f-725146a07cb2" name="b_4" x="1148" y="1890">
      <params/>
      <attribs/>
      <object id="patch/object" uuid="f997e173-90de-45b4-818f-725146a07cb2">
         <sDescription>Generates a single pulse after a rising edge on trigger input. A new trigger before the pulse finishes at the output, extends the pulse.</sDescription>
         <author>Johannes Taelman</author>
         <license>BSD</license>
         <helpPatch>pulselength.axh</helpPatch>
         <inlets>
            <bool32.rising name="trig" description="trigger"/>
         </inlets>
         <outlets>
            <bool32 name="pulse" description="pulse output"/>
         </outlets>
         <displays/>
         <params/>
         <attribs/>
         <includes/>
         <code.declaration><![CDATA[int ntrig;]]></code.declaration>
         <code.init><![CDATA[ntrig = 0;]]></code.init>
         <code.krate><![CDATA[if ((inlet_trig > 0) && !ntrig) {
  ntrig = 1;
  outlet_pulse = 1;
}
else outlet_pulse=0;
if (!(inlet_trig > 0))
{
    ntrig = 0;
  }]]></code.krate>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="410c588c-3f3a-406a-b965-e9f359a10624" name="launch_3" x="1274" y="1890">
      <params>
         <int32 name="length" value="7"/>
         <int32 name="start" value="0"/>
         <int32 name="offset" value="0"/>
      </params>
      <attribs>
         <objref attributeName="table" obj="lcxl2"/>
         <combo attributeName="device" selection="usb host port / LP"/>
         <combo attributeName="coloron" selection="green W"/>
         <combo attributeName="coloroff" selection="off"/>
         <spinner attributeName="channel" value="1"/>
         <spinner attributeName="column" value="3"/>
      </attribs>
      <object id="patch/object" uuid="410c588c-3f3a-406a-b965-e9f359a10624">
         <sDescription>visual feedback of table data for midi controllers</sDescription>
         <author>Robert Schirmer</author>
         <license>BSD</license>
         <helpPatch>launchpad.axh</helpPatch>
         <rotatedParams>true</rotatedParams>
         <inlets>
            <int32 name="offset" description="offset in the table to read from"/>
            <int32 name="start" description="display start modulation"/>
            <int32 name="length" description="display length modulation"/>
            <int32 name="coloron" description="color on modulation"/>
            <int32 name="coloroff"/>
            <bool32.rising name="redraw"/>
         </inlets>
         <outlets>
            <int32 name="offset" description="offset through"/>
            <int32 name="start" description="start through"/>
            <int32 name="coloron" description="color on through"/>
            <int32 name="coloroff" description="color off through"/>
            <int32 name="blocksize"/>
         </outlets>
         <displays/>
         <params>
            <int32 name="length" description="length of the area to display">
               <MinValue i="1"/>
               <MaxValue i="127"/>
            </int32>
            <int32 name="start" description="display start on the LP">
               <MinValue i="0"/>
               <MaxValue i="127"/>
            </int32>
            <int32 name="offset">
               <MinValue i="0"/>
               <MaxValue i="10000000"/>
            </int32>
         </params>
         <attribs>
            <objref name="table" description="name of the table to display"/>
            <combo name="device">
               <MenuEntries>
                  <string>usb host port / LP</string>
               </MenuEntries>
               <CEntries>
                  <string>MIDI_DEVICE_USB_HOST, 9</string>
               </CEntries>
            </combo>
            <combo name="coloron">
               <MenuEntries>
                  <string>off</string>
                  <string>red W</string>
                  <string>red M</string>
                  <string>red S</string>
                  <string>orange W</string>
                  <string>orange S</string>
                  <string>green W</string>
                  <string>green M</string>
                  <string>green S</string>
                  <string>lime 1 W</string>
                  <string>lime 1 S</string>
                  <string>lime 2</string>
                  <string>yellow W</string>
                  <string>yellow M</string>
                  <string>yellow S</string>
               </MenuEntries>
               <CEntries>
                  <string>0</string>
                  <string>1</string>
                  <string>2</string>
                  <string>3</string>
                  <string>18</string>
                  <string>35</string>
                  <string>16</string>
                  <string>32</string>
                  <string>48</string>
                  <string>33</string>
                  <string>50</string>
                  <string>49</string>
                  <string>17</string>
                  <string>34</string>
                  <string>51</string>
               </CEntries>
            </combo>
            <combo name="coloroff">
               <MenuEntries>
                  <string>off</string>
                  <string>red W</string>
                  <string>red M</string>
                  <string>red S</string>
                  <string>orange W</string>
                  <string>orange S</string>
                  <string>green W</string>
                  <string>green M</string>
                  <string>green S</string>
                  <string>lime 1 W</string>
                  <string>lime 1 S</string>
                  <string>lime 2</string>
                  <string>yellow W</string>
                  <string>yellow M</string>
                  <string>yellow S</string>
               </MenuEntries>
               <CEntries>
                  <string>0</string>
                  <string>1</string>
                  <string>2</string>
                  <string>3</string>
                  <string>18</string>
                  <string>35</string>
                  <string>16</string>
                  <string>32</string>
                  <string>48</string>
                  <string>33</string>
                  <string>50</string>
                  <string>49</string>
                  <string>17</string>
                  <string>34</string>
                  <string>51</string>
               </CEntries>
            </combo>
            <spinner name="channel" MinValue="1" MaxValue="16" DefaultValue="9"/>
            <spinner name="column" MinValue="0" MaxValue="7" DefaultValue="0"/>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[int ntrig;
int rtrig;
uint8_t map[127];
int i;
int vt;
int trigt;
int prevt[64];
int length;
int plength;

uint8_t coloron;
uint8_t prevcoloron;
uint8_t start;
uint8_t coloroff;
uint8_t prevcoloroff;
uint32_t offset;]]></code.declaration>
         <code.init><![CDATA[{ 
  int i;
  for(i=0;i<8;i++) prevt[i]= -666 ;}

  { 
  int i;
  for(i=0;i<8;i++) 

  map[0] = 0;
map[1] = 16;
map[2] = 32;
map[3] = 48;
map[4] = 64;
map[5] = 80;
map[6] = 96;
map[7] = 112;
}]]></code.init>
         <code.krate><![CDATA[//coloron = inlet_coloron + attr_coloron;

coloroff = inlet_coloroff + attr_coloroff;prevcoloroff=coloroff;
coloron = inlet_coloron + attr_coloron;prevcoloron=coloron;
offset = param_offset + inlet_offset;
start = inlet_start+ param_start;
length = inlet_length +param_length;

//redraw
if (inlet_redraw > 0)
  { 
  int ii;
  for(ii=0;ii<8;ii++) prevt[ii]= -666 ;}
  
  { 
  int ii;
  for(ii=0;ii<8;ii++) 

  map[0] = 0+attr_column;
map[1] = 16+attr_column;
map[2] = 32+attr_column;
map[3] = 48+attr_column;
map[4] = 64+attr_column;
map[5] = 80+attr_column;
map[6] = 96+attr_column;
map[7] = 112+attr_column;
}




    
//display steps

{ 
  i += 1;
  if (i == (length)) i = 0; 
  vt = attr_table.array[__USAT((offset + (i)),attr_table.LENGTHPOW)]<<attr_table.GAIN;
if (prevt[i] != vt ) trigt = 0;
prevt[i] = vt;
if (vt && (!trigt)) {
MidiSend3((midi_device_t) attr_device, MIDI_NOTE_ON + (attr_channel-1)   ,map[(i + start)],(coloron));  trigt=1;
}
if ((!vt) && (!trigt)){
MidiSend3((midi_device_t) attr_device, MIDI_NOTE_ON + (attr_channel-1)  ,map[(i + start)],(coloroff));  trigt=1;
}
 }




outlet_coloron = coloron;
outlet_coloroff = coloroff;
outlet_offset = offset;
outlet_start = start;]]></code.krate>
      </object>
   </patchobj>
   <obj type="logic/flipflop" uuid="f9b15363f5ee203152e062c08a8846f0074b0ea5" name="flipflop_6" x="1554" y="1890">
      <params/>
      <attribs/>
   </obj>
   <patchobj type="patch/object" uuid="b40a4170-891d-4fc1-a6a6-b93c8206156a" name="launch_8" x="1652" y="1890">
      <params/>
      <attribs>
         <objref attributeName="table" obj="lcxl2"/>
         <combo attributeName="device" selection="usb host port / LP"/>
         <combo attributeName="color" selection="green S"/>
         <spinner attributeName="channel" value="1"/>
         <spinner attributeName="column" value="3"/>
      </attribs>
      <object id="patch/object" uuid="b40a4170-891d-4fc1-a6a6-b93c8206156a">
         <sDescription>display a step counter on a midi controller</sDescription>
         <author>Robert Schirmer</author>
         <license>BSD</license>
         <helpPatch>launchpad.axh</helpPatch>
         <rotatedParams>true</rotatedParams>
         <inlets>
            <int32 name="offset" description="offset in the table to read from"/>
            <int32 name="barcount"/>
            <int32 name="start" description="display start on the LP"/>
            <bool32 name="clear"/>
            <bool32 name="wait"/>
            <bool32 name="rec"/>
            <bool32 name="play"/>
            <bool32 name="stop"/>
            <int32 name="coloron" description="color on"/>
            <int32 name="coloroff" description="color off"/>
            <int32 name="color" description="step color modulation"/>
            <int32 name="step" description="current step"/>
            <bool32 name="active" description="active??"/>
            <bool32.rising name="redraw"/>
            <bool32 name="trigger"/>
         </inlets>
         <outlets/>
         <displays/>
         <params/>
         <attribs>
            <objref name="table" description="table to display"/>
            <combo name="device">
               <MenuEntries>
                  <string>usb host port / LP</string>
               </MenuEntries>
               <CEntries>
                  <string>MIDI_DEVICE_USB_HOST, 1</string>
               </CEntries>
            </combo>
            <combo name="color">
               <MenuEntries>
                  <string>off</string>
                  <string>red W</string>
                  <string>red M</string>
                  <string>red S</string>
                  <string>orange W</string>
                  <string>orange S</string>
                  <string>green W</string>
                  <string>green M</string>
                  <string>green S</string>
                  <string>lime 1 W</string>
                  <string>lime 1 S</string>
                  <string>lime 2</string>
                  <string>yellow W</string>
                  <string>yellow M</string>
                  <string>yellow S</string>
               </MenuEntries>
               <CEntries>
                  <string>0</string>
                  <string>1</string>
                  <string>2</string>
                  <string>3</string>
                  <string>18</string>
                  <string>35</string>
                  <string>16</string>
                  <string>32</string>
                  <string>48</string>
                  <string>33</string>
                  <string>50</string>
                  <string>49</string>
                  <string>17</string>
                  <string>34</string>
                  <string>51</string>
               </CEntries>
            </combo>
            <spinner name="channel" MinValue="1" MaxValue="16" DefaultValue="9"/>
            <spinner name="column" MinValue="0" MaxValue="7" DefaultValue="0"/>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[int color;
int strig;
int prevcolor;
int stoptrig;
int ntrig;
int rtrig;
int full;
int prev;
int32_t map[126];
int32_t v;]]></code.declaration>
         <code.init><![CDATA[{ 
  int i;
  for(i=0;i<8;i++) 

  map[0] = 0+attr_column;
map[1] = 16+attr_column;
map[2] = 32+attr_column;
map[3] = 48+attr_column;
map[4] = 64+attr_column;
map[5] = 80+attr_column;
map[6] = 96+attr_column;
map[7] = 112+attr_column;

}
strig=1;]]></code.init>
         <code.krate><![CDATA[if (inlet_wait){color=17;}
if (inlet_barcount==0){
	if (inlet_rec){color=1;}}
else if(inlet_barcount>0){
	if ((inlet_rec)&&(!inlet_wait)){color=1;}	
}
if ((inlet_play)&&(!inlet_wait)) {
	if((inlet_trigger>0)&&(!inlet_clear)){
	color=attr_color;}
	if((inlet_trigger>0)&&(inlet_clear)){
	color=3;}
	else if (!(inlet_trigger>0)){
	color=inlet_coloron;}
}

full = attr_table.array[__USAT((inlet_offset + inlet_step),attr_table.LENGTHPOW)]<<attr_table.GAIN ;
if ((!inlet_wait)&&(!inlet_rec)&&(!inlet_play)){
	if (full){
	color=inlet_coloron;
	}
	else if (!full){
	color=0;
	}
	}




if (inlet_active){ 
	rtrig = 0;

if (((color!=prevcolor)||(inlet_redraw>0))&&!ntrig){
	if (inlet_step<7){
	MidiSend3((midi_device_t) attr_device, MIDI_NOTE_ON + (attr_channel-1) ,map[inlet_step + inlet_start],(color));}
	else if (inlet_step==7){
		if (inlet_wait>0){
		MidiSend3((midi_device_t) attr_device, MIDI_NOTE_ON + (attr_channel-1) ,map[prev + inlet_start],(17));}
		else if (!inlet_wait)
		{
			v = attr_table.array[__USAT((inlet_offset + (prev)),attr_table.LENGTHPOW)]<<attr_table.GAIN ;
			if (v){
			MidiSend3((midi_device_t) attr_device, MIDI_NOTE_ON + (attr_channel-1) ,map[prev + inlet_start],(16));
			}
			else if (!v){
			MidiSend3((midi_device_t) attr_device, MIDI_NOTE_ON + (attr_channel-1) ,map[prev + inlet_start],(0));
			}
		}
	}
	prevcolor=color;
	ntrig=1;
	}

if (!inlet_trigger){ntrig=0;}


if ((inlet_step  != prev)&&(inlet_step<7)) {
  v = attr_table.array[__USAT((inlet_offset + (prev)),attr_table.LENGTHPOW)]<<attr_table.GAIN ;
  if (v) MidiSend3((midi_device_t) attr_device, MIDI_NOTE_ON + (attr_channel-1) ,map[(prev  + inlet_start)],inlet_coloron);
     	else
     	MidiSend3((midi_device_t) attr_device, MIDI_NOTE_ON + (attr_channel-1) ,map[(prev + inlet_start)],inlet_coloroff);
prev = inlet_step;
}

}]]></code.krate>
      </object>
   </patchobj>
   <obj type="logic/and 2" uuid="c67031682f552aa0a80b23377495c51ea28a8c9c" name="and_2" x="840" y="1904">
      <params/>
      <attribs/>
   </obj>
   <obj type="logic/and 2" uuid="c67031682f552aa0a80b23377495c51ea28a8c9c" name="and_3" x="924" y="1904">
      <params/>
      <attribs/>
   </obj>
   <comment type="patch/comment" x="854" y="1974" text="master play &amp; unchanging lights"/>
   <patchobj type="patch/object" uuid="2eed6504-95b2-41a7-be75-2a8fd3be310d" name="top_2" x="854" y="1988">
      <params/>
      <attribs>
         <combo attributeName="device" selection="usb host port / LP"/>
         <spinner attributeName="button" value="7"/>
         <combo attributeName="on" selection="green S"/>
         <combo attributeName="off" selection="green W"/>
      </attribs>
      <object id="patch/object" uuid="2eed6504-95b2-41a7-be75-2a8fd3be310d">
         <sDescription>sets a top row button on the &apos;launchpad&apos; to the defined color</sDescription>
         <author>robert schirmer</author>
         <license>BSD</license>
         <helpPatch>launchpad.axh</helpPatch>
         <inlets>
            <bool32.risingfalling name="on"/>
            <bool32 name="coloron"/>
            <int32 name="coloroff"/>
            <bool32.rising name="redraw"/>
         </inlets>
         <outlets/>
         <displays/>
         <params/>
         <attribs>
            <combo name="device">
               <MenuEntries>
                  <string>usb host port / LP</string>
               </MenuEntries>
               <CEntries>
                  <string>MIDI_DEVICE_USB_HOST, 1</string>
               </CEntries>
            </combo>
            <spinner name="button" MinValue="0" MaxValue="7" DefaultValue="0"/>
            <combo name="on">
               <MenuEntries>
                  <string>off</string>
                  <string>red W</string>
                  <string>red M</string>
                  <string>red S</string>
                  <string>orange W</string>
                  <string>orange S</string>
                  <string>green W</string>
                  <string>green M</string>
                  <string>green S</string>
                  <string>lime 1 W</string>
                  <string>lime 1 S</string>
                  <string>lime 2</string>
                  <string>yellow W</string>
                  <string>yellow M</string>
                  <string>yellow S</string>
               </MenuEntries>
               <CEntries>
                  <string>0</string>
                  <string>1</string>
                  <string>2</string>
                  <string>3</string>
                  <string>18</string>
                  <string>35</string>
                  <string>16</string>
                  <string>32</string>
                  <string>48</string>
                  <string>33</string>
                  <string>50</string>
                  <string>49</string>
                  <string>17</string>
                  <string>34</string>
                  <string>51</string>
               </CEntries>
            </combo>
            <combo name="off">
               <MenuEntries>
                  <string>off</string>
                  <string>red W</string>
                  <string>red M</string>
                  <string>red S</string>
                  <string>orange W</string>
                  <string>orange S</string>
                  <string>green W</string>
                  <string>green M</string>
                  <string>green S</string>
                  <string>lime 1 W</string>
                  <string>lime 1 S</string>
                  <string>lime 2</string>
                  <string>yellow W</string>
                  <string>yellow M</string>
                  <string>yellow S</string>
               </MenuEntries>
               <CEntries>
                  <string>0</string>
                  <string>1</string>
                  <string>2</string>
                  <string>3</string>
                  <string>18</string>
                  <string>35</string>
                  <string>16</string>
                  <string>32</string>
                  <string>48</string>
                  <string>33</string>
                  <string>50</string>
                  <string>49</string>
                  <string>17</string>
                  <string>34</string>
                  <string>51</string>
               </CEntries>
            </combo>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[uint8_t b;
uint8_t prevb;
int coloron;
int ntrig;
uint8_t map[31];
int i;
int length;]]></code.declaration>
         <code.init><![CDATA[MidiSend3((midi_device_t) attr_device, MIDI_CONTROL_CHANGE, (104), 17);
MidiSend3((midi_device_t) attr_device, MIDI_CONTROL_CHANGE, (105), 17);
MidiSend3((midi_device_t) attr_device, MIDI_CONTROL_CHANGE, (106), 17);
MidiSend3((midi_device_t) attr_device, MIDI_CONTROL_CHANGE, (107), 17);
MidiSend3((midi_device_t) attr_device, MIDI_NOTE_ON+0, (112), 17);
MidiSend3((midi_device_t) attr_device, MIDI_NOTE_ON+0, (113), 17);
MidiSend3((midi_device_t) attr_device, MIDI_NOTE_ON+0, (114), 17);
MidiSend3((midi_device_t) attr_device, MIDI_NOTE_ON+0, (115), 17);
MidiSend3((midi_device_t) attr_device, MIDI_NOTE_ON+0, (116), 17);

MidiSend3((midi_device_t) attr_device, MIDI_NOTE_ON+0, (4), 16);
MidiSend3((midi_device_t) attr_device, MIDI_NOTE_ON+0, (20), 16);
MidiSend3((midi_device_t) attr_device, MIDI_NOTE_ON+0, (36), 16);
MidiSend3((midi_device_t) attr_device, MIDI_NOTE_ON+0, (52), 16);
MidiSend3((midi_device_t) attr_device, MIDI_NOTE_ON+0, (68), 16);
MidiSend3((midi_device_t) attr_device, MIDI_NOTE_ON+0, (84), 16);
MidiSend3((midi_device_t) attr_device, MIDI_NOTE_ON+0, (100), 16);]]></code.init>
         <code.krate><![CDATA[if (inlet_coloron) {coloron=3;}
else if (!inlet_on){coloron=attr_on;}

b  = (inlet_on)?(coloron):(attr_off + inlet_coloroff);
if (((b != prevb ) || (inlet_redraw > 0)) && (!ntrig))
{ MidiSend3((midi_device_t) attr_device, MIDI_CONTROL_CHANGE, (104 + attr_button), b);
ntrig = 1; prevb=b;}
else ntrig = 0;

//  if (i < length){
//  	if (i<24){
//MidiSend3((midi_device_t) attr_device, MIDI_NOTE_ON ,map[(i + (0))],1);}
//
//  	if (i>23){
//MidiSend3((midi_device_t) attr_device, MIDI_NOTE_ON ,map[(i + (0))],17);}
//i += 1;
//  }
//  else i = 666;]]></code.krate>
      </object>
   </patchobj>
   <comment type="patch/comment" x="966" y="2198" text="loads initial patch (for patch changing)"/>
   <patchobj type="patch/object" uuid="27a4893e-93bb-4a7c-b41c-0b02da02cbed" name="keyb_3" x="966" y="2212">
      <params/>
      <attribs/>
      <object id="patch/object" uuid="27a4893e-93bb-4a7c-b41c-0b02da02cbed">
         <sDescription>Monophonic MIDI keyboard note input, gate, velocity and release velocity</sDescription>
         <author>Johannes Taelman</author>
         <license>BSD</license>
         <helpPatch>midi_in.axh</helpPatch>
         <inlets/>
         <outlets>
            <bool32 name="gate" description="key pressed?"/>
         </outlets>
         <displays/>
         <params/>
         <attribs/>
         <includes/>
         <code.declaration><![CDATA[uint8_t _gate;
int ccv;]]></code.declaration>
         <code.init><![CDATA[_gate = 0;
]]></code.init>
         <code.krate><![CDATA[if (ccv&&_gate){
	outlet_gate=1;
}
else outlet_gate=0;]]></code.krate>
         <code.midihandler><![CDATA[if ((status == MIDI_NOTE_ON + 8) && (data2)) {if (data1 == 108) {
   _gate = 1;
}
} else if (((status == MIDI_NOTE_ON + 8) && (!data2))||          (status == MIDI_NOTE_OFF + 8)) {
  if (data1 == 108) {
    _gate = 0;
  }
} 
if ((status == 8 + MIDI_CONTROL_CHANGE)&&(data1 == 107)) { ccv = data2;}]]></code.midihandler>
      </object>
   </patchobj>
   <obj type="patch/load" uuid="634bf1f8c313920d7f19fc402ba937fd1ee27802" name="load_3" x="1050" y="2212">
      <params/>
      <attribs>
         <table attributeName="filename" table="/init malcolm upload/patch.bin"/>
      </attribs>
   </obj>
   <nets>
      <net>
         <source obj="object_3" outlet="nplaytrig"/>
         <dest obj="counter_1" inlet="r"/>
         <dest obj="counter_3" inlet="r"/>
         <dest obj="or_1" inlet="i2"/>
         <dest obj="counter_4" inlet="r"/>
         <dest obj="or_3" inlet="i2"/>
         <dest obj="launch_5" inlet="redraw"/>
         <dest obj="counter_9" inlet="r"/>
         <dest obj="counter_11" inlet="r"/>
      </net>
      <net>
         <source obj="note_2" outlet="gate"/>
         <dest obj="clk_mul_2" inlet="clk"/>
         <dest obj="clk_mul_6" inlet="clk"/>
         <dest obj="counter_14" inlet="trig"/>
         <dest obj="counter_1" inlet="trig"/>
         <dest obj="or_9" inlet="i1"/>
         <dest obj="counter_11" inlet="trig"/>
         <dest obj="step_5" inlet="trig"/>
         <dest obj="counter_12" inlet="trig"/>
      </net>
      <net>
         <source obj="toggle_1" outlet="o"/>
         <dest obj="and_13" inlet="i1"/>
         <dest obj="and_14" inlet="i1"/>
         <dest obj="and_2" inlet="i2"/>
         <dest obj="and_3" inlet="i2"/>
         <dest obj="and_8" inlet="i2"/>
         <dest obj="object_7" inlet="play"/>
      </net>
      <net>
         <source obj="clk_mul_2" outlet="clk"/>
         <dest obj="counter_9" inlet="trig"/>
         <dest obj="counter_13" inlet="trig"/>
         <dest obj="counter_10" inlet="trig"/>
         <dest obj="counter_16" inlet="trig"/>
      </net>
      <net>
         <source obj="counter2_init_start_3" outlet="c"/>
         <dest obj="counter_15" inlet="trig"/>
         <dest obj="counter_7" inlet="trig"/>
         <dest obj="counter_8" inlet="trig"/>
      </net>
      <net>
         <source obj="object_3" outlet="offsetnotes"/>
         <dest obj="tablestore_21" inlet="offset"/>
         <dest obj="patcher_2" inlet="offset"/>
      </net>
      <net>
         <source obj="counter_9" outlet="o"/>
         <dest obj="tablestore_11" inlet="stepunQ"/>
         <dest obj="tablestore_12" inlet="stepunQ"/>
         <dest obj="tablestore_22" inlet="stepunQ"/>
         <dest obj="tablestore_23" inlet="stepunQ"/>
         <dest obj="tablestore_24" inlet="stepunQ"/>
         <dest obj="tablestore_25" inlet="stepunQ"/>
         <dest obj="tablestore_21" inlet="stepunQ"/>
         <dest obj="patcher_2" inlet="stepunQ"/>
         <dest obj="tablestore_26" inlet="stepunQ"/>
      </net>
      <net>
         <source obj="counter_11" outlet="o"/>
         <dest obj="tablestore_12" inlet="step"/>
         <dest obj="tablestore_22" inlet="step"/>
         <dest obj="tablestore_23" inlet="step"/>
         <dest obj="tablestore_24" inlet="step"/>
         <dest obj="tablestore_25" inlet="step"/>
         <dest obj="tablestore_21" inlet="step"/>
         <dest obj="patcher_2" inlet="step"/>
         <dest obj="tablestore_26" inlet="step"/>
      </net>
      <net>
         <source obj="clk_mul_6" outlet="clk"/>
         <dest obj="counter2_init_start_3" inlet="inc"/>
      </net>
      <net>
         <source obj="and_14" outlet="o"/>
         <dest obj="object_3" inlet="pulse"/>
         <dest obj="object_4" inlet="pulse"/>
      </net>
      <net>
         <source obj="and_13" outlet="o"/>
         <dest obj="or_9" inlet="i2"/>
         <dest obj="object_3" inlet="pulseplay"/>
         <dest obj="object_4" inlet="pulseplay"/>
      </net>
      <net>
         <source obj="toggle_1" outlet="stop"/>
         <dest obj="flipflop_2" inlet="reset"/>
         <dest obj="delayedpulse_2" inlet="trig"/>
         <dest obj="object_3" inlet="stop"/>
         <dest obj="object_4" inlet="stop"/>
      </net>
      <net>
         <source obj="object_3" outlet="rec"/>
         <dest obj="tablestore_11" inlet="rec"/>
         <dest obj="patcher_2" inlet="rec"/>
         <dest obj="launch_5" inlet="rec"/>
      </net>
      <net>
         <source obj="object_3" outlet="play"/>
         <dest obj="tablestore_12" inlet="play"/>
         <dest obj="tablestore_22" inlet="play"/>
         <dest obj="tablestore_23" inlet="play"/>
         <dest obj="tablestore_24" inlet="play"/>
         <dest obj="tablestore_25" inlet="play"/>
         <dest obj="tablestore_21" inlet="play"/>
         <dest obj="tablestore_26" inlet="play"/>
         <dest obj="launch_5" inlet="play"/>
      </net>
      <net>
         <source obj="tablestore_21" outlet="totaloffset"/>
         <dest obj="tablestore_22" inlet="offset"/>
      </net>
      <net>
         <source obj="tablestore_22" outlet="totaloffset"/>
         <dest obj="tablestore_23" inlet="offset"/>
      </net>
      <net>
         <source obj="tablestore_23" outlet="totaloffset"/>
         <dest obj="tablestore_24" inlet="offset"/>
      </net>
      <net>
         <source obj="tablestore_24" outlet="totaloffset"/>
         <dest obj="tablestore_25" inlet="offset"/>
      </net>
      <net>
         <source obj="tablestore_25" outlet="totaloffset"/>
         <dest obj="tablestore_26" inlet="offset"/>
      </net>
      <net>
         <source obj="toggle_1" outlet="start"/>
         <dest obj="flipflop_2" inlet="set"/>
         <dest obj="counter_15" inlet="r"/>
         <dest obj="counter_14" inlet="r"/>
         <dest obj="counter2_init_start_3" inlet="r"/>
         <dest obj="counter_13" inlet="r"/>
         <dest obj="counter_16" inlet="r"/>
         <dest obj="object_3" inlet="start"/>
         <dest obj="object_4" inlet="start"/>
      </net>
      <net>
         <source obj="counter_1" outlet="c"/>
         <dest obj="counter_3" inlet="trig"/>
         <dest obj="or_3" inlet="i1"/>
      </net>
      <net>
         <source obj="tablestore_26" outlet="totaloffset"/>
         <dest obj="tablestore_11" inlet="offset"/>
         <dest obj="tablestore_12" inlet="offset"/>
      </net>
      <net>
         <source obj="object_3" outlet="clipslot"/>
         <dest obj="==_1" inlet="in2"/>
         <dest obj="launch_5" inlet="step"/>
      </net>
      <net>
         <source obj="counter_3" outlet="o"/>
         <dest obj="==_2" inlet="in1"/>
      </net>
      <net>
         <source obj="i_7" outlet="out"/>
         <dest obj="==_2" inlet="in2"/>
      </net>
      <net>
         <source obj="pulselength_1" outlet="pulse"/>
         <dest obj="and_3" inlet="i1"/>
         <dest obj="launch_5" inlet="clear"/>
         <dest obj="launch_8" inlet="clear"/>
         <dest obj="object_7" inlet="pulser"/>
      </net>
      <net>
         <source obj="==_2" outlet="out"/>
         <dest obj="or_1" inlet="i1"/>
      </net>
      <net>
         <source obj="or_1" outlet="o"/>
         <dest obj="pulselength_1" inlet="trig"/>
      </net>
      <net>
         <source obj="counter_4" outlet="c"/>
         <dest obj="flipflop_2" inlet="trig"/>
      </net>
      <net>
         <source obj="or_9" outlet="o"/>
         <dest obj="counter_4" inlet="trig"/>
      </net>
      <net>
         <source obj="flipflop_2" outlet="o"/>
         <dest obj="and_2" inlet="i1"/>
         <dest obj="launch_5" inlet="trigger"/>
         <dest obj="launch_8" inlet="trigger"/>
         <dest obj="object_7" inlet="pulse"/>
      </net>
      <net>
         <source obj="launch_1" outlet="coloron"/>
         <dest obj="launch_5" inlet="coloron"/>
      </net>
      <net>
         <source obj="launch_1" outlet="coloroff"/>
         <dest obj="launch_5" inlet="coloroff"/>
      </net>
      <net>
         <source obj="launch_1" outlet="offset"/>
         <dest obj="launch_5" inlet="offset"/>
      </net>
      <net>
         <source obj="launch_1" outlet="start"/>
         <dest obj="launch_5" inlet="start"/>
      </net>
      <net>
         <source obj="b_3" outlet="pulse"/>
         <dest obj="flipflop_5" inlet="reset"/>
         <dest obj="launch_1" inlet="redraw"/>
      </net>
      <net>
         <source obj="flipflop_5" outlet="o"/>
         <dest obj="launch_5" inlet="active"/>
      </net>
      <net>
         <source obj="==_1" outlet="out"/>
         <dest obj="and_5" inlet="i1"/>
      </net>
      <net>
         <source obj="c_1" outlet="out"/>
         <dest obj="save_1" inlet="filename"/>
      </net>
      <net>
         <source obj="c_2" outlet="out"/>
         <dest obj="save_2" inlet="filename"/>
      </net>
      <net>
         <source obj="keyb_2" outlet="gate"/>
         <dest obj="save_1" inlet="trig"/>
         <dest obj="save_2" inlet="trig"/>
      </net>
      <net>
         <source obj="i_6" outlet="out"/>
         <dest obj="tablestore_12" inlet="channel"/>
         <dest obj="tablestore_22" inlet="channel"/>
         <dest obj="tablestore_23" inlet="channel"/>
         <dest obj="tablestore_24" inlet="channel"/>
         <dest obj="tablestore_25" inlet="channel"/>
         <dest obj="tablestore_21" inlet="channel"/>
         <dest obj="tablestore_27" inlet="channel"/>
         <dest obj="tablestore_28" inlet="channel"/>
         <dest obj="tablestore_29" inlet="channel"/>
         <dest obj="tablestore_30" inlet="channel"/>
         <dest obj="tablestore_31" inlet="channel"/>
         <dest obj="tablestore_32" inlet="channel"/>
         <dest obj="tablestore_14" inlet="channel"/>
         <dest obj="tablestore_26" inlet="channel"/>
      </net>
      <net>
         <source obj="i_5" outlet="out"/>
         <dest obj="tablestore_11" inlet="channel"/>
         <dest obj="patcher_2" inlet="channel"/>
         <dest obj="tablestore_13" inlet="channel"/>
         <dest obj="patcher_4" inlet="channel"/>
      </net>
      <net>
         <source obj="in_1" outlet="left"/>
         <dest obj="out_1" inlet="left"/>
      </net>
      <net>
         <source obj="in_1" outlet="right"/>
         <dest obj="out_1" inlet="right"/>
      </net>
      <net>
         <source obj="counter_14" outlet="c"/>
         <dest obj="and_13" inlet="i2"/>
         <dest obj="step_5" inlet="pulse"/>
         <dest obj="object_7" inlet="bartrig"/>
      </net>
      <net>
         <source obj="counter_15" outlet="c"/>
         <dest obj="and_14" inlet="i2"/>
      </net>
      <net>
         <source obj="note_3" outlet="gate"/>
         <dest obj="toggle_1" inlet="set"/>
         <dest obj="step_5" inlet="r"/>
      </net>
      <net>
         <source obj="note_1" outlet="gate"/>
         <dest obj="toggle_1" inlet="reset"/>
      </net>
      <net>
         <source obj="top_1" outlet="t7"/>
         <dest obj="object_3" inlet="shift"/>
         <dest obj="object_4" inlet="shift"/>
      </net>
      <net>
         <source obj="and_2" outlet="o"/>
         <dest obj="top_2" inlet="on"/>
      </net>
      <net>
         <source obj="and_3" outlet="o"/>
         <dest obj="top_2" inlet="coloron"/>
      </net>
      <net>
         <source obj="*_1" outlet="result"/>
         <dest obj="out_2" inlet="left"/>
         <dest obj="out_2" inlet="right"/>
      </net>
      <net>
         <source obj="dial_1" outlet="out"/>
         <dest obj="*_1" inlet="a"/>
      </net>
      <net>
         <source obj="flashplay_1" outlet="out"/>
         <dest obj="*_1" inlet="b"/>
      </net>
      <net>
         <source obj="or_3" outlet="o"/>
         <dest obj="and_8" inlet="i1"/>
      </net>
      <net>
         <source obj="and_8" outlet="o"/>
         <dest obj="flashplay_1" inlet="trig"/>
      </net>
      <net>
         <source obj="launch_7" outlet="note"/>
         <dest obj="tablestore_1" inlet="v"/>
      </net>
      <net>
         <source obj="tablestore_1" outlet="v"/>
         <dest obj="step_2" inlet="step"/>
         <dest obj="launch_5" inlet="barcount"/>
         <dest obj="launch_8" inlet="barcount"/>
         <dest obj="object_3" inlet="barcount"/>
         <dest obj="object_4" inlet="barcount"/>
      </net>
      <net>
         <source obj="launch_7" outlet="gate"/>
         <dest obj="tablestore_1" inlet="trig"/>
      </net>
      <net>
         <source obj="object_4" outlet="offsetnotes"/>
         <dest obj="tablestore_27" inlet="offset"/>
         <dest obj="patcher_4" inlet="offset"/>
      </net>
      <net>
         <source obj="counter_10" outlet="o"/>
         <dest obj="tablestore_13" inlet="stepunQ"/>
         <dest obj="tablestore_14" inlet="stepunQ"/>
         <dest obj="tablestore_28" inlet="stepunQ"/>
         <dest obj="tablestore_29" inlet="stepunQ"/>
         <dest obj="tablestore_30" inlet="stepunQ"/>
         <dest obj="tablestore_31" inlet="stepunQ"/>
         <dest obj="tablestore_32" inlet="stepunQ"/>
         <dest obj="tablestore_27" inlet="stepunQ"/>
         <dest obj="patcher_4" inlet="stepunQ"/>
      </net>
      <net>
         <source obj="counter_12" outlet="o"/>
         <dest obj="tablestore_14" inlet="step"/>
         <dest obj="tablestore_28" inlet="step"/>
         <dest obj="tablestore_29" inlet="step"/>
         <dest obj="tablestore_30" inlet="step"/>
         <dest obj="tablestore_31" inlet="step"/>
         <dest obj="tablestore_32" inlet="step"/>
         <dest obj="tablestore_27" inlet="step"/>
         <dest obj="patcher_4" inlet="step"/>
      </net>
      <net>
         <source obj="object_4" outlet="rec"/>
         <dest obj="tablestore_13" inlet="rec"/>
         <dest obj="patcher_4" inlet="rec"/>
         <dest obj="launch_8" inlet="rec"/>
      </net>
      <net>
         <source obj="object_4" outlet="play"/>
         <dest obj="tablestore_14" inlet="play"/>
         <dest obj="tablestore_28" inlet="play"/>
         <dest obj="tablestore_29" inlet="play"/>
         <dest obj="tablestore_30" inlet="play"/>
         <dest obj="tablestore_31" inlet="play"/>
         <dest obj="tablestore_32" inlet="play"/>
         <dest obj="tablestore_27" inlet="play"/>
         <dest obj="launch_8" inlet="play"/>
      </net>
      <net>
         <source obj="tablestore_27" outlet="totaloffset"/>
         <dest obj="tablestore_28" inlet="offset"/>
      </net>
      <net>
         <source obj="tablestore_28" outlet="totaloffset"/>
         <dest obj="tablestore_29" inlet="offset"/>
      </net>
      <net>
         <source obj="tablestore_29" outlet="totaloffset"/>
         <dest obj="tablestore_30" inlet="offset"/>
      </net>
      <net>
         <source obj="tablestore_30" outlet="totaloffset"/>
         <dest obj="tablestore_31" inlet="offset"/>
      </net>
      <net>
         <source obj="tablestore_31" outlet="totaloffset"/>
         <dest obj="tablestore_32" inlet="offset"/>
      </net>
      <net>
         <source obj="tablestore_32" outlet="totaloffset"/>
         <dest obj="tablestore_13" inlet="offset"/>
         <dest obj="tablestore_14" inlet="offset"/>
      </net>
      <net>
         <source obj="object_4" outlet="clipslot"/>
         <dest obj="==_3" inlet="in2"/>
         <dest obj="launch_8" inlet="step"/>
      </net>
      <net>
         <source obj="launch_3" outlet="coloron"/>
         <dest obj="launch_8" inlet="coloron"/>
      </net>
      <net>
         <source obj="launch_3" outlet="coloroff"/>
         <dest obj="launch_8" inlet="coloroff"/>
      </net>
      <net>
         <source obj="launch_3" outlet="offset"/>
         <dest obj="launch_8" inlet="offset"/>
      </net>
      <net>
         <source obj="launch_3" outlet="start"/>
         <dest obj="launch_8" inlet="start"/>
      </net>
      <net>
         <source obj="b_4" outlet="pulse"/>
         <dest obj="flipflop_6" inlet="reset"/>
         <dest obj="launch_3" inlet="redraw"/>
      </net>
      <net>
         <source obj="flipflop_6" outlet="o"/>
         <dest obj="launch_8" inlet="active"/>
      </net>
      <net>
         <source obj="==_3" outlet="out"/>
         <dest obj="and_6" inlet="i1"/>
      </net>
      <net>
         <source obj="i_3" outlet="out"/>
         <dest obj="launch_3" inlet="offset"/>
      </net>
      <net>
         <source obj="loadbang_1" outlet="pulse"/>
         <dest obj="delayedpulse_1" inlet="trig"/>
      </net>
      <net>
         <source obj="delayedpulse_1" outlet="pulse"/>
         <dest obj="step_2" inlet="active"/>
      </net>
      <net>
         <source obj="keyb_3" outlet="gate"/>
         <dest obj="load_3" inlet="trig"/>
      </net>
      <net>
         <source obj="and_5" outlet="o"/>
         <dest obj="b_3" inlet="trig"/>
      </net>
      <net>
         <source obj="and_6" outlet="o"/>
         <dest obj="b_4" inlet="trig"/>
      </net>
      <net>
         <source obj="delayedpulse_2" outlet="pulse"/>
         <dest obj="launch_5" inlet="stop"/>
         <dest obj="launch_8" inlet="stop"/>
      </net>
      <net>
         <source obj="i_1" outlet="out"/>
         <dest obj="step_5" inlet="offset"/>
      </net>
      <net>
         <source obj="c_3" outlet="out"/>
         <dest obj="load_1" inlet="filename"/>
      </net>
      <net>
         <source obj="top_1" outlet="t4"/>
         <dest obj="load_1" inlet="trig"/>
      </net>
      <net>
         <source obj="object_3" outlet="nrectrig"/>
         <dest obj="counter_7" inlet="r"/>
      </net>
      <net>
         <source obj="counter_13" outlet="o"/>
         <dest obj="patcher_2" inlet="qstep"/>
      </net>
      <net>
         <source obj="counter_7" outlet="o"/>
         <dest obj="patcher_2" inlet="steprec"/>
      </net>
      <net>
         <source obj="object_3" outlet="clearslot"/>
         <dest obj="==_1" inlet="in1"/>
      </net>
      <net>
         <source obj="object_3" outlet="cleartrigger"/>
         <dest obj="and_5" inlet="i2"/>
      </net>
      <net>
         <source obj="object_3" outlet="cliptrigger"/>
         <dest obj="flipflop_5" inlet="set"/>
      </net>
      <net>
         <source obj="object_3" outlet="wait"/>
         <dest obj="launch_5" inlet="wait"/>
      </net>
      <net>
         <source obj="object_4" outlet="nplaytrig"/>
         <dest obj="counter_10" inlet="r"/>
         <dest obj="counter_12" inlet="r"/>
         <dest obj="launch_8" inlet="redraw"/>
      </net>
      <net>
         <source obj="object_4" outlet="nrectrig"/>
         <dest obj="counter_8" inlet="r"/>
      </net>
      <net>
         <source obj="counter_16" outlet="o"/>
         <dest obj="patcher_4" inlet="qstep"/>
      </net>
      <net>
         <source obj="counter_8" outlet="o"/>
         <dest obj="patcher_4" inlet="steprec"/>
      </net>
      <net>
         <source obj="object_4" outlet="clearslot"/>
         <dest obj="==_3" inlet="in1"/>
      </net>
      <net>
         <source obj="object_4" outlet="cleartrigger"/>
         <dest obj="and_6" inlet="i2"/>
      </net>
      <net>
         <source obj="object_4" outlet="cliptrigger"/>
         <dest obj="flipflop_6" inlet="set"/>
      </net>
      <net>
         <source obj="object_4" outlet="wait"/>
         <dest obj="launch_8" inlet="wait"/>
      </net>
   </nets>
   <settings>
      <subpatchmode>no</subpatchmode>
      <MidiChannel>9</MidiChannel>
      <NPresets>0</NPresets>
      <NPresetEntries>0</NPresetEntries>
      <NModulationSources>0</NModulationSources>
      <NModulationTargetsPerSource>0</NModulationTargetsPerSource>
   </settings>
   <notes><![CDATA[can i use 1 table write for the notes? use offset
]]></notes>
   <windowPos>
      <x>-8</x>
      <y>-8</y>
      <width>1616</width>
      <height>876</height>
   </windowPos>
</patch-1.0>