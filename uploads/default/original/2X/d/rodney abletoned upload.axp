<patch-1.0 appVersion="1.0.12">
   <comment type="patch/comment" x="1358" y="0" text="launch control xl to DIN"/>
   <comment type="patch/comment" x="168" y="14" text="clock 4 ppq"/>
   <comment type="patch/comment" x="518" y="14" text="start"/>
   <comment type="patch/comment" x="658" y="14" text="stop"/>
   <comment type="patch/comment" x="798" y="14" text="top right button (launchpad)"/>
   <obj type="tb/midi/utils/midithru" uuid="b3868bd5-625c-4482-9948-a34e59fe2a21" name="midithru_1" x="1358" y="14">
      <params/>
      <attribs>
         <combo attributeName="input" selection="usb host port 1"/>
         <combo attributeName="output" selection="din"/>
         <combo attributeName="led" selection="off"/>
      </attribs>
   </obj>
   <patchobj type="patch/object" uuid="50cc8a99-8d1d-4e24-bfa0-9ab776a20b04" name="note_2" x="140" y="28">
      <params/>
      <attribs>
         <spinner attributeName="note" value="0"/>
         <spinner attributeName="channel" value="15"/>
      </attribs>
      <object id="patch/object" uuid="50cc8a99-8d1d-4e24-bfa0-9ab776a20b04">
         <sDescription>Monophonic MIDI keyboard note input, gate, velocity and release velocity</sDescription>
         <author>Johannes Taelman</author>
         <license>BSD</license>
         <helpPatch>midi_in.axh</helpPatch>
         <inlets/>
         <outlets>
            <bool32 name="gate" description="key pressed?"/>
         </outlets>
         <displays/>
         <params/>
         <attribs>
            <spinner name="note" MinValue="0" MaxValue="127" DefaultValue="64"/>
            <spinner name="channel" MinValue="1" MaxValue="16" DefaultValue="0"/>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[uint8_t _gate;]]></code.declaration>
         <code.init><![CDATA[_gate = 0;]]></code.init>
         <code.krate><![CDATA[outlet_gate= _gate<<27;]]></code.krate>
         <code.midihandler><![CDATA[if ((status == MIDI_NOTE_ON + (attr_channel-1)) && (data2)) {if (data1 == attr_note) {
   _gate = 1;
}
} else if (((status == MIDI_NOTE_ON + (attr_channel-1)) && (!data2))||          (status == MIDI_NOTE_OFF + (attr_channel-1))) {
  if (data1 == attr_note) {
    _gate = 0;
  }
} else if ((status == (attr_channel-1) + MIDI_CONTROL_CHANGE)&&(data1 == MIDI_C_ALL_NOTES_OFF)) {
  _gate = 0;
}]]></code.midihandler>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="fc6ccaec-f6d3-4786-ae42-bf5420ff9feb" name="note_3" x="518" y="28">
      <params/>
      <attribs>
         <spinner attributeName="note" value="2"/>
         <spinner attributeName="channel" value="15"/>
      </attribs>
      <object id="patch/object" uuid="fc6ccaec-f6d3-4786-ae42-bf5420ff9feb">
         <sDescription>Monophonic MIDI keyboard note input, gate, velocity and release velocity</sDescription>
         <author>Johannes Taelman</author>
         <license>BSD</license>
         <helpPatch>midi_in.axh</helpPatch>
         <inlets/>
         <outlets>
            <bool32 name="gate" description="key pressed?"/>
         </outlets>
         <displays/>
         <params/>
         <attribs>
            <spinner name="note" MinValue="0" MaxValue="127" DefaultValue="64"/>
            <spinner name="channel" MinValue="1" MaxValue="16" DefaultValue="0"/>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[uint8_t _gate;]]></code.declaration>
         <code.init><![CDATA[_gate = 0;]]></code.init>
         <code.krate><![CDATA[outlet_gate= _gate<<27;]]></code.krate>
         <code.midihandler><![CDATA[if ((status == MIDI_NOTE_ON + (attr_channel-1)) && (data2)) {if (data1 == attr_note) {
   _gate = 1;
}
} else if (((status == MIDI_NOTE_ON + (attr_channel-1)) && (!data2))||          (status == MIDI_NOTE_OFF + (attr_channel-1))) {
  if (data1 == attr_note) {
    _gate = 0;
  }
} else if ((status == (attr_channel-1) + MIDI_CONTROL_CHANGE)&&(data1 == MIDI_C_ALL_NOTES_OFF)) {
  _gate = 0;
}]]></code.midihandler>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="68b472eb-1a52-4ad3-b27c-92480a3ee776" name="note_1" x="658" y="28">
      <params/>
      <attribs>
         <spinner attributeName="note" value="3"/>
         <spinner attributeName="channel" value="15"/>
      </attribs>
      <object id="patch/object" uuid="68b472eb-1a52-4ad3-b27c-92480a3ee776">
         <sDescription>Monophonic MIDI keyboard note input, gate, velocity and release velocity</sDescription>
         <author>Johannes Taelman</author>
         <license>BSD</license>
         <helpPatch>midi_in.axh</helpPatch>
         <inlets/>
         <outlets>
            <bool32 name="gate" description="key pressed?"/>
         </outlets>
         <displays/>
         <params/>
         <attribs>
            <spinner name="note" MinValue="0" MaxValue="127" DefaultValue="64"/>
            <spinner name="channel" MinValue="1" MaxValue="16" DefaultValue="0"/>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[uint8_t _gate;]]></code.declaration>
         <code.init><![CDATA[_gate = 0;]]></code.init>
         <code.krate><![CDATA[outlet_gate= _gate<<27;]]></code.krate>
         <code.midihandler><![CDATA[if ((status == MIDI_NOTE_ON + (attr_channel-1)) && (data2)) {if (data1 == attr_note) {
   _gate = 1;
}
} else if (((status == MIDI_NOTE_ON + (attr_channel-1)) && (!data2))||          (status == MIDI_NOTE_OFF + (attr_channel-1))) {
  if (data1 == attr_note) {
    _gate = 0;
  }
} else if ((status == (attr_channel-1) + MIDI_CONTROL_CHANGE)&&(data1 == MIDI_C_ALL_NOTES_OFF)) {
  _gate = 0;
}]]></code.midihandler>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="9bfcf277-a28b-41d6-b233-8dd0d8b7eab0" name="top_1" x="798" y="28">
      <params/>
      <attribs/>
      <object id="patch/object" uuid="9bfcf277-a28b-41d6-b233-8dd0d8b7eab0">
         <sDescription>outputs the state of the top-row buttons of a &apos;novation launchpad&apos;.
DOES NOT work with the &apos;LP mark 1&apos;.</sDescription>
         <author>Robert Schirmer</author>
         <license>BSD</license>
         <helpPatch>launchpad.axh</helpPatch>
         <inlets/>
         <outlets>
            <bool32 name="t0"/>
            <bool32 name="t1"/>
            <bool32 name="t2"/>
            <bool32 name="t4"/>
            <bool32 name="t6"/>
            <bool32 name="t7"/>
            <bool32 name="shift"/>
            <int32 name="mode"/>
            <int32 name="track"/>
         </outlets>
         <displays/>
         <params/>
         <attribs/>
         <includes/>
         <code.declaration><![CDATA[uint8_t cc [128];
int hold;
int track;]]></code.declaration>
         <code.krate><![CDATA[outlet_t0 = cc[104];
outlet_t1 = cc[105];
outlet_t2 = cc[106];
outlet_t4 = cc[108];

outlet_t6 = cc[110];
outlet_t7 = cc[111];
if (cc[105]) {outlet_mode=0;hold=0;track=0;}
if (cc[107]) {outlet_mode=1;hold=1;track=1;}
if (cc[109]) {outlet_mode=2;hold=2;track=2;}
if (cc[104]) {outlet_mode=3;hold=3;track=0;}
if (cc[106]) {outlet_mode=4;hold=4;track=1;}
if (cc[108]) {outlet_mode=5;hold=5;track=2;}
outlet_mode=hold;
outlet_track=track;
outlet_shift = (cc[105])||(cc[107])||(cc[109])||(cc[104])||(cc[106])||(cc[108]);]]></code.krate>
         <code.midihandler><![CDATA[if (status == 0 + MIDI_CONTROL_CHANGE) cc[data1] = data2;]]></code.midihandler>
      </object>
   </patchobj>
   <obj type="drj/seq/clk_mul" uuid="1413af5343f97123abeeb627811120af4b3a4793" name="clk_mul_1" x="280" y="112">
      <params>
         <int32 name="clockmul" value="2"/>
      </params>
      <attribs/>
   </obj>
   <obj type="drj/seq/clk_mul" uuid="1413af5343f97123abeeb627811120af4b3a4793" name="clk_mul_2" x="392" y="112">
      <params>
         <int32 name="clockmul" value="32"/>
      </params>
      <attribs/>
   </obj>
   <comment type="patch/comment" x="1148" y="112" text="play"/>
   <patchobj type="patch/object" uuid="2402584d-2694-4ed4-8d77-54830ea0fabf" name="toggle_1" x="1134" y="126">
      <params/>
      <attribs/>
      <object id="patch/object" uuid="2402584d-2694-4ed4-8d77-54830ea0fabf">
         <sDescription>toggle</sDescription>
         <author>Johannes Taelman</author>
         <license>BSD</license>
         <helpPatch>logic.axh</helpPatch>
         <inlets>
            <bool32.rising name="trig" description="trigger"/>
            <bool32 name="set"/>
            <bool32 name="reset"/>
         </inlets>
         <outlets>
            <bool32 name="o" description="output"/>
            <bool32 name="stop"/>
            <bool32 name="start"/>
         </outlets>
         <displays/>
         <params/>
         <attribs/>
         <includes/>
         <code.declaration><![CDATA[int ntrig;
   int op;
int Mtrig;
int MBtrig;
   int p_set;
   int p_reset;]]></code.declaration>
         <code.init><![CDATA[ntrig = 0;
op = 0;
]]></code.init>
         <code.krate><![CDATA[if ((inlet_trig>0) && !ntrig) {op = !op; ntrig=1;}
if (!(inlet_trig>0)) ntrig=0;
if ((inlet_set>0) && !p_set) {op = 1; p_set=1;}
if ((inlet_reset>0) && !p_reset) {op = 0; p_reset=1;}
if (!(inlet_set>0)) p_set=0;
if (!(inlet_reset>0)) p_reset=0;

outlet_o= op;
if ((!(op>0))&&!Mtrig) {
outlet_stop=1;
	Mtrig=1;
}
else outlet_stop=0;
if ((op>0)&&(!MBtrig)) {
outlet_start=1;
	MBtrig=1;
}
else outlet_start=0;

if (op>0) {Mtrig=0;}
if(!(op>0)) {MBtrig=0;}]]></code.krate>
      </object>
   </patchobj>
   <obj type="logic/or 2" uuid="3805d3c84d30032a44fbdbe42d9a2988a1790a3e" name="or_4" x="1232" y="126">
      <params/>
      <attribs/>
   </obj>
   <comment type="patch/comment" x="84" y="168" text="max bar length + fx data"/>
   <comment type="patch/comment" x="294" y="168" text="clip data"/>
   <obj type="table/alloc 16b sdram load" uuid="e6b85dad3ab43565cda93ea4c43c73b668b1cd43" name="lcxl3" x="84" y="182">
      <params/>
      <attribs>
         <combo attributeName="size" selection="64"/>
         <file attributeName="filename" file="/abletones"/>
      </attribs>
   </obj>
   <obj type="table/alloc 16b sdram load" uuid="e6b85dad3ab43565cda93ea4c43c73b668b1cd43" name="lcxl2" x="294" y="182">
      <params/>
      <attribs>
         <combo attributeName="size" selection="2097152"/>
         <file attributeName="filename" file="/abletone"/>
      </attribs>
   </obj>
   <comment type="patch/comment" x="518" y="210" text="4ppq half a step early for quantize"/>
   <comment type="patch/comment" x="714" y="210" text="barcount play"/>
   <comment type="patch/comment" x="812" y="210" text="bar count rec"/>
   <obj type="djrm/logic/counter2_init_start" uuid="d5936f238ab92e53ac93d5927c3b43ceef998dc1" name="counter2_init_start_3" x="546" y="224">
      <params>
         <int32 name="maximum" value="1"/>
         <int32 name="init" value="1"/>
      </params>
      <attribs/>
   </obj>
   <obj type="logic/counter" uuid="7a141ba82230e54e5f5cd12da5dbe5a74ba854a5" name="counter_14" x="714" y="224">
      <params>
         <int32 name="maximum" value="16"/>
      </params>
      <attribs/>
   </obj>
   <obj type="logic/counter" uuid="7a141ba82230e54e5f5cd12da5dbe5a74ba854a5" name="counter_15" x="812" y="224">
      <params>
         <int32 name="maximum" value="16"/>
      </params>
      <attribs/>
   </obj>
   <obj type="logic/and 2" uuid="c67031682f552aa0a80b23377495c51ea28a8c9c" name="and_13" x="910" y="224">
      <params/>
      <attribs/>
   </obj>
   <obj type="logic/and 2" uuid="c67031682f552aa0a80b23377495c51ea28a8c9c" name="and_14" x="994" y="224">
      <params/>
      <attribs/>
   </obj>
   <comment type="patch/comment" x="196" y="294" text="max bar  record length"/>
   <patchobj type="patch/object" uuid="7adf6824-f78a-4e1a-90e6-9f120b9662c8" name="launch_7" x="84" y="308">
      <params/>
      <attribs>
         <spinner attributeName="channel" value="1"/>
      </attribs>
      <object id="patch/object" uuid="7adf6824-f78a-4e1a-90e6-9f120b9662c8">
         <sDescription>Monophonic MIDI keyboard note input, gate, velocity and release velocity, only responding to a range of notes</sDescription>
         <author>Johannes Taelman</author>
         <license>BSD</license>
         <helpPatch>midi_in.axh</helpPatch>
         <inlets>
            <bool32 name="active"/>
         </inlets>
         <outlets>
            <int32 name="note"/>
            <bool32 name="gate" description="key pressed?"/>
         </outlets>
         <displays/>
         <params/>
         <attribs>
            <spinner name="channel" MinValue="1" MaxValue="16" DefaultValue="9"/>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[int8_t _note;
uint8_t _gate;]]></code.declaration>
         <code.init><![CDATA[_gate = 0;
_note = 0;]]></code.init>
         <code.krate><![CDATA[outlet_note= _note;

outlet_gate= _gate<<27;]]></code.krate>
         <code.midihandler><![CDATA[if ((status == MIDI_NOTE_ON + (attr_channel-1)) && (data2) && (data1 == 6)) {
    _note = 0;
    _gate = 1;
}
if ((status == MIDI_NOTE_ON + (attr_channel-1)) && (data2) && (data1 == 22)) {
    _note = 1;
    _gate = 1;
} 
if ((status == MIDI_NOTE_ON + (attr_channel-1)) && (data2) && (data1 == 38)) {
    _note = 2;
    _gate = 1;
} 
if ((status == MIDI_NOTE_ON + (attr_channel-1)) && (data2) && (data1 == 54)) {
    _note = 3;
    _gate = 1;
} 
if ((status == MIDI_NOTE_ON + (attr_channel-1)) && (data2) && (data1 == 70)) {
    _note = 4;
    _gate = 1;
} 
if ((status == MIDI_NOTE_ON + (attr_channel-1)) && (data2) && (data1 == 86)) {
    _note = 5;
    _gate = 1;
} 
if ((status == MIDI_NOTE_ON + + (attr_channel-1)) && (data2) && (data1 == 102)) {
    _note = 6;
    _gate = 1;
} 
if ((status == MIDI_NOTE_ON + (attr_channel-1)) && (data2) && (data1 == 118)) {
    _note = 7;
    _gate = 1;
} 
if ((status == MIDI_NOTE_ON + (attr_channel-1)) && (data2) && (data1 == 7)) {
    _note = 8;
    _gate = 1;
} 
if ((status == MIDI_NOTE_ON + (attr_channel-1)) && (data2) && (data1 == 23)) {
    _note = 9;
    _gate = 1;
} 
if ((status == MIDI_NOTE_ON + (attr_channel-1)) && (data2) && (data1 == 39)) {
    _note = 10;
    _gate = 1;
} 
if ((status == MIDI_NOTE_ON + (attr_channel-1)) && (data2) && (data1 == 55)) {
    _note = 11;
    _gate = 1;
} 
if ((status == MIDI_NOTE_ON + (attr_channel-1)) && (data2) && (data1 == 71)) {
    _note = 12;
    _gate = 1;
} 
if ((status == MIDI_NOTE_ON + (attr_channel-1)) && (data2) && (data1 == 87)) {
    _note = 13;
    _gate = 1;
} 
if ((status == MIDI_NOTE_ON + (attr_channel-1)) && (data2) && (data1 == 103)) {
    _note = 14;
    _gate = 1;
} 
if ((status == MIDI_NOTE_ON + (attr_channel-1)) && (data2) && (data1 == 119)) {
    _note = 15;
    _gate = 1;
} 
else if (((status == MIDI_NOTE_ON + (attr_channel-1)) && (!data2))||          (status == MIDI_NOTE_OFF + (attr_channel-1))) {
    _gate = 0;
  }]]></code.midihandler>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="e8c7c633-0416-4595-9cf3-ad1b828c06dd" name="tablestore_1" x="182" y="308">
      <params/>
      <attribs>
         <objref attributeName="table" obj="lcxl3"/>
      </attribs>
      <object id="patch/object" uuid="e8c7c633-0416-4595-9cf3-ad1b828c06dd">
         <sDescription>writes and outputs values to a table at position &apos;i&apos; + &apos;offset&apos; at the rising edge of &apos;trig&apos;</sDescription>
         <author>robert schirmer</author>
         <license>who cares</license>
         <inlets>
            <frac32 name="v" description="value to write to a table"/>
            <int32 name="i" description="writes to a table at position i + offset"/>
            <bool32.rising name="trig" description="trigger write"/>
         </inlets>
         <outlets>
            <frac32 name="v" description="out0  +  i"/>
         </outlets>
         <displays/>
         <params/>
         <attribs>
            <objref name="table"/>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[int ntrig;]]></code.declaration>
         <code.init><![CDATA[ntrig = 0;]]></code.init>
         <code.krate><![CDATA[if ((inlet_trig>0) && !ntrig) {
	ntrig = 1;
attr_table.array[inlet_i ]=__SSAT(inlet_v,28)>>attr_table.GAIN;
}
if (!(inlet_trig>0)) ntrig=0;
outlet_v= attr_table.array[__USAT((inlet_i),attr_table.LENGTHPOW)]<<attr_table.GAIN;]]></code.krate>
      </object>
   </patchobj>
   <comment type="patch/comment" x="742" y="322" text="track 1"/>
   <comment type="patch/comment" x="1008" y="322" text="track 2"/>
   <comment type="patch/comment" x="742" y="336" text="transport &amp; pattern length rec"/>
   <comment type="patch/comment" x="1008" y="336" text="transport &amp; pattern length rec"/>
   <patchobj type="patch/object" uuid="8385bd19-937d-47af-9b09-08facf287fbb" name="object_3" x="742" y="350">
      <params/>
      <attribs>
         <objref attributeName="table" obj="lcxl2"/>
         <spinner attributeName="buttonoffset" value="0"/>
         <spinner attributeName="total" value="137217"/>
         <spinner attributeName="barcount" value="16"/>
         <spinner attributeName="column" value="1"/>
      </attribs>
      <object id="patch/object" uuid="8385bd19-937d-47af-9b09-08facf287fbb">
         <inlets>
            <bool32 name="shift"/>
            <bool32 name="pulse"/>
            <bool32 name="pulseplay"/>
            <int32 name="barcount"/>
            <bool32 name="start"/>
            <bool32 name="stop"/>
         </inlets>
         <outlets>
            <int32 name="clipslot"/>
            <int32 name="clearslot"/>
            <bool32 name="cliptrigger"/>
            <bool32 name="cleartrigger"/>
            <int32 name="offsetnotes"/>
            <bool32 name="wait"/>
            <bool32 name="rec"/>
            <bool32 name="play"/>
            <bool32 name="nplaytrig"/>
            <bool32 name="nrectrig"/>
         </outlets>
         <displays/>
         <params/>
         <attribs>
            <objref name="table"/>
            <spinner name="buttonoffset" MinValue="0" MaxValue="10000000" DefaultValue="0"/>
            <spinner name="total" MinValue="0" MaxValue="5000000" DefaultValue="0"/>
            <spinner name="barcount" MinValue="0" MaxValue="16" DefaultValue="0"/>
            <spinner name="column" MinValue="1" MaxValue="8" DefaultValue="1"/>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[uint32_t i;
uint32_t ii;
uint32_t src;
uint32_t range;
uint32_t block;
int note;
int trigger;
int clipslot;
int clearslot;
int clear;
int clip;
int clipB;

int cloffset;
int nclear;
int rclear;
int speed;



int pclipslot;
int slotoffset;
int offset;
int full;
int ntrig;
int xtrig;
int prevplay;
int playtrig;
int recordtrig;
int recofftrig;
int wait;
int zwait;
int ztrig;
int record;
int play;
int outletrectrig;
int bar_record;
int maxbar;
int vcount;
int vtrig;
int vrtrig;
int vr2trig;
int ctrig;
int rtrig;
int count;
int prevfull;
int nrectrig;
int nplaytrig;
int prevoffset;]]></code.declaration>
         <code.init><![CDATA[full=attr_table.array[__USAT((0+ attr_buttonoffset),attr_table.LENGTHPOW)]<<attr_table.GAIN;
slotoffset=0;
count=0;
ctrig = 0;
rtrig = 0;
clipslot=6;
clearslot=6;
pclipslot=8;]]></code.init>
         <code.krate><![CDATA[/////
if ((!inlet_shift)&&trigger){
if (note==(0+(attr_column-1))) {clipslot=0;clip=1;clipB=0;}
if (note==(16+(attr_column-1))) {clipslot=1;clip=1;clipB=0;}
if (note==(32+(attr_column-1))) {clipslot=2;clip=1;clipB=0;}
if (note==(48+(attr_column-1))) {clipslot=3;clip=1;clipB=0;}
if (note==(64+(attr_column-1))) {clipslot=4;clip=1;clipB=0;}
if (note==(80+(attr_column-1))) {clipslot=5;clip=1;clipB=0;}
if (note==(96+(attr_column-1))) {clipslot=6;clip=1;clipB=0;}
if ((note==(112+(attr_column-1)))||(note==120)) {clipslot=7;clip=1;}
	if (note==8) {clipslot=0;clipB=1;clip=1;}
	if (note==24) {clipslot=1;clipB=1;clip=1;}
	if (note==40) {clipslot=2;clipB=1;clip=1;}
	if (note==56) {clipslot=3;clipB=1;clip=1;}
	if (note==72) {clipslot=4;clipB=1;clip=1;}
	if (note==88) {clipslot=5;clipB=1;clip=1;}
	if (note==104) {clipslot=6;clipB=1;clip=1;}
	if (note==120) {clipslot=7;clipB=1;clip=1;}
	
}

else if (inlet_shift){
if ((note==(0+(attr_column-1)))&&trigger) {clearslot=0;clear=1;}
if ((note==(16+(attr_column-1)))&&trigger) {clearslot=1;clear=1;}
if ((note==(32+(attr_column-1)))&&trigger) {clearslot=2;clear=1;}
if ((note==(48+(attr_column-1)))&&trigger) {clearslot=3;clear=1;}
if ((note==(64+(attr_column-1)))&&trigger) {clearslot=4;clear=1;}
if ((note==(80+(attr_column-1)))&&trigger) {clearslot=5;clear=1;}
if ((note==(96+(attr_column-1)))&&trigger) {clearslot=6;clear=1;}
if ((note==(112+(attr_column-1)))&&trigger) {clearslot=7;clear=1;}
}




//full=attr_table.array[__USAT((clipslot+ attr_buttonoffset),attr_table.LENGTHPOW)]<<attr_table.GAIN;
//if ((clipB)&&(full>0)){clip=1;clipB=0;}
//if ((clipB)&&(!(full>0))){clip=1;}
       

if (!trigger) {clip=0;clear=0;}



/////

full=attr_table.array[__USAT((clipslot+ attr_buttonoffset),attr_table.LENGTHPOW)]<<attr_table.GAIN;
nrectrig=0;
nplaytrig=0;
offset=8+slotoffset+attr_buttonoffset;
outlet_offsetnotes=offset+1;

if (inlet_start>0){play=prevplay;}
//if ((clipB>0)&&(full)&&!ntrig){	
//	wait=1;
//	zwait=1;	
//	ntrig=1;
//}
if ((clip>0)&&!ntrig){	
	wait=1;
	zwait=1;	
	ntrig=1;
}
if ((wait>0)&&(!(clip>0))&&(inlet_pulse>0)) {xtrig=1;nrectrig=1;wait=0;ntrig=0;}
if ((zwait>0)&&(!(clip>0))&&(inlet_pulseplay>0)) {
	nplaytrig=1;
	zwait=0;
	}

//
if ((clipslot==7)&&xtrig){
	if (record>0){
		attr_table.array[prevfull + attr_buttonoffset]=__SSAT(0,28)>>attr_table.GAIN;
	}
	prevplay=play;
	play=0;
	record=0;
	wait=0;
	ntrig=0;
	xtrig=0;
	clipB=0;
	pclipslot=8;
}
//
if (clipslot<7)
{
if ((clipslot!=pclipslot)&&xtrig){
	if (record>0){
		attr_table.array[offset]=__SSAT((bar_record),28)>>attr_table.GAIN;
	}
	xtrig=0;
	vcount=0;
	count=-1;
	nrectrig=1;
	slotoffset=(attr_total*clipslot);
	offset=8+slotoffset+attr_buttonoffset;
	prevoffset=slotoffset;
	full=attr_table.array[__USAT((clipslot+ attr_buttonoffset),attr_table.LENGTHPOW)]<<attr_table.GAIN;
	if (full>0){
		play=1;
		record=0;
	}
	if (!(full>0)){
		if (!clipB){
		play=0;
		attr_table.array[clipslot + attr_buttonoffset]=__SSAT(0x07FFFFFF,28)>>attr_table.GAIN;
		prevfull=clipslot;
		record=1;
		}
		else if (clipB){
		play=0;
		record=0;
		clipB=0;
		}
	}
	pclipslot=clipslot;
	
}
if (!clipB){
if ((!(full>0))&&xtrig){
	attr_table.array[clipslot + attr_buttonoffset]=__SSAT(0x07FFFFFF,28)>>attr_table.GAIN;
	prevfull=clipslot;
	record=1;
	xtrig=0;
}

if ((full>0)&&(!(play>0))&&xtrig){
	record=0;
	play=1;
	xtrig=0;
}
if ((full>0)&&(play>0)&&xtrig){
	record=0;
	vcount=0;
	play=1;
	xtrig=0;
}
}
else if ((clipB)&&(xtrig)){
	if (!full){
	play=0;
	record=0;
	}
	else if (full){
		play=1;
		record=0;
	}
	clipB=0;
	xtrig=0;
}

}


if (inlet_stop>0){
	prevplay=play;
	play=0;
	record=0;
	wait=0;
	ntrig=0;
	xtrig=0;
	clipB=0;
}


if ((clear>0)&&!ntrig){
	ntrig=1;
	attr_table.array[clearslot + attr_buttonoffset]=__SSAT(0,28)>>attr_table.GAIN;
	if (clipslot==clearslot){
		play=0;
		record=0;
		wait=0;
		zwait=0;
	}
}
else if(!(clear)) {ntrig=0;}



//





outlet_play=play;


outlet_wait=wait;
outlet_rec=record;


//playback
if ((play>0)&&!playtrig){
	playtrig=1;
	vcount=0;
}
if (!(play>0)) {playtrig=0;}
outletrectrig=0;
if ((record>0)&&!recordtrig){
	recordtrig=1;
	outletrectrig=1;
}


if (!(record>0)) {recordtrig=0;}

if ((!(record>0))&&!recofftrig){
	attr_table.array[offset]=__SSAT(bar_record,28)>>attr_table.GAIN;
	zwait=1;
	recofftrig=1;
}

//reset
if (record>0){recofftrig=0;}

//barclocks
if ((inlet_pulse>0) && !ctrig) {
   count += 1; 
   if (count>=attr_barcount) 
   {
   	count = attr_barcount;
   }
   if ((count==(inlet_barcount))&&(record>0)){wait=1;}
   ctrig=1;
}
else if (!(inlet_pulse>0)) ctrig=0;

bar_record=(count+1)<<21;
if ((outletrectrig>0) && !rtrig) {count=0; rtrig = 1;}
else if (!(outletrectrig>0)) rtrig=0;



//barlength=recorded
maxbar=(attr_table.array[__USAT(offset,attr_table.LENGTHPOW)]<<attr_table.GAIN)>>21;
//play bar counter
if ((inlet_pulseplay>0) && !vtrig) {
   vcount += 1; if ((vcount>(maxbar))||(vcount>(16))) {
   	vcount = 1; 
   	if ((play>0)&&(!(record>0))){
   	nplaytrig=1;
   	}
   }
   vtrig=1;
}
else if (!(inlet_pulseplay>0)) vtrig=0;
//start
if ((inlet_start>0) && !vr2trig) {vcount=1; vr2trig = 1; nplaytrig=1; nrectrig=1;}
else if (!(inlet_start>0)) vr2trig=0;
//reset vcount
if (vcount>(maxbar)){vcount=1;}

/////////////
cloffset=(attr_buttonoffset+8)+(attr_total*clearslot);


speed = 16 << 4;
src = cloffset;
range = (attr_total);
block  = (range / speed) * speed;

if ((clear)&& (!nclear)){ nclear= 1;i = 0;rclear = 0;}
if ((i == attr_total) && (!clear)) {nclear= 0;i = 0;}


//copy n chunks of size 'speed'
if (nclear && (i < block)){ 
	{ 
  for(ii=0;ii<speed;ii++)
  attr_table.array[(i + ii + src)]= (( attr_table.array[(i + ii + src)] + (attr_table.array[(i + ii + src)] * 0)) * (0));
  }
  i += speed;	
}

//copy what's left
if (i == block) rclear = 1; 

if ((ntrig && rclear) && (i < (attr_total))){ 
	attr_table.array[(i + src)]= (( attr_table.array[(i + src)] + (attr_table.array[(i + src)] * 0)) * (0));
   i += 1;  
 }
//////////////////////////////


outlet_clipslot=clipslot;
outlet_cliptrigger=clip;
outlet_clearslot=clearslot;
outlet_cleartrigger=clear;


outlet_nrectrig=nrectrig;
outlet_nplaytrig=nplaytrig;]]></code.krate>
         <code.midihandler><![CDATA[if ((status == MIDI_NOTE_ON + 0)&&(data2))
	{
		note=data1;
		trigger=1;
	}
if ((status == MIDI_NOTE_ON + 0)&&(!data2))
	{trigger=0;
	}]]></code.midihandler>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="8385bd19-937d-47af-9b09-08facf287fbb" name="object_4" x="1008" y="350">
      <params/>
      <attribs>
         <objref attributeName="table" obj="lcxl2"/>
         <spinner attributeName="buttonoffset" value="960527"/>
         <spinner attributeName="total" value="137217"/>
         <spinner attributeName="barcount" value="16"/>
         <spinner attributeName="column" value="2"/>
      </attribs>
      <object id="patch/object" uuid="8385bd19-937d-47af-9b09-08facf287fbb">
         <inlets>
            <bool32 name="shift"/>
            <bool32 name="pulse"/>
            <bool32 name="pulseplay"/>
            <int32 name="barcount"/>
            <bool32 name="start"/>
            <bool32 name="stop"/>
         </inlets>
         <outlets>
            <int32 name="clipslot"/>
            <int32 name="clearslot"/>
            <bool32 name="cliptrigger"/>
            <bool32 name="cleartrigger"/>
            <int32 name="offsetnotes"/>
            <bool32 name="wait"/>
            <bool32 name="rec"/>
            <bool32 name="play"/>
            <bool32 name="nplaytrig"/>
            <bool32 name="nrectrig"/>
         </outlets>
         <displays/>
         <params/>
         <attribs>
            <objref name="table"/>
            <spinner name="buttonoffset" MinValue="0" MaxValue="10000000" DefaultValue="0"/>
            <spinner name="total" MinValue="0" MaxValue="5000000" DefaultValue="0"/>
            <spinner name="barcount" MinValue="0" MaxValue="16" DefaultValue="0"/>
            <spinner name="column" MinValue="1" MaxValue="8" DefaultValue="1"/>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[uint32_t i;
uint32_t ii;
uint32_t src;
uint32_t range;
uint32_t block;
int note;
int trigger;
int clipslot;
int clearslot;
int clear;
int clip;
int clipB;

int cloffset;
int nclear;
int rclear;
int speed;



int pclipslot;
int slotoffset;
int offset;
int full;
int ntrig;
int xtrig;
int prevplay;
int playtrig;
int recordtrig;
int recofftrig;
int wait;
int zwait;
int ztrig;
int record;
int play;
int outletrectrig;
int bar_record;
int maxbar;
int vcount;
int vtrig;
int vrtrig;
int vr2trig;
int ctrig;
int rtrig;
int count;
int prevfull;
int nrectrig;
int nplaytrig;
int prevoffset;]]></code.declaration>
         <code.init><![CDATA[full=attr_table.array[__USAT((0+ attr_buttonoffset),attr_table.LENGTHPOW)]<<attr_table.GAIN;
slotoffset=0;
count=0;
ctrig = 0;
rtrig = 0;
clipslot=6;
clearslot=6;
pclipslot=8;]]></code.init>
         <code.krate><![CDATA[/////
if ((!inlet_shift)&&trigger){
if (note==(0+(attr_column-1))) {clipslot=0;clip=1;clipB=0;}
if (note==(16+(attr_column-1))) {clipslot=1;clip=1;clipB=0;}
if (note==(32+(attr_column-1))) {clipslot=2;clip=1;clipB=0;}
if (note==(48+(attr_column-1))) {clipslot=3;clip=1;clipB=0;}
if (note==(64+(attr_column-1))) {clipslot=4;clip=1;clipB=0;}
if (note==(80+(attr_column-1))) {clipslot=5;clip=1;clipB=0;}
if (note==(96+(attr_column-1))) {clipslot=6;clip=1;clipB=0;}
if ((note==(112+(attr_column-1)))||(note==120)) {clipslot=7;clip=1;}
	if (note==8) {clipslot=0;clipB=1;clip=1;}
	if (note==24) {clipslot=1;clipB=1;clip=1;}
	if (note==40) {clipslot=2;clipB=1;clip=1;}
	if (note==56) {clipslot=3;clipB=1;clip=1;}
	if (note==72) {clipslot=4;clipB=1;clip=1;}
	if (note==88) {clipslot=5;clipB=1;clip=1;}
	if (note==104) {clipslot=6;clipB=1;clip=1;}
	if (note==120) {clipslot=7;clipB=1;clip=1;}
	
}

else if (inlet_shift){
if ((note==(0+(attr_column-1)))&&trigger) {clearslot=0;clear=1;}
if ((note==(16+(attr_column-1)))&&trigger) {clearslot=1;clear=1;}
if ((note==(32+(attr_column-1)))&&trigger) {clearslot=2;clear=1;}
if ((note==(48+(attr_column-1)))&&trigger) {clearslot=3;clear=1;}
if ((note==(64+(attr_column-1)))&&trigger) {clearslot=4;clear=1;}
if ((note==(80+(attr_column-1)))&&trigger) {clearslot=5;clear=1;}
if ((note==(96+(attr_column-1)))&&trigger) {clearslot=6;clear=1;}
if ((note==(112+(attr_column-1)))&&trigger) {clearslot=7;clear=1;}
}




//full=attr_table.array[__USAT((clipslot+ attr_buttonoffset),attr_table.LENGTHPOW)]<<attr_table.GAIN;
//if ((clipB)&&(full>0)){clip=1;clipB=0;}
//if ((clipB)&&(!(full>0))){clip=1;}
       

if (!trigger) {clip=0;clear=0;}



/////

full=attr_table.array[__USAT((clipslot+ attr_buttonoffset),attr_table.LENGTHPOW)]<<attr_table.GAIN;
nrectrig=0;
nplaytrig=0;
offset=8+slotoffset+attr_buttonoffset;
outlet_offsetnotes=offset+1;

if (inlet_start>0){play=prevplay;}
//if ((clipB>0)&&(full)&&!ntrig){	
//	wait=1;
//	zwait=1;	
//	ntrig=1;
//}
if ((clip>0)&&!ntrig){	
	wait=1;
	zwait=1;	
	ntrig=1;
}
if ((wait>0)&&(!(clip>0))&&(inlet_pulse>0)) {xtrig=1;nrectrig=1;wait=0;ntrig=0;}
if ((zwait>0)&&(!(clip>0))&&(inlet_pulseplay>0)) {
	nplaytrig=1;
	zwait=0;
	}

//
if ((clipslot==7)&&xtrig){
	if (record>0){
		attr_table.array[prevfull + attr_buttonoffset]=__SSAT(0,28)>>attr_table.GAIN;
	}
	prevplay=play;
	play=0;
	record=0;
	wait=0;
	ntrig=0;
	xtrig=0;
	clipB=0;
	pclipslot=8;
}
//
if (clipslot<7)
{
if ((clipslot!=pclipslot)&&xtrig){
	if (record>0){
		attr_table.array[offset]=__SSAT((bar_record),28)>>attr_table.GAIN;
	}
	xtrig=0;
	vcount=0;
	count=-1;
	nrectrig=1;
	slotoffset=(attr_total*clipslot);
	offset=8+slotoffset+attr_buttonoffset;
	prevoffset=slotoffset;
	full=attr_table.array[__USAT((clipslot+ attr_buttonoffset),attr_table.LENGTHPOW)]<<attr_table.GAIN;
	if (full>0){
		play=1;
		record=0;
	}
	if (!(full>0)){
		if (!clipB){
		play=0;
		attr_table.array[clipslot + attr_buttonoffset]=__SSAT(0x07FFFFFF,28)>>attr_table.GAIN;
		prevfull=clipslot;
		record=1;
		}
		else if (clipB){
		play=0;
		record=0;
		clipB=0;
		}
	}
	pclipslot=clipslot;
	
}
if (!clipB){
if ((!(full>0))&&xtrig){
	attr_table.array[clipslot + attr_buttonoffset]=__SSAT(0x07FFFFFF,28)>>attr_table.GAIN;
	prevfull=clipslot;
	record=1;
	xtrig=0;
}

if ((full>0)&&(!(play>0))&&xtrig){
	record=0;
	play=1;
	xtrig=0;
}
if ((full>0)&&(play>0)&&xtrig){
	record=0;
	vcount=0;
	play=1;
	xtrig=0;
}
}
else if ((clipB)&&(xtrig)){
	if (!full){
	play=0;
	record=0;
	}
	else if (full){
		play=1;
		record=0;
	}
	clipB=0;
	xtrig=0;
}

}


if (inlet_stop>0){
	prevplay=play;
	play=0;
	record=0;
	wait=0;
	ntrig=0;
	xtrig=0;
	clipB=0;
}


if ((clear>0)&&!ntrig){
	ntrig=1;
	attr_table.array[clearslot + attr_buttonoffset]=__SSAT(0,28)>>attr_table.GAIN;
	if (clipslot==clearslot){
		play=0;
		record=0;
		wait=0;
		zwait=0;
	}
}
else if(!(clear)) {ntrig=0;}



//





outlet_play=play;


outlet_wait=wait;
outlet_rec=record;


//playback
if ((play>0)&&!playtrig){
	playtrig=1;
	vcount=0;
}
if (!(play>0)) {playtrig=0;}
outletrectrig=0;
if ((record>0)&&!recordtrig){
	recordtrig=1;
	outletrectrig=1;
}


if (!(record>0)) {recordtrig=0;}

if ((!(record>0))&&!recofftrig){
	attr_table.array[offset]=__SSAT(bar_record,28)>>attr_table.GAIN;
	zwait=1;
	recofftrig=1;
}

//reset
if (record>0){recofftrig=0;}

//barclocks
if ((inlet_pulse>0) && !ctrig) {
   count += 1; 
   if (count>=attr_barcount) 
   {
   	count = attr_barcount;
   }
   if ((count==(inlet_barcount))&&(record>0)){wait=1;}
   ctrig=1;
}
else if (!(inlet_pulse>0)) ctrig=0;

bar_record=(count+1)<<21;
if ((outletrectrig>0) && !rtrig) {count=0; rtrig = 1;}
else if (!(outletrectrig>0)) rtrig=0;



//barlength=recorded
maxbar=(attr_table.array[__USAT(offset,attr_table.LENGTHPOW)]<<attr_table.GAIN)>>21;
//play bar counter
if ((inlet_pulseplay>0) && !vtrig) {
   vcount += 1; if ((vcount>(maxbar))||(vcount>(16))) {
   	vcount = 1; 
   	if ((play>0)&&(!(record>0))){
   	nplaytrig=1;
   	}
   }
   vtrig=1;
}
else if (!(inlet_pulseplay>0)) vtrig=0;
//start
if ((inlet_start>0) && !vr2trig) {vcount=1; vr2trig = 1; nplaytrig=1; nrectrig=1;}
else if (!(inlet_start>0)) vr2trig=0;
//reset vcount
if (vcount>(maxbar)){vcount=1;}

/////////////
cloffset=(attr_buttonoffset+8)+(attr_total*clearslot);


speed = 16 << 4;
src = cloffset;
range = (attr_total);
block  = (range / speed) * speed;

if ((clear)&& (!nclear)){ nclear= 1;i = 0;rclear = 0;}
if ((i == attr_total) && (!clear)) {nclear= 0;i = 0;}


//copy n chunks of size 'speed'
if (nclear && (i < block)){ 
	{ 
  for(ii=0;ii<speed;ii++)
  attr_table.array[(i + ii + src)]= (( attr_table.array[(i + ii + src)] + (attr_table.array[(i + ii + src)] * 0)) * (0));
  }
  i += speed;	
}

//copy what's left
if (i == block) rclear = 1; 

if ((ntrig && rclear) && (i < (attr_total))){ 
	attr_table.array[(i + src)]= (( attr_table.array[(i + src)] + (attr_table.array[(i + src)] * 0)) * (0));
   i += 1;  
 }
//////////////////////////////


outlet_clipslot=clipslot;
outlet_cliptrigger=clip;
outlet_clearslot=clearslot;
outlet_cleartrigger=clear;


outlet_nrectrig=nrectrig;
outlet_nplaytrig=nplaytrig;]]></code.krate>
         <code.midihandler><![CDATA[if ((status == MIDI_NOTE_ON + 0)&&(data2))
	{
		note=data1;
		trigger=1;
	}
if ((status == MIDI_NOTE_ON + 0)&&(!data2))
	{trigger=0;
	}]]></code.midihandler>
      </object>
   </patchobj>
   <comment type="patch/comment" x="448" y="630" text="track 1"/>
   <comment type="patch/comment" x="1008" y="630" text="track 2"/>
   <comment type="patch/comment" x="448" y="644" text="note off &amp; cc counter"/>
   <comment type="patch/comment" x="602" y="644" text="note on play counter"/>
   <comment type="patch/comment" x="742" y="644" text="noteoffshift counter"/>
   <comment type="patch/comment" x="854" y="644" text="note on rec counter"/>
   <comment type="patch/comment" x="1008" y="644" text="note off &amp; cc counter"/>
   <comment type="patch/comment" x="1162" y="644" text="note on play counter"/>
   <comment type="patch/comment" x="1288" y="644" text="noteoffshift counter"/>
   <comment type="patch/comment" x="1400" y="644" text="note on rec counter"/>
   <obj type="logic/counter" uuid="7a141ba82230e54e5f5cd12da5dbe5a74ba854a5" name="counter_9" x="448" y="658">
      <params>
         <int32 name="maximum" value="8192"/>
      </params>
      <attribs/>
   </obj>
   <obj type="logic/counter" uuid="7a141ba82230e54e5f5cd12da5dbe5a74ba854a5" name="counter_11" x="602" y="658">
      <params>
         <int32 name="maximum" value="256"/>
      </params>
      <attribs/>
   </obj>
   <obj type="logic/counter" uuid="7a141ba82230e54e5f5cd12da5dbe5a74ba854a5" name="counter_13" x="742" y="658">
      <params>
         <int32 name="maximum" value="16"/>
      </params>
      <attribs/>
   </obj>
   <obj type="logic/counter" uuid="7a141ba82230e54e5f5cd12da5dbe5a74ba854a5" name="counter_7" x="854" y="658">
      <params>
         <int32 name="maximum" value="256"/>
      </params>
      <attribs/>
   </obj>
   <obj type="logic/counter" uuid="7a141ba82230e54e5f5cd12da5dbe5a74ba854a5" name="counter_10" x="1008" y="658">
      <params>
         <int32 name="maximum" value="8192"/>
      </params>
      <attribs/>
   </obj>
   <obj type="logic/counter" uuid="7a141ba82230e54e5f5cd12da5dbe5a74ba854a5" name="counter_12" x="1162" y="658">
      <params>
         <int32 name="maximum" value="256"/>
      </params>
      <attribs/>
   </obj>
   <obj type="logic/counter" uuid="7a141ba82230e54e5f5cd12da5dbe5a74ba854a5" name="counter_16" x="1288" y="658">
      <params>
         <int32 name="maximum" value="16"/>
      </params>
      <attribs/>
   </obj>
   <obj type="logic/counter" uuid="7a141ba82230e54e5f5cd12da5dbe5a74ba854a5" name="counter_8" x="1400" y="658">
      <params>
         <int32 name="maximum" value="256"/>
      </params>
      <attribs/>
   </obj>
   <comment type="patch/comment" x="154" y="672" text="in channel"/>
   <comment type="patch/comment" x="98" y="686" text="need to set in polysubpatch too"/>
   <comment type="patch/comment" x="322" y="686" text="out channel"/>
   <obj type="ctrl/i" uuid="a3786816db6ea5bc6ac4193a5cccdb2c83b83496" name="i_5" x="154" y="700">
      <params>
         <int32 name="value" value="6"/>
      </params>
      <attribs/>
   </obj>
   <obj type="ctrl/i" uuid="a3786816db6ea5bc6ac4193a5cccdb2c83b83496" name="i_6" x="322" y="700">
      <params>
         <int32 name="value" value="6"/>
      </params>
      <attribs/>
   </obj>
   <comment type="patch/comment" x="154" y="770" text="track 1"/>
   <comment type="patch/comment" x="154" y="784" text="poly recorder"/>
   <comment type="patch/comment" x="280" y="784" text="track 1"/>
   <comment type="patch/comment" x="1204" y="784" text="track 1"/>
   <comment type="patch/comment" x="1330" y="784" text="track 1"/>
   <patcher type="patch/patcher" uuid="d77a2a6e-5231-49e0-a7d4-ed6b2fc4e219" name="patcher_2" x="154" y="798">
      <params/>
      <attribs>
         <combo attributeName="poly" selection="6"/>
         <combo attributeName="midichannel" selection="7"/>
         <combo attributeName="mididevice" selection="omni"/>
         <combo attributeName="midiport" selection="omni"/>
      </attribs>
      <subpatch appVersion="1.0.12">
         <patchobj type="patch/object" uuid="20502dcd-a0bc-49c2-ad5e-e405aac40702" name="polyindex_1" x="56" y="0">
            <params/>
            <attribs/>
            <object id="patch/object" uuid="20502dcd-a0bc-49c2-ad5e-e405aac40702">
               <sDescription>Outputs the voice index number from 0 to n-1. Only works in a polyphonic sub-patch!</sDescription>
               <author>Johannes Taelman</author>
               <license>BSD</license>
               <helpPatch>polyindex.axh</helpPatch>
               <inlets/>
               <outlets>
                  <int32.positive name="index" description="index from 0 to n-1"/>
               </outlets>
               <displays/>
               <params/>
               <attribs/>
               <includes/>
               <code.krate><![CDATA[outlet_index = parent->polyIndex;
]]></code.krate>
            </object>
         </patchobj>
         <obj type="patch/inlet i" uuid="f11927f00c59219df0c50f73056aa19f125540b7" name="channel" x="154" y="0">
            <params/>
            <attribs/>
         </obj>
         <obj type="patch/inlet i" uuid="f11927f00c59219df0c50f73056aa19f125540b7" name="offset" x="252" y="0">
            <params/>
            <attribs/>
         </obj>
         <obj type="patch/inlet b" uuid="3b0d3eacb5bb978cb05d1372aa2714d5a4790844" name="rec" x="364" y="0">
            <params/>
            <attribs/>
         </obj>
         <obj type="patch/inlet i" uuid="f11927f00c59219df0c50f73056aa19f125540b7" name="qstep" x="476" y="0">
            <params/>
            <attribs/>
         </obj>
         <obj type="patch/inlet i" uuid="f11927f00c59219df0c50f73056aa19f125540b7" name="steprec" x="560" y="0">
            <params/>
            <attribs/>
         </obj>
         <obj type="patch/inlet i" uuid="f11927f00c59219df0c50f73056aa19f125540b7" name="step" x="644" y="0">
            <params/>
            <attribs/>
         </obj>
         <obj type="patch/inlet i" uuid="f11927f00c59219df0c50f73056aa19f125540b7" name="stepunQ" x="728" y="0">
            <params/>
            <attribs/>
         </obj>
         <patchobj type="patch/object" uuid="a919ffab-f138-4bb2-9193-1455073b35ac" name="tablestore_7" x="812" y="0">
            <params/>
            <attribs>
               <objref attributeName="table" obj="../lcxl2"/>
               <spinner attributeName="seqlength" value="256"/>
            </attribs>
            <object id="patch/object" uuid="a919ffab-f138-4bb2-9193-1455073b35ac">
               <sDescription>writes and outputs 8 values to a table.</sDescription>
               <author>robert schirmer</author>
               <license>who cares</license>
               <inlets>
                  <int32 name="channel"/>
                  <bool32 name="rec"/>
                  <int32 name="polyphony"/>
                  <int32 name="offset" description="sets an offset for writing to the table"/>
                  <int32 name="steprec"/>
                  <int32 name="step"/>
                  <int32 name="stepunQ"/>
                  <int32 name="Qstep"/>
               </inlets>
               <outlets/>
               <displays/>
               <params/>
               <attribs>
                  <objref name="table"/>
                  <spinner name="seqlength" MinValue="1" MaxValue="10000" DefaultValue="0"/>
               </attribs>
               <includes/>
               <code.declaration><![CDATA[int channel;
int polyphony;
int innote;
int invel;
int inputnote;
int inputvel;
int inputnoteon;
int inputnoteoff;
int ingate;
int ingate2;
int inntrig;
int inytrig;
int op;
int Atrig;
int notecount;
int seqlength;
int seqlengthUNQ;
int off1;
int recoffset1g;
int voiceoffset;
int offset;
int offset1;
int totaloffset;
int offsetg;
int offset1g;
int etrig;
int early;
int earlyshift;
int offsetunQ1;
int offsetunQ1g;
int noteon;
int noteoff;
int ytrig;
int xtrig;
int prevsteprec;
int prevstep;
int prevstepunQ;
int prevx;
int prevy;
int Pnoteoff;
int Poffset;]]></code.declaration>
               <code.init><![CDATA[seqlengthUNQ=(attr_seqlength*32);
seqlength=attr_seqlength;
noteon=0;
notecount=0;
offsetg=offset;]]></code.init>
               <code.krate><![CDATA[off1= !inlet_rec;
channel=inlet_channel;
voiceoffset=seqlength+seqlength+seqlengthUNQ;
totaloffset=voiceoffset+voiceoffset;
offset=inlet_offset+(totaloffset*(inlet_polyphony));



inputnote = innote<<20;
inputvel= invel<<20;

if((ingate2)&&!inntrig){
inputnoteon=ingate2;
inntrig=1;}
else inputnoteon=0;
if (!ingate2){
inntrig=0;
}

if((!ingate)&&!inytrig){
inputnoteoff=64<<20;
inytrig=1;}
else inputnoteoff=0;
if (ingate){
inytrig=0;
}

ingate2=ingate;

if ((inputnoteon>0) && !Atrig) {op = !op; Atrig=1;}
if (!(inputnoteon>0)) Atrig=0;
notecount= op;


if (notecount){offsetg=offset;}
if (!notecount){offsetg=offset+voiceoffset;}


recoffset1g=(offsetg + (inlet_steprec));
offsetunQ1g=(offsetg + inlet_stepunQ);




//1
if (!off1){
if ((inputnoteon>0)&&(!ytrig))
{
attr_table.array[recoffset1g]=__SSAT(inputnote,28)>>attr_table.GAIN;
attr_table.array[recoffset1g + seqlength]=__SSAT(inputvel,28)>>attr_table.GAIN;
Pnoteoff=0;
if ((inlet_steprec!=inlet_step)&&!etrig) {
	
	earlyshift=(16-inlet_Qstep);
	etrig=1;
}
if ((inlet_steprec==inlet_step)&&!etrig) 
{
	
	earlyshift=(0-inlet_Qstep);
	etrig=1;
	//if (inlet_steprec==0)
	//{
	//	early=2;
	//}
}

//if (inlet_steprec==(seqlength-1)){early=2;}
prevy=inlet_steprec;
ytrig=1;
}
else if ((!(inputnoteon>0))&&(inlet_steprec!=prevy)){
	ytrig=0;
	
}


if ((inputnoteoff>0)&&(!xtrig))
{early=earlyshift;
	

		attr_table.array[offsetunQ1g + seqlength + seqlength + earlyshift]=__SSAT(inputnoteoff,28)>>attr_table.GAIN;
		Pnoteoff=1;
		//attr_table.array[recoffset1g]=__SSAT(inputnote,28)>>attr_table.GAIN;
	
etrig=0;
prevx=inlet_stepunQ;
xtrig=1;
}
else if ((!(inputnoteoff>0))&&(inlet_stepunQ!=prevx)){
	xtrig=0;
}


if ((offsetg!=Poffset)&&ingate){
	inputnoteoff=64<<20;
	attr_table.array[Poffset + prevstepunQ + seqlength + seqlength]=__SSAT(inputnoteoff,28)>>attr_table.GAIN;
	}

prevstep=inlet_step;
prevstepunQ=inlet_stepunQ;
prevsteprec=inlet_steprec;
Poffset=offsetg;
}



else if (off1)
{
	if (!Pnoteoff){
	inputnoteoff=64<<20;
	attr_table.array[offsetg + prevstepunQ + seqlength + seqlength + earlyshift]=__SSAT(inputnoteoff,28)>>attr_table.GAIN;Pnoteoff=1;}
inputnoteoff=0;
etrig=0;
ytrig=0;
xtrig=0;
op=0;
prevx=(-1);
prevy=(-1);
}]]></code.krate>
               <code.midihandler><![CDATA[if (status == MIDI_NOTE_ON + (channel)) {
  innote = data1;
  invel = data2;
  ingate=1;
  ingate2=0;
}
if (status == MIDI_NOTE_OFF + (channel)) {
	if (data1==(innote)){
		ingate=0;
	}
}]]></code.midihandler>
            </object>
         </patchobj>
         <nets>
            <net>
               <source obj="rec" outlet="inlet"/>
               <dest obj="tablestore_7" inlet="rec"/>
            </net>
            <net>
               <source obj="steprec" outlet="inlet"/>
               <dest obj="tablestore_7" inlet="steprec"/>
            </net>
            <net>
               <source obj="step" outlet="inlet"/>
               <dest obj="tablestore_7" inlet="step"/>
            </net>
            <net>
               <source obj="stepunQ" outlet="inlet"/>
               <dest obj="tablestore_7" inlet="stepunQ"/>
            </net>
            <net>
               <source obj="qstep" outlet="inlet"/>
               <dest obj="tablestore_7" inlet="Qstep"/>
            </net>
            <net>
               <source obj="offset" outlet="inlet"/>
               <dest obj="tablestore_7" inlet="offset"/>
            </net>
            <net>
               <source obj="polyindex_1" outlet="index"/>
               <dest obj="tablestore_7" inlet="polyphony"/>
            </net>
            <net>
               <source obj="channel" outlet="inlet"/>
               <dest obj="tablestore_7" inlet="channel"/>
            </net>
         </nets>
         <settings>
            <subpatchmode>polyphonic</subpatchmode>
            <MidiChannel>7</MidiChannel>
            <HasMidiChannelSelector>true</HasMidiChannelSelector>
            <NPresets>0</NPresets>
            <NPresetEntries>0</NPresetEntries>
            <NModulationSources>0</NModulationSources>
            <NModulationTargetsPerSource>0</NModulationTargetsPerSource>
         </settings>
         <notes><![CDATA[]]></notes>
         <windowPos>
            <x>-8</x>
            <y>-8</y>
            <width>1616</width>
            <height>876</height>
         </windowPos>
      </subpatch>
   </patcher>
   <comment type="patch/comment" x="280" y="798" text=" noteplay poly 1"/>
   <comment type="patch/comment" x="434" y="798" text=" noteplay poly 2"/>
   <comment type="patch/comment" x="588" y="798" text=" noteplay poly 3"/>
   <comment type="patch/comment" x="728" y="798" text=" noteplay poly 4"/>
   <comment type="patch/comment" x="896" y="798" text=" noteplay poly 5"/>
   <comment type="patch/comment" x="1050" y="798" text=" noteplay poly 6"/>
   <comment type="patch/comment" x="1204" y="798" text="cbend touch cc recorder"/>
   <comment type="patch/comment" x="1330" y="798" text="bend/touch.CC play"/>
   <patchobj type="patch/object" uuid="a919ffab-f138-4bb2-9193-1455073b35ac" name="tablestore_21" x="280" y="812">
      <params/>
      <attribs>
         <objref attributeName="table" obj="lcxl2"/>
         <spinner attributeName="seqlength" value="256"/>
         <combo attributeName="device" selection="din"/>
      </attribs>
      <object id="patch/object" uuid="a919ffab-f138-4bb2-9193-1455073b35ac">
         <sDescription>writes and outputs 8 values to a table.</sDescription>
         <author>robert schirmer</author>
         <license>who cares</license>
         <inlets>
            <int32 name="channel"/>
            <bool32 name="play"/>
            <int32 name="offset" description="sets an offset for writing to the table"/>
            <int32 name="step"/>
            <int32 name="stepunQ"/>
         </inlets>
         <outlets>
            <int32 name="totaloffset"/>
         </outlets>
         <displays/>
         <params/>
         <attribs>
            <objref name="table"/>
            <spinner name="seqlength" MinValue="1" MaxValue="10000" DefaultValue="0"/>
            <combo name="device">
               <MenuEntries>
                  <string>din</string>
                  <string>usb host port 1</string>
                  <string>usb host port 2</string>
                  <string>usb host port 3</string>
                  <string>usb host port 4</string>
                  <string>internal port 1</string>
                  <string>internal port 2</string>
                  <string>usb device port 1</string>
               </MenuEntries>
               <CEntries>
                  <string>MIDI_DEVICE_DIN, 1</string>
                  <string>MIDI_DEVICE_USB_HOST, 1</string>
                  <string>MIDI_DEVICE_USB_HOST, 2</string>
                  <string>MIDI_DEVICE_USB_HOST, 3</string>
                  <string>MIDI_DEVICE_USB_HOST, 4</string>
                  <string>MIDI_DEVICE_INTERNAL, 1</string>
                  <string>MIDI_DEVICE_INTERNAL, 2</string>
                  <string>MIDI_DEVICE_USB_DEVICE, 1</string>
               </CEntries>
            </combo>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[int prevchannel;
int steptrig;
int TntrigA;
int TntrigB;
int TlastnoteA;
int TlastnoteB;
int seqlength;
int seqlengthUNQ;
int voiceoffset;
int off1;
int offtrig;
int offset1;
int offsetunQ1;
int noteonA;
int noteoffA;
int noteA;
int holdnoteA;
int holdvelA;
int TnoteA;
int TvelA;
int TnoteonA;
int TnoteoffA;
int noteonB;
int noteoffB;
int noteB;
int holdnoteB;
int holdvelB;
int TnoteB;
int TvelB;
int TnoteonB;
int TnoteoffB;
int prevoffset;
int prevstep;
int prevstepunQ;]]></code.declaration>
         <code.init><![CDATA[noteonA=0;
seqlengthUNQ=(attr_seqlength*32);
seqlength=attr_seqlength;]]></code.init>
         <code.krate><![CDATA[off1= inlet_play;
if ((inlet_channel!=prevchannel)||(inlet_offset!=prevoffset)){
	if ((TntrigB>0)&&(TlastnoteB>0)){
	MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (prevchannel),TlastnoteB,__USAT(TvelB,7)); TntrigB=0;}
	if ((TntrigA>0)&&(TlastnoteA>0)){
	MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (prevchannel),TlastnoteA,__USAT(TvelA,7)); TntrigA=0;}
	prevchannel=inlet_channel;
}
//if (inlet_offset!=prevoffset){
//	if ((TntrigB>0)&&(TlastnoteB>0)){
//	MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (inlet_channel),TlastnoteB,__USAT(TvelB,7)); TntrigB=0;}
//	if ((TntrigA>0)&&(TlastnoteA>0)){
//	MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (inlet_channel),TlastnoteA,__USAT(TvelA,7)); TntrigA=0;}
//}

offset1=(inlet_offset + inlet_step);
offsetunQ1=(inlet_offset + inlet_stepunQ);
voiceoffset=(seqlength+seqlength+seqlengthUNQ);



//1
if (!off1){
TnoteA=0;
TvelA=0;
TnoteonA=0;
TnoteB=0;
TvelB=0;
TnoteonB=0;
if (offtrig==0){

if ((TntrigB>0)&&(TlastnoteB>0)){
MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (inlet_channel),TlastnoteB,__USAT(TvelB,7)); TntrigB=0;}
if ((TntrigA>0)&&(TlastnoteA>0)){
MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (inlet_channel),TlastnoteA,__USAT(TvelA,7)); TntrigA=0;}

offtrig=1;
}}





else if (off1)
{



	noteA= attr_table.array[__USAT((offset1),attr_table.LENGTHPOW)]<<attr_table.GAIN;
noteonA=attr_table.array[__USAT((offset1 + seqlength),attr_table.LENGTHPOW)]<<attr_table.GAIN;
noteoffA=attr_table.array[__USAT((offsetunQ1+ seqlength + seqlength),attr_table.LENGTHPOW)]<<attr_table.GAIN;
noteB= attr_table.array[__USAT((voiceoffset+ offset1),attr_table.LENGTHPOW)]<<attr_table.GAIN;
noteonB=attr_table.array[__USAT((voiceoffset+ offset1 + seqlength),attr_table.LENGTHPOW)]<<attr_table.GAIN;
noteoffB=attr_table.array[__USAT((voiceoffset+ offsetunQ1+ seqlength + seqlength),attr_table.LENGTHPOW)]<<attr_table.GAIN;


//voiceA*****************************************
//note
if ((inlet_step != prevstep )&&(noteA > (0) )) { 
     holdnoteA = noteA>>20;
     TnoteA = holdnoteA;
}
else {
	TnoteA = holdnoteA;
}

//vel
if ((inlet_step != prevstep )&&(noteonA> 0 )) { 
     holdvelA = noteonA>>20;
     TvelA = holdvelA;
}
else {
	TvelA = holdvelA;
}


if ((noteoffA>0)&&(inlet_stepunQ!=prevstepunQ)){
	TnoteoffA=1;}
else TnoteoffA=0;

if ((noteonA>0)&&(inlet_step!=prevstep)){
	TnoteonA=1;}
else TnoteonA=0;

//voiceB*****************************************
//note
if ((inlet_step != prevstep )&&(noteB > 0) ) { 
     holdnoteB = noteB>>20;
     TnoteB = holdnoteB;
}
else {
	TnoteB = holdnoteB;
}

//vel
if ((inlet_step != prevstep )&&(noteonB> 0 )) { 
     holdvelB = noteonB>>20;
     TvelB = holdvelB;
}
else {
	TvelB = holdvelB;
}


if ((noteoffB>0)&&(inlet_stepunQ!=prevstepunQ)){
	TnoteoffB=1;}
else TnoteoffB=0;

if ((noteonB>0)&&(inlet_step!=prevstep)){
	TnoteonB=1;}
else TnoteonB=0;


if ((TnoteonA>0) && !TntrigA) {
if ((TlastnoteB>0)&&TntrigB){	
MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (inlet_channel),TlastnoteB,__USAT(TvelB,7)); TntrigB=0;
}
MidiSend3((midi_device_t) attr_device, MIDI_NOTE_ON + (inlet_channel),TnoteA,TvelA);  TntrigA=1;
TlastnoteA = TnoteA;
}
if ((TnoteoffA>0) && TntrigA) {MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (inlet_channel),TlastnoteA,__USAT(TvelA,7)); TntrigA=0;}

if ((TnoteonB>0) && !TntrigB) {
if ((TlastnoteA>0)&&TntrigA){
MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (inlet_channel),TlastnoteA,__USAT(TvelA,7)); TntrigA=0;
}
MidiSend3((midi_device_t) attr_device, MIDI_NOTE_ON + (inlet_channel),TnoteB,TvelB);  TntrigB=1;
TlastnoteB = TnoteB;
}
if ((TnoteoffB>0) && TntrigB) {MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (inlet_channel),TlastnoteB,__USAT(TvelB,7)); TntrigB=0;}




offtrig=0;
}
prevoffset=inlet_offset;
prevstep=inlet_step;
prevstepunQ=inlet_stepunQ;
outlet_totaloffset=inlet_offset+voiceoffset+voiceoffset;]]></code.krate>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="a919ffab-f138-4bb2-9193-1455073b35ac" name="tablestore_22" x="434" y="812">
      <params/>
      <attribs>
         <objref attributeName="table" obj="lcxl2"/>
         <spinner attributeName="seqlength" value="256"/>
         <combo attributeName="device" selection="din"/>
      </attribs>
      <object id="patch/object" uuid="a919ffab-f138-4bb2-9193-1455073b35ac">
         <sDescription>writes and outputs 8 values to a table.</sDescription>
         <author>robert schirmer</author>
         <license>who cares</license>
         <inlets>
            <int32 name="channel"/>
            <bool32 name="play"/>
            <int32 name="offset" description="sets an offset for writing to the table"/>
            <int32 name="step"/>
            <int32 name="stepunQ"/>
         </inlets>
         <outlets>
            <int32 name="totaloffset"/>
         </outlets>
         <displays/>
         <params/>
         <attribs>
            <objref name="table"/>
            <spinner name="seqlength" MinValue="1" MaxValue="10000" DefaultValue="0"/>
            <combo name="device">
               <MenuEntries>
                  <string>din</string>
                  <string>usb host port 1</string>
                  <string>usb host port 2</string>
                  <string>usb host port 3</string>
                  <string>usb host port 4</string>
                  <string>internal port 1</string>
                  <string>internal port 2</string>
                  <string>usb device port 1</string>
               </MenuEntries>
               <CEntries>
                  <string>MIDI_DEVICE_DIN, 1</string>
                  <string>MIDI_DEVICE_USB_HOST, 1</string>
                  <string>MIDI_DEVICE_USB_HOST, 2</string>
                  <string>MIDI_DEVICE_USB_HOST, 3</string>
                  <string>MIDI_DEVICE_USB_HOST, 4</string>
                  <string>MIDI_DEVICE_INTERNAL, 1</string>
                  <string>MIDI_DEVICE_INTERNAL, 2</string>
                  <string>MIDI_DEVICE_USB_DEVICE, 1</string>
               </CEntries>
            </combo>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[int prevchannel;
int steptrig;
int TntrigA;
int TntrigB;
int TlastnoteA;
int TlastnoteB;
int seqlength;
int seqlengthUNQ;
int voiceoffset;
int off1;
int offtrig;
int offset1;
int offsetunQ1;
int noteonA;
int noteoffA;
int noteA;
int holdnoteA;
int holdvelA;
int TnoteA;
int TvelA;
int TnoteonA;
int TnoteoffA;
int noteonB;
int noteoffB;
int noteB;
int holdnoteB;
int holdvelB;
int TnoteB;
int TvelB;
int TnoteonB;
int TnoteoffB;
int prevoffset;
int prevstep;
int prevstepunQ;]]></code.declaration>
         <code.init><![CDATA[noteonA=0;
seqlengthUNQ=(attr_seqlength*32);
seqlength=attr_seqlength;]]></code.init>
         <code.krate><![CDATA[off1= inlet_play;
if ((inlet_channel!=prevchannel)||(inlet_offset!=prevoffset)){
	if ((TntrigB>0)&&(TlastnoteB>0)){
	MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (prevchannel),TlastnoteB,__USAT(TvelB,7)); TntrigB=0;}
	if ((TntrigA>0)&&(TlastnoteA>0)){
	MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (prevchannel),TlastnoteA,__USAT(TvelA,7)); TntrigA=0;}
	prevchannel=inlet_channel;
}
//if (inlet_offset!=prevoffset){
//	if ((TntrigB>0)&&(TlastnoteB>0)){
//	MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (inlet_channel),TlastnoteB,__USAT(TvelB,7)); TntrigB=0;}
//	if ((TntrigA>0)&&(TlastnoteA>0)){
//	MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (inlet_channel),TlastnoteA,__USAT(TvelA,7)); TntrigA=0;}
//}

offset1=(inlet_offset + inlet_step);
offsetunQ1=(inlet_offset + inlet_stepunQ);
voiceoffset=(seqlength+seqlength+seqlengthUNQ);



//1
if (!off1){
TnoteA=0;
TvelA=0;
TnoteonA=0;
TnoteB=0;
TvelB=0;
TnoteonB=0;
if (offtrig==0){

if ((TntrigB>0)&&(TlastnoteB>0)){
MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (inlet_channel),TlastnoteB,__USAT(TvelB,7)); TntrigB=0;}
if ((TntrigA>0)&&(TlastnoteA>0)){
MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (inlet_channel),TlastnoteA,__USAT(TvelA,7)); TntrigA=0;}

offtrig=1;
}}





else if (off1)
{



	noteA= attr_table.array[__USAT((offset1),attr_table.LENGTHPOW)]<<attr_table.GAIN;
noteonA=attr_table.array[__USAT((offset1 + seqlength),attr_table.LENGTHPOW)]<<attr_table.GAIN;
noteoffA=attr_table.array[__USAT((offsetunQ1+ seqlength + seqlength),attr_table.LENGTHPOW)]<<attr_table.GAIN;
noteB= attr_table.array[__USAT((voiceoffset+ offset1),attr_table.LENGTHPOW)]<<attr_table.GAIN;
noteonB=attr_table.array[__USAT((voiceoffset+ offset1 + seqlength),attr_table.LENGTHPOW)]<<attr_table.GAIN;
noteoffB=attr_table.array[__USAT((voiceoffset+ offsetunQ1+ seqlength + seqlength),attr_table.LENGTHPOW)]<<attr_table.GAIN;


//voiceA*****************************************
//note
if ((inlet_step != prevstep )&&(noteA > (0) )) { 
     holdnoteA = noteA>>20;
     TnoteA = holdnoteA;
}
else {
	TnoteA = holdnoteA;
}

//vel
if ((inlet_step != prevstep )&&(noteonA> 0 )) { 
     holdvelA = noteonA>>20;
     TvelA = holdvelA;
}
else {
	TvelA = holdvelA;
}


if ((noteoffA>0)&&(inlet_stepunQ!=prevstepunQ)){
	TnoteoffA=1;}
else TnoteoffA=0;

if ((noteonA>0)&&(inlet_step!=prevstep)){
	TnoteonA=1;}
else TnoteonA=0;

//voiceB*****************************************
//note
if ((inlet_step != prevstep )&&(noteB > 0) ) { 
     holdnoteB = noteB>>20;
     TnoteB = holdnoteB;
}
else {
	TnoteB = holdnoteB;
}

//vel
if ((inlet_step != prevstep )&&(noteonB> 0 )) { 
     holdvelB = noteonB>>20;
     TvelB = holdvelB;
}
else {
	TvelB = holdvelB;
}


if ((noteoffB>0)&&(inlet_stepunQ!=prevstepunQ)){
	TnoteoffB=1;}
else TnoteoffB=0;

if ((noteonB>0)&&(inlet_step!=prevstep)){
	TnoteonB=1;}
else TnoteonB=0;


if ((TnoteonA>0) && !TntrigA) {
if ((TlastnoteB>0)&&TntrigB){	
MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (inlet_channel),TlastnoteB,__USAT(TvelB,7)); TntrigB=0;
}
MidiSend3((midi_device_t) attr_device, MIDI_NOTE_ON + (inlet_channel),TnoteA,TvelA);  TntrigA=1;
TlastnoteA = TnoteA;
}
if ((TnoteoffA>0) && TntrigA) {MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (inlet_channel),TlastnoteA,__USAT(TvelA,7)); TntrigA=0;}

if ((TnoteonB>0) && !TntrigB) {
if ((TlastnoteA>0)&&TntrigA){
MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (inlet_channel),TlastnoteA,__USAT(TvelA,7)); TntrigA=0;
}
MidiSend3((midi_device_t) attr_device, MIDI_NOTE_ON + (inlet_channel),TnoteB,TvelB);  TntrigB=1;
TlastnoteB = TnoteB;
}
if ((TnoteoffB>0) && TntrigB) {MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (inlet_channel),TlastnoteB,__USAT(TvelB,7)); TntrigB=0;}




offtrig=0;
}
prevoffset=inlet_offset;
prevstep=inlet_step;
prevstepunQ=inlet_stepunQ;
outlet_totaloffset=inlet_offset+voiceoffset+voiceoffset;]]></code.krate>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="a919ffab-f138-4bb2-9193-1455073b35ac" name="tablestore_23" x="588" y="812">
      <params/>
      <attribs>
         <objref attributeName="table" obj="lcxl2"/>
         <spinner attributeName="seqlength" value="256"/>
         <combo attributeName="device" selection="din"/>
      </attribs>
      <object id="patch/object" uuid="a919ffab-f138-4bb2-9193-1455073b35ac">
         <sDescription>writes and outputs 8 values to a table.</sDescription>
         <author>robert schirmer</author>
         <license>who cares</license>
         <inlets>
            <int32 name="channel"/>
            <bool32 name="play"/>
            <int32 name="offset" description="sets an offset for writing to the table"/>
            <int32 name="step"/>
            <int32 name="stepunQ"/>
         </inlets>
         <outlets>
            <int32 name="totaloffset"/>
         </outlets>
         <displays/>
         <params/>
         <attribs>
            <objref name="table"/>
            <spinner name="seqlength" MinValue="1" MaxValue="10000" DefaultValue="0"/>
            <combo name="device">
               <MenuEntries>
                  <string>din</string>
                  <string>usb host port 1</string>
                  <string>usb host port 2</string>
                  <string>usb host port 3</string>
                  <string>usb host port 4</string>
                  <string>internal port 1</string>
                  <string>internal port 2</string>
                  <string>usb device port 1</string>
               </MenuEntries>
               <CEntries>
                  <string>MIDI_DEVICE_DIN, 1</string>
                  <string>MIDI_DEVICE_USB_HOST, 1</string>
                  <string>MIDI_DEVICE_USB_HOST, 2</string>
                  <string>MIDI_DEVICE_USB_HOST, 3</string>
                  <string>MIDI_DEVICE_USB_HOST, 4</string>
                  <string>MIDI_DEVICE_INTERNAL, 1</string>
                  <string>MIDI_DEVICE_INTERNAL, 2</string>
                  <string>MIDI_DEVICE_USB_DEVICE, 1</string>
               </CEntries>
            </combo>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[int prevchannel;
int steptrig;
int TntrigA;
int TntrigB;
int TlastnoteA;
int TlastnoteB;
int seqlength;
int seqlengthUNQ;
int voiceoffset;
int off1;
int offtrig;
int offset1;
int offsetunQ1;
int noteonA;
int noteoffA;
int noteA;
int holdnoteA;
int holdvelA;
int TnoteA;
int TvelA;
int TnoteonA;
int TnoteoffA;
int noteonB;
int noteoffB;
int noteB;
int holdnoteB;
int holdvelB;
int TnoteB;
int TvelB;
int TnoteonB;
int TnoteoffB;
int prevoffset;
int prevstep;
int prevstepunQ;]]></code.declaration>
         <code.init><![CDATA[noteonA=0;
seqlengthUNQ=(attr_seqlength*32);
seqlength=attr_seqlength;]]></code.init>
         <code.krate><![CDATA[off1= inlet_play;
if ((inlet_channel!=prevchannel)||(inlet_offset!=prevoffset)){
	if ((TntrigB>0)&&(TlastnoteB>0)){
	MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (prevchannel),TlastnoteB,__USAT(TvelB,7)); TntrigB=0;}
	if ((TntrigA>0)&&(TlastnoteA>0)){
	MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (prevchannel),TlastnoteA,__USAT(TvelA,7)); TntrigA=0;}
	prevchannel=inlet_channel;
}
//if (inlet_offset!=prevoffset){
//	if ((TntrigB>0)&&(TlastnoteB>0)){
//	MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (inlet_channel),TlastnoteB,__USAT(TvelB,7)); TntrigB=0;}
//	if ((TntrigA>0)&&(TlastnoteA>0)){
//	MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (inlet_channel),TlastnoteA,__USAT(TvelA,7)); TntrigA=0;}
//}

offset1=(inlet_offset + inlet_step);
offsetunQ1=(inlet_offset + inlet_stepunQ);
voiceoffset=(seqlength+seqlength+seqlengthUNQ);



//1
if (!off1){
TnoteA=0;
TvelA=0;
TnoteonA=0;
TnoteB=0;
TvelB=0;
TnoteonB=0;
if (offtrig==0){

if ((TntrigB>0)&&(TlastnoteB>0)){
MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (inlet_channel),TlastnoteB,__USAT(TvelB,7)); TntrigB=0;}
if ((TntrigA>0)&&(TlastnoteA>0)){
MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (inlet_channel),TlastnoteA,__USAT(TvelA,7)); TntrigA=0;}

offtrig=1;
}}





else if (off1)
{



	noteA= attr_table.array[__USAT((offset1),attr_table.LENGTHPOW)]<<attr_table.GAIN;
noteonA=attr_table.array[__USAT((offset1 + seqlength),attr_table.LENGTHPOW)]<<attr_table.GAIN;
noteoffA=attr_table.array[__USAT((offsetunQ1+ seqlength + seqlength),attr_table.LENGTHPOW)]<<attr_table.GAIN;
noteB= attr_table.array[__USAT((voiceoffset+ offset1),attr_table.LENGTHPOW)]<<attr_table.GAIN;
noteonB=attr_table.array[__USAT((voiceoffset+ offset1 + seqlength),attr_table.LENGTHPOW)]<<attr_table.GAIN;
noteoffB=attr_table.array[__USAT((voiceoffset+ offsetunQ1+ seqlength + seqlength),attr_table.LENGTHPOW)]<<attr_table.GAIN;


//voiceA*****************************************
//note
if ((inlet_step != prevstep )&&(noteA > (0) )) { 
     holdnoteA = noteA>>20;
     TnoteA = holdnoteA;
}
else {
	TnoteA = holdnoteA;
}

//vel
if ((inlet_step != prevstep )&&(noteonA> 0 )) { 
     holdvelA = noteonA>>20;
     TvelA = holdvelA;
}
else {
	TvelA = holdvelA;
}


if ((noteoffA>0)&&(inlet_stepunQ!=prevstepunQ)){
	TnoteoffA=1;}
else TnoteoffA=0;

if ((noteonA>0)&&(inlet_step!=prevstep)){
	TnoteonA=1;}
else TnoteonA=0;

//voiceB*****************************************
//note
if ((inlet_step != prevstep )&&(noteB > 0) ) { 
     holdnoteB = noteB>>20;
     TnoteB = holdnoteB;
}
else {
	TnoteB = holdnoteB;
}

//vel
if ((inlet_step != prevstep )&&(noteonB> 0 )) { 
     holdvelB = noteonB>>20;
     TvelB = holdvelB;
}
else {
	TvelB = holdvelB;
}


if ((noteoffB>0)&&(inlet_stepunQ!=prevstepunQ)){
	TnoteoffB=1;}
else TnoteoffB=0;

if ((noteonB>0)&&(inlet_step!=prevstep)){
	TnoteonB=1;}
else TnoteonB=0;


if ((TnoteonA>0) && !TntrigA) {
if ((TlastnoteB>0)&&TntrigB){	
MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (inlet_channel),TlastnoteB,__USAT(TvelB,7)); TntrigB=0;
}
MidiSend3((midi_device_t) attr_device, MIDI_NOTE_ON + (inlet_channel),TnoteA,TvelA);  TntrigA=1;
TlastnoteA = TnoteA;
}
if ((TnoteoffA>0) && TntrigA) {MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (inlet_channel),TlastnoteA,__USAT(TvelA,7)); TntrigA=0;}

if ((TnoteonB>0) && !TntrigB) {
if ((TlastnoteA>0)&&TntrigA){
MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (inlet_channel),TlastnoteA,__USAT(TvelA,7)); TntrigA=0;
}
MidiSend3((midi_device_t) attr_device, MIDI_NOTE_ON + (inlet_channel),TnoteB,TvelB);  TntrigB=1;
TlastnoteB = TnoteB;
}
if ((TnoteoffB>0) && TntrigB) {MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (inlet_channel),TlastnoteB,__USAT(TvelB,7)); TntrigB=0;}




offtrig=0;
}
prevoffset=inlet_offset;
prevstep=inlet_step;
prevstepunQ=inlet_stepunQ;
outlet_totaloffset=inlet_offset+voiceoffset+voiceoffset;]]></code.krate>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="a919ffab-f138-4bb2-9193-1455073b35ac" name="tablestore_24" x="728" y="812">
      <params/>
      <attribs>
         <objref attributeName="table" obj="lcxl2"/>
         <spinner attributeName="seqlength" value="256"/>
         <combo attributeName="device" selection="din"/>
      </attribs>
      <object id="patch/object" uuid="a919ffab-f138-4bb2-9193-1455073b35ac">
         <sDescription>writes and outputs 8 values to a table.</sDescription>
         <author>robert schirmer</author>
         <license>who cares</license>
         <inlets>
            <int32 name="channel"/>
            <bool32 name="play"/>
            <int32 name="offset" description="sets an offset for writing to the table"/>
            <int32 name="step"/>
            <int32 name="stepunQ"/>
         </inlets>
         <outlets>
            <int32 name="totaloffset"/>
         </outlets>
         <displays/>
         <params/>
         <attribs>
            <objref name="table"/>
            <spinner name="seqlength" MinValue="1" MaxValue="10000" DefaultValue="0"/>
            <combo name="device">
               <MenuEntries>
                  <string>din</string>
                  <string>usb host port 1</string>
                  <string>usb host port 2</string>
                  <string>usb host port 3</string>
                  <string>usb host port 4</string>
                  <string>internal port 1</string>
                  <string>internal port 2</string>
                  <string>usb device port 1</string>
               </MenuEntries>
               <CEntries>
                  <string>MIDI_DEVICE_DIN, 1</string>
                  <string>MIDI_DEVICE_USB_HOST, 1</string>
                  <string>MIDI_DEVICE_USB_HOST, 2</string>
                  <string>MIDI_DEVICE_USB_HOST, 3</string>
                  <string>MIDI_DEVICE_USB_HOST, 4</string>
                  <string>MIDI_DEVICE_INTERNAL, 1</string>
                  <string>MIDI_DEVICE_INTERNAL, 2</string>
                  <string>MIDI_DEVICE_USB_DEVICE, 1</string>
               </CEntries>
            </combo>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[int prevchannel;
int steptrig;
int TntrigA;
int TntrigB;
int TlastnoteA;
int TlastnoteB;
int seqlength;
int seqlengthUNQ;
int voiceoffset;
int off1;
int offtrig;
int offset1;
int offsetunQ1;
int noteonA;
int noteoffA;
int noteA;
int holdnoteA;
int holdvelA;
int TnoteA;
int TvelA;
int TnoteonA;
int TnoteoffA;
int noteonB;
int noteoffB;
int noteB;
int holdnoteB;
int holdvelB;
int TnoteB;
int TvelB;
int TnoteonB;
int TnoteoffB;
int prevoffset;
int prevstep;
int prevstepunQ;]]></code.declaration>
         <code.init><![CDATA[noteonA=0;
seqlengthUNQ=(attr_seqlength*32);
seqlength=attr_seqlength;]]></code.init>
         <code.krate><![CDATA[off1= inlet_play;
if ((inlet_channel!=prevchannel)||(inlet_offset!=prevoffset)){
	if ((TntrigB>0)&&(TlastnoteB>0)){
	MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (prevchannel),TlastnoteB,__USAT(TvelB,7)); TntrigB=0;}
	if ((TntrigA>0)&&(TlastnoteA>0)){
	MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (prevchannel),TlastnoteA,__USAT(TvelA,7)); TntrigA=0;}
	prevchannel=inlet_channel;
}
//if (inlet_offset!=prevoffset){
//	if ((TntrigB>0)&&(TlastnoteB>0)){
//	MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (inlet_channel),TlastnoteB,__USAT(TvelB,7)); TntrigB=0;}
//	if ((TntrigA>0)&&(TlastnoteA>0)){
//	MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (inlet_channel),TlastnoteA,__USAT(TvelA,7)); TntrigA=0;}
//}

offset1=(inlet_offset + inlet_step);
offsetunQ1=(inlet_offset + inlet_stepunQ);
voiceoffset=(seqlength+seqlength+seqlengthUNQ);



//1
if (!off1){
TnoteA=0;
TvelA=0;
TnoteonA=0;
TnoteB=0;
TvelB=0;
TnoteonB=0;
if (offtrig==0){

if ((TntrigB>0)&&(TlastnoteB>0)){
MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (inlet_channel),TlastnoteB,__USAT(TvelB,7)); TntrigB=0;}
if ((TntrigA>0)&&(TlastnoteA>0)){
MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (inlet_channel),TlastnoteA,__USAT(TvelA,7)); TntrigA=0;}

offtrig=1;
}}





else if (off1)
{



	noteA= attr_table.array[__USAT((offset1),attr_table.LENGTHPOW)]<<attr_table.GAIN;
noteonA=attr_table.array[__USAT((offset1 + seqlength),attr_table.LENGTHPOW)]<<attr_table.GAIN;
noteoffA=attr_table.array[__USAT((offsetunQ1+ seqlength + seqlength),attr_table.LENGTHPOW)]<<attr_table.GAIN;
noteB= attr_table.array[__USAT((voiceoffset+ offset1),attr_table.LENGTHPOW)]<<attr_table.GAIN;
noteonB=attr_table.array[__USAT((voiceoffset+ offset1 + seqlength),attr_table.LENGTHPOW)]<<attr_table.GAIN;
noteoffB=attr_table.array[__USAT((voiceoffset+ offsetunQ1+ seqlength + seqlength),attr_table.LENGTHPOW)]<<attr_table.GAIN;


//voiceA*****************************************
//note
if ((inlet_step != prevstep )&&(noteA > (0) )) { 
     holdnoteA = noteA>>20;
     TnoteA = holdnoteA;
}
else {
	TnoteA = holdnoteA;
}

//vel
if ((inlet_step != prevstep )&&(noteonA> 0 )) { 
     holdvelA = noteonA>>20;
     TvelA = holdvelA;
}
else {
	TvelA = holdvelA;
}


if ((noteoffA>0)&&(inlet_stepunQ!=prevstepunQ)){
	TnoteoffA=1;}
else TnoteoffA=0;

if ((noteonA>0)&&(inlet_step!=prevstep)){
	TnoteonA=1;}
else TnoteonA=0;

//voiceB*****************************************
//note
if ((inlet_step != prevstep )&&(noteB > 0) ) { 
     holdnoteB = noteB>>20;
     TnoteB = holdnoteB;
}
else {
	TnoteB = holdnoteB;
}

//vel
if ((inlet_step != prevstep )&&(noteonB> 0 )) { 
     holdvelB = noteonB>>20;
     TvelB = holdvelB;
}
else {
	TvelB = holdvelB;
}


if ((noteoffB>0)&&(inlet_stepunQ!=prevstepunQ)){
	TnoteoffB=1;}
else TnoteoffB=0;

if ((noteonB>0)&&(inlet_step!=prevstep)){
	TnoteonB=1;}
else TnoteonB=0;


if ((TnoteonA>0) && !TntrigA) {
if ((TlastnoteB>0)&&TntrigB){	
MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (inlet_channel),TlastnoteB,__USAT(TvelB,7)); TntrigB=0;
}
MidiSend3((midi_device_t) attr_device, MIDI_NOTE_ON + (inlet_channel),TnoteA,TvelA);  TntrigA=1;
TlastnoteA = TnoteA;
}
if ((TnoteoffA>0) && TntrigA) {MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (inlet_channel),TlastnoteA,__USAT(TvelA,7)); TntrigA=0;}

if ((TnoteonB>0) && !TntrigB) {
if ((TlastnoteA>0)&&TntrigA){
MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (inlet_channel),TlastnoteA,__USAT(TvelA,7)); TntrigA=0;
}
MidiSend3((midi_device_t) attr_device, MIDI_NOTE_ON + (inlet_channel),TnoteB,TvelB);  TntrigB=1;
TlastnoteB = TnoteB;
}
if ((TnoteoffB>0) && TntrigB) {MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (inlet_channel),TlastnoteB,__USAT(TvelB,7)); TntrigB=0;}




offtrig=0;
}
prevoffset=inlet_offset;
prevstep=inlet_step;
prevstepunQ=inlet_stepunQ;
outlet_totaloffset=inlet_offset+voiceoffset+voiceoffset;]]></code.krate>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="a919ffab-f138-4bb2-9193-1455073b35ac" name="tablestore_25" x="896" y="812">
      <params/>
      <attribs>
         <objref attributeName="table" obj="lcxl2"/>
         <spinner attributeName="seqlength" value="256"/>
         <combo attributeName="device" selection="din"/>
      </attribs>
      <object id="patch/object" uuid="a919ffab-f138-4bb2-9193-1455073b35ac">
         <sDescription>writes and outputs 8 values to a table.</sDescription>
         <author>robert schirmer</author>
         <license>who cares</license>
         <inlets>
            <int32 name="channel"/>
            <bool32 name="play"/>
            <int32 name="offset" description="sets an offset for writing to the table"/>
            <int32 name="step"/>
            <int32 name="stepunQ"/>
         </inlets>
         <outlets>
            <int32 name="totaloffset"/>
         </outlets>
         <displays/>
         <params/>
         <attribs>
            <objref name="table"/>
            <spinner name="seqlength" MinValue="1" MaxValue="10000" DefaultValue="0"/>
            <combo name="device">
               <MenuEntries>
                  <string>din</string>
                  <string>usb host port 1</string>
                  <string>usb host port 2</string>
                  <string>usb host port 3</string>
                  <string>usb host port 4</string>
                  <string>internal port 1</string>
                  <string>internal port 2</string>
                  <string>usb device port 1</string>
               </MenuEntries>
               <CEntries>
                  <string>MIDI_DEVICE_DIN, 1</string>
                  <string>MIDI_DEVICE_USB_HOST, 1</string>
                  <string>MIDI_DEVICE_USB_HOST, 2</string>
                  <string>MIDI_DEVICE_USB_HOST, 3</string>
                  <string>MIDI_DEVICE_USB_HOST, 4</string>
                  <string>MIDI_DEVICE_INTERNAL, 1</string>
                  <string>MIDI_DEVICE_INTERNAL, 2</string>
                  <string>MIDI_DEVICE_USB_DEVICE, 1</string>
               </CEntries>
            </combo>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[int prevchannel;
int steptrig;
int TntrigA;
int TntrigB;
int TlastnoteA;
int TlastnoteB;
int seqlength;
int seqlengthUNQ;
int voiceoffset;
int off1;
int offtrig;
int offset1;
int offsetunQ1;
int noteonA;
int noteoffA;
int noteA;
int holdnoteA;
int holdvelA;
int TnoteA;
int TvelA;
int TnoteonA;
int TnoteoffA;
int noteonB;
int noteoffB;
int noteB;
int holdnoteB;
int holdvelB;
int TnoteB;
int TvelB;
int TnoteonB;
int TnoteoffB;
int prevoffset;
int prevstep;
int prevstepunQ;]]></code.declaration>
         <code.init><![CDATA[noteonA=0;
seqlengthUNQ=(attr_seqlength*32);
seqlength=attr_seqlength;]]></code.init>
         <code.krate><![CDATA[off1= inlet_play;
if ((inlet_channel!=prevchannel)||(inlet_offset!=prevoffset)){
	if ((TntrigB>0)&&(TlastnoteB>0)){
	MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (prevchannel),TlastnoteB,__USAT(TvelB,7)); TntrigB=0;}
	if ((TntrigA>0)&&(TlastnoteA>0)){
	MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (prevchannel),TlastnoteA,__USAT(TvelA,7)); TntrigA=0;}
	prevchannel=inlet_channel;
}
//if (inlet_offset!=prevoffset){
//	if ((TntrigB>0)&&(TlastnoteB>0)){
//	MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (inlet_channel),TlastnoteB,__USAT(TvelB,7)); TntrigB=0;}
//	if ((TntrigA>0)&&(TlastnoteA>0)){
//	MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (inlet_channel),TlastnoteA,__USAT(TvelA,7)); TntrigA=0;}
//}

offset1=(inlet_offset + inlet_step);
offsetunQ1=(inlet_offset + inlet_stepunQ);
voiceoffset=(seqlength+seqlength+seqlengthUNQ);



//1
if (!off1){
TnoteA=0;
TvelA=0;
TnoteonA=0;
TnoteB=0;
TvelB=0;
TnoteonB=0;
if (offtrig==0){

if ((TntrigB>0)&&(TlastnoteB>0)){
MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (inlet_channel),TlastnoteB,__USAT(TvelB,7)); TntrigB=0;}
if ((TntrigA>0)&&(TlastnoteA>0)){
MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (inlet_channel),TlastnoteA,__USAT(TvelA,7)); TntrigA=0;}

offtrig=1;
}}





else if (off1)
{



	noteA= attr_table.array[__USAT((offset1),attr_table.LENGTHPOW)]<<attr_table.GAIN;
noteonA=attr_table.array[__USAT((offset1 + seqlength),attr_table.LENGTHPOW)]<<attr_table.GAIN;
noteoffA=attr_table.array[__USAT((offsetunQ1+ seqlength + seqlength),attr_table.LENGTHPOW)]<<attr_table.GAIN;
noteB= attr_table.array[__USAT((voiceoffset+ offset1),attr_table.LENGTHPOW)]<<attr_table.GAIN;
noteonB=attr_table.array[__USAT((voiceoffset+ offset1 + seqlength),attr_table.LENGTHPOW)]<<attr_table.GAIN;
noteoffB=attr_table.array[__USAT((voiceoffset+ offsetunQ1+ seqlength + seqlength),attr_table.LENGTHPOW)]<<attr_table.GAIN;


//voiceA*****************************************
//note
if ((inlet_step != prevstep )&&(noteA > (0) )) { 
     holdnoteA = noteA>>20;
     TnoteA = holdnoteA;
}
else {
	TnoteA = holdnoteA;
}

//vel
if ((inlet_step != prevstep )&&(noteonA> 0 )) { 
     holdvelA = noteonA>>20;
     TvelA = holdvelA;
}
else {
	TvelA = holdvelA;
}


if ((noteoffA>0)&&(inlet_stepunQ!=prevstepunQ)){
	TnoteoffA=1;}
else TnoteoffA=0;

if ((noteonA>0)&&(inlet_step!=prevstep)){
	TnoteonA=1;}
else TnoteonA=0;

//voiceB*****************************************
//note
if ((inlet_step != prevstep )&&(noteB > 0) ) { 
     holdnoteB = noteB>>20;
     TnoteB = holdnoteB;
}
else {
	TnoteB = holdnoteB;
}

//vel
if ((inlet_step != prevstep )&&(noteonB> 0 )) { 
     holdvelB = noteonB>>20;
     TvelB = holdvelB;
}
else {
	TvelB = holdvelB;
}


if ((noteoffB>0)&&(inlet_stepunQ!=prevstepunQ)){
	TnoteoffB=1;}
else TnoteoffB=0;

if ((noteonB>0)&&(inlet_step!=prevstep)){
	TnoteonB=1;}
else TnoteonB=0;


if ((TnoteonA>0) && !TntrigA) {
if ((TlastnoteB>0)&&TntrigB){	
MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (inlet_channel),TlastnoteB,__USAT(TvelB,7)); TntrigB=0;
}
MidiSend3((midi_device_t) attr_device, MIDI_NOTE_ON + (inlet_channel),TnoteA,TvelA);  TntrigA=1;
TlastnoteA = TnoteA;
}
if ((TnoteoffA>0) && TntrigA) {MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (inlet_channel),TlastnoteA,__USAT(TvelA,7)); TntrigA=0;}

if ((TnoteonB>0) && !TntrigB) {
if ((TlastnoteA>0)&&TntrigA){
MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (inlet_channel),TlastnoteA,__USAT(TvelA,7)); TntrigA=0;
}
MidiSend3((midi_device_t) attr_device, MIDI_NOTE_ON + (inlet_channel),TnoteB,TvelB);  TntrigB=1;
TlastnoteB = TnoteB;
}
if ((TnoteoffB>0) && TntrigB) {MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (inlet_channel),TlastnoteB,__USAT(TvelB,7)); TntrigB=0;}




offtrig=0;
}
prevoffset=inlet_offset;
prevstep=inlet_step;
prevstepunQ=inlet_stepunQ;
outlet_totaloffset=inlet_offset+voiceoffset+voiceoffset;]]></code.krate>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="a919ffab-f138-4bb2-9193-1455073b35ac" name="tablestore_26" x="1050" y="812">
      <params/>
      <attribs>
         <objref attributeName="table" obj="lcxl2"/>
         <spinner attributeName="seqlength" value="256"/>
         <combo attributeName="device" selection="din"/>
      </attribs>
      <object id="patch/object" uuid="a919ffab-f138-4bb2-9193-1455073b35ac">
         <sDescription>writes and outputs 8 values to a table.</sDescription>
         <author>robert schirmer</author>
         <license>who cares</license>
         <inlets>
            <int32 name="channel"/>
            <bool32 name="play"/>
            <int32 name="offset" description="sets an offset for writing to the table"/>
            <int32 name="step"/>
            <int32 name="stepunQ"/>
         </inlets>
         <outlets>
            <int32 name="totaloffset"/>
         </outlets>
         <displays/>
         <params/>
         <attribs>
            <objref name="table"/>
            <spinner name="seqlength" MinValue="1" MaxValue="10000" DefaultValue="0"/>
            <combo name="device">
               <MenuEntries>
                  <string>din</string>
                  <string>usb host port 1</string>
                  <string>usb host port 2</string>
                  <string>usb host port 3</string>
                  <string>usb host port 4</string>
                  <string>internal port 1</string>
                  <string>internal port 2</string>
                  <string>usb device port 1</string>
               </MenuEntries>
               <CEntries>
                  <string>MIDI_DEVICE_DIN, 1</string>
                  <string>MIDI_DEVICE_USB_HOST, 1</string>
                  <string>MIDI_DEVICE_USB_HOST, 2</string>
                  <string>MIDI_DEVICE_USB_HOST, 3</string>
                  <string>MIDI_DEVICE_USB_HOST, 4</string>
                  <string>MIDI_DEVICE_INTERNAL, 1</string>
                  <string>MIDI_DEVICE_INTERNAL, 2</string>
                  <string>MIDI_DEVICE_USB_DEVICE, 1</string>
               </CEntries>
            </combo>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[int prevchannel;
int steptrig;
int TntrigA;
int TntrigB;
int TlastnoteA;
int TlastnoteB;
int seqlength;
int seqlengthUNQ;
int voiceoffset;
int off1;
int offtrig;
int offset1;
int offsetunQ1;
int noteonA;
int noteoffA;
int noteA;
int holdnoteA;
int holdvelA;
int TnoteA;
int TvelA;
int TnoteonA;
int TnoteoffA;
int noteonB;
int noteoffB;
int noteB;
int holdnoteB;
int holdvelB;
int TnoteB;
int TvelB;
int TnoteonB;
int TnoteoffB;
int prevoffset;
int prevstep;
int prevstepunQ;]]></code.declaration>
         <code.init><![CDATA[noteonA=0;
seqlengthUNQ=(attr_seqlength*32);
seqlength=attr_seqlength;]]></code.init>
         <code.krate><![CDATA[off1= inlet_play;
if ((inlet_channel!=prevchannel)||(inlet_offset!=prevoffset)){
	if ((TntrigB>0)&&(TlastnoteB>0)){
	MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (prevchannel),TlastnoteB,__USAT(TvelB,7)); TntrigB=0;}
	if ((TntrigA>0)&&(TlastnoteA>0)){
	MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (prevchannel),TlastnoteA,__USAT(TvelA,7)); TntrigA=0;}
	prevchannel=inlet_channel;
}
//if (inlet_offset!=prevoffset){
//	if ((TntrigB>0)&&(TlastnoteB>0)){
//	MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (inlet_channel),TlastnoteB,__USAT(TvelB,7)); TntrigB=0;}
//	if ((TntrigA>0)&&(TlastnoteA>0)){
//	MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (inlet_channel),TlastnoteA,__USAT(TvelA,7)); TntrigA=0;}
//}

offset1=(inlet_offset + inlet_step);
offsetunQ1=(inlet_offset + inlet_stepunQ);
voiceoffset=(seqlength+seqlength+seqlengthUNQ);



//1
if (!off1){
TnoteA=0;
TvelA=0;
TnoteonA=0;
TnoteB=0;
TvelB=0;
TnoteonB=0;
if (offtrig==0){

if ((TntrigB>0)&&(TlastnoteB>0)){
MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (inlet_channel),TlastnoteB,__USAT(TvelB,7)); TntrigB=0;}
if ((TntrigA>0)&&(TlastnoteA>0)){
MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (inlet_channel),TlastnoteA,__USAT(TvelA,7)); TntrigA=0;}

offtrig=1;
}}





else if (off1)
{



	noteA= attr_table.array[__USAT((offset1),attr_table.LENGTHPOW)]<<attr_table.GAIN;
noteonA=attr_table.array[__USAT((offset1 + seqlength),attr_table.LENGTHPOW)]<<attr_table.GAIN;
noteoffA=attr_table.array[__USAT((offsetunQ1+ seqlength + seqlength),attr_table.LENGTHPOW)]<<attr_table.GAIN;
noteB= attr_table.array[__USAT((voiceoffset+ offset1),attr_table.LENGTHPOW)]<<attr_table.GAIN;
noteonB=attr_table.array[__USAT((voiceoffset+ offset1 + seqlength),attr_table.LENGTHPOW)]<<attr_table.GAIN;
noteoffB=attr_table.array[__USAT((voiceoffset+ offsetunQ1+ seqlength + seqlength),attr_table.LENGTHPOW)]<<attr_table.GAIN;


//voiceA*****************************************
//note
if ((inlet_step != prevstep )&&(noteA > (0) )) { 
     holdnoteA = noteA>>20;
     TnoteA = holdnoteA;
}
else {
	TnoteA = holdnoteA;
}

//vel
if ((inlet_step != prevstep )&&(noteonA> 0 )) { 
     holdvelA = noteonA>>20;
     TvelA = holdvelA;
}
else {
	TvelA = holdvelA;
}


if ((noteoffA>0)&&(inlet_stepunQ!=prevstepunQ)){
	TnoteoffA=1;}
else TnoteoffA=0;

if ((noteonA>0)&&(inlet_step!=prevstep)){
	TnoteonA=1;}
else TnoteonA=0;

//voiceB*****************************************
//note
if ((inlet_step != prevstep )&&(noteB > 0) ) { 
     holdnoteB = noteB>>20;
     TnoteB = holdnoteB;
}
else {
	TnoteB = holdnoteB;
}

//vel
if ((inlet_step != prevstep )&&(noteonB> 0 )) { 
     holdvelB = noteonB>>20;
     TvelB = holdvelB;
}
else {
	TvelB = holdvelB;
}


if ((noteoffB>0)&&(inlet_stepunQ!=prevstepunQ)){
	TnoteoffB=1;}
else TnoteoffB=0;

if ((noteonB>0)&&(inlet_step!=prevstep)){
	TnoteonB=1;}
else TnoteonB=0;


if ((TnoteonA>0) && !TntrigA) {
if ((TlastnoteB>0)&&TntrigB){	
MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (inlet_channel),TlastnoteB,__USAT(TvelB,7)); TntrigB=0;
}
MidiSend3((midi_device_t) attr_device, MIDI_NOTE_ON + (inlet_channel),TnoteA,TvelA);  TntrigA=1;
TlastnoteA = TnoteA;
}
if ((TnoteoffA>0) && TntrigA) {MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (inlet_channel),TlastnoteA,__USAT(TvelA,7)); TntrigA=0;}

if ((TnoteonB>0) && !TntrigB) {
if ((TlastnoteA>0)&&TntrigA){
MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (inlet_channel),TlastnoteA,__USAT(TvelA,7)); TntrigA=0;
}
MidiSend3((midi_device_t) attr_device, MIDI_NOTE_ON + (inlet_channel),TnoteB,TvelB);  TntrigB=1;
TlastnoteB = TnoteB;
}
if ((TnoteoffB>0) && TntrigB) {MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (inlet_channel),TlastnoteB,__USAT(TvelB,7)); TntrigB=0;}




offtrig=0;
}
prevoffset=inlet_offset;
prevstep=inlet_step;
prevstepunQ=inlet_stepunQ;
outlet_totaloffset=inlet_offset+voiceoffset+voiceoffset;]]></code.krate>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="a919ffab-f138-4bb2-9193-1455073b35ac" name="tablestore_11" x="1204" y="812">
      <params/>
      <attribs>
         <objref attributeName="table" obj="lcxl2"/>
         <spinner attributeName="seqlength" value="256"/>
      </attribs>
      <object id="patch/object" uuid="a919ffab-f138-4bb2-9193-1455073b35ac">
         <sDescription>writes and outputs 8 values to a table.</sDescription>
         <author>robert schirmer</author>
         <license>who cares</license>
         <inlets>
            <int32 name="channel"/>
            <bool32 name="rec"/>
            <int32 name="offset" description="sets an offset for writing to the table"/>
            <int32 name="stepunQ"/>
         </inlets>
         <outlets>
            <int32 name="offset"/>
         </outlets>
         <displays/>
         <params/>
         <attribs>
            <objref name="table"/>
            <spinner name="seqlength" MinValue="1" MaxValue="10000" DefaultValue="0"/>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[uint32_t i;
uint32_t ii;
int32_t _bend;
int32_t Btrig;
int32_t _press;
int channel;
int cc;
int ccv;
int innote;
int invel;
int inputnote;
int inputvel;
int inputnoteon;
int inputnoteoff;
int ingate;
int ingate2;
int inntrig;
int inytrig;
int op;
int Atrig;
int notecount;
int seqlength;
int seqlengthUNQ;
int splat;
int clear;
int ntrig;
int rtrig;
int speed;
int off1;
int recoffset1g;
int voiceoffset;
int offset;
int offset1;
int totaloffset;
int offsetg;
int offset1g;
int early;
int offsetunQ1;
int offsetunQ1g;
int noteon;
int noteoff;
int ytrig;
int xtrig;
int prevsteprec;
int prevstep;
int prevstepunQ;
int prevx;
int prevy;]]></code.declaration>
         <code.init><![CDATA[seqlengthUNQ=(attr_seqlength*32);
seqlength=attr_seqlength;
_bend=0;
_press=0;]]></code.init>
         <code.krate><![CDATA[off1= !inlet_rec;
channel=inlet_channel;
offset=inlet_offset;

//1
if (!off1){
	if(inlet_stepunQ!=prevstepunQ){
	attr_table.array[offset + inlet_stepunQ]=__SSAT(_bend,28)>>attr_table.GAIN;
	attr_table.array[offset + inlet_stepunQ + seqlengthUNQ]=__SSAT(_press,28)>>attr_table.GAIN;
	attr_table.array[offset + inlet_stepunQ + seqlengthUNQ + seqlengthUNQ]=__SSAT(cc,28)>>attr_table.GAIN;
	attr_table.array[offset + inlet_stepunQ + seqlengthUNQ + seqlengthUNQ + seqlengthUNQ]=__SSAT(ccv,28)>>attr_table.GAIN;
	prevstepunQ=inlet_stepunQ;
	}
}


else if (off1)
{
	_bend=0;
	_press=0;
	cc=0;
	ccv=0;
}

outlet_offset=inlet_offset+seqlengthUNQ+seqlengthUNQ+seqlengthUNQ+seqlengthUNQ;]]></code.krate>
         <code.midihandler><![CDATA[if (status == MIDI_PITCH_BEND + (channel)) {  _bend = ((int)((data2<<7)+data1)-0x2000)<<14;
}
if (status == MIDI_CHANNEL_PRESSURE + (channel)) {  _press = (data1)<<20;
}
if (status == (channel) + MIDI_CONTROL_CHANGE) {
  ccv = data2<<20;
  cc = data1<<20;
}]]></code.midihandler>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="a919ffab-f138-4bb2-9193-1455073b35ac" name="tablestore_12" x="1330" y="812">
      <params/>
      <attribs>
         <objref attributeName="table" obj="lcxl2"/>
         <spinner attributeName="seqlength" value="256"/>
         <combo attributeName="device" selection="din"/>
      </attribs>
      <object id="patch/object" uuid="a919ffab-f138-4bb2-9193-1455073b35ac">
         <sDescription>writes and outputs 8 values to a table.</sDescription>
         <author>robert schirmer</author>
         <license>who cares</license>
         <inlets>
            <int32 name="channel"/>
            <bool32 name="play"/>
            <int32 name="offset" description="sets an offset for writing to the table"/>
            <int32 name="step"/>
            <int32 name="stepunQ"/>
         </inlets>
         <outlets>
            <int32 name="totaloffset"/>
         </outlets>
         <displays/>
         <params/>
         <attribs>
            <objref name="table"/>
            <spinner name="seqlength" MinValue="1" MaxValue="10000" DefaultValue="0"/>
            <combo name="device">
               <MenuEntries>
                  <string>din</string>
                  <string>usb host port 1</string>
                  <string>usb host port 2</string>
                  <string>usb host port 3</string>
                  <string>usb host port 4</string>
                  <string>internal port 1</string>
                  <string>internal port 2</string>
                  <string>usb device port 1</string>
               </MenuEntries>
               <CEntries>
                  <string>MIDI_DEVICE_DIN, 1</string>
                  <string>MIDI_DEVICE_USB_HOST, 1</string>
                  <string>MIDI_DEVICE_USB_HOST, 2</string>
                  <string>MIDI_DEVICE_USB_HOST, 3</string>
                  <string>MIDI_DEVICE_USB_HOST, 4</string>
                  <string>MIDI_DEVICE_INTERNAL, 1</string>
                  <string>MIDI_DEVICE_INTERNAL, 2</string>
                  <string>MIDI_DEVICE_USB_DEVICE, 1</string>
               </CEntries>
            </combo>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[int prevchannel;
int steptrigger;
int seqlength;
int seqlengthUNQ;
int off1;
int offtrig;
int offsetunQ1;
int bend;
int bendA;
int bendB;
int touch;
int cc;
int ccv;
int prevbend;
int prevbendB;
int prevtouch;
int prevcc;
int prevccv;
int prevoffset;
int prevstepunQ;]]></code.declaration>
         <code.init><![CDATA[seqlengthUNQ=(attr_seqlength*32);
seqlength=attr_seqlength;
bendB=64;
bendA=0;
bend=0;
prevbendB=64;]]></code.init>
         <code.krate><![CDATA[off1= inlet_play;
if (inlet_channel!=prevchannel){
	if (prevbendB!=64){
	MidiSend3((midi_device_t) attr_device , MIDI_PITCH_BEND + (inlet_channel),0,64);prevbendB=64;
	}
	if (touch>0){
	MidiSend2((midi_device_t) attr_device, MIDI_CHANNEL_PRESSURE + (inlet_channel),0>>20);
	}
	prevchannel=inlet_channel;
}


offsetunQ1=(inlet_offset + inlet_stepunQ);

if (inlet_offset!=prevoffset){
	if (prevbendB!=64){
MidiSend3((midi_device_t) attr_device , MIDI_PITCH_BEND + (inlet_channel),0,64);prevbendB=64;
}
if (touch>0){
MidiSend2((midi_device_t) attr_device, MIDI_CHANNEL_PRESSURE + (inlet_channel),0>>20);
}
prevoffset=inlet_offset;
}

if (!off1){

if (offtrig==0){
//TnoteoffA=1;
//TnoteoffB=1;
if (prevbendB!=64){
MidiSend3((midi_device_t) attr_device , MIDI_PITCH_BEND + (inlet_channel),0,64);prevbendB=64;
}
if (touch>0){
MidiSend2((midi_device_t) attr_device, MIDI_CHANNEL_PRESSURE + (inlet_channel),0>>20);
}
offtrig=1;
}
bendB=64;
bendA=0;
bend=0;
touch=0;
}





else if (off1)
{
	if ((inlet_stepunQ==0)&&!steptrigger){
	if (prevbendB!=64){
		
	MidiSend3((midi_device_t) attr_device , MIDI_PITCH_BEND + (inlet_channel),0,64);prevbendB=64;}
	if (touch>0){
	MidiSend2((midi_device_t) attr_device, MIDI_CHANNEL_PRESSURE + (inlet_channel),0>>20);touch=0;}
	steptrigger=1;
}
if (inlet_stepunQ>0){
	steptrigger=0;
}
bend=attr_table.array[__USAT((offsetunQ1),attr_table.LENGTHPOW)]<<attr_table.GAIN;
bendA=(bend>>14)&0x7F;
bendB=(bend>>21)+64;
touch=attr_table.array[__USAT((offsetunQ1+ seqlengthUNQ),attr_table.LENGTHPOW)]<<attr_table.GAIN;
cc=attr_table.array[__USAT((offsetunQ1+ seqlengthUNQ+ seqlengthUNQ),attr_table.LENGTHPOW)]<<attr_table.GAIN;
ccv=attr_table.array[__USAT((offsetunQ1+ seqlengthUNQ+ seqlengthUNQ+ seqlengthUNQ),attr_table.LENGTHPOW)]<<attr_table.GAIN;

//pitchbend
if ((inlet_stepunQ!=prevstepunQ)&&(bendB!=prevbendB)){
MidiSend3((midi_device_t) attr_device , MIDI_PITCH_BEND + (inlet_channel),bendA,bendB);
prevbend=bend;
prevbendB=bendB;
}
//aftertouch
if ((touch!=prevtouch)&&(inlet_stepunQ!=prevstepunQ)){
MidiSend2((midi_device_t) attr_device, MIDI_CHANNEL_PRESSURE + (inlet_channel),touch>>20);
prevtouch=touch;
}
if (((ccv!=prevccv)||(cc!=prevcc))&&(inlet_stepunQ!=prevstepunQ)){
	MidiSend3((midi_device_t) attr_device, MIDI_CONTROL_CHANGE + (inlet_channel),(cc>>20),__USAT(ccv>>20,7));
	prevcc=cc;
	prevccv=ccv;
}

}

prevstepunQ=inlet_stepunQ;
outlet_totaloffset=inlet_offset+seqlengthUNQ+seqlengthUNQ+seqlengthUNQ+seqlengthUNQ;]]></code.krate>
      </object>
   </patchobj>
   <comment type="patch/comment" x="1302" y="1008" text="launch control xl shift button &amp; delay sync button"/>
   <comment type="patch/comment" x="154" y="1022" text="track 2"/>
   <comment type="patch/comment" x="294" y="1022" text="track 2"/>
   <comment type="patch/comment" x="448" y="1022" text="track 2"/>
   <comment type="patch/comment" x="574" y="1022" text="track 2"/>
   <patchobj type="patch/object" uuid="54915728-2133-4a5d-9879-466b5dedf37f" name="launchcontrol_1" x="1302" y="1022">
      <params/>
      <attribs>
         <spinner attributeName="channel" value="9"/>
      </attribs>
      <object id="patch/object" uuid="54915728-2133-4a5d-9879-466b5dedf37f">
         <sDescription>outputs the state of the top-row buttons of a &apos;novation launchpad&apos;.
DOES NOT work with the &apos;LP mark 1&apos;.</sDescription>
         <author>Robert Schirmer</author>
         <license>BSD</license>
         <helpPatch>launchpad.axh</helpPatch>
         <inlets/>
         <outlets>
            <bool32 name="shift"/>
            <bool32 name="t3"/>
         </outlets>
         <displays/>
         <params/>
         <attribs>
            <spinner name="channel" MinValue="1" MaxValue="16" DefaultValue="9"/>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[uint8_t cc [128];
int shift;]]></code.declaration>
         <code.krate><![CDATA[outlet_t3 = cc[107];
outlet_shift=shift;]]></code.krate>
         <code.midihandler><![CDATA[if (status == (attr_channel-1) + MIDI_CONTROL_CHANGE) cc[data1] = data2;
if ((status == MIDI_NOTE_ON + (attr_channel-1)) && (data2) && (data1 == 108)) {
    shift=1;
} 

else if (((status == MIDI_NOTE_ON + (attr_channel-1)) && (!data2)&&(data1==108))||          (status == MIDI_NOTE_OFF + (attr_channel-1)&&(data1==108))) {
    shift = 0;

  }]]></code.midihandler>
      </object>
   </patchobj>
   <comment type="patch/comment" x="154" y="1036" text="mono recorder"/>
   <comment type="patch/comment" x="294" y="1036" text=" noteplay  1"/>
   <comment type="patch/comment" x="448" y="1036" text="cbend touch cc recorder"/>
   <comment type="patch/comment" x="574" y="1036" text="bend/touch.CC play"/>
   <comment type="patch/comment" x="994" y="1036" text="sync delay to clock, more stable than direct syncing"/>
   <patchobj type="patch/object" uuid="a919ffab-f138-4bb2-9193-1455073b35ac" name="tablestore_7" x="154" y="1050">
      <params/>
      <attribs>
         <objref attributeName="table" obj="lcxl2"/>
         <spinner attributeName="seqlength" value="256"/>
      </attribs>
      <object id="patch/object" uuid="a919ffab-f138-4bb2-9193-1455073b35ac">
         <sDescription>writes and outputs 8 values to a table.</sDescription>
         <author>robert schirmer</author>
         <license>who cares</license>
         <inlets>
            <int32 name="channel"/>
            <bool32 name="rec"/>
            <int32 name="polyphony"/>
            <int32 name="offset" description="sets an offset for writing to the table"/>
            <int32 name="steprec"/>
            <int32 name="step"/>
            <int32 name="stepunQ"/>
            <int32 name="Qstep"/>
         </inlets>
         <outlets/>
         <displays/>
         <params/>
         <attribs>
            <objref name="table"/>
            <spinner name="seqlength" MinValue="1" MaxValue="10000" DefaultValue="0"/>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[int channel;
int polyphony;
int innote;
int invel;
int inputnote;
int inputvel;
int inputnoteon;
int inputnoteoff;
int ingate;
int ingate2;
int inntrig;
int inytrig;
int op;
int Atrig;
int notecount;
int seqlength;
int seqlengthUNQ;
int off1;
int recoffset1g;
int voiceoffset;
int offset;
int offset1;
int totaloffset;
int offsetg;
int offset1g;
int etrig;
int early;
int earlyshift;
int offsetunQ1;
int offsetunQ1g;
int noteon;
int noteoff;
int ytrig;
int xtrig;
int prevsteprec;
int prevstep;
int prevstepunQ;
int prevx;
int prevy;
int Pnoteoff;
int Poffset;]]></code.declaration>
         <code.init><![CDATA[seqlengthUNQ=(attr_seqlength*32);
seqlength=attr_seqlength;
noteon=0;
notecount=0;
offsetg=offset;]]></code.init>
         <code.krate><![CDATA[off1= !inlet_rec;
channel=inlet_channel;
voiceoffset=seqlength+seqlength+seqlengthUNQ;
totaloffset=voiceoffset+voiceoffset;
offset=inlet_offset+(totaloffset*(inlet_polyphony));



inputnote = innote<<20;
inputvel= invel<<20;

if((ingate2)&&!inntrig){
inputnoteon=ingate2;
inntrig=1;}
else inputnoteon=0;
if (!ingate2){
inntrig=0;
}

if((!ingate)&&!inytrig){
inputnoteoff=64<<20;
inytrig=1;}
else inputnoteoff=0;
if (ingate){
inytrig=0;
}

ingate2=ingate;

if ((inputnoteon>0) && !Atrig) {op = !op; Atrig=1;}
if (!(inputnoteon>0)) Atrig=0;
notecount= op;


if (notecount){offsetg=offset;}
if (!notecount){offsetg=offset+voiceoffset;}


recoffset1g=(offsetg + (inlet_steprec));
offsetunQ1g=(offsetg + inlet_stepunQ);




//1
if (!off1){
if ((inputnoteon>0)&&(!ytrig))
{
attr_table.array[recoffset1g]=__SSAT(inputnote,28)>>attr_table.GAIN;
attr_table.array[recoffset1g + seqlength]=__SSAT(inputvel,28)>>attr_table.GAIN;
Pnoteoff=0;
if ((inlet_steprec!=inlet_step)&&!etrig) {
	
	earlyshift=(16-inlet_Qstep);
	etrig=1;
}
if ((inlet_steprec==inlet_step)&&!etrig) 
{
	
	earlyshift=(0-inlet_Qstep);
	etrig=1;
	//if (inlet_steprec==0)
	//{
	//	early=2;
	//}
}

//if (inlet_steprec==(seqlength-1)){early=2;}
prevy=inlet_steprec;
ytrig=1;
}
else if ((!(inputnoteon>0))&&(inlet_steprec!=prevy)){
	ytrig=0;
	
}


if ((inputnoteoff>0)&&(!xtrig))
{early=earlyshift;
	

		attr_table.array[offsetunQ1g + seqlength + seqlength + earlyshift]=__SSAT(inputnoteoff,28)>>attr_table.GAIN;
		Pnoteoff=1;
		//attr_table.array[recoffset1g]=__SSAT(inputnote,28)>>attr_table.GAIN;
	
etrig=0;
prevx=inlet_stepunQ;
xtrig=1;
}
else if ((!(inputnoteoff>0))&&(inlet_stepunQ!=prevx)){
	xtrig=0;
}


if ((offsetg!=Poffset)&&ingate){
	inputnoteoff=64<<20;
	attr_table.array[Poffset + prevstepunQ + seqlength + seqlength]=__SSAT(inputnoteoff,28)>>attr_table.GAIN;
	}

prevstep=inlet_step;
prevstepunQ=inlet_stepunQ;
prevsteprec=inlet_steprec;
Poffset=offsetg;
}



else if (off1)
{
	if (!Pnoteoff){
	inputnoteoff=64<<20;
	attr_table.array[offsetg + prevstepunQ + seqlength + seqlength + earlyshift]=__SSAT(inputnoteoff,28)>>attr_table.GAIN;Pnoteoff=1;}
inputnoteoff=0;
etrig=0;
ytrig=0;
xtrig=0;
op=0;
prevx=(-1);
prevy=(-1);
}]]></code.krate>
         <code.midihandler><![CDATA[if (status == MIDI_NOTE_ON + (channel)) {
  innote = data1;
  invel = data2;
  ingate=1;
  ingate2=0;
}
if (status == MIDI_NOTE_OFF + (channel)) {
	if (data1==(innote)){
		ingate=0;
	}
}]]></code.midihandler>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="a919ffab-f138-4bb2-9193-1455073b35ac" name="tablestore_27" x="294" y="1050">
      <params/>
      <attribs>
         <objref attributeName="table" obj="lcxl2"/>
         <spinner attributeName="seqlength" value="256"/>
         <combo attributeName="device" selection="din"/>
      </attribs>
      <object id="patch/object" uuid="a919ffab-f138-4bb2-9193-1455073b35ac">
         <sDescription>writes and outputs 8 values to a table.</sDescription>
         <author>robert schirmer</author>
         <license>who cares</license>
         <inlets>
            <int32 name="channel"/>
            <bool32 name="play"/>
            <int32 name="offset" description="sets an offset for writing to the table"/>
            <int32 name="step"/>
            <int32 name="stepunQ"/>
         </inlets>
         <outlets>
            <int32 name="totaloffset"/>
         </outlets>
         <displays/>
         <params/>
         <attribs>
            <objref name="table"/>
            <spinner name="seqlength" MinValue="1" MaxValue="10000" DefaultValue="0"/>
            <combo name="device">
               <MenuEntries>
                  <string>din</string>
                  <string>usb host port 1</string>
                  <string>usb host port 2</string>
                  <string>usb host port 3</string>
                  <string>usb host port 4</string>
                  <string>internal port 1</string>
                  <string>internal port 2</string>
                  <string>usb device port 1</string>
               </MenuEntries>
               <CEntries>
                  <string>MIDI_DEVICE_DIN, 1</string>
                  <string>MIDI_DEVICE_USB_HOST, 1</string>
                  <string>MIDI_DEVICE_USB_HOST, 2</string>
                  <string>MIDI_DEVICE_USB_HOST, 3</string>
                  <string>MIDI_DEVICE_USB_HOST, 4</string>
                  <string>MIDI_DEVICE_INTERNAL, 1</string>
                  <string>MIDI_DEVICE_INTERNAL, 2</string>
                  <string>MIDI_DEVICE_USB_DEVICE, 1</string>
               </CEntries>
            </combo>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[int prevchannel;
int steptrig;
int TntrigA;
int TntrigB;
int TlastnoteA;
int TlastnoteB;
int seqlength;
int seqlengthUNQ;
int voiceoffset;
int off1;
int offtrig;
int offset1;
int offsetunQ1;
int noteonA;
int noteoffA;
int noteA;
int holdnoteA;
int holdvelA;
int TnoteA;
int TvelA;
int TnoteonA;
int TnoteoffA;
int noteonB;
int noteoffB;
int noteB;
int holdnoteB;
int holdvelB;
int TnoteB;
int TvelB;
int TnoteonB;
int TnoteoffB;
int prevoffset;
int prevstep;
int prevstepunQ;]]></code.declaration>
         <code.init><![CDATA[noteonA=0;
seqlengthUNQ=(attr_seqlength*32);
seqlength=attr_seqlength;]]></code.init>
         <code.krate><![CDATA[off1= inlet_play;
if ((inlet_channel!=prevchannel)||(inlet_offset!=prevoffset)){
	if ((TntrigB>0)&&(TlastnoteB>0)){
	MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (prevchannel),TlastnoteB,__USAT(TvelB,7)); TntrigB=0;}
	if ((TntrigA>0)&&(TlastnoteA>0)){
	MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (prevchannel),TlastnoteA,__USAT(TvelA,7)); TntrigA=0;}
	prevchannel=inlet_channel;
}
//if (inlet_offset!=prevoffset){
//	if ((TntrigB>0)&&(TlastnoteB>0)){
//	MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (inlet_channel),TlastnoteB,__USAT(TvelB,7)); TntrigB=0;}
//	if ((TntrigA>0)&&(TlastnoteA>0)){
//	MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (inlet_channel),TlastnoteA,__USAT(TvelA,7)); TntrigA=0;}
//}

offset1=(inlet_offset + inlet_step);
offsetunQ1=(inlet_offset + inlet_stepunQ);
voiceoffset=(seqlength+seqlength+seqlengthUNQ);



//1
if (!off1){
TnoteA=0;
TvelA=0;
TnoteonA=0;
TnoteB=0;
TvelB=0;
TnoteonB=0;
if (offtrig==0){

if ((TntrigB>0)&&(TlastnoteB>0)){
MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (inlet_channel),TlastnoteB,__USAT(TvelB,7)); TntrigB=0;}
if ((TntrigA>0)&&(TlastnoteA>0)){
MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (inlet_channel),TlastnoteA,__USAT(TvelA,7)); TntrigA=0;}

offtrig=1;
}}





else if (off1)
{



	noteA= attr_table.array[__USAT((offset1),attr_table.LENGTHPOW)]<<attr_table.GAIN;
noteonA=attr_table.array[__USAT((offset1 + seqlength),attr_table.LENGTHPOW)]<<attr_table.GAIN;
noteoffA=attr_table.array[__USAT((offsetunQ1+ seqlength + seqlength),attr_table.LENGTHPOW)]<<attr_table.GAIN;
noteB= attr_table.array[__USAT((voiceoffset+ offset1),attr_table.LENGTHPOW)]<<attr_table.GAIN;
noteonB=attr_table.array[__USAT((voiceoffset+ offset1 + seqlength),attr_table.LENGTHPOW)]<<attr_table.GAIN;
noteoffB=attr_table.array[__USAT((voiceoffset+ offsetunQ1+ seqlength + seqlength),attr_table.LENGTHPOW)]<<attr_table.GAIN;


//voiceA*****************************************
//note
if ((inlet_step != prevstep )&&(noteA > (0) )) { 
     holdnoteA = noteA>>20;
     TnoteA = holdnoteA;
}
else {
	TnoteA = holdnoteA;
}

//vel
if ((inlet_step != prevstep )&&(noteonA> 0 )) { 
     holdvelA = noteonA>>20;
     TvelA = holdvelA;
}
else {
	TvelA = holdvelA;
}


if ((noteoffA>0)&&(inlet_stepunQ!=prevstepunQ)){
	TnoteoffA=1;}
else TnoteoffA=0;

if ((noteonA>0)&&(inlet_step!=prevstep)){
	TnoteonA=1;}
else TnoteonA=0;

//voiceB*****************************************
//note
if ((inlet_step != prevstep )&&(noteB > 0) ) { 
     holdnoteB = noteB>>20;
     TnoteB = holdnoteB;
}
else {
	TnoteB = holdnoteB;
}

//vel
if ((inlet_step != prevstep )&&(noteonB> 0 )) { 
     holdvelB = noteonB>>20;
     TvelB = holdvelB;
}
else {
	TvelB = holdvelB;
}


if ((noteoffB>0)&&(inlet_stepunQ!=prevstepunQ)){
	TnoteoffB=1;}
else TnoteoffB=0;

if ((noteonB>0)&&(inlet_step!=prevstep)){
	TnoteonB=1;}
else TnoteonB=0;


if ((TnoteonA>0) && !TntrigA) {
if ((TlastnoteB>0)&&TntrigB){	
MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (inlet_channel),TlastnoteB,__USAT(TvelB,7)); TntrigB=0;
}
MidiSend3((midi_device_t) attr_device, MIDI_NOTE_ON + (inlet_channel),TnoteA,TvelA);  TntrigA=1;
TlastnoteA = TnoteA;
}
if ((TnoteoffA>0) && TntrigA) {MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (inlet_channel),TlastnoteA,__USAT(TvelA,7)); TntrigA=0;}

if ((TnoteonB>0) && !TntrigB) {
if ((TlastnoteA>0)&&TntrigA){
MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (inlet_channel),TlastnoteA,__USAT(TvelA,7)); TntrigA=0;
}
MidiSend3((midi_device_t) attr_device, MIDI_NOTE_ON + (inlet_channel),TnoteB,TvelB);  TntrigB=1;
TlastnoteB = TnoteB;
}
if ((TnoteoffB>0) && TntrigB) {MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (inlet_channel),TlastnoteB,__USAT(TvelB,7)); TntrigB=0;}




offtrig=0;
}
prevoffset=inlet_offset;
prevstep=inlet_step;
prevstepunQ=inlet_stepunQ;
outlet_totaloffset=inlet_offset+voiceoffset+voiceoffset;]]></code.krate>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="a919ffab-f138-4bb2-9193-1455073b35ac" name="tablestore_13" x="448" y="1050">
      <params/>
      <attribs>
         <objref attributeName="table" obj="lcxl2"/>
         <spinner attributeName="seqlength" value="256"/>
      </attribs>
      <object id="patch/object" uuid="a919ffab-f138-4bb2-9193-1455073b35ac">
         <sDescription>writes and outputs 8 values to a table.</sDescription>
         <author>robert schirmer</author>
         <license>who cares</license>
         <inlets>
            <int32 name="channel"/>
            <bool32 name="rec"/>
            <int32 name="offset" description="sets an offset for writing to the table"/>
            <int32 name="stepunQ"/>
         </inlets>
         <outlets>
            <int32 name="offset"/>
         </outlets>
         <displays/>
         <params/>
         <attribs>
            <objref name="table"/>
            <spinner name="seqlength" MinValue="1" MaxValue="10000" DefaultValue="0"/>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[uint32_t i;
uint32_t ii;
int32_t _bend;
int32_t Btrig;
int32_t _press;
int channel;
int cc;
int ccv;
int innote;
int invel;
int inputnote;
int inputvel;
int inputnoteon;
int inputnoteoff;
int ingate;
int ingate2;
int inntrig;
int inytrig;
int op;
int Atrig;
int notecount;
int seqlength;
int seqlengthUNQ;
int splat;
int clear;
int ntrig;
int rtrig;
int speed;
int off1;
int recoffset1g;
int voiceoffset;
int offset;
int offset1;
int totaloffset;
int offsetg;
int offset1g;
int early;
int offsetunQ1;
int offsetunQ1g;
int noteon;
int noteoff;
int ytrig;
int xtrig;
int prevsteprec;
int prevstep;
int prevstepunQ;
int prevx;
int prevy;]]></code.declaration>
         <code.init><![CDATA[seqlengthUNQ=(attr_seqlength*32);
seqlength=attr_seqlength;
_bend=0;
_press=0;]]></code.init>
         <code.krate><![CDATA[off1= !inlet_rec;
channel=inlet_channel;
offset=inlet_offset;

//1
if (!off1){
	if(inlet_stepunQ!=prevstepunQ){
	attr_table.array[offset + inlet_stepunQ]=__SSAT(_bend,28)>>attr_table.GAIN;
	attr_table.array[offset + inlet_stepunQ + seqlengthUNQ]=__SSAT(_press,28)>>attr_table.GAIN;
	attr_table.array[offset + inlet_stepunQ + seqlengthUNQ + seqlengthUNQ]=__SSAT(cc,28)>>attr_table.GAIN;
	attr_table.array[offset + inlet_stepunQ + seqlengthUNQ + seqlengthUNQ + seqlengthUNQ]=__SSAT(ccv,28)>>attr_table.GAIN;
	prevstepunQ=inlet_stepunQ;
	}
}


else if (off1)
{
	_bend=0;
	_press=0;
	cc=0;
	ccv=0;
}

outlet_offset=inlet_offset+seqlengthUNQ+seqlengthUNQ+seqlengthUNQ+seqlengthUNQ;]]></code.krate>
         <code.midihandler><![CDATA[if (status == MIDI_PITCH_BEND + (channel)) {  _bend = ((int)((data2<<7)+data1)-0x2000)<<14;
}
if (status == MIDI_CHANNEL_PRESSURE + (channel)) {  _press = (data1)<<20;
}
if (status == (channel) + MIDI_CONTROL_CHANGE) {
  ccv = data2<<20;
  cc = data1<<20;
}]]></code.midihandler>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="a919ffab-f138-4bb2-9193-1455073b35ac" name="tablestore_14" x="574" y="1050">
      <params/>
      <attribs>
         <objref attributeName="table" obj="lcxl2"/>
         <spinner attributeName="seqlength" value="256"/>
         <combo attributeName="device" selection="din"/>
      </attribs>
      <object id="patch/object" uuid="a919ffab-f138-4bb2-9193-1455073b35ac">
         <sDescription>writes and outputs 8 values to a table.</sDescription>
         <author>robert schirmer</author>
         <license>who cares</license>
         <inlets>
            <int32 name="channel"/>
            <bool32 name="play"/>
            <int32 name="offset" description="sets an offset for writing to the table"/>
            <int32 name="step"/>
            <int32 name="stepunQ"/>
         </inlets>
         <outlets>
            <int32 name="totaloffset"/>
         </outlets>
         <displays/>
         <params/>
         <attribs>
            <objref name="table"/>
            <spinner name="seqlength" MinValue="1" MaxValue="10000" DefaultValue="0"/>
            <combo name="device">
               <MenuEntries>
                  <string>din</string>
                  <string>usb host port 1</string>
                  <string>usb host port 2</string>
                  <string>usb host port 3</string>
                  <string>usb host port 4</string>
                  <string>internal port 1</string>
                  <string>internal port 2</string>
                  <string>usb device port 1</string>
               </MenuEntries>
               <CEntries>
                  <string>MIDI_DEVICE_DIN, 1</string>
                  <string>MIDI_DEVICE_USB_HOST, 1</string>
                  <string>MIDI_DEVICE_USB_HOST, 2</string>
                  <string>MIDI_DEVICE_USB_HOST, 3</string>
                  <string>MIDI_DEVICE_USB_HOST, 4</string>
                  <string>MIDI_DEVICE_INTERNAL, 1</string>
                  <string>MIDI_DEVICE_INTERNAL, 2</string>
                  <string>MIDI_DEVICE_USB_DEVICE, 1</string>
               </CEntries>
            </combo>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[int prevchannel;
int steptrigger;
int seqlength;
int seqlengthUNQ;
int off1;
int offtrig;
int offsetunQ1;
int bend;
int bendA;
int bendB;
int touch;
int cc;
int ccv;
int prevbend;
int prevbendB;
int prevtouch;
int prevcc;
int prevccv;
int prevoffset;
int prevstepunQ;]]></code.declaration>
         <code.init><![CDATA[seqlengthUNQ=(attr_seqlength*32);
seqlength=attr_seqlength;
bendB=64;
bendA=0;
bend=0;
prevbendB=64;]]></code.init>
         <code.krate><![CDATA[off1= inlet_play;
if (inlet_channel!=prevchannel){
	if (prevbendB!=64){
	MidiSend3((midi_device_t) attr_device , MIDI_PITCH_BEND + (inlet_channel),0,64);prevbendB=64;
	}
	if (touch>0){
	MidiSend2((midi_device_t) attr_device, MIDI_CHANNEL_PRESSURE + (inlet_channel),0>>20);
	}
	prevchannel=inlet_channel;
}


offsetunQ1=(inlet_offset + inlet_stepunQ);

if (inlet_offset!=prevoffset){
	if (prevbendB!=64){
MidiSend3((midi_device_t) attr_device , MIDI_PITCH_BEND + (inlet_channel),0,64);prevbendB=64;
}
if (touch>0){
MidiSend2((midi_device_t) attr_device, MIDI_CHANNEL_PRESSURE + (inlet_channel),0>>20);
}
prevoffset=inlet_offset;
}

if (!off1){

if (offtrig==0){
//TnoteoffA=1;
//TnoteoffB=1;
if (prevbendB!=64){
MidiSend3((midi_device_t) attr_device , MIDI_PITCH_BEND + (inlet_channel),0,64);prevbendB=64;
}
if (touch>0){
MidiSend2((midi_device_t) attr_device, MIDI_CHANNEL_PRESSURE + (inlet_channel),0>>20);
}
offtrig=1;
}
bendB=64;
bendA=0;
bend=0;
touch=0;
}





else if (off1)
{
	if ((inlet_stepunQ==0)&&!steptrigger){
	if (prevbendB!=64){
		
	MidiSend3((midi_device_t) attr_device , MIDI_PITCH_BEND + (inlet_channel),0,64);prevbendB=64;}
	if (touch>0){
	MidiSend2((midi_device_t) attr_device, MIDI_CHANNEL_PRESSURE + (inlet_channel),0>>20);touch=0;}
	steptrigger=1;
}
if (inlet_stepunQ>0){
	steptrigger=0;
}
bend=attr_table.array[__USAT((offsetunQ1),attr_table.LENGTHPOW)]<<attr_table.GAIN;
bendA=(bend>>14)&0x7F;
bendB=(bend>>21)+64;
touch=attr_table.array[__USAT((offsetunQ1+ seqlengthUNQ),attr_table.LENGTHPOW)]<<attr_table.GAIN;
cc=attr_table.array[__USAT((offsetunQ1+ seqlengthUNQ+ seqlengthUNQ),attr_table.LENGTHPOW)]<<attr_table.GAIN;
ccv=attr_table.array[__USAT((offsetunQ1+ seqlengthUNQ+ seqlengthUNQ+ seqlengthUNQ),attr_table.LENGTHPOW)]<<attr_table.GAIN;

//pitchbend
if ((inlet_stepunQ!=prevstepunQ)&&(bendB!=prevbendB)){
MidiSend3((midi_device_t) attr_device , MIDI_PITCH_BEND + (inlet_channel),bendA,bendB);
prevbend=bend;
prevbendB=bendB;
}
//aftertouch
if ((touch!=prevtouch)&&(inlet_stepunQ!=prevstepunQ)){
MidiSend2((midi_device_t) attr_device, MIDI_CHANNEL_PRESSURE + (inlet_channel),touch>>20);
prevtouch=touch;
}
if (((ccv!=prevccv)||(cc!=prevcc))&&(inlet_stepunQ!=prevstepunQ)){
	MidiSend3((midi_device_t) attr_device, MIDI_CONTROL_CHANGE + (inlet_channel),(cc>>20),__USAT(ccv>>20,7));
	prevcc=cc;
	prevccv=ccv;
}

}

prevstepunQ=inlet_stepunQ;
outlet_totaloffset=inlet_offset+seqlengthUNQ+seqlengthUNQ+seqlengthUNQ+seqlengthUNQ;]]></code.krate>
      </object>
   </patchobj>
   <obj type="logic/counter" uuid="7a141ba82230e54e5f5cd12da5dbe5a74ba854a5" name="counter_5" x="966" y="1050">
      <params>
         <int32 name="maximum" value="3"/>
      </params>
      <attribs/>
   </obj>
   <obj type="logic/flipflop toggle" uuid="195e489e5fc3d275944b0de56c7a91c8641ea22a" name="flipflop_3" x="1064" y="1050">
      <params/>
      <attribs/>
   </obj>
   <obj type="logic/and 2" uuid="c67031682f552aa0a80b23377495c51ea28a8c9c" name="and_4" x="1176" y="1050">
      <params/>
      <attribs/>
   </obj>
   <patchobj type="patch/object" uuid="28016b8b-78a6-4cb1-8f05-fe371f8b131f" name="tap_tempo_2" x="1106" y="1120">
      <params>
         <int32 name="clockmul" value="1"/>
         <int32 name="clockdiv" value="1"/>
         <bool32.mom name="tap" value="0"/>
      </params>
      <attribs/>
      <object id="patch/object" uuid="28016b8b-78a6-4cb1-8f05-fe371f8b131f">
         <sDescription>Tap tempo, mul/div as live parameters</sDescription>
         <author>Are Leistad</author>
         <license>BSD</license>
         <inlets>
            <bool32.rising name="tap" description="Tap input"/>
         </inlets>
         <outlets>
            <bool32.pulse name="clock" description="Clock output"/>
            <frac32.positive name="phasor" description="Phasor output"/>
         </outlets>
         <displays/>
         <params>
            <int32 name="clockmul" noLabel="false">
               <MinValue i="1"/>
               <MaxValue i="128"/>
            </int32>
            <int32 name="clockdiv" noLabel="false">
               <MinValue i="1"/>
               <MaxValue i="128"/>
            </int32>
            <bool32.mom name="tap" noLabel="false"/>
         </params>
         <attribs/>
         <includes/>
         <code.declaration><![CDATA[

      uint32_t  ktimer;
      uint32_t  last_ktime;
      uint32_t  phase;
      float     base_freq;
      uint32_t  old_phase;
      uint32_t  old_inlet_tap;
      uint32_t  old_param_tap;

    ]]></code.declaration>
         <code.init><![CDATA[

      ktimer        = 0;
      last_ktime    = 0;
      phase         = 0;
      base_freq     = 64.0f * (double)(1 << 30) * 1.0f / (SAMPLERATE * 1.0f);
      old_phase     = 0;
      old_inlet_tap = 0;
      old_param_tap = 0;

    ]]></code.init>
         <code.krate><![CDATA[

      if(   (inlet_tap && !old_inlet_tap)
         || (param_tap && !old_param_tap)
        )
        {
          float period = (ktimer - last_ktime);
          if( period < 15000 ) // 5 seconds at most between taps
            {
              period = period * 16;
              if( period < 1.0f )
                {
                  period = 1.0f;
                }
              float f_clock = SAMPLERATE / period;
              base_freq     = 64.0f * (float)(1 << 30) * f_clock / (SAMPLERATE * 1.0f);
              phase         = 0;
            }
          last_ktime  = ktimer;
        }

      float freq  = (base_freq * (float) param_clockmul) / (float) param_clockdiv;
      phase += (uint32_t) freq;

      outlet_clock = 0;
      if( phase < old_phase )
        {
          outlet_clock = 1;
        }

      outlet_phasor = (phase>>5);

      old_phase     = phase;
      old_inlet_tap = inlet_tap;
      old_param_tap = param_tap;

      ktimer++;

    ]]></code.krate>
      </object>
   </patchobj>
   <comment type="patch/comment" x="1092" y="1246" text="shift"/>
   <comment type="patch/comment" x="1540" y="1246" text="shift"/>
   <comment type="patch/comment" x="798" y="1260" text="launch control xl to table"/>
   <comment type="patch/comment" x="952" y="1260" text="knob row1 table to fx"/>
   <comment type="patch/comment" x="1092" y="1260" text="knob row1 table to fx"/>
   <comment type="patch/comment" x="1232" y="1260" text="launch control xl to table"/>
   <comment type="patch/comment" x="1386" y="1260" text="knob row3 table to fx"/>
   <comment type="patch/comment" x="1540" y="1260" text="knob row1 table to fx"/>
   <patchobj type="patch/object" uuid="613066c7-76ff-4579-80e3-3bf2ebf44ad6" name="table_5" x="798" y="1274">
      <params>
         <int32 name="offset" value="3"/>
         <bool32.tgl name="active" value="1"/>
      </params>
      <attribs>
         <objref attributeName="table" obj="lcxl3"/>
         <spinner attributeName="startcc" value="13"/>
         <spinner attributeName="length" value="8"/>
      </attribs>
      <object id="patch/object" uuid="613066c7-76ff-4579-80e3-3bf2ebf44ad6">
         <sDescription>writes midi controler data to a table.set the start of the range of the controlers to read out with &apos;startcc&apos;,the length of the range with &apos;length&apos;.
the data is written to the table starting at &apos;offset&apos;.</sDescription>
         <author>robert schirmer</author>
         <license>BSD</license>
         <helpPatch>launchpad.axh</helpPatch>
         <rotatedParams>true</rotatedParams>
         <inlets>
            <int32 name="offset"/>
            <int32 name="startcc"/>
            <bool32.risingfalling name="active"/>
            <bool32 name="shift"/>
         </inlets>
         <outlets>
            <bool32.pulse name="chtrig" description="pulse if any cc value changes"/>
         </outlets>
         <displays/>
         <params>
            <int32 name="offset">
               <MinValue i="0"/>
               <MaxValue i="1000000"/>
            </int32>
            <bool32.tgl name="active"/>
         </params>
         <attribs>
            <objref name="table"/>
            <spinner name="startcc" MinValue="0" MaxValue="127" DefaultValue="0"/>
            <spinner name="length" MinValue="1" MaxValue="128" DefaultValue="1"/>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[int8_t cc;
int8_t cv;
uint8_t prevcv;
uint8_t prevcc;

uint8_t end;
uint8_t start;
uint32_t offset;

bool chtrig;]]></code.declaration>
         <code.init><![CDATA[prevcv=  0;
prevcc = 0;
chtrig = 0;]]></code.init>
         <code.krate><![CDATA[start = attr_startcc + inlet_startcc;
end = start + attr_length;
if (!inlet_shift){
offset = (inlet_offset + param_offset);}
if (inlet_shift){
offset = (inlet_offset + param_offset + 8);}
	

if (((cc >= start) && (cc < end)) && (inlet_active || param_active)) {

if ((cv != prevcv)||(cc != prevcc)){
      attr_table.array[(cc - start) + offset]= ((cv << 20) >>attr_table.GAIN);
      prevcv = cv; 
      prevcc = cc;
      chtrig = 1;   
   }  

   outlet_chtrig = chtrig;
  chtrig = 0;
}]]></code.krate>
         <code.midihandler><![CDATA[if (status == attr_midichannel + MIDI_CONTROL_CHANGE) {cc = data1;cv = data2;}]]></code.midihandler>
      </object>
   </patchobj>
   <obj type="rbrt/data/tableread 8" uuid="e91f7d4e-591f-49b4-8277-241cf4661605" name="tableread_5" x="952" y="1274">
      <params>
         <int32 name="offset" value="3"/>
      </params>
      <attribs>
         <objref attributeName="table" obj="lcxl3"/>
      </attribs>
   </obj>
   <obj type="rbrt/data/tableread 8" uuid="e91f7d4e-591f-49b4-8277-241cf4661605" name="tableread_2" x="1092" y="1274">
      <params>
         <int32 name="offset" value="11"/>
      </params>
      <attribs>
         <objref attributeName="table" obj="lcxl3"/>
      </attribs>
   </obj>
   <patchobj type="patch/object" uuid="613066c7-76ff-4579-80e3-3bf2ebf44ad6" name="table_6" x="1232" y="1274">
      <params>
         <int32 name="offset" value="19"/>
         <bool32.tgl name="active" value="1"/>
      </params>
      <attribs>
         <objref attributeName="table" obj="lcxl3"/>
         <spinner attributeName="startcc" value="49"/>
         <spinner attributeName="length" value="8"/>
      </attribs>
      <object id="patch/object" uuid="613066c7-76ff-4579-80e3-3bf2ebf44ad6">
         <sDescription>writes midi controler data to a table.set the start of the range of the controlers to read out with &apos;startcc&apos;,the length of the range with &apos;length&apos;.
the data is written to the table starting at &apos;offset&apos;.</sDescription>
         <author>robert schirmer</author>
         <license>BSD</license>
         <helpPatch>launchpad.axh</helpPatch>
         <rotatedParams>true</rotatedParams>
         <inlets>
            <int32 name="offset"/>
            <int32 name="startcc"/>
            <bool32.risingfalling name="active"/>
            <bool32 name="shift"/>
         </inlets>
         <outlets>
            <bool32.pulse name="chtrig" description="pulse if any cc value changes"/>
         </outlets>
         <displays/>
         <params>
            <int32 name="offset">
               <MinValue i="0"/>
               <MaxValue i="1000000"/>
            </int32>
            <bool32.tgl name="active"/>
         </params>
         <attribs>
            <objref name="table"/>
            <spinner name="startcc" MinValue="0" MaxValue="127" DefaultValue="0"/>
            <spinner name="length" MinValue="1" MaxValue="128" DefaultValue="1"/>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[int8_t cc;
int8_t cv;
uint8_t prevcv;
uint8_t prevcc;

uint8_t end;
uint8_t start;
uint32_t offset;

bool chtrig;]]></code.declaration>
         <code.init><![CDATA[prevcv=  0;
prevcc = 0;
chtrig = 0;]]></code.init>
         <code.krate><![CDATA[start = attr_startcc + inlet_startcc;
end = start + attr_length;
if (!inlet_shift){
offset = (inlet_offset + param_offset);}
if (inlet_shift){
offset = (inlet_offset + param_offset + 8);}
	

if (((cc >= start) && (cc < end)) && (inlet_active || param_active)) {

if ((cv != prevcv)||(cc != prevcc)){
      attr_table.array[(cc - start) + offset]= ((cv << 20) >>attr_table.GAIN);
      prevcv = cv; 
      prevcc = cc;
      chtrig = 1;   
   }  

   outlet_chtrig = chtrig;
  chtrig = 0;
}]]></code.krate>
         <code.midihandler><![CDATA[if (status == attr_midichannel + MIDI_CONTROL_CHANGE) {cc = data1;cv = data2;}]]></code.midihandler>
      </object>
   </patchobj>
   <obj type="rbrt/data/tableread 8" uuid="e91f7d4e-591f-49b4-8277-241cf4661605" name="tableread_6" x="1386" y="1274">
      <params>
         <int32 name="offset" value="19"/>
      </params>
      <attribs>
         <objref attributeName="table" obj="lcxl3"/>
      </attribs>
   </obj>
   <obj type="rbrt/data/tableread 4" uuid="e273ffa8-7368-4748-ba60-f5fa6e082deb" name="tableread_3" x="1540" y="1274">
      <params/>
      <attribs>
         <objref attributeName="table" obj="lcxl3"/>
         <spinner attributeName="offset" value="27"/>
      </attribs>
   </obj>
   <comment type="patch/comment" x="812" y="1316" text="delay sync button"/>
   <comment type="patch/comment" x="812" y="1456" text="chorus delay modulation"/>
   <comment type="patch/comment" x="1442" y="1456" text="delay modulation"/>
   <comment type="patch/comment" x="812" y="1470" text="lfo speed"/>
   <comment type="patch/comment" x="1134" y="1470" text="lfo dpth"/>
   <comment type="patch/comment" x="1442" y="1470" text="lfo speed"/>
   <comment type="patch/comment" x="1764" y="1470" text="lfo dpth"/>
   <obj type="math/*c" uuid="7d5ef61c3bcd571ee6bbd8437ef3612125dfb225" name="*c_1" x="812" y="1484">
      <params>
         <frac32.u.map name="amp" value="45.5"/>
      </params>
      <attribs/>
   </obj>
   <obj type="conv/unipolar2bipolar" uuid="efc8ee28c508740c5edf7995eaaa07a6d6818e5e" name="unipolar2bipolar_3" x="910" y="1484">
      <params/>
      <attribs/>
   </obj>
   <obj type="drj/lfo/tri_ph_p" uuid="ef2a164985b533c6e46ce43c0decba17b1862d85" name="tri_ph_p_3" x="1036" y="1484">
      <params>
         <frac32.s.map name="pitch" value="0.0"/>
      </params>
      <attribs/>
   </obj>
   <obj type="math/*" uuid="922423f2db9f222aa3e5ba095778288c446da47a" name="*_4" x="1134" y="1484">
      <params/>
      <attribs/>
   </obj>
   <obj type="math/*c" uuid="7d5ef61c3bcd571ee6bbd8437ef3612125dfb225" name="*c_3" x="1190" y="1484">
      <params>
         <frac32.u.map name="amp" value="13.999999523162842"/>
      </params>
      <attribs/>
   </obj>
   <obj type="math/*c" uuid="7d5ef61c3bcd571ee6bbd8437ef3612125dfb225" name="*c_9" x="1302" y="1484">
      <params>
         <frac32.u.map name="amp" value="59.799999713897705"/>
      </params>
      <attribs/>
   </obj>
   <obj type="math/*c" uuid="7d5ef61c3bcd571ee6bbd8437ef3612125dfb225" name="*c_5" x="1442" y="1484">
      <params>
         <frac32.u.map name="amp" value="47.0"/>
      </params>
      <attribs/>
   </obj>
   <obj type="conv/unipolar2bipolar" uuid="efc8ee28c508740c5edf7995eaaa07a6d6818e5e" name="unipolar2bipolar_4" x="1540" y="1484">
      <params/>
      <attribs/>
   </obj>
   <obj type="drj/lfo/tri_ph_p" uuid="ef2a164985b533c6e46ce43c0decba17b1862d85" name="tri_ph_p_2" x="1666" y="1484">
      <params>
         <frac32.s.map name="pitch" value="0.0"/>
      </params>
      <attribs/>
   </obj>
   <obj type="math/*" uuid="922423f2db9f222aa3e5ba095778288c446da47a" name="*_3" x="1764" y="1484">
      <params/>
      <attribs/>
   </obj>
   <obj type="math/*c" uuid="7d5ef61c3bcd571ee6bbd8437ef3612125dfb225" name="*c_6" x="1834" y="1484">
      <params>
         <frac32.u.map name="amp" value="0.7999997138977051"/>
      </params>
      <attribs/>
   </obj>
   <patchobj type="patch/object" uuid="08c2ef85-e91c-4dc7-a013-a0cdf0dcaf2e" name="scale_1" x="1960" y="1484">
      <params>
         <frac32.u.map name="a" value="30.0"/>
         <frac32.u.map name="b" value="55.5"/>
      </params>
      <attribs/>
      <object id="patch/object" uuid="08c2ef85-e91c-4dc7-a013-a0cdf0dcaf2e">
         <sDescription>Maps 0..64 to a..b</sDescription>
         <author>Johannes Elliesen</author>
         <license>BSD</license>
         <inlets>
            <frac32.positive name="c" description="control"/>
         </inlets>
         <outlets>
            <frac32 name="o" description="output"/>
         </outlets>
         <displays/>
         <params>
            <frac32.u.map name="a"/>
            <frac32.u.map name="b"/>
         </params>
         <attribs/>
         <includes/>
         <code.krate><![CDATA[{
      int64_t a = (int64_t)param_b * inlet_c;
      a += (int64_t)param_a * ((128<<20)-inlet_c);
      outlet_o= a>>27;
   }]]></code.krate>
      </object>
   </patchobj>
   <obj type="conv/unipolar2bipolar" uuid="efc8ee28c508740c5edf7995eaaa07a6d6818e5e" name="unipolar2bipolar_2" x="2072" y="1484">
      <params/>
      <attribs/>
   </obj>
   <obj type="math/*c" uuid="7d5ef61c3bcd571ee6bbd8437ef3612125dfb225" name="*c_2" x="2212" y="1484">
      <params>
         <frac32.u.map name="amp" value="35.0"/>
      </params>
      <attribs/>
   </obj>
   <comment type="patch/comment" x="378" y="1554" text="metronom for lights"/>
   <obj type="logic/counter" uuid="7a141ba82230e54e5f5cd12da5dbe5a74ba854a5" name="counter_1" x="378" y="1568">
      <params>
         <int32 name="maximum" value="4"/>
      </params>
      <attribs/>
   </obj>
   <obj type="logic/or 2" uuid="3805d3c84d30032a44fbdbe42d9a2988a1790a3e" name="or_3" x="476" y="1568">
      <params/>
      <attribs/>
   </obj>
   <obj type="logic/counter" uuid="7a141ba82230e54e5f5cd12da5dbe5a74ba854a5" name="counter_3" x="560" y="1568">
      <params>
         <int32 name="maximum" value="4"/>
      </params>
      <attribs/>
   </obj>
   <comment type="patch/comment" x="1064" y="1596" text="modulated delay"/>
   <comment type="patch/comment" x="910" y="1610" text="chorus level"/>
   <comment type="patch/comment" x="1064" y="1610" text="for chorus"/>
   <comment type="patch/comment" x="1372" y="1610" text="delay level"/>
   <comment type="patch/comment" x="1470" y="1610" text="synced delay"/>
   <comment type="patch/comment" x="1778" y="1610" text="verb level"/>
   <comment type="patch/comment" x="1876" y="1610" text="verb highpass"/>
   <comment type="patch/comment" x="2058" y="1610" text="verb"/>
   <obj type="audio/in left" uuid="d40e60b7641fe75af4d7c91b45bb038aacafc52e" name="in_2" x="812" y="1624">
      <params/>
      <attribs/>
   </obj>
   <obj type="gain/vca" uuid="a9f2dcd18043e2f47364e45cb8814f63c2a37c0d" name="vca_3" x="910" y="1624">
      <params/>
      <attribs/>
   </obj>
   <obj type="math/*" uuid="922423f2db9f222aa3e5ba095778288c446da47a" name="*_1" x="994" y="1624">
      <params/>
      <attribs/>
   </obj>
   <patcher type="patch/patcher" uuid="bdfb06e5-2965-4979-b634-19921b294984" name="obj_2" x="1064" y="1624">
      <params/>
      <attribs/>
      <subpatch appVersion="1.0.12">
         <obj type="patch/inlet a" uuid="b577fe41e0a6bc7b5502ce33cb8a3129e2e28ee5" name="audio-in" x="84" y="14">
            <params/>
            <attribs/>
         </obj>
         <obj type="patch/inlet f" uuid="5c585d2dcd9c05631e345ac09626a22a639d7c13" name="time" x="84" y="154">
            <params/>
            <attribs/>
         </obj>
         <obj type="patch/inlet f" uuid="5c585d2dcd9c05631e345ac09626a22a639d7c13" name="feedback" x="84" y="238">
            <params/>
            <attribs/>
         </obj>
         <obj type="patch/inlet f" uuid="5c585d2dcd9c05631e345ac09626a22a639d7c13" name="tm" x="98" y="280">
            <params/>
            <attribs/>
         </obj>
         <obj type="kfilter/lowpass" uuid="4f0d68b39b6f6b1c1d371b028d84391d14062d68" name="lowpass_2" x="686" y="336">
            <params>
               <frac32.s.map name="freq" value="44.0"/>
            </params>
            <attribs/>
         </obj>
         <obj type="patch/inlet f" uuid="5c585d2dcd9c05631e345ac09626a22a639d7c13" name="hpcut" x="224" y="378">
            <params/>
            <attribs/>
         </obj>
         <obj type="conv/unipolar2bipolar" uuid="efc8ee28c508740c5edf7995eaaa07a6d6818e5e" name="unipolar2bipolar_1" x="322" y="378">
            <params/>
            <attribs/>
         </obj>
         <obj type="conv/interp" uuid="d68c1a8709d8b55e3de8715d727ec0a2d8569d9a" name="interp_3" x="812" y="378">
            <params/>
            <attribs/>
         </obj>
         <obj type="kfilter/lowpass" uuid="4f0d68b39b6f6b1c1d371b028d84391d14062d68" name="lowpass_1" x="700" y="434">
            <params>
               <frac32.s.map name="freq" value="26.0"/>
            </params>
            <attribs/>
         </obj>
         <obj type="conv/interp" uuid="d68c1a8709d8b55e3de8715d727ec0a2d8569d9a" name="interp_2" x="812" y="434">
            <params/>
            <attribs/>
         </obj>
         <patchobj type="patch/object" uuid="109043ad-898d-4a87-b513-d2b4b77811b7" name="read_interp_sync_1" x="910" y="434">
            <params>
               <int32 name="clockmul" value="4"/>
               <int32 name="clockdiv" value="1"/>
               <frac32.u.map name="time" value="0.0"/>
            </params>
            <attribs>
               <objref attributeName="delayname" obj="sound"/>
               <combo attributeName="clocksource" selection="Internal"/>
               <combo attributeName="device" selection="omni"/>
               <combo attributeName="smooth" selection="5"/>
            </attribs>
            <object id="patch/object" uuid="109043ad-898d-4a87-b513-d2b4b77811b7">
               <sDescription>Syncable delay read, interpolated, proportional time modulation</sDescription>
               <author>Are Leistad</author>
               <license>BSD</license>
               <inlets>
                  <frac32buffer name="time" description="Delay time bias"/>
                  <frac32buffer name="tmod" description="Delay time modulation"/>
                  <int32 name="clkoverride" description="Override clocksource attribute, 0,1,2,3,4 = attr,int,ext,midi,midi-omni"/>
                  <int32 name="muloverride" description="Override clockmul parameter, values above 0 overrides clockmul"/>
                  <int32 name="divoverride" description="Override clockdiv parameter, values above 0 overrides clockdiv"/>
                  <bool32.rising name="24ppq" description="Clock input"/>
                  <int32 name="div"/>
               </inlets>
               <outlets>
                  <frac32buffer name="out" description="Delay output"/>
                  <frac32 name="time" description="Delay time, fraction of the referenced delay writer&apos;s time"/>
               </outlets>
               <displays/>
               <params>
                  <int32 name="clockmul" noLabel="false">
                     <MinValue i="1"/>
                     <MaxValue i="128"/>
                  </int32>
                  <int32 name="clockdiv" noLabel="false">
                     <MinValue i="1"/>
                     <MaxValue i="128"/>
                  </int32>
                  <frac32.u.map name="time" description="Internal delay time"/>
               </params>
               <attribs>
                  <objref name="delayname"/>
                  <combo name="clocksource">
                     <MenuEntries>
                        <string>Internal</string>
                        <string>External</string>
                        <string>MIDI</string>
                     </MenuEntries>
                     <CEntries>
                        <string>0</string>
                        <string>1</string>
                        <string>2</string>
                     </CEntries>
                  </combo>
                  <combo name="device">
                     <MenuEntries>
                        <string>omni</string>
                        <string>din</string>
                        <string>usb host port 1</string>
                        <string>usb host port 2</string>
                        <string>usb host port 3</string>
                        <string>usb host port 4</string>
                        <string>internal port 1</string>
                        <string>internal port 2</string>
                        <string>usb device port 1</string>
                     </MenuEntries>
                     <CEntries>
                        <string>MIDI_DEVICE_OMNI, 0</string>
                        <string>MIDI_DEVICE_DIN, 1</string>
                        <string>MIDI_DEVICE_USB_HOST, 1</string>
                        <string>MIDI_DEVICE_USB_HOST, 2</string>
                        <string>MIDI_DEVICE_USB_HOST, 3</string>
                        <string>MIDI_DEVICE_USB_HOST, 4</string>
                        <string>MIDI_DEVICE_INTERNAL, 1</string>
                        <string>MIDI_DEVICE_INTERNAL, 2</string>
                        <string>MIDI_DEVICE_USB_DEVICE, 1</string>
                     </CEntries>
                  </combo>
                  <combo name="smooth">
                     <MenuEntries>
                        <string>5</string>
                        <string>4</string>
                        <string>3</string>
                        <string>2</string>
                        <string>1</string>
                        <string>0</string>
                     </MenuEntries>
                     <CEntries>
                        <string>5</string>
                        <string>4</string>
                        <string>3</string>
                        <string>2</string>
                        <string>1</string>
                        <string>0</string>
                     </CEntries>
                  </combo>
               </attribs>
               <includes/>
               <code.declaration><![CDATA[//#define DEBUGF LogTextMessage
      #define DEBUGF(...) {}

      enum
      {
        CLOCK_SOURCE_internal = 0,
        CLOCK_SOURCE_external = 1,
        CLOCK_SOURCE_midi     = 2,
        CLOCK_SOURCE_midi_omni= 3
      } CLOCK_SOURCE;

      int32_t   start_sequence;
      int32_t   clock_source;
      int32_t   clock_multiplier;
      int32_t   clock_divider;
      uint32_t  sync_count;       // At least N clocks before deriving synced time
      uint32_t  sync_time;        // Synced time expressed in fractional delay length
      uint32_t  ktimer;           // 3kHz timer
      uint32_t  last_ktime;
      float     delay_length_cpl; // cache result of  1.0 / lenght of delay line
      uint32_t  old_24ppq;

      __attribute__ ( ( always_inline ) ) __STATIC_INLINE float Q27ToF(int32_t op1)
      {
        float fop1 = *(float*)(&op1);
        __ASM volatile ("VCVT.F32.S32 %0, %0, 27" : "+w" (fop1) );
        return(fop1);
      }

      __attribute__ ( ( always_inline ) ) __STATIC_INLINE int32_t FToQ27(float fop1)
      {
        __ASM volatile ("VCVT.S32.F32 %0, %0, 27" : "+w" (fop1) );
        int32_t r = *(int32_t*)(&fop1);
        return(r);
      }

      __attribute__ ( ( always_inline ) ) __STATIC_INLINE int midi_device_test( midi_device_t dev, uint8_t port, int selected_dev, uint8_t selected_port )
      {
        if(    (selected_dev == MIDI_DEVICE_OMNI)
            || (selected_dev == dev && selected_port == port)
            )
          return 1;
        return 0;
      }

#if attr_smooth>0
      #define FIFO_EXP attr_smooth
      #define FIFO_LEN (1<<FIFO_EXP)
      #define FIFO_MASK (FIFO_LEN-1)
      typedef struct _AveragerContext
      {
        int32_t fifo[FIFO_LEN];
        int32_t fifo_i;
        int32_t acc;
      } AveragerContext;
      AveragerContext avg;
      __attribute__ ( ( always_inline ) ) __STATIC_INLINE int32_t moving_average( AveragerContext *avg, int32_t new_value )
      {
        avg->fifo_i             = (avg->fifo_i + 1) & FIFO_MASK;
        avg->acc               -= avg->fifo[avg->fifo_i];
        avg->acc               += new_value;
        avg->fifo[avg->fifo_i]  = new_value;
        return avg->acc >> FIFO_EXP;
      }
#endif

      void on_clock( void )
      {
        float   period;
        int32_t kperiod;
#if attr_smooth>0
        kperiod = moving_average( &avg, ktimer - last_ktime );
#else
        kperiod = ktimer - last_ktime;
#endif
        last_ktime = ktimer;
        period = kperiod * 16 * clock_divider;
        period = period / clock_multiplier;

        if( period < 1.0f )
          {
            period = 1.0f;
          }

        if( sync_count < 1 )
          {
            sync_count++;
          }
        else
          {
            sync_time = FToQ27( period * delay_length_cpl );
          }
      }]]></code.declaration>
               <code.init><![CDATA[#if attr_smooth>0
      for( avg.fifo_i = 0; avg.fifo_i < FIFO_LEN; avg.fifo_i++ )
        {
          avg.fifo[avg.fifo_i] = 0;
        }
      avg.fifo_i       = 0;
      avg.acc          = 0;
#endif
      start_sequence   = 0;
      clock_source     = CLOCK_SOURCE_internal;
      clock_multiplier = 1;
      clock_divider    = 12;
      sync_count       = 0;
      sync_time        = 0;
      ktimer           = 0;
      last_ktime       = 0;
      delay_length_cpl = 1.0f/attr_delayname.LENGTH;
      old_24ppq        = 0;]]></code.init>
               <code.krate><![CDATA[// Use preset time until synced
      if( start_sequence == 0 && clock_source != CLOCK_SOURCE_internal )
        {
          sync_time = param_time;
          start_sequence++;
        }

#ifdef USE_SYNC_HOLDOFF
      // If too long between clocks (likely absence of clock), require two successive clocks to resync.
      // Use max delay time as the minimum clock interval (using 5 seconds for now)?
      if( ktimer - last_ktime > (5*3000) )
        {
          sync_count = 0;
        }
#endif

      // Live overrides for the clock source and clock divider parameters.
      // Allow clock selection without restarting the patch is good :)
      // (The int32 spinbox is not CC assignable...(bug?))
      if( inlet_clkoverride > 0 )
        {
          clock_source = inlet_clkoverride - 1;
          if( clock_source > CLOCK_SOURCE_midi_omni )
            {
              clock_source = CLOCK_SOURCE_midi_omni;
            }
          else if( clock_source < CLOCK_SOURCE_internal )
            {
              clock_source = CLOCK_SOURCE_internal;
            }
        }
      else
        {
          clock_source = attr_clocksource;
        }

      if( inlet_divoverride > 0 )
        {
          clock_divider = inlet_divoverride;
          if( clock_divider < 1 )
            {
              clock_divider = 1;
            }
        }
      else
        {
          clock_divider = inlet_div;
        }

      if( inlet_muloverride > 0 )
        {
          clock_multiplier = inlet_muloverride;
          if( clock_multiplier < 1 )
            {
              clock_multiplier = 1;
            }
        }
      else
        {
          clock_multiplier = param_clockmul;
        }

      if( clock_source == CLOCK_SOURCE_external && inlet_24ppq && !old_24ppq  )
        {
          on_clock();
        }

      old_24ppq = inlet_24ppq;
      ktimer++;]]></code.krate>
               <code.srate><![CDATA[uint32_t tmp_time;
      int32_t  time_mod;
      uint32_t tmp_d;
      uint32_t tmp_d_limited;
      uint32_t tmp_di;
      uint32_t tmp_w1;
      uint32_t tmp_w2;
      int32_t  tmp_a1;
      int32_t  tmp_a2;
      int32_t  tmp_r;

      if( clock_source != CLOCK_SOURCE_internal )
        {
          tmp_time = sync_time;
        }
      else
        {
          tmp_time = param_time;
        }

      time_mod    = ___SMMUL( (tmp_time + inlet_time)<<3, inlet_tmod<<2 );
      tmp_d       = __USAT(tmp_time + inlet_time + time_mod,27);
      outlet_time = tmp_d;

      // Must limit the length!
      tmp_d_limited = tmp_d>>(27-attr_delayname.LENGTHPOW);
      if( tmp_d_limited > attr_delayname.LENGTHMASK - BUFSIZE )
        {
          tmp_d_limited = attr_delayname.LENGTHMASK - BUFSIZE;
          tmp_d = 0;
        }
      tmp_di = attr_delayname.writepos - tmp_d_limited - BUFSIZE + buffer_index -1;
      tmp_w1 = (tmp_d<<(attr_delayname.LENGTHPOW+3)) & 0x3FFFFFFF;
      tmp_w2 = (1<<30) - tmp_w1;
      tmp_a1 = attr_delayname.array[tmp_di&attr_delayname.LENGTHMASK]<<16;
      tmp_a2 = attr_delayname.array[(tmp_di+1)&attr_delayname.LENGTHMASK]<<16;
      tmp_r  = ___SMMUL(tmp_a1,tmp_w1);
      tmp_r  = ___SMMLA(tmp_a2,tmp_w2,tmp_r);

      outlet_out = tmp_r;]]></code.srate>
               <code.midihandler><![CDATA[if(    clock_source == CLOCK_SOURCE_midi_omni
         || (clock_source == CLOCK_SOURCE_midi && midi_device_test( dev, port, attr_device ) == 1)
        )
        {
          if( status == MIDI_TIMING_CLOCK )
            {
              on_clock();
            }
        }]]></code.midihandler>
            </object>
         </patchobj>
         <obj type="math/*" uuid="c16a625a661f40e4b359db604dcd00b3befcdbe3" name="*_2" x="1078" y="434">
            <params/>
            <attribs/>
         </obj>
         <obj type="math/+" uuid="faedbea4612d9bd3644d6d3bf31946d848a70e19" name="+_1" x="1148" y="434">
            <params/>
            <attribs/>
         </obj>
         <obj type="delay/write sdram" uuid="5ae03f8d7b815edcfc40585d8bbac2ed48460fba" name="sound" x="1232" y="434">
            <params/>
            <attribs>
               <combo attributeName="size" selection="8192 (170ms)"/>
            </attribs>
         </obj>
         <obj type="filter/hp m" uuid="fdba806c3cfd2b7aca3256c733379a06e5811e66" name="hp_1" x="1372" y="434">
            <params>
               <frac32.s.map name="pitch" value="0.0"/>
               <frac32.u.map name="reso" value="0.0"/>
            </params>
            <attribs/>
         </obj>
         <obj type="patch/outlet a" uuid="abd8c5fd3b0524a6630f65cad6dc27f6c58e2a3e" name="outlet_1" x="1484" y="434">
            <params/>
            <attribs/>
         </obj>
         <nets>
            <net>
               <source obj="read_interp_sync_1" outlet="out"/>
               <dest obj="*_2" inlet="a"/>
               <dest obj="hp_1" inlet="in"/>
            </net>
            <net>
               <source obj="interp_2" outlet="o"/>
               <dest obj="read_interp_sync_1" inlet="time"/>
            </net>
            <net>
               <source obj="lowpass_1" outlet="out"/>
               <dest obj="interp_2" inlet="i"/>
            </net>
            <net>
               <source obj="*_2" outlet="result"/>
               <dest obj="+_1" inlet="in2"/>
            </net>
            <net>
               <source obj="audio-in" outlet="inlet"/>
               <dest obj="+_1" inlet="in1"/>
            </net>
            <net>
               <source obj="feedback" outlet="inlet"/>
               <dest obj="*_2" inlet="b"/>
            </net>
            <net>
               <source obj="interp_3" outlet="o"/>
               <dest obj="read_interp_sync_1" inlet="tmod"/>
            </net>
            <net>
               <source obj="lowpass_2" outlet="out"/>
               <dest obj="interp_3" inlet="i"/>
            </net>
            <net>
               <source obj="tm" outlet="inlet"/>
               <dest obj="lowpass_2" inlet="in"/>
            </net>
            <net>
               <source obj="unipolar2bipolar_1" outlet="o"/>
               <dest obj="hp_1" inlet="pitch"/>
            </net>
            <net>
               <source obj="hpcut" outlet="inlet"/>
               <dest obj="unipolar2bipolar_1" inlet="i"/>
            </net>
            <net>
               <source obj="+_1" outlet="out"/>
               <dest obj="sound" inlet="in"/>
            </net>
            <net>
               <source obj="hp_1" outlet="out"/>
               <dest obj="outlet_1" inlet="outlet"/>
            </net>
            <net>
               <source obj="time" outlet="inlet"/>
               <dest obj="lowpass_1" inlet="in"/>
            </net>
         </nets>
         <settings>
            <subpatchmode>no</subpatchmode>
            <MidiChannel>1</MidiChannel>
            <NPresets>0</NPresets>
            <NPresetEntries>0</NPresetEntries>
            <NModulationSources>0</NModulationSources>
            <NModulationTargetsPerSource>0</NModulationTargetsPerSource>
         </settings>
         <notes><![CDATA[]]></notes>
         <windowPos>
            <x>-8</x>
            <y>-8</y>
            <width>1616</width>
            <height>876</height>
         </windowPos>
      </subpatch>
   </patcher>
   <obj type="math/gain" uuid="62b1c1a6337c7c8f6aec96408a432477b113cfa0" name="gain_2" x="1176" y="1624">
      <params>
         <frac32.u.map name="amp" value="4.0"/>
      </params>
      <attribs/>
   </obj>
   <obj type="math/+" uuid="faedbea4612d9bd3644d6d3bf31946d848a70e19" name="+_1" x="1302" y="1624">
      <params/>
      <attribs/>
   </obj>
   <obj type="gain/vca" uuid="a9f2dcd18043e2f47364e45cb8814f63c2a37c0d" name="vca_2" x="1372" y="1624">
      <params/>
      <attribs/>
   </obj>
   <patcher type="patch/patcher" uuid="283df883-2966-46f0-8172-c3aed60d6b46" name="obj_1" x="1470" y="1624">
      <params/>
      <attribs/>
      <subpatch appVersion="1.0.12">
         <obj type="patch/inlet a" uuid="b577fe41e0a6bc7b5502ce33cb8a3129e2e28ee5" name="audio-in" x="84" y="14">
            <params/>
            <attribs/>
         </obj>
         <obj type="patch/inlet b" uuid="3b0d3eacb5bb978cb05d1372aa2714d5a4790844" name="24ppq" x="84" y="56">
            <params/>
            <attribs/>
         </obj>
         <obj type="patch/inlet f" uuid="5c585d2dcd9c05631e345ac09626a22a639d7c13" name="div" x="84" y="98">
            <params/>
            <attribs/>
         </obj>
         <patchobj type="patch/object" uuid="f349747a-cc23-4a11-896b-91f836d4f385" name="scale_1" x="406" y="140">
            <params>
               <frac32.u.map name="a" value="0.0"/>
               <frac32.u.map name="b" value="11.0"/>
            </params>
            <attribs/>
            <object id="patch/object" uuid="f349747a-cc23-4a11-896b-91f836d4f385">
               <sDescription>Maps 0..64 to a..b</sDescription>
               <author>Johannes Elliesen</author>
               <license>BSD</license>
               <inlets>
                  <frac32.positive name="c" description="control"/>
               </inlets>
               <outlets>
                  <frac32 name="o" description="output"/>
               </outlets>
               <displays/>
               <params>
                  <frac32.u.map name="a"/>
                  <frac32.u.map name="b"/>
               </params>
               <attribs/>
               <includes/>
               <code.krate><![CDATA[{
      int64_t a = (int64_t)param_b * inlet_c;
      a += (int64_t)param_a * ((128<<20)-inlet_c);
      outlet_o= a>>27;
   }]]></code.krate>
            </object>
         </patchobj>
         <patchobj type="patch/object" uuid="48f0d302-e63c-4e8e-8db4-51a74e6ceef6" name="mux_2" x="490" y="168">
            <params/>
            <attribs/>
            <object id="patch/object" uuid="48f0d302-e63c-4e8e-8db4-51a74e6ceef6">
               <sDescription>input multiplexer. Output is i1 when s &lt; 1, i[i] when....</sDescription>
               <author>Johannes Taelman</author>
               <license>BSD</license>
               <helpPatch>mux.axh</helpPatch>
               <inlets>
                  <int32.positive name="s" description="select"/>
               </inlets>
               <outlets>
                  <int32 name="o" description="output"/>
               </outlets>
               <displays/>
               <params/>
               <attribs/>
               <includes/>
               <code.krate><![CDATA[switch(inlet_s>0?inlet_s:0){
      case 0: outlet_o= 0;break;
      case 1: outlet_o= 1;break;
      case 2: outlet_o= 4;break;
      case 3: outlet_o= 6;break;
      case 4: outlet_o= 8;break;
      case 5: outlet_o= 12;break;
      case 6: outlet_o= 16;break;
      case 7: outlet_o= 24;break;
      case 8: outlet_o= 32;break;
      case 9: outlet_o= 48;break;
      case 10: outlet_o= 64;break;
      default: outlet_o= 16;break;
}]]></code.krate>
            </object>
         </patchobj>
         <obj type="patch/inlet f" uuid="5c585d2dcd9c05631e345ac09626a22a639d7c13" name="feedback" x="84" y="238">
            <params/>
            <attribs/>
         </obj>
         <obj type="patch/inlet f" uuid="5c585d2dcd9c05631e345ac09626a22a639d7c13" name="tm" x="98" y="280">
            <params/>
            <attribs/>
         </obj>
         <obj type="kfilter/lowpass" uuid="4f0d68b39b6f6b1c1d371b028d84391d14062d68" name="lowpass_2" x="686" y="336">
            <params>
               <frac32.s.map name="freq" value="56.0"/>
            </params>
            <attribs/>
         </obj>
         <obj type="patch/inlet f" uuid="5c585d2dcd9c05631e345ac09626a22a639d7c13" name="fcut" x="1148" y="364">
            <params/>
            <attribs/>
         </obj>
         <obj type="conv/interp" uuid="d68c1a8709d8b55e3de8715d727ec0a2d8569d9a" name="interp_3" x="812" y="378">
            <params/>
            <attribs/>
         </obj>
         <obj type="patch/inlet f" uuid="5c585d2dcd9c05631e345ac09626a22a639d7c13" name="hp" x="1330" y="378">
            <params/>
            <attribs/>
         </obj>
         <patchobj type="patch/object" uuid="109043ad-898d-4a87-b513-d2b4b77811b7" name="read_interp_sync_1" x="896" y="434">
            <params>
               <int32 name="clockmul" value="4"/>
               <int32 name="clockdiv" value="1"/>
               <frac32.u.map name="time" value="0.0"/>
            </params>
            <attribs>
               <objref attributeName="delayname" obj="sound"/>
               <combo attributeName="clocksource" selection="External"/>
               <combo attributeName="device" selection="omni"/>
               <combo attributeName="smooth" selection="5"/>
            </attribs>
            <object id="patch/object" uuid="109043ad-898d-4a87-b513-d2b4b77811b7">
               <sDescription>Syncable delay read, interpolated, proportional time modulation</sDescription>
               <author>Are Leistad</author>
               <license>BSD</license>
               <inlets>
                  <frac32buffer name="time" description="Delay time bias"/>
                  <frac32buffer name="tmod" description="Delay time modulation"/>
                  <int32 name="clkoverride" description="Override clocksource attribute, 0,1,2,3,4 = attr,int,ext,midi,midi-omni"/>
                  <int32 name="muloverride" description="Override clockmul parameter, values above 0 overrides clockmul"/>
                  <int32 name="divoverride" description="Override clockdiv parameter, values above 0 overrides clockdiv"/>
                  <bool32.rising name="24ppq" description="Clock input"/>
                  <int32 name="div"/>
               </inlets>
               <outlets>
                  <frac32buffer name="out" description="Delay output"/>
                  <frac32 name="time" description="Delay time, fraction of the referenced delay writer&apos;s time"/>
               </outlets>
               <displays/>
               <params>
                  <int32 name="clockmul" noLabel="false">
                     <MinValue i="1"/>
                     <MaxValue i="128"/>
                  </int32>
                  <int32 name="clockdiv" noLabel="false">
                     <MinValue i="1"/>
                     <MaxValue i="128"/>
                  </int32>
                  <frac32.u.map name="time" description="Internal delay time"/>
               </params>
               <attribs>
                  <objref name="delayname"/>
                  <combo name="clocksource">
                     <MenuEntries>
                        <string>Internal</string>
                        <string>External</string>
                        <string>MIDI</string>
                     </MenuEntries>
                     <CEntries>
                        <string>0</string>
                        <string>1</string>
                        <string>2</string>
                     </CEntries>
                  </combo>
                  <combo name="device">
                     <MenuEntries>
                        <string>omni</string>
                        <string>din</string>
                        <string>usb host port 1</string>
                        <string>usb host port 2</string>
                        <string>usb host port 3</string>
                        <string>usb host port 4</string>
                        <string>internal port 1</string>
                        <string>internal port 2</string>
                        <string>usb device port 1</string>
                     </MenuEntries>
                     <CEntries>
                        <string>MIDI_DEVICE_OMNI, 0</string>
                        <string>MIDI_DEVICE_DIN, 1</string>
                        <string>MIDI_DEVICE_USB_HOST, 1</string>
                        <string>MIDI_DEVICE_USB_HOST, 2</string>
                        <string>MIDI_DEVICE_USB_HOST, 3</string>
                        <string>MIDI_DEVICE_USB_HOST, 4</string>
                        <string>MIDI_DEVICE_INTERNAL, 1</string>
                        <string>MIDI_DEVICE_INTERNAL, 2</string>
                        <string>MIDI_DEVICE_USB_DEVICE, 1</string>
                     </CEntries>
                  </combo>
                  <combo name="smooth">
                     <MenuEntries>
                        <string>5</string>
                        <string>4</string>
                        <string>3</string>
                        <string>2</string>
                        <string>1</string>
                        <string>0</string>
                     </MenuEntries>
                     <CEntries>
                        <string>5</string>
                        <string>4</string>
                        <string>3</string>
                        <string>2</string>
                        <string>1</string>
                        <string>0</string>
                     </CEntries>
                  </combo>
               </attribs>
               <includes/>
               <code.declaration><![CDATA[//#define DEBUGF LogTextMessage
      #define DEBUGF(...) {}

      enum
      {
        CLOCK_SOURCE_internal = 0,
        CLOCK_SOURCE_external = 1,
        CLOCK_SOURCE_midi     = 2,
        CLOCK_SOURCE_midi_omni= 3
      } CLOCK_SOURCE;

      int32_t   start_sequence;
      int32_t   clock_source;
      int32_t   clock_multiplier;
      int32_t   clock_divider;
      uint32_t  sync_count;       // At least N clocks before deriving synced time
      uint32_t  sync_time;        // Synced time expressed in fractional delay length
      uint32_t  ktimer;           // 3kHz timer
      uint32_t  last_ktime;
      float     delay_length_cpl; // cache result of  1.0 / lenght of delay line
      uint32_t  old_24ppq;

      __attribute__ ( ( always_inline ) ) __STATIC_INLINE float Q27ToF(int32_t op1)
      {
        float fop1 = *(float*)(&op1);
        __ASM volatile ("VCVT.F32.S32 %0, %0, 27" : "+w" (fop1) );
        return(fop1);
      }

      __attribute__ ( ( always_inline ) ) __STATIC_INLINE int32_t FToQ27(float fop1)
      {
        __ASM volatile ("VCVT.S32.F32 %0, %0, 27" : "+w" (fop1) );
        int32_t r = *(int32_t*)(&fop1);
        return(r);
      }

      __attribute__ ( ( always_inline ) ) __STATIC_INLINE int midi_device_test( midi_device_t dev, uint8_t port, int selected_dev, uint8_t selected_port )
      {
        if(    (selected_dev == MIDI_DEVICE_OMNI)
            || (selected_dev == dev && selected_port == port)
            )
          return 1;
        return 0;
      }

#if attr_smooth>0
      #define FIFO_EXP attr_smooth
      #define FIFO_LEN (1<<FIFO_EXP)
      #define FIFO_MASK (FIFO_LEN-1)
      typedef struct _AveragerContext
      {
        int32_t fifo[FIFO_LEN];
        int32_t fifo_i;
        int32_t acc;
      } AveragerContext;
      AveragerContext avg;
      __attribute__ ( ( always_inline ) ) __STATIC_INLINE int32_t moving_average( AveragerContext *avg, int32_t new_value )
      {
        avg->fifo_i             = (avg->fifo_i + 1) & FIFO_MASK;
        avg->acc               -= avg->fifo[avg->fifo_i];
        avg->acc               += new_value;
        avg->fifo[avg->fifo_i]  = new_value;
        return avg->acc >> FIFO_EXP;
      }
#endif

      void on_clock( void )
      {
        float   period;
        int32_t kperiod;
#if attr_smooth>0
        kperiod = moving_average( &avg, ktimer - last_ktime );
#else
        kperiod = ktimer - last_ktime;
#endif
        last_ktime = ktimer;
        period = kperiod * 16 * clock_divider;
        period = period / clock_multiplier;

        if( period < 1.0f )
          {
            period = 1.0f;
          }

        if( sync_count < 1 )
          {
            sync_count++;
          }
        else
          {
            sync_time = FToQ27( period * delay_length_cpl );
          }
      }]]></code.declaration>
               <code.init><![CDATA[#if attr_smooth>0
      for( avg.fifo_i = 0; avg.fifo_i < FIFO_LEN; avg.fifo_i++ )
        {
          avg.fifo[avg.fifo_i] = 0;
        }
      avg.fifo_i       = 0;
      avg.acc          = 0;
#endif
      start_sequence   = 0;
      clock_source     = CLOCK_SOURCE_internal;
      clock_multiplier = 1;
      clock_divider    = 12;
      sync_count       = 0;
      sync_time        = 0;
      ktimer           = 0;
      last_ktime       = 0;
      delay_length_cpl = 1.0f/attr_delayname.LENGTH;
      old_24ppq        = 0;]]></code.init>
               <code.krate><![CDATA[// Use preset time until synced
      if( start_sequence == 0 && clock_source != CLOCK_SOURCE_internal )
        {
          sync_time = param_time;
          start_sequence++;
        }

#ifdef USE_SYNC_HOLDOFF
      // If too long between clocks (likely absence of clock), require two successive clocks to resync.
      // Use max delay time as the minimum clock interval (using 5 seconds for now)?
      if( ktimer - last_ktime > (5*3000) )
        {
          sync_count = 0;
        }
#endif

      // Live overrides for the clock source and clock divider parameters.
      // Allow clock selection without restarting the patch is good :)
      // (The int32 spinbox is not CC assignable...(bug?))
      if( inlet_clkoverride > 0 )
        {
          clock_source = inlet_clkoverride - 1;
          if( clock_source > CLOCK_SOURCE_midi_omni )
            {
              clock_source = CLOCK_SOURCE_midi_omni;
            }
          else if( clock_source < CLOCK_SOURCE_internal )
            {
              clock_source = CLOCK_SOURCE_internal;
            }
        }
      else
        {
          clock_source = attr_clocksource;
        }

      if( inlet_divoverride > 0 )
        {
          clock_divider = inlet_divoverride;
          if( clock_divider < 1 )
            {
              clock_divider = 1;
            }
        }
      else
        {
          clock_divider = inlet_div;
        }

      if( inlet_muloverride > 0 )
        {
          clock_multiplier = inlet_muloverride;
          if( clock_multiplier < 1 )
            {
              clock_multiplier = 1;
            }
        }
      else
        {
          clock_multiplier = param_clockmul;
        }

      if( clock_source == CLOCK_SOURCE_external && inlet_24ppq && !old_24ppq  )
        {
          on_clock();
        }

      old_24ppq = inlet_24ppq;
      ktimer++;]]></code.krate>
               <code.srate><![CDATA[uint32_t tmp_time;
      int32_t  time_mod;
      uint32_t tmp_d;
      uint32_t tmp_d_limited;
      uint32_t tmp_di;
      uint32_t tmp_w1;
      uint32_t tmp_w2;
      int32_t  tmp_a1;
      int32_t  tmp_a2;
      int32_t  tmp_r;

      if( clock_source != CLOCK_SOURCE_internal )
        {
          tmp_time = sync_time;
        }
      else
        {
          tmp_time = param_time;
        }

      time_mod    = ___SMMUL( (tmp_time + inlet_time)<<3, inlet_tmod<<2 );
      tmp_d       = __USAT(tmp_time + inlet_time + time_mod,27);
      outlet_time = tmp_d;

      // Must limit the length!
      tmp_d_limited = tmp_d>>(27-attr_delayname.LENGTHPOW);
      if( tmp_d_limited > attr_delayname.LENGTHMASK - BUFSIZE )
        {
          tmp_d_limited = attr_delayname.LENGTHMASK - BUFSIZE;
          tmp_d = 0;
        }
      tmp_di = attr_delayname.writepos - tmp_d_limited - BUFSIZE + buffer_index -1;
      tmp_w1 = (tmp_d<<(attr_delayname.LENGTHPOW+3)) & 0x3FFFFFFF;
      tmp_w2 = (1<<30) - tmp_w1;
      tmp_a1 = attr_delayname.array[tmp_di&attr_delayname.LENGTHMASK]<<16;
      tmp_a2 = attr_delayname.array[(tmp_di+1)&attr_delayname.LENGTHMASK]<<16;
      tmp_r  = ___SMMUL(tmp_a1,tmp_w1);
      tmp_r  = ___SMMLA(tmp_a2,tmp_w2,tmp_r);

      outlet_out = tmp_r;]]></code.srate>
               <code.midihandler><![CDATA[if(    clock_source == CLOCK_SOURCE_midi_omni
         || (clock_source == CLOCK_SOURCE_midi && midi_device_test( dev, port, attr_device ) == 1)
        )
        {
          if( status == MIDI_TIMING_CLOCK )
            {
              on_clock();
            }
        }]]></code.midihandler>
            </object>
         </patchobj>
         <obj type="math/*" uuid="c16a625a661f40e4b359db604dcd00b3befcdbe3" name="*_2" x="1064" y="434">
            <params/>
            <attribs/>
         </obj>
         <obj type="math/+" uuid="faedbea4612d9bd3644d6d3bf31946d848a70e19" name="+_1" x="1134" y="434">
            <params/>
            <attribs/>
         </obj>
         <patchobj type="patch/object" uuid="bbef262e-c1da-4318-9f2e-7412828c0b07" name="lp_1" x="1218" y="434">
            <params/>
            <attribs/>
            <object id="patch/object" uuid="bbef262e-c1da-4318-9f2e-7412828c0b07">
               <sDescription>2-pole resonant low-pass filter (biquad)</sDescription>
               <author>Johannes Taelman</author>
               <license>BSD</license>
               <helpPatch>filter.axh</helpPatch>
               <inlets>
                  <frac32buffer name="in" description="filter input"/>
                  <frac32 name="pitch" description="pitch"/>
                  <frac32 name="reso" description="filter resonance"/>
               </inlets>
               <outlets>
                  <frac32buffer name="out" description="filter output"/>
               </outlets>
               <displays/>
               <params/>
               <attribs/>
               <includes/>
               <code.declaration><![CDATA[biquad_state bs;biquad_coefficients bc;]]></code.declaration>
               <code.init><![CDATA[biquad_clearstate(&bs);]]></code.init>
               <code.krate><![CDATA[int32_t freq;
      MTOF(inlet_pitch,freq);
      biquad_lp_coefs(&bc,freq,INT_MAX - (__USAT(inlet_reso,27)<<4));
      biquad_dsp(&bs,&bc,inlet_in,outlet_out);]]></code.krate>
            </object>
         </patchobj>
         <obj type="delay/write sdram" uuid="5ae03f8d7b815edcfc40585d8bbac2ed48460fba" name="sound" x="1316" y="434">
            <params/>
            <attribs>
               <combo attributeName="size" selection="524288 (10.9s)"/>
            </attribs>
         </obj>
         <obj type="filter/hp m" uuid="fdba806c3cfd2b7aca3256c733379a06e5811e66" name="hp_2" x="1442" y="434">
            <params>
               <frac32.s.map name="pitch" value="0.0"/>
               <frac32.u.map name="reso" value="0.0"/>
            </params>
            <attribs/>
         </obj>
         <obj type="patch/outlet a" uuid="abd8c5fd3b0524a6630f65cad6dc27f6c58e2a3e" name="outlet_1" x="1568" y="434">
            <params/>
            <attribs/>
         </obj>
         <nets>
            <net>
               <source obj="+_1" outlet="out"/>
               <dest obj="lp_1" inlet="in"/>
            </net>
            <net>
               <source obj="read_interp_sync_1" outlet="out"/>
               <dest obj="*_2" inlet="a"/>
               <dest obj="hp_2" inlet="in"/>
            </net>
            <net>
               <source obj="*_2" outlet="result"/>
               <dest obj="+_1" inlet="in2"/>
            </net>
            <net>
               <source obj="audio-in" outlet="inlet"/>
               <dest obj="+_1" inlet="in1"/>
            </net>
            <net>
               <source obj="24ppq" outlet="inlet"/>
               <dest obj="read_interp_sync_1" inlet="24ppq"/>
            </net>
            <net>
               <source obj="scale_1" outlet="o"/>
               <dest obj="mux_2" inlet="s"/>
            </net>
            <net>
               <source obj="mux_2" outlet="o"/>
               <dest obj="read_interp_sync_1" inlet="div"/>
            </net>
            <net>
               <source obj="div" outlet="inlet"/>
               <dest obj="scale_1" inlet="c"/>
            </net>
            <net>
               <source obj="feedback" outlet="inlet"/>
               <dest obj="*_2" inlet="b"/>
            </net>
            <net>
               <source obj="interp_3" outlet="o"/>
               <dest obj="read_interp_sync_1" inlet="tmod"/>
            </net>
            <net>
               <source obj="lowpass_2" outlet="out"/>
               <dest obj="interp_3" inlet="i"/>
            </net>
            <net>
               <source obj="tm" outlet="inlet"/>
               <dest obj="lowpass_2" inlet="in"/>
            </net>
            <net>
               <source obj="lp_1" outlet="out"/>
               <dest obj="sound" inlet="in"/>
            </net>
            <net>
               <source obj="fcut" outlet="inlet"/>
               <dest obj="lp_1" inlet="pitch"/>
            </net>
            <net>
               <source obj="hp" outlet="inlet"/>
               <dest obj="hp_2" inlet="pitch"/>
            </net>
            <net>
               <source obj="hp_2" outlet="out"/>
               <dest obj="outlet_1" inlet="outlet"/>
            </net>
         </nets>
         <settings>
            <subpatchmode>no</subpatchmode>
            <MidiChannel>1</MidiChannel>
            <NPresets>0</NPresets>
            <NPresetEntries>0</NPresetEntries>
            <NModulationSources>0</NModulationSources>
            <NModulationTargetsPerSource>0</NModulationTargetsPerSource>
         </settings>
         <notes><![CDATA[]]></notes>
         <windowPos>
            <x>-8</x>
            <y>-8</y>
            <width>1616</width>
            <height>876</height>
         </windowPos>
      </subpatch>
   </patcher>
   <obj type="math/gain" uuid="62b1c1a6337c7c8f6aec96408a432477b113cfa0" name="gain_1" x="1582" y="1624">
      <params>
         <frac32.u.map name="amp" value="8.0"/>
      </params>
      <attribs/>
   </obj>
   <obj type="math/+" uuid="faedbea4612d9bd3644d6d3bf31946d848a70e19" name="+_2" x="1694" y="1624">
      <params/>
      <attribs/>
   </obj>
   <obj type="gain/vca" uuid="a9f2dcd18043e2f47364e45cb8814f63c2a37c0d" name="vca_1" x="1778" y="1624">
      <params/>
      <attribs/>
   </obj>
   <patchobj type="patch/object" uuid="aaabceff-5472-422b-9c7d-472a1c319a49" name="hp_1" x="1876" y="1624">
      <params>
         <frac32.s.map name="pitch" value="0.0"/>
         <frac32.u.map name="reso" value="0.0"/>
      </params>
      <attribs/>
      <object id="patch/object" uuid="aaabceff-5472-422b-9c7d-472a1c319a49">
         <sDescription>Highpass filter, state-variable type</sDescription>
         <author>Johannes Taelman</author>
         <license>BSD</license>
         <helpPatch>filter.axh</helpPatch>
         <inlets>
            <frac32buffer name="in" description="filter input"/>
            <frac32.bipolar name="pitch"/>
         </inlets>
         <outlets>
            <frac32buffer name="out" description="filter output"/>
         </outlets>
         <displays/>
         <params>
            <frac32.s.map.pitch name="pitch"/>
            <frac32.u.map.filterq name="reso"/>
         </params>
         <attribs/>
         <includes/>
         <code.declaration><![CDATA[int32_t low;
int32_t band;]]></code.declaration>
         <code.init><![CDATA[low = 0;
band = 0;]]></code.init>
         <code.krate><![CDATA[int32_t damp = (0x80<<24) - (param_reso<<4);
damp = ___SMMUL(damp,damp);
int32_t alpha;
int32_t freq;
MTOFEXTENDED(inlet_pitch,alpha);
SINE2TINTERP(alpha,freq);]]></code.krate>
         <code.srate><![CDATA[int32_t in1 = inlet_in;
int32_t notch = inlet_in - (___SMMUL(damp,band)<<1);
low = low + (___SMMUL(freq,band)<<1);
int32_t high  = notch - low;
band = (___SMMUL(freq,high)<<1) + band;// - drive*band*band*band;
int32_t out1 = high;
outlet_out = out1;]]></code.srate>
      </object>
   </patchobj>
   <obj type="fx/lmnts/reverb" uuid="8027561C-A0B5-4DF8-A10E-3ED1274F2980" name="reverb_2" x="2058" y="1624">
      <params>
         <frac32.u.map name="amount" value="64.0"/>
         <frac32.u.map name="time" value="0.0"/>
         <frac32.u.map name="diffusion" value="0.0"/>
         <frac32.u.map name="gain" value="33.0"/>
         <frac32.u.map name="lowpass" value="0.0"/>
      </params>
      <attribs/>
   </obj>
   <obj type="drj/math/sum3" uuid="93cb11244902274d118a237aed86ae7d7fd46107" name="sum3_1" x="2170" y="1624">
      <params/>
      <attribs/>
   </obj>
   <obj type="audio/out left" uuid="b11a3c09b2fdd575ea8212f2ce7743d5269253b1" name="out_2" x="2268" y="1624">
      <params/>
      <attribs/>
   </obj>
   <obj type="const/i" uuid="e202f44b2df17ae0b3e663b98ea6b14c8ff00408" name="i_7" x="364" y="1638">
      <params/>
      <attribs>
         <spinner attributeName="value" value="0"/>
      </attribs>
   </obj>
   <obj type="math/==" uuid="deaf0d36642c57876c4101e86f8a0b6a06021ab2" name="==_2" x="476" y="1638">
      <params/>
      <attribs/>
   </obj>
   <obj type="logic/or 2" uuid="3805d3c84d30032a44fbdbe42d9a2988a1790a3e" name="or_1" x="574" y="1638">
      <params/>
      <attribs/>
   </obj>
   <obj type="timer/pulselength" uuid="ca68725237d8ba8407773340801660a9fd9b0dba" name="pulselength_1" x="658" y="1638">
      <params>
         <frac32.s.map name="delay" value="-11.0"/>
      </params>
      <attribs/>
   </obj>
   <obj type="rbrt/patching/loadbang" uuid="45d1f29d-ac62-4e5b-86f8-2201d2f6c689" name="loadbang_1" x="28" y="1680">
      <params/>
      <attribs/>
   </obj>
   <obj type="timer/delayedpulse" uuid="3f05ee534ca67755fb20c7437f9e4de3d4c2f73d" name="delayedpulse_1" x="168" y="1680">
      <params>
         <frac32.s.map name="delay" value="29.0"/>
      </params>
      <attribs/>
   </obj>
   <obj type="logic/or 2" uuid="3805d3c84d30032a44fbdbe42d9a2988a1790a3e" name="or_9" x="350" y="1708">
      <params/>
      <attribs/>
   </obj>
   <obj type="logic/counter" uuid="7a141ba82230e54e5f5cd12da5dbe5a74ba854a5" name="counter_4" x="420" y="1708">
      <params>
         <int32 name="maximum" value="2"/>
      </params>
      <attribs/>
   </obj>
   <obj type="logic/flipflop toggle" uuid="195e489e5fc3d275944b0de56c7a91c8641ea22a" name="flipflop_2" x="532" y="1708">
      <params/>
      <attribs/>
   </obj>
   <obj type="const/i" uuid="e202f44b2df17ae0b3e663b98ea6b14c8ff00408" name="i_3" x="994" y="1764">
      <params/>
      <attribs>
         <spinner attributeName="value" value="960527"/>
      </attribs>
   </obj>
   <comment type="patch/comment" x="280" y="1806" text="track 1 lights (to DIN)"/>
   <comment type="patch/comment" x="644" y="1806" text="track 1 lights (to DIN)"/>
   <comment type="patch/comment" x="1106" y="1806" text="track 2 lights to DIN"/>
   <comment type="patch/comment" x="1428" y="1806" text="track 2 lights (to DIN)"/>
   <obj type="math/==" uuid="deaf0d36642c57876c4101e86f8a0b6a06021ab2" name="==_1" x="0" y="1820">
      <params/>
      <attribs/>
   </obj>
   <obj type="logic/and 2" uuid="c67031682f552aa0a80b23377495c51ea28a8c9c" name="and_5" x="56" y="1820">
      <params/>
      <attribs/>
   </obj>
   <patchobj type="patch/object" uuid="7a6a5bd7-82a7-4c32-b22f-c516f2699a8c" name="b_3" x="126" y="1820">
      <params/>
      <attribs/>
      <object id="patch/object" uuid="7a6a5bd7-82a7-4c32-b22f-c516f2699a8c">
         <sDescription>Generates a single pulse after a rising edge on trigger input. A new trigger before the pulse finishes at the output, extends the pulse.</sDescription>
         <author>Johannes Taelman</author>
         <license>BSD</license>
         <helpPatch>pulselength.axh</helpPatch>
         <inlets>
            <bool32.rising name="trig" description="trigger"/>
         </inlets>
         <outlets>
            <bool32 name="pulse" description="pulse output"/>
         </outlets>
         <displays/>
         <params/>
         <attribs/>
         <includes/>
         <code.declaration><![CDATA[int ntrig;]]></code.declaration>
         <code.init><![CDATA[ntrig = 0;]]></code.init>
         <code.krate><![CDATA[if ((inlet_trig > 0) && !ntrig) {
  ntrig = 1;
  outlet_pulse = 1;
}
else outlet_pulse=0;
if (!(inlet_trig > 0))
{
    ntrig = 0;
  }]]></code.krate>
      </object>
   </patchobj>
   <obj type="logic/or 2" uuid="3805d3c84d30032a44fbdbe42d9a2988a1790a3e" name="or_2" x="210" y="1820">
      <params/>
      <attribs/>
   </obj>
   <patchobj type="patch/object" uuid="410c588c-3f3a-406a-b965-e9f359a10624" name="launch_5" x="280" y="1820">
      <params>
         <int32 name="length" value="7"/>
         <int32 name="start" value="0"/>
         <int32 name="offset" value="0"/>
      </params>
      <attribs>
         <objref attributeName="table" obj="lcxl2"/>
         <combo attributeName="device" selection="usb host port / LP"/>
         <combo attributeName="coloron" selection="green W"/>
         <combo attributeName="coloroff" selection="off"/>
         <spinner attributeName="channel" value="1"/>
         <spinner attributeName="column" value="0"/>
      </attribs>
      <object id="patch/object" uuid="410c588c-3f3a-406a-b965-e9f359a10624">
         <sDescription>visual feedback of table data for midi controllers</sDescription>
         <author>Robert Schirmer</author>
         <license>BSD</license>
         <helpPatch>launchpad.axh</helpPatch>
         <rotatedParams>true</rotatedParams>
         <inlets>
            <int32 name="offset" description="offset in the table to read from"/>
            <int32 name="start" description="display start modulation"/>
            <int32 name="length" description="display length modulation"/>
            <int32 name="coloron" description="color on modulation"/>
            <int32 name="coloroff"/>
            <bool32.rising name="redraw"/>
         </inlets>
         <outlets>
            <int32 name="offset" description="offset through"/>
            <int32 name="start" description="start through"/>
            <int32 name="coloron" description="color on through"/>
            <int32 name="coloroff" description="color off through"/>
            <int32 name="blocksize"/>
         </outlets>
         <displays/>
         <params>
            <int32 name="length" description="length of the area to display">
               <MinValue i="1"/>
               <MaxValue i="127"/>
            </int32>
            <int32 name="start" description="display start on the LP">
               <MinValue i="0"/>
               <MaxValue i="127"/>
            </int32>
            <int32 name="offset">
               <MinValue i="0"/>
               <MaxValue i="10000000"/>
            </int32>
         </params>
         <attribs>
            <objref name="table" description="name of the table to display"/>
            <combo name="device">
               <MenuEntries>
                  <string>usb host port / LP</string>
               </MenuEntries>
               <CEntries>
                  <string>MIDI_DEVICE_DIN, 1</string>
               </CEntries>
            </combo>
            <combo name="coloron">
               <MenuEntries>
                  <string>off</string>
                  <string>red W</string>
                  <string>red M</string>
                  <string>red S</string>
                  <string>orange W</string>
                  <string>orange S</string>
                  <string>green W</string>
                  <string>green M</string>
                  <string>green S</string>
                  <string>lime 1 W</string>
                  <string>lime 1 S</string>
                  <string>lime 2</string>
                  <string>yellow W</string>
                  <string>yellow M</string>
                  <string>yellow S</string>
               </MenuEntries>
               <CEntries>
                  <string>0</string>
                  <string>1</string>
                  <string>2</string>
                  <string>3</string>
                  <string>18</string>
                  <string>35</string>
                  <string>16</string>
                  <string>32</string>
                  <string>48</string>
                  <string>33</string>
                  <string>50</string>
                  <string>49</string>
                  <string>17</string>
                  <string>34</string>
                  <string>51</string>
               </CEntries>
            </combo>
            <combo name="coloroff">
               <MenuEntries>
                  <string>off</string>
                  <string>red W</string>
                  <string>red M</string>
                  <string>red S</string>
                  <string>orange W</string>
                  <string>orange S</string>
                  <string>green W</string>
                  <string>green M</string>
                  <string>green S</string>
                  <string>lime 1 W</string>
                  <string>lime 1 S</string>
                  <string>lime 2</string>
                  <string>yellow W</string>
                  <string>yellow M</string>
                  <string>yellow S</string>
               </MenuEntries>
               <CEntries>
                  <string>0</string>
                  <string>1</string>
                  <string>2</string>
                  <string>3</string>
                  <string>18</string>
                  <string>35</string>
                  <string>16</string>
                  <string>32</string>
                  <string>48</string>
                  <string>33</string>
                  <string>50</string>
                  <string>49</string>
                  <string>17</string>
                  <string>34</string>
                  <string>51</string>
               </CEntries>
            </combo>
            <spinner name="channel" MinValue="1" MaxValue="16" DefaultValue="9"/>
            <spinner name="column" MinValue="0" MaxValue="7" DefaultValue="0"/>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[int ntrig;
int rtrig;
uint8_t map[127];
int i;
int vt;
int trigt;
int prevt[64];
int length;
int plength;

uint8_t coloron;
uint8_t prevcoloron;
uint8_t start;
uint8_t coloroff;
uint8_t prevcoloroff;
uint32_t offset;]]></code.declaration>
         <code.init><![CDATA[{ 
  int i;
  for(i=0;i<8;i++) prevt[i]= -666 ;}

  { 
  int i;
  for(i=0;i<8;i++) 

  map[0] = 0;
map[1] = 16;
map[2] = 32;
map[3] = 48;
map[4] = 64;
map[5] = 80;
map[6] = 96;
map[7] = 112;
}]]></code.init>
         <code.krate><![CDATA[//coloron = inlet_coloron + attr_coloron;

coloroff = inlet_coloroff + attr_coloroff;prevcoloroff=coloroff;
coloron = inlet_coloron + attr_coloron;prevcoloron=coloron;
offset = param_offset + inlet_offset;
start = inlet_start+ param_start;
length = inlet_length +param_length;

//redraw
if (inlet_redraw > 0)
  { 
  int ii;
  for(ii=0;ii<8;ii++) prevt[ii]= -666 ;}
  
  { 
  int ii;
  for(ii=0;ii<8;ii++) 

  map[0] = 0+attr_column;
map[1] = 16+attr_column;
map[2] = 32+attr_column;
map[3] = 48+attr_column;
map[4] = 64+attr_column;
map[5] = 80+attr_column;
map[6] = 96+attr_column;
map[7] = 112+attr_column;
}




    
//display steps

{ 
  i += 1;
  if (i == (length)) i = 0; 
  vt = attr_table.array[__USAT((offset + (i)),attr_table.LENGTHPOW)]<<attr_table.GAIN;
if (prevt[i] != vt ) trigt = 0;
prevt[i] = vt;
if (vt && (!trigt)) {
MidiSend3((midi_device_t) attr_device, MIDI_NOTE_ON + (attr_channel-1)   ,map[(i + start)],(coloron));  trigt=1;
}
if ((!vt) && (!trigt)){
MidiSend3((midi_device_t) attr_device, MIDI_NOTE_ON + (attr_channel-1)  ,map[(i + start)],(coloroff));  trigt=1;
}
 }




outlet_coloron = coloron;
outlet_coloroff = coloroff;
outlet_offset = offset;
outlet_start = start;]]></code.krate>
      </object>
   </patchobj>
   <obj type="logic/flipflop" uuid="f9b15363f5ee203152e062c08a8846f0074b0ea5" name="flipflop_5" x="546" y="1820">
      <params/>
      <attribs/>
   </obj>
   <patchobj type="patch/object" uuid="b40a4170-891d-4fc1-a6a6-b93c8206156a" name="launch_6" x="644" y="1820">
      <params/>
      <attribs>
         <objref attributeName="table" obj="lcxl2"/>
         <combo attributeName="device" selection="usb host port / LP"/>
         <combo attributeName="color" selection="green S"/>
         <spinner attributeName="channel" value="1"/>
         <spinner attributeName="column" value="0"/>
      </attribs>
      <object id="patch/object" uuid="b40a4170-891d-4fc1-a6a6-b93c8206156a">
         <sDescription>display a step counter on a midi controller</sDescription>
         <author>Robert Schirmer</author>
         <license>BSD</license>
         <helpPatch>launchpad.axh</helpPatch>
         <rotatedParams>true</rotatedParams>
         <inlets>
            <int32 name="offset" description="offset in the table to read from"/>
            <int32 name="barcount"/>
            <int32 name="start" description="display start on the LP"/>
            <bool32 name="clear"/>
            <bool32 name="wait"/>
            <bool32 name="rec"/>
            <bool32 name="play"/>
            <bool32 name="stop"/>
            <int32 name="coloron" description="color on"/>
            <int32 name="coloroff" description="color off"/>
            <int32 name="color" description="step color modulation"/>
            <int32 name="step" description="current step"/>
            <bool32 name="active" description="active??"/>
            <bool32.rising name="redraw"/>
            <bool32 name="trigger"/>
         </inlets>
         <outlets/>
         <displays/>
         <params/>
         <attribs>
            <objref name="table" description="table to display"/>
            <combo name="device">
               <MenuEntries>
                  <string>usb host port / LP</string>
               </MenuEntries>
               <CEntries>
                  <string>MIDI_DEVICE_DIN, 1</string>
               </CEntries>
            </combo>
            <combo name="color">
               <MenuEntries>
                  <string>off</string>
                  <string>red W</string>
                  <string>red M</string>
                  <string>red S</string>
                  <string>orange W</string>
                  <string>orange S</string>
                  <string>green W</string>
                  <string>green M</string>
                  <string>green S</string>
                  <string>lime 1 W</string>
                  <string>lime 1 S</string>
                  <string>lime 2</string>
                  <string>yellow W</string>
                  <string>yellow M</string>
                  <string>yellow S</string>
               </MenuEntries>
               <CEntries>
                  <string>0</string>
                  <string>1</string>
                  <string>2</string>
                  <string>3</string>
                  <string>18</string>
                  <string>35</string>
                  <string>16</string>
                  <string>32</string>
                  <string>48</string>
                  <string>33</string>
                  <string>50</string>
                  <string>49</string>
                  <string>17</string>
                  <string>34</string>
                  <string>51</string>
               </CEntries>
            </combo>
            <spinner name="channel" MinValue="1" MaxValue="16" DefaultValue="9"/>
            <spinner name="column" MinValue="0" MaxValue="7" DefaultValue="0"/>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[int color;
int strig;
int prevcolor;
int stoptrig;
int ntrig;
int rtrig;
int full;
int prev;
int32_t map[126];
int32_t v;]]></code.declaration>
         <code.init><![CDATA[{ 
  int i;
  for(i=0;i<8;i++) 

  map[0] = 0+attr_column;
map[1] = 16+attr_column;
map[2] = 32+attr_column;
map[3] = 48+attr_column;
map[4] = 64+attr_column;
map[5] = 80+attr_column;
map[6] = 96+attr_column;
map[7] = 112+attr_column;

}
strig=1;]]></code.init>
         <code.krate><![CDATA[if (inlet_wait){color=17;}
if (inlet_barcount==0){
	if (inlet_rec){color=1;}}
else if(inlet_barcount>0){
	if ((inlet_rec)&&(!inlet_wait)){color=1;}	
}
if ((inlet_play)&&(!inlet_wait)) {
	if((inlet_trigger>0)&&(!inlet_clear)){
	color=attr_color;}
	if((inlet_trigger>0)&&(inlet_clear)){
	color=3;}
	else if (!(inlet_trigger>0)){
	color=inlet_coloron;}
}

full = attr_table.array[__USAT((inlet_offset + inlet_step),attr_table.LENGTHPOW)]<<attr_table.GAIN ;
if ((!inlet_wait)&&(!inlet_rec)&&(!inlet_play)){
	if (full){
	color=inlet_coloron;
	}
	else if (!full){
	color=0;
	}
	}




if (inlet_active){ 
	rtrig = 0;

if (((color!=prevcolor)||(inlet_redraw>0))&&!ntrig){
	if (inlet_step<7){
	MidiSend3((midi_device_t) attr_device, MIDI_NOTE_ON + (attr_channel-1) ,map[inlet_step + inlet_start],(color));}
	else if (inlet_step==7){
		if (inlet_wait>0){
		MidiSend3((midi_device_t) attr_device, MIDI_NOTE_ON + (attr_channel-1) ,map[prev + inlet_start],(17));}
		else if (!inlet_wait)
		{
			v = attr_table.array[__USAT((inlet_offset + (prev)),attr_table.LENGTHPOW)]<<attr_table.GAIN ;
			if (v){
			MidiSend3((midi_device_t) attr_device, MIDI_NOTE_ON + (attr_channel-1) ,map[prev + inlet_start],(16));
			}
			else if (!v){
			MidiSend3((midi_device_t) attr_device, MIDI_NOTE_ON + (attr_channel-1) ,map[prev + inlet_start],(0));
			}
		}
	}
	prevcolor=color;
	ntrig=1;
	}

if (!inlet_trigger){ntrig=0;}


if ((inlet_step  != prev)&&(inlet_step<7)) {
  v = attr_table.array[__USAT((inlet_offset + (prev)),attr_table.LENGTHPOW)]<<attr_table.GAIN ;
  if (v) MidiSend3((midi_device_t) attr_device, MIDI_NOTE_ON + (attr_channel-1) ,map[(prev  + inlet_start)],inlet_coloron);
     	else
     	MidiSend3((midi_device_t) attr_device, MIDI_NOTE_ON + (attr_channel-1) ,map[(prev + inlet_start)],inlet_coloroff);
prev = inlet_step;
}

}]]></code.krate>
      </object>
   </patchobj>
   <obj type="math/==" uuid="deaf0d36642c57876c4101e86f8a0b6a06021ab2" name="==_3" x="784" y="1820">
      <params/>
      <attribs/>
   </obj>
   <obj type="logic/and 2" uuid="c67031682f552aa0a80b23377495c51ea28a8c9c" name="and_6" x="854" y="1820">
      <params/>
      <attribs/>
   </obj>
   <patchobj type="patch/object" uuid="35595f99-57b0-469f-a8c6-b1f024bde33c" name="b_4" x="924" y="1820">
      <params/>
      <attribs/>
      <object id="patch/object" uuid="35595f99-57b0-469f-a8c6-b1f024bde33c">
         <sDescription>Generates a single pulse after a rising edge on trigger input. A new trigger before the pulse finishes at the output, extends the pulse.</sDescription>
         <author>Johannes Taelman</author>
         <license>BSD</license>
         <helpPatch>pulselength.axh</helpPatch>
         <inlets>
            <bool32.rising name="trig" description="trigger"/>
         </inlets>
         <outlets>
            <bool32 name="pulse" description="pulse output"/>
         </outlets>
         <displays/>
         <params/>
         <attribs/>
         <includes/>
         <code.declaration><![CDATA[int ntrig;]]></code.declaration>
         <code.init><![CDATA[ntrig = 0;]]></code.init>
         <code.krate><![CDATA[if ((inlet_trig > 0) && !ntrig) {
  ntrig = 1;
  outlet_pulse = 1;
}
else outlet_pulse=0;
if (!(inlet_trig > 0))
{
    ntrig = 0;
  }]]></code.krate>
      </object>
   </patchobj>
   <obj type="logic/or 2" uuid="3805d3c84d30032a44fbdbe42d9a2988a1790a3e" name="or_5" x="1008" y="1820">
      <params/>
      <attribs/>
   </obj>
   <patchobj type="patch/object" uuid="410c588c-3f3a-406a-b965-e9f359a10624" name="launch_3" x="1078" y="1820">
      <params>
         <int32 name="length" value="7"/>
         <int32 name="start" value="0"/>
         <int32 name="offset" value="0"/>
      </params>
      <attribs>
         <objref attributeName="table" obj="lcxl2"/>
         <combo attributeName="device" selection="usb host port / LP"/>
         <combo attributeName="coloron" selection="green W"/>
         <combo attributeName="coloroff" selection="off"/>
         <spinner attributeName="channel" value="1"/>
         <spinner attributeName="column" value="1"/>
      </attribs>
      <object id="patch/object" uuid="410c588c-3f3a-406a-b965-e9f359a10624">
         <sDescription>visual feedback of table data for midi controllers</sDescription>
         <author>Robert Schirmer</author>
         <license>BSD</license>
         <helpPatch>launchpad.axh</helpPatch>
         <rotatedParams>true</rotatedParams>
         <inlets>
            <int32 name="offset" description="offset in the table to read from"/>
            <int32 name="start" description="display start modulation"/>
            <int32 name="length" description="display length modulation"/>
            <int32 name="coloron" description="color on modulation"/>
            <int32 name="coloroff"/>
            <bool32.rising name="redraw"/>
         </inlets>
         <outlets>
            <int32 name="offset" description="offset through"/>
            <int32 name="start" description="start through"/>
            <int32 name="coloron" description="color on through"/>
            <int32 name="coloroff" description="color off through"/>
            <int32 name="blocksize"/>
         </outlets>
         <displays/>
         <params>
            <int32 name="length" description="length of the area to display">
               <MinValue i="1"/>
               <MaxValue i="127"/>
            </int32>
            <int32 name="start" description="display start on the LP">
               <MinValue i="0"/>
               <MaxValue i="127"/>
            </int32>
            <int32 name="offset">
               <MinValue i="0"/>
               <MaxValue i="10000000"/>
            </int32>
         </params>
         <attribs>
            <objref name="table" description="name of the table to display"/>
            <combo name="device">
               <MenuEntries>
                  <string>usb host port / LP</string>
               </MenuEntries>
               <CEntries>
                  <string>MIDI_DEVICE_DIN, 1</string>
               </CEntries>
            </combo>
            <combo name="coloron">
               <MenuEntries>
                  <string>off</string>
                  <string>red W</string>
                  <string>red M</string>
                  <string>red S</string>
                  <string>orange W</string>
                  <string>orange S</string>
                  <string>green W</string>
                  <string>green M</string>
                  <string>green S</string>
                  <string>lime 1 W</string>
                  <string>lime 1 S</string>
                  <string>lime 2</string>
                  <string>yellow W</string>
                  <string>yellow M</string>
                  <string>yellow S</string>
               </MenuEntries>
               <CEntries>
                  <string>0</string>
                  <string>1</string>
                  <string>2</string>
                  <string>3</string>
                  <string>18</string>
                  <string>35</string>
                  <string>16</string>
                  <string>32</string>
                  <string>48</string>
                  <string>33</string>
                  <string>50</string>
                  <string>49</string>
                  <string>17</string>
                  <string>34</string>
                  <string>51</string>
               </CEntries>
            </combo>
            <combo name="coloroff">
               <MenuEntries>
                  <string>off</string>
                  <string>red W</string>
                  <string>red M</string>
                  <string>red S</string>
                  <string>orange W</string>
                  <string>orange S</string>
                  <string>green W</string>
                  <string>green M</string>
                  <string>green S</string>
                  <string>lime 1 W</string>
                  <string>lime 1 S</string>
                  <string>lime 2</string>
                  <string>yellow W</string>
                  <string>yellow M</string>
                  <string>yellow S</string>
               </MenuEntries>
               <CEntries>
                  <string>0</string>
                  <string>1</string>
                  <string>2</string>
                  <string>3</string>
                  <string>18</string>
                  <string>35</string>
                  <string>16</string>
                  <string>32</string>
                  <string>48</string>
                  <string>33</string>
                  <string>50</string>
                  <string>49</string>
                  <string>17</string>
                  <string>34</string>
                  <string>51</string>
               </CEntries>
            </combo>
            <spinner name="channel" MinValue="1" MaxValue="16" DefaultValue="9"/>
            <spinner name="column" MinValue="0" MaxValue="7" DefaultValue="0"/>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[int ntrig;
int rtrig;
uint8_t map[127];
int i;
int vt;
int trigt;
int prevt[64];
int length;
int plength;

uint8_t coloron;
uint8_t prevcoloron;
uint8_t start;
uint8_t coloroff;
uint8_t prevcoloroff;
uint32_t offset;]]></code.declaration>
         <code.init><![CDATA[{ 
  int i;
  for(i=0;i<8;i++) prevt[i]= -666 ;}

  { 
  int i;
  for(i=0;i<8;i++) 

  map[0] = 0;
map[1] = 16;
map[2] = 32;
map[3] = 48;
map[4] = 64;
map[5] = 80;
map[6] = 96;
map[7] = 112;
}]]></code.init>
         <code.krate><![CDATA[//coloron = inlet_coloron + attr_coloron;

coloroff = inlet_coloroff + attr_coloroff;prevcoloroff=coloroff;
coloron = inlet_coloron + attr_coloron;prevcoloron=coloron;
offset = param_offset + inlet_offset;
start = inlet_start+ param_start;
length = inlet_length +param_length;

//redraw
if (inlet_redraw > 0)
  { 
  int ii;
  for(ii=0;ii<8;ii++) prevt[ii]= -666 ;}
  
  { 
  int ii;
  for(ii=0;ii<8;ii++) 

  map[0] = 0+attr_column;
map[1] = 16+attr_column;
map[2] = 32+attr_column;
map[3] = 48+attr_column;
map[4] = 64+attr_column;
map[5] = 80+attr_column;
map[6] = 96+attr_column;
map[7] = 112+attr_column;
}




    
//display steps

{ 
  i += 1;
  if (i == (length)) i = 0; 
  vt = attr_table.array[__USAT((offset + (i)),attr_table.LENGTHPOW)]<<attr_table.GAIN;
if (prevt[i] != vt ) trigt = 0;
prevt[i] = vt;
if (vt && (!trigt)) {
MidiSend3((midi_device_t) attr_device, MIDI_NOTE_ON + (attr_channel-1)   ,map[(i + start)],(coloron));  trigt=1;
}
if ((!vt) && (!trigt)){
MidiSend3((midi_device_t) attr_device, MIDI_NOTE_ON + (attr_channel-1)  ,map[(i + start)],(coloroff));  trigt=1;
}
 }




outlet_coloron = coloron;
outlet_coloroff = coloroff;
outlet_offset = offset;
outlet_start = start;]]></code.krate>
      </object>
   </patchobj>
   <obj type="logic/flipflop" uuid="f9b15363f5ee203152e062c08a8846f0074b0ea5" name="flipflop_6" x="1330" y="1820">
      <params/>
      <attribs/>
   </obj>
   <patchobj type="patch/object" uuid="b40a4170-891d-4fc1-a6a6-b93c8206156a" name="launch_8" x="1428" y="1820">
      <params/>
      <attribs>
         <objref attributeName="table" obj="lcxl2"/>
         <combo attributeName="device" selection="usb host port / LP"/>
         <combo attributeName="color" selection="green S"/>
         <spinner attributeName="channel" value="1"/>
         <spinner attributeName="column" value="1"/>
      </attribs>
      <object id="patch/object" uuid="b40a4170-891d-4fc1-a6a6-b93c8206156a">
         <sDescription>display a step counter on a midi controller</sDescription>
         <author>Robert Schirmer</author>
         <license>BSD</license>
         <helpPatch>launchpad.axh</helpPatch>
         <rotatedParams>true</rotatedParams>
         <inlets>
            <int32 name="offset" description="offset in the table to read from"/>
            <int32 name="barcount"/>
            <int32 name="start" description="display start on the LP"/>
            <bool32 name="clear"/>
            <bool32 name="wait"/>
            <bool32 name="rec"/>
            <bool32 name="play"/>
            <bool32 name="stop"/>
            <int32 name="coloron" description="color on"/>
            <int32 name="coloroff" description="color off"/>
            <int32 name="color" description="step color modulation"/>
            <int32 name="step" description="current step"/>
            <bool32 name="active" description="active??"/>
            <bool32.rising name="redraw"/>
            <bool32 name="trigger"/>
         </inlets>
         <outlets/>
         <displays/>
         <params/>
         <attribs>
            <objref name="table" description="table to display"/>
            <combo name="device">
               <MenuEntries>
                  <string>usb host port / LP</string>
               </MenuEntries>
               <CEntries>
                  <string>MIDI_DEVICE_DIN, 1</string>
               </CEntries>
            </combo>
            <combo name="color">
               <MenuEntries>
                  <string>off</string>
                  <string>red W</string>
                  <string>red M</string>
                  <string>red S</string>
                  <string>orange W</string>
                  <string>orange S</string>
                  <string>green W</string>
                  <string>green M</string>
                  <string>green S</string>
                  <string>lime 1 W</string>
                  <string>lime 1 S</string>
                  <string>lime 2</string>
                  <string>yellow W</string>
                  <string>yellow M</string>
                  <string>yellow S</string>
               </MenuEntries>
               <CEntries>
                  <string>0</string>
                  <string>1</string>
                  <string>2</string>
                  <string>3</string>
                  <string>18</string>
                  <string>35</string>
                  <string>16</string>
                  <string>32</string>
                  <string>48</string>
                  <string>33</string>
                  <string>50</string>
                  <string>49</string>
                  <string>17</string>
                  <string>34</string>
                  <string>51</string>
               </CEntries>
            </combo>
            <spinner name="channel" MinValue="1" MaxValue="16" DefaultValue="9"/>
            <spinner name="column" MinValue="0" MaxValue="7" DefaultValue="0"/>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[int color;
int strig;
int prevcolor;
int stoptrig;
int ntrig;
int rtrig;
int full;
int prev;
int32_t map[126];
int32_t v;]]></code.declaration>
         <code.init><![CDATA[{ 
  int i;
  for(i=0;i<8;i++) 

  map[0] = 0+attr_column;
map[1] = 16+attr_column;
map[2] = 32+attr_column;
map[3] = 48+attr_column;
map[4] = 64+attr_column;
map[5] = 80+attr_column;
map[6] = 96+attr_column;
map[7] = 112+attr_column;

}
strig=1;]]></code.init>
         <code.krate><![CDATA[if (inlet_wait){color=17;}
if (inlet_barcount==0){
	if (inlet_rec){color=1;}}
else if(inlet_barcount>0){
	if ((inlet_rec)&&(!inlet_wait)){color=1;}	
}
if ((inlet_play)&&(!inlet_wait)) {
	if((inlet_trigger>0)&&(!inlet_clear)){
	color=attr_color;}
	if((inlet_trigger>0)&&(inlet_clear)){
	color=3;}
	else if (!(inlet_trigger>0)){
	color=inlet_coloron;}
}

full = attr_table.array[__USAT((inlet_offset + inlet_step),attr_table.LENGTHPOW)]<<attr_table.GAIN ;
if ((!inlet_wait)&&(!inlet_rec)&&(!inlet_play)){
	if (full){
	color=inlet_coloron;
	}
	else if (!full){
	color=0;
	}
	}




if (inlet_active){ 
	rtrig = 0;

if (((color!=prevcolor)||(inlet_redraw>0))&&!ntrig){
	if (inlet_step<7){
	MidiSend3((midi_device_t) attr_device, MIDI_NOTE_ON + (attr_channel-1) ,map[inlet_step + inlet_start],(color));}
	else if (inlet_step==7){
		if (inlet_wait>0){
		MidiSend3((midi_device_t) attr_device, MIDI_NOTE_ON + (attr_channel-1) ,map[prev + inlet_start],(17));}
		else if (!inlet_wait)
		{
			v = attr_table.array[__USAT((inlet_offset + (prev)),attr_table.LENGTHPOW)]<<attr_table.GAIN ;
			if (v){
			MidiSend3((midi_device_t) attr_device, MIDI_NOTE_ON + (attr_channel-1) ,map[prev + inlet_start],(16));
			}
			else if (!v){
			MidiSend3((midi_device_t) attr_device, MIDI_NOTE_ON + (attr_channel-1) ,map[prev + inlet_start],(0));
			}
		}
	}
	prevcolor=color;
	ntrig=1;
	}

if (!inlet_trigger){ntrig=0;}


if ((inlet_step  != prev)&&(inlet_step<7)) {
  v = attr_table.array[__USAT((inlet_offset + (prev)),attr_table.LENGTHPOW)]<<attr_table.GAIN ;
  if (v) MidiSend3((midi_device_t) attr_device, MIDI_NOTE_ON + (attr_channel-1) ,map[(prev  + inlet_start)],inlet_coloron);
     	else
     	MidiSend3((midi_device_t) attr_device, MIDI_NOTE_ON + (attr_channel-1) ,map[(prev + inlet_start)],inlet_coloroff);
prev = inlet_step;
}

}]]></code.krate>
      </object>
   </patchobj>
   <comment type="patch/comment" x="28" y="1932" text="trevor record light to launch control xl"/>
   <patchobj type="patch/object" uuid="4102f896-2532-4710-b2fc-5ec4e4d2f42f" name="keyb_3" x="28" y="1946">
      <params/>
      <attribs>
         <spinner attributeName="note" value="108"/>
      </attribs>
      <object id="patch/object" uuid="4102f896-2532-4710-b2fc-5ec4e4d2f42f">
         <sDescription>Monophonic MIDI keyboard note input, gate, velocity and release velocity</sDescription>
         <author>Johannes Taelman</author>
         <license>BSD</license>
         <helpPatch>midi_in.axh</helpPatch>
         <inlets/>
         <outlets>
            <bool32 name="gate" description="key pressed?"/>
            <frac32.positive name="velocity" description="note-on velocity"/>
            <frac32.positive name="releaseVelocity" description="note-off velocity"/>
         </outlets>
         <displays/>
         <params/>
         <attribs>
            <spinner name="note" MinValue="0" MaxValue="127" DefaultValue="64"/>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[uint8_t _gate;
uint8_t _velo;
uint8_t _rvelo;
]]></code.declaration>
         <code.init><![CDATA[_gate = 0;
]]></code.init>
         <code.krate><![CDATA[outlet_gate= _gate<<27;
outlet_velocity= _velo<<20;
outlet_releaseVelocity= _rvelo<<20;
]]></code.krate>
         <code.midihandler><![CDATA[if ((status == MIDI_NOTE_ON + 8) && (data2)) {if (data1 == attr_note) {
   _velo = data2;
   _gate = 1;
}
} else if (((status == MIDI_NOTE_ON + 8) && (!data2))||          (status == MIDI_NOTE_OFF + 8)) {
  if (data1 == attr_note) {
    _rvelo = data2;
    _gate = 0;
  }
}]]></code.midihandler>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="aca76334-27dd-4dd7-b0b0-d971e80c7521" name="note_4" x="126" y="1946">
      <params/>
      <attribs>
         <combo attributeName="device" selection="usb host port 1"/>
         <spinner attributeName="channel" value="9"/>
      </attribs>
      <object id="patch/object" uuid="aca76334-27dd-4dd7-b0b0-d971e80c7521">
         <sDescription>Midi note output</sDescription>
         <author>Johannes Taelman</author>
         <license>BSD</license>
         <helpPatch>midi_out.axh</helpPatch>
         <inlets>
            <frac32.bipolar name="note" description="note (-64..63)"/>
            <frac32.positive name="velo" description="velocity"/>
            <bool32.rising name="trig" description="trigger"/>
         </inlets>
         <outlets/>
         <displays/>
         <params/>
         <attribs>
            <combo name="device">
               <MenuEntries>
                  <string>din</string>
                  <string>usb host port 1</string>
                  <string>usb host port 2</string>
                  <string>usb host port 3</string>
                  <string>usb host port 4</string>
                  <string>internal port 1</string>
                  <string>internal port 2</string>
                  <string>usb device port 1</string>
               </MenuEntries>
               <CEntries>
                  <string>MIDI_DEVICE_DIN, 1</string>
                  <string>MIDI_DEVICE_USB_HOST, 1</string>
                  <string>MIDI_DEVICE_USB_HOST, 2</string>
                  <string>MIDI_DEVICE_USB_HOST, 3</string>
                  <string>MIDI_DEVICE_USB_HOST, 4</string>
                  <string>MIDI_DEVICE_INTERNAL, 1</string>
                  <string>MIDI_DEVICE_INTERNAL, 2</string>
                  <string>MIDI_DEVICE_USB_DEVICE, 1</string>
               </CEntries>
            </combo>
            <spinner name="channel" MinValue="1" MaxValue="16" DefaultValue="0"/>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[int ntrig;
int lastnote;]]></code.declaration>
         <code.init><![CDATA[ntrig=0;
]]></code.init>
         <code.krate><![CDATA[if ((inlet_trig>0) && !ntrig) {
MidiSend3((midi_device_t) attr_device, MIDI_NOTE_ON + (attr_channel-1),108,inlet_velo>>20);  ntrig=1;
}
if (!(inlet_trig>0) && ntrig) {MidiSend3((midi_device_t) attr_device, MIDI_NOTE_OFF + (attr_channel-1),108,127); ntrig=0;}]]></code.krate>
      </object>
   </patchobj>
   <comment type="patch/comment" x="84" y="2170" text="save all to sd card"/>
   <comment type="patch/comment" x="910" y="2170" text="load initalise patch for patch changing"/>
   <patchobj type="patch/object" uuid="27a4893e-93bb-4a7c-b41c-0b02da02cbed" name="keyb_1" x="84" y="2184">
      <params/>
      <attribs/>
      <object id="patch/object" uuid="27a4893e-93bb-4a7c-b41c-0b02da02cbed">
         <sDescription>Monophonic MIDI keyboard note input, gate, velocity and release velocity</sDescription>
         <author>Johannes Taelman</author>
         <license>BSD</license>
         <helpPatch>midi_in.axh</helpPatch>
         <inlets/>
         <outlets>
            <bool32 name="gate" description="key pressed?"/>
         </outlets>
         <displays/>
         <params/>
         <attribs/>
         <includes/>
         <code.declaration><![CDATA[uint8_t _gate;
int ccv;]]></code.declaration>
         <code.init><![CDATA[_gate = 0;
]]></code.init>
         <code.krate><![CDATA[if (ccv&&_gate){
	outlet_gate=1;
}
else outlet_gate=0;]]></code.krate>
         <code.midihandler><![CDATA[if ((status == MIDI_NOTE_ON + 8) && (data2)) {
	if (data1 == 108) {
   _gate = 1;
}
	if (data1 == 107) {
   ccv = 1;
}
}
 else if (((status == MIDI_NOTE_ON + 8) && (!data2))||          (status == MIDI_NOTE_OFF + 8)) {
  
    _gate = 0;
    ccv=0;
  
}]]></code.midihandler>
      </object>
   </patchobj>
   <obj type="string/c" uuid="4aa90a90c435a742ddfa152d232883fc5b2f1b3" name="c_1" x="168" y="2184">
      <params/>
      <attribs>
         <table attributeName="str" table="/abletone"/>
      </attribs>
   </obj>
   <obj type="table/save" uuid="3e4108b607d56d9e1cd10abb898b58eea11e53b2" name="save_1" x="322" y="2184">
      <params/>
      <attribs>
         <objref attributeName="table" obj="lcxl2"/>
      </attribs>
   </obj>
   <obj type="string/c" uuid="4aa90a90c435a742ddfa152d232883fc5b2f1b3" name="c_2" x="462" y="2184">
      <params/>
      <attribs>
         <table attributeName="str" table="/abletones"/>
      </attribs>
   </obj>
   <obj type="table/save" uuid="3e4108b607d56d9e1cd10abb898b58eea11e53b2" name="save_2" x="616" y="2184">
      <params/>
      <attribs>
         <objref attributeName="table" obj="lcxl3"/>
      </attribs>
   </obj>
   <patchobj type="patch/object" uuid="27a4893e-93bb-4a7c-b41c-0b02da02cbed" name="keyb_2" x="910" y="2184">
      <params/>
      <attribs/>
      <object id="patch/object" uuid="27a4893e-93bb-4a7c-b41c-0b02da02cbed">
         <sDescription>Monophonic MIDI keyboard note input, gate, velocity and release velocity</sDescription>
         <author>Johannes Taelman</author>
         <license>BSD</license>
         <helpPatch>midi_in.axh</helpPatch>
         <inlets/>
         <outlets>
            <bool32 name="gate" description="key pressed?"/>
         </outlets>
         <displays/>
         <params/>
         <attribs/>
         <includes/>
         <code.declaration><![CDATA[uint8_t _gate;
int ccv;]]></code.declaration>
         <code.init><![CDATA[_gate = 0;
]]></code.init>
         <code.krate><![CDATA[if (ccv&&_gate){
	outlet_gate=1;
}
else outlet_gate=0;]]></code.krate>
         <code.midihandler><![CDATA[if ((status == MIDI_NOTE_ON + 8) && (data2)) {if (data1 == 108) {
   _gate = 1;
}
} else if (((status == MIDI_NOTE_ON + 8) && (!data2))||          (status == MIDI_NOTE_OFF + 8)) {
  if (data1 == 108) {
    _gate = 0;
  }
} 
if ((status == 8 + MIDI_CONTROL_CHANGE)&&(data1 == 107)) { ccv = data2;}]]></code.midihandler>
      </object>
   </patchobj>
   <obj type="patch/load" uuid="634bf1f8c313920d7f19fc402ba937fd1ee27802" name="load_3" x="994" y="2184">
      <params/>
      <attribs>
         <table attributeName="filename" table="/init rodney upload/patch.bin"/>
      </attribs>
   </obj>
   <nets>
      <net>
         <source obj="object_4" outlet="nplaytrig"/>
         <dest obj="counter_1" inlet="r"/>
         <dest obj="counter_3" inlet="r"/>
         <dest obj="or_1" inlet="i2"/>
         <dest obj="counter_4" inlet="r"/>
         <dest obj="or_3" inlet="i2"/>
         <dest obj="launch_8" inlet="redraw"/>
         <dest obj="counter_10" inlet="r"/>
         <dest obj="counter_12" inlet="r"/>
      </net>
      <net>
         <source obj="note_2" outlet="gate"/>
         <dest obj="counter_14" inlet="trig"/>
         <dest obj="counter_1" inlet="trig"/>
         <dest obj="or_9" inlet="i1"/>
         <dest obj="clk_mul_1" inlet="clk"/>
         <dest obj="clk_mul_2" inlet="clk"/>
         <dest obj="and_4" inlet="i1"/>
         <dest obj="counter_11" inlet="trig"/>
         <dest obj="counter_12" inlet="trig"/>
      </net>
      <net>
         <source obj="toggle_1" outlet="o"/>
         <dest obj="and_13" inlet="i1"/>
         <dest obj="and_14" inlet="i1"/>
      </net>
      <net>
         <source obj="clk_mul_2" outlet="clk"/>
         <dest obj="counter_9" inlet="trig"/>
         <dest obj="counter_13" inlet="trig"/>
         <dest obj="counter_10" inlet="trig"/>
         <dest obj="counter_16" inlet="trig"/>
      </net>
      <net>
         <source obj="counter2_init_start_3" outlet="c"/>
         <dest obj="counter_15" inlet="trig"/>
         <dest obj="counter_7" inlet="trig"/>
         <dest obj="counter_8" inlet="trig"/>
      </net>
      <net>
         <source obj="object_3" outlet="offsetnotes"/>
         <dest obj="tablestore_21" inlet="offset"/>
         <dest obj="patcher_2" inlet="offset"/>
      </net>
      <net>
         <source obj="counter_9" outlet="o"/>
         <dest obj="tablestore_11" inlet="stepunQ"/>
         <dest obj="tablestore_12" inlet="stepunQ"/>
         <dest obj="tablestore_22" inlet="stepunQ"/>
         <dest obj="tablestore_23" inlet="stepunQ"/>
         <dest obj="tablestore_24" inlet="stepunQ"/>
         <dest obj="tablestore_25" inlet="stepunQ"/>
         <dest obj="tablestore_26" inlet="stepunQ"/>
         <dest obj="tablestore_21" inlet="stepunQ"/>
         <dest obj="patcher_2" inlet="stepunQ"/>
      </net>
      <net>
         <source obj="counter_11" outlet="o"/>
         <dest obj="tablestore_12" inlet="step"/>
         <dest obj="tablestore_22" inlet="step"/>
         <dest obj="tablestore_23" inlet="step"/>
         <dest obj="tablestore_24" inlet="step"/>
         <dest obj="tablestore_25" inlet="step"/>
         <dest obj="tablestore_26" inlet="step"/>
         <dest obj="tablestore_21" inlet="step"/>
         <dest obj="patcher_2" inlet="step"/>
      </net>
      <net>
         <source obj="clk_mul_1" outlet="clk"/>
         <dest obj="counter2_init_start_3" inlet="inc"/>
      </net>
      <net>
         <source obj="and_14" outlet="o"/>
         <dest obj="object_3" inlet="pulse"/>
         <dest obj="object_4" inlet="pulse"/>
      </net>
      <net>
         <source obj="and_13" outlet="o"/>
         <dest obj="or_9" inlet="i2"/>
         <dest obj="object_3" inlet="pulseplay"/>
         <dest obj="object_4" inlet="pulseplay"/>
      </net>
      <net>
         <source obj="toggle_1" outlet="stop"/>
         <dest obj="flipflop_2" inlet="reset"/>
         <dest obj="or_4" inlet="i1"/>
         <dest obj="launch_6" inlet="stop"/>
         <dest obj="launch_8" inlet="stop"/>
      </net>
      <net>
         <source obj="object_3" outlet="rec"/>
         <dest obj="tablestore_11" inlet="rec"/>
         <dest obj="patcher_2" inlet="rec"/>
         <dest obj="launch_6" inlet="rec"/>
      </net>
      <net>
         <source obj="object_3" outlet="play"/>
         <dest obj="tablestore_12" inlet="play"/>
         <dest obj="tablestore_22" inlet="play"/>
         <dest obj="tablestore_23" inlet="play"/>
         <dest obj="tablestore_24" inlet="play"/>
         <dest obj="tablestore_25" inlet="play"/>
         <dest obj="tablestore_26" inlet="play"/>
         <dest obj="tablestore_21" inlet="play"/>
         <dest obj="launch_6" inlet="play"/>
      </net>
      <net>
         <source obj="tablestore_21" outlet="totaloffset"/>
         <dest obj="tablestore_22" inlet="offset"/>
      </net>
      <net>
         <source obj="tablestore_22" outlet="totaloffset"/>
         <dest obj="tablestore_23" inlet="offset"/>
      </net>
      <net>
         <source obj="tablestore_23" outlet="totaloffset"/>
         <dest obj="tablestore_24" inlet="offset"/>
      </net>
      <net>
         <source obj="tablestore_24" outlet="totaloffset"/>
         <dest obj="tablestore_25" inlet="offset"/>
      </net>
      <net>
         <source obj="tablestore_25" outlet="totaloffset"/>
         <dest obj="tablestore_26" inlet="offset"/>
      </net>
      <net>
         <source obj="toggle_1" outlet="start"/>
         <dest obj="flipflop_2" inlet="set"/>
         <dest obj="counter_15" inlet="r"/>
         <dest obj="counter_14" inlet="r"/>
         <dest obj="counter2_init_start_3" inlet="r"/>
         <dest obj="object_3" inlet="start"/>
         <dest obj="counter_13" inlet="r"/>
         <dest obj="object_4" inlet="start"/>
         <dest obj="counter_16" inlet="r"/>
      </net>
      <net>
         <source obj="counter_1" outlet="c"/>
         <dest obj="counter_3" inlet="trig"/>
         <dest obj="or_3" inlet="i1"/>
      </net>
      <net>
         <source obj="tablestore_26" outlet="totaloffset"/>
         <dest obj="tablestore_11" inlet="offset"/>
         <dest obj="tablestore_12" inlet="offset"/>
      </net>
      <net>
         <source obj="object_3" outlet="clipslot"/>
         <dest obj="==_1" inlet="in2"/>
         <dest obj="launch_6" inlet="step"/>
      </net>
      <net>
         <source obj="counter_3" outlet="o"/>
         <dest obj="==_2" inlet="in1"/>
      </net>
      <net>
         <source obj="i_7" outlet="out"/>
         <dest obj="==_2" inlet="in2"/>
      </net>
      <net>
         <source obj="pulselength_1" outlet="pulse"/>
         <dest obj="launch_6" inlet="clear"/>
         <dest obj="launch_8" inlet="clear"/>
      </net>
      <net>
         <source obj="==_2" outlet="out"/>
         <dest obj="or_1" inlet="i1"/>
      </net>
      <net>
         <source obj="or_1" outlet="o"/>
         <dest obj="pulselength_1" inlet="trig"/>
      </net>
      <net>
         <source obj="counter_4" outlet="c"/>
         <dest obj="flipflop_2" inlet="trig"/>
      </net>
      <net>
         <source obj="or_9" outlet="o"/>
         <dest obj="counter_4" inlet="trig"/>
      </net>
      <net>
         <source obj="flipflop_2" outlet="o"/>
         <dest obj="launch_6" inlet="trigger"/>
         <dest obj="launch_8" inlet="trigger"/>
      </net>
      <net>
         <source obj="or_2" outlet="o"/>
         <dest obj="flipflop_5" inlet="reset"/>
         <dest obj="launch_5" inlet="redraw"/>
      </net>
      <net>
         <source obj="flipflop_5" outlet="o"/>
         <dest obj="launch_6" inlet="active"/>
      </net>
      <net>
         <source obj="==_1" outlet="out"/>
         <dest obj="and_5" inlet="i1"/>
      </net>
      <net>
         <source obj="c_1" outlet="out"/>
         <dest obj="save_1" inlet="filename"/>
      </net>
      <net>
         <source obj="c_2" outlet="out"/>
         <dest obj="save_2" inlet="filename"/>
      </net>
      <net>
         <source obj="keyb_1" outlet="gate"/>
         <dest obj="save_1" inlet="trig"/>
         <dest obj="save_2" inlet="trig"/>
      </net>
      <net>
         <source obj="i_6" outlet="out"/>
         <dest obj="tablestore_12" inlet="channel"/>
         <dest obj="tablestore_22" inlet="channel"/>
         <dest obj="tablestore_23" inlet="channel"/>
         <dest obj="tablestore_24" inlet="channel"/>
         <dest obj="tablestore_25" inlet="channel"/>
         <dest obj="tablestore_26" inlet="channel"/>
         <dest obj="tablestore_21" inlet="channel"/>
         <dest obj="tablestore_27" inlet="channel"/>
         <dest obj="tablestore_14" inlet="channel"/>
      </net>
      <net>
         <source obj="or_4" outlet="o"/>
         <dest obj="object_3" inlet="stop"/>
         <dest obj="object_4" inlet="stop"/>
      </net>
      <net>
         <source obj="i_5" outlet="out"/>
         <dest obj="tablestore_11" inlet="channel"/>
         <dest obj="patcher_2" inlet="channel"/>
         <dest obj="tablestore_13" inlet="channel"/>
         <dest obj="tablestore_7" inlet="channel"/>
      </net>
      <net>
         <source obj="counter_14" outlet="c"/>
         <dest obj="and_13" inlet="i2"/>
      </net>
      <net>
         <source obj="counter_15" outlet="c"/>
         <dest obj="and_14" inlet="i2"/>
      </net>
      <net>
         <source obj="note_3" outlet="gate"/>
         <dest obj="toggle_1" inlet="set"/>
      </net>
      <net>
         <source obj="note_1" outlet="gate"/>
         <dest obj="toggle_1" inlet="reset"/>
      </net>
      <net>
         <source obj="top_1" outlet="t7"/>
         <dest obj="object_3" inlet="shift"/>
         <dest obj="object_4" inlet="shift"/>
      </net>
      <net>
         <source obj="launch_7" outlet="note"/>
         <dest obj="tablestore_1" inlet="v"/>
      </net>
      <net>
         <source obj="tablestore_1" outlet="v"/>
         <dest obj="launch_6" inlet="barcount"/>
         <dest obj="launch_8" inlet="barcount"/>
         <dest obj="object_3" inlet="barcount"/>
         <dest obj="object_4" inlet="barcount"/>
      </net>
      <net>
         <source obj="launch_7" outlet="gate"/>
         <dest obj="tablestore_1" inlet="trig"/>
      </net>
      <net>
         <source obj="object_4" outlet="cleartrigger"/>
         <dest obj="and_6" inlet="i2"/>
      </net>
      <net>
         <source obj="object_4" outlet="clearslot"/>
         <dest obj="==_3" inlet="in1"/>
      </net>
      <net>
         <source obj="object_4" outlet="offsetnotes"/>
         <dest obj="tablestore_7" inlet="offset"/>
         <dest obj="tablestore_27" inlet="offset"/>
      </net>
      <net>
         <source obj="counter_10" outlet="o"/>
         <dest obj="tablestore_13" inlet="stepunQ"/>
         <dest obj="tablestore_14" inlet="stepunQ"/>
         <dest obj="tablestore_27" inlet="stepunQ"/>
         <dest obj="tablestore_7" inlet="stepunQ"/>
      </net>
      <net>
         <source obj="counter_12" outlet="o"/>
         <dest obj="tablestore_14" inlet="step"/>
         <dest obj="tablestore_27" inlet="step"/>
         <dest obj="tablestore_7" inlet="step"/>
      </net>
      <net>
         <source obj="object_4" outlet="rec"/>
         <dest obj="tablestore_13" inlet="rec"/>
         <dest obj="tablestore_7" inlet="rec"/>
         <dest obj="launch_8" inlet="rec"/>
      </net>
      <net>
         <source obj="object_4" outlet="play"/>
         <dest obj="tablestore_14" inlet="play"/>
         <dest obj="tablestore_27" inlet="play"/>
         <dest obj="launch_8" inlet="play"/>
      </net>
      <net>
         <source obj="tablestore_27" outlet="totaloffset"/>
         <dest obj="tablestore_13" inlet="offset"/>
         <dest obj="tablestore_14" inlet="offset"/>
      </net>
      <net>
         <source obj="object_4" outlet="clipslot"/>
         <dest obj="==_3" inlet="in2"/>
         <dest obj="launch_8" inlet="step"/>
      </net>
      <net>
         <source obj="launch_3" outlet="coloron"/>
         <dest obj="launch_8" inlet="coloron"/>
      </net>
      <net>
         <source obj="launch_3" outlet="coloroff"/>
         <dest obj="launch_8" inlet="coloroff"/>
      </net>
      <net>
         <source obj="launch_3" outlet="offset"/>
         <dest obj="launch_8" inlet="offset"/>
      </net>
      <net>
         <source obj="launch_3" outlet="start"/>
         <dest obj="launch_8" inlet="start"/>
      </net>
      <net>
         <source obj="or_5" outlet="o"/>
         <dest obj="flipflop_6" inlet="reset"/>
         <dest obj="launch_3" inlet="redraw"/>
      </net>
      <net>
         <source obj="flipflop_6" outlet="o"/>
         <dest obj="launch_8" inlet="active"/>
      </net>
      <net>
         <source obj="==_3" outlet="out"/>
         <dest obj="and_6" inlet="i1"/>
      </net>
      <net>
         <source obj="i_3" outlet="out"/>
         <dest obj="launch_3" inlet="offset"/>
      </net>
      <net>
         <source obj="launch_5" outlet="offset"/>
         <dest obj="launch_6" inlet="offset"/>
      </net>
      <net>
         <source obj="launch_5" outlet="start"/>
         <dest obj="launch_6" inlet="start"/>
      </net>
      <net>
         <source obj="launch_5" outlet="coloron"/>
         <dest obj="launch_6" inlet="coloron"/>
      </net>
      <net>
         <source obj="launch_5" outlet="coloroff"/>
         <dest obj="launch_6" inlet="coloroff"/>
      </net>
      <net>
         <source obj="keyb_2" outlet="gate"/>
         <dest obj="load_3" inlet="trig"/>
      </net>
      <net>
         <source obj="and_5" outlet="o"/>
         <dest obj="b_3" inlet="trig"/>
      </net>
      <net>
         <source obj="and_6" outlet="o"/>
         <dest obj="b_4" inlet="trig"/>
      </net>
      <net>
         <source obj="tableread_6" outlet="v0"/>
         <dest obj="vca_2" inlet="v"/>
      </net>
      <net>
         <source obj="tableread_6" outlet="v1"/>
         <dest obj="obj_1" inlet="feedback"/>
      </net>
      <net>
         <source obj="+_2" outlet="out"/>
         <dest obj="vca_1" inlet="a"/>
         <dest obj="sum3_1" inlet="in1"/>
      </net>
      <net>
         <source obj="+_1" outlet="out"/>
         <dest obj="vca_2" inlet="a"/>
         <dest obj="+_2" inlet="in1"/>
      </net>
      <net>
         <source obj="obj_1" outlet="outlet_1"/>
         <dest obj="gain_1" inlet="in"/>
      </net>
      <net>
         <source obj="vca_1" outlet="o"/>
         <dest obj="hp_1" inlet="in"/>
      </net>
      <net>
         <source obj="tableread_6" outlet="v2"/>
         <dest obj="obj_1" inlet="div"/>
      </net>
      <net>
         <source obj="launchcontrol_1" outlet="t3"/>
         <dest obj="flipflop_3" inlet="set"/>
         <dest obj="counter_5" inlet="r"/>
      </net>
      <net>
         <source obj="launchcontrol_1" outlet="shift"/>
         <dest obj="table_6" inlet="shift"/>
         <dest obj="table_5" inlet="shift"/>
      </net>
      <net>
         <source obj="hp_1" outlet="out"/>
         <dest obj="reverb_2" inlet="l"/>
         <dest obj="reverb_2" inlet="r"/>
      </net>
      <net>
         <source obj="*c_2" outlet="out"/>
         <dest obj="vca_1" inlet="v"/>
      </net>
      <net>
         <source obj="unipolar2bipolar_2" outlet="o"/>
         <dest obj="hp_1" inlet="pitch"/>
      </net>
      <net>
         <source obj="tri_ph_p_2" outlet="tri"/>
         <dest obj="*_3" inlet="b"/>
      </net>
      <net>
         <source obj="*_3" outlet="result"/>
         <dest obj="*c_6" inlet="in"/>
      </net>
      <net>
         <source obj="*c_5" outlet="out"/>
         <dest obj="unipolar2bipolar_4" inlet="i"/>
      </net>
      <net>
         <source obj="unipolar2bipolar_4" outlet="o"/>
         <dest obj="tri_ph_p_2" inlet="pitch"/>
      </net>
      <net>
         <source obj="*c_6" outlet="out"/>
         <dest obj="obj_1" inlet="tm"/>
      </net>
      <net>
         <source obj="and_4" outlet="o"/>
         <dest obj="counter_5" inlet="trig"/>
         <dest obj="tap_tempo_2" inlet="tap"/>
      </net>
      <net>
         <source obj="counter_5" outlet="c"/>
         <dest obj="flipflop_3" inlet="reset"/>
      </net>
      <net>
         <source obj="flipflop_3" outlet="o"/>
         <dest obj="and_4" inlet="i2"/>
      </net>
      <net>
         <source obj="tap_tempo_2" outlet="clock"/>
         <dest obj="obj_1" inlet="24ppq"/>
      </net>
      <net>
         <source obj="sum3_1" outlet="out"/>
         <dest obj="out_2" inlet="wave"/>
      </net>
      <net>
         <source obj="reverb_2" outlet="l"/>
         <dest obj="sum3_1" inlet="in2"/>
      </net>
      <net>
         <source obj="reverb_2" outlet="r"/>
         <dest obj="sum3_1" inlet="in3"/>
      </net>
      <net>
         <source obj="in_2" outlet="wave"/>
         <dest obj="vca_3" inlet="a"/>
         <dest obj="+_1" inlet="in1"/>
      </net>
      <net>
         <source obj="obj_2" outlet="outlet_1"/>
         <dest obj="gain_2" inlet="in"/>
      </net>
      <net>
         <source obj="tableread_5" outlet="v0"/>
         <dest obj="vca_3" inlet="v"/>
      </net>
      <net>
         <source obj="tableread_5" outlet="v1"/>
         <dest obj="*c_9" inlet="in"/>
      </net>
      <net>
         <source obj="scale_1" outlet="o"/>
         <dest obj="reverb_2" inlet="diffusion"/>
      </net>
      <net>
         <source obj="tableread_6" outlet="v3"/>
         <dest obj="obj_1" inlet="fcut"/>
      </net>
      <net>
         <source obj="vca_3" outlet="o"/>
         <dest obj="obj_2" inlet="audio-in"/>
      </net>
      <net>
         <source obj="tri_ph_p_3" outlet="tri"/>
         <dest obj="*_4" inlet="b"/>
      </net>
      <net>
         <source obj="*_4" outlet="result"/>
         <dest obj="*c_3" inlet="in"/>
      </net>
      <net>
         <source obj="*c_1" outlet="out"/>
         <dest obj="unipolar2bipolar_3" inlet="i"/>
      </net>
      <net>
         <source obj="unipolar2bipolar_3" outlet="o"/>
         <dest obj="tri_ph_p_3" inlet="pitch"/>
      </net>
      <net>
         <source obj="*c_3" outlet="out"/>
         <dest obj="obj_2" inlet="tm"/>
      </net>
      <net>
         <source obj="tableread_2" outlet="v0"/>
         <dest obj="*_4" inlet="a"/>
      </net>
      <net>
         <source obj="tableread_2" outlet="v1"/>
         <dest obj="*c_1" inlet="in"/>
      </net>
      <net>
         <source obj="tableread_5" outlet="v2"/>
         <dest obj="*_1" inlet="a"/>
      </net>
      <net>
         <source obj="tableread_2" outlet="v2"/>
         <dest obj="*_1" inlet="b"/>
      </net>
      <net>
         <source obj="tableread_5" outlet="v3"/>
         <dest obj="obj_2" inlet="hpcut"/>
      </net>
      <net>
         <source obj="tableread_6" outlet="v7"/>
         <dest obj="*c_2" inlet="in"/>
      </net>
      <net>
         <source obj="tableread_6" outlet="v6"/>
         <dest obj="reverb_2" inlet="time"/>
      </net>
      <net>
         <source obj="tableread_6" outlet="v5"/>
         <dest obj="scale_1" inlet="c"/>
      </net>
      <net>
         <source obj="tableread_6" outlet="v4"/>
         <dest obj="reverb_2" inlet="lowpass"/>
      </net>
      <net>
         <source obj="*c_9" outlet="out"/>
         <dest obj="obj_2" inlet="feedback"/>
      </net>
      <net>
         <source obj="tableread_3" outlet="v0"/>
         <dest obj="*_3" inlet="a"/>
      </net>
      <net>
         <source obj="tableread_3" outlet="v1"/>
         <dest obj="*c_5" inlet="in"/>
      </net>
      <net>
         <source obj="tableread_3" outlet="v3"/>
         <dest obj="unipolar2bipolar_2" inlet="i"/>
      </net>
      <net>
         <source obj="tableread_3" outlet="v2"/>
         <dest obj="obj_1" inlet="hp"/>
      </net>
      <net>
         <source obj="vca_2" outlet="o"/>
         <dest obj="obj_1" inlet="audio-in"/>
      </net>
      <net>
         <source obj="gain_1" outlet="out"/>
         <dest obj="+_2" inlet="in2"/>
      </net>
      <net>
         <source obj="gain_2" outlet="out"/>
         <dest obj="+_1" inlet="in2"/>
      </net>
      <net>
         <source obj="*_1" outlet="result"/>
         <dest obj="obj_2" inlet="time"/>
      </net>
      <net>
         <source obj="keyb_3" outlet="gate"/>
         <dest obj="note_4" inlet="trig"/>
         <dest obj="note_4" inlet="velo"/>
      </net>
      <net>
         <source obj="object_3" outlet="nplaytrig"/>
         <dest obj="counter_9" inlet="r"/>
         <dest obj="counter_11" inlet="r"/>
         <dest obj="launch_6" inlet="redraw"/>
      </net>
      <net>
         <source obj="object_3" outlet="nrectrig"/>
         <dest obj="counter_7" inlet="r"/>
      </net>
      <net>
         <source obj="counter_13" outlet="o"/>
         <dest obj="patcher_2" inlet="qstep"/>
      </net>
      <net>
         <source obj="counter_7" outlet="o"/>
         <dest obj="patcher_2" inlet="steprec"/>
      </net>
      <net>
         <source obj="object_3" outlet="clearslot"/>
         <dest obj="==_1" inlet="in1"/>
      </net>
      <net>
         <source obj="object_3" outlet="cleartrigger"/>
         <dest obj="and_5" inlet="i2"/>
      </net>
      <net>
         <source obj="object_3" outlet="cliptrigger"/>
         <dest obj="flipflop_5" inlet="set"/>
      </net>
      <net>
         <source obj="object_3" outlet="wait"/>
         <dest obj="launch_6" inlet="wait"/>
      </net>
      <net>
         <source obj="object_4" outlet="nrectrig"/>
         <dest obj="counter_8" inlet="r"/>
      </net>
      <net>
         <source obj="counter_8" outlet="o"/>
         <dest obj="tablestore_7" inlet="steprec"/>
      </net>
      <net>
         <source obj="counter_16" outlet="o"/>
         <dest obj="tablestore_7" inlet="Qstep"/>
      </net>
      <net>
         <source obj="object_4" outlet="wait"/>
         <dest obj="launch_8" inlet="wait"/>
      </net>
      <net>
         <source obj="object_4" outlet="cliptrigger"/>
         <dest obj="flipflop_6" inlet="set"/>
      </net>
      <net>
         <source obj="loadbang_1" outlet="pulse"/>
         <dest obj="delayedpulse_1" inlet="trig"/>
      </net>
      <net>
         <source obj="b_3" outlet="pulse"/>
         <dest obj="or_2" inlet="i1"/>
      </net>
      <net>
         <source obj="delayedpulse_1" outlet="pulse"/>
         <dest obj="or_2" inlet="i2"/>
         <dest obj="or_5" inlet="i2"/>
      </net>
      <net>
         <source obj="b_4" outlet="pulse"/>
         <dest obj="or_5" inlet="i1"/>
      </net>
   </nets>
   <settings>
      <subpatchmode>no</subpatchmode>
      <MidiChannel>9</MidiChannel>
      <NPresets>0</NPresets>
      <NPresetEntries>0</NPresetEntries>
      <NModulationSources>0</NModulationSources>
      <NModulationTargetsPerSource>0</NModulationTargetsPerSource>
   </settings>
   <notes><![CDATA[can i use 1 table write for the notes? use offset
]]></notes>
   <windowPos>
      <x>-8</x>
      <y>-8</y>
      <width>1616</width>
      <height>876</height>
   </windowPos>
</patch-1.0>