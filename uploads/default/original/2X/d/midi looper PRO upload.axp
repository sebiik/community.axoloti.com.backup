<patch-1.0 appVersion="1.0.12">
   <comment type="patch/comment" x="616" y="0" text="NOTES"/>
   <comment type="patch/comment" x="462" y="14" text="Updated midi looper. it&apos;s 4 objects - one to sync to the clock, one to record/play back notes, one to record bend/mono touch/ ccs, and one to record poly touch. I made it like this so if you only want notes, you can delete the others"/>
   <comment type="patch/comment" x="462" y="42" text="DO NOT PUT IN POLY SUB PATCH - it does it&apos;s own poly assigning. currently it can record up to 9 notes at once, and can playback 15."/>
   <comment type="patch/comment" x="61" y="55" text="KNOWN BUGS!!!!!!!!!!!!!!!"/>
   <comment type="patch/comment" x="462" y="56" text="the note recorder is a big object, I&apos;m going to make a couple of variations with different amounts of record/playback voices so you can use smaller ones when space/sram is running out"/>
   <comment type="patch/comment" x="56" y="70" text="it sometimes plays back a note from the last playing "/>
   <comment type="patch/comment" x="56" y="84" text="loop whilst recording a new loop. not sure why yet!"/>
   <comment type="patch/comment" x="532" y="84" text="It records at 128PPQ, when quantized it preserves note lengths and shifts start and end points by the same amount"/>
   <comment type="patch/comment" x="686" y="98" text=". you can turn quantize on/off while overdubbing and record a mix of the two"/>
   <comment type="patch/comment" x="56" y="112" text="if you find any weirdness, let me know!"/>
   <comment type="patch/comment" x="532" y="126" text="it will record any cc&apos;s coming in on that channel, and is able to play back 3 at once"/>
   <comment type="patch/comment" x="532" y="154" text="DATA - you can have a max of 32 slots, each can be as many bars long as you like (depending on settings on object)"/>
   <comment type="patch/comment" x="532" y="168" text="the &quot;size&quot; attribute sets the size the note rec/play object will use on the table. the table must be the same size or bigger than this. "/>
   <comment type="patch/comment" x="532" y="182" text="if the cc/bend/touch recorders are used, you can see the total size on table from the final offset output, if you see what i mean (disp object below)"/>
   <obj type="table/alloc 16b sdram load" uuid="e6b85dad3ab43565cda93ea4c43c73b668b1cd43" name="midiloop" x="42" y="196">
      <params/>
      <attribs>
         <combo attributeName="size" selection="1048576"/>
         <file attributeName="filename" file="/midiloop"/>
      </attribs>
   </obj>
   <comment type="patch/comment" x="532" y="196" text="you can see the maximum amount of notes per slot (derived from the size attribute) on the maxnotes outlet (display below)"/>
   <comment type="patch/comment" x="532" y="224" text="the cc/bend/touch recording uses much more rooom on the table than the note recorder (i&apos;ve found a size of 16384 is fine for 7 x 8bar loops, with a LOT of notes playing)"/>
   <comment type="patch/comment" x="532" y="252" text="INPUT/OUTPUT DVEICES - you can set the inputs and outputs and channels in the three recording objects  in the objects."/>
   <comment type="patch/comment" x="532" y="266" text="INTERNAL MIDI BUS ROUTING - if you want to record from AND play back from the internal midi bus, use different ports for input and output. other wise when you overdub it&apos;s going to keep recording it&apos;s own playback"/>
   <comment type="patch/comment" x="532" y="280" text="the outlets are mainly for feedback or controlling the sub modules"/>
   <comment type="patch/comment" x="182" y="308" text="start/stop internal clock"/>
   <comment type="patch/comment" x="308" y="308" text="internal clock"/>
   <comment type="patch/comment" x="630" y="308" text="CONTROLS"/>
   <obj type="ctrl/toggle" uuid="42b8134fa729d54bfc8d62d6ef3fa99498c1de99" name="toggle_1" x="196" y="322">
      <params>
         <bool32.tgl name="b" value="0"/>
      </params>
      <attribs/>
   </obj>
   <obj type="midi/intern/clock" uuid="7f6f35e92d2c29e950af2b3af5cebb2e9e3b778c" name="clock_3" x="308" y="322">
      <params>
         <frac32.u.map name="bpm" value="14.5"/>
      </params>
      <attribs/>
   </obj>
   <comment type="patch/comment" x="630" y="322" text="it&apos;s currently setup to record channel 7 from the DIN, and to playback to internal bus, port 1"/>
   <comment type="patch/comment" x="630" y="336" text="it currently has 7 available slots, each has a maximum length of 8 bars"/>
   <comment type="patch/comment" x="630" y="364" text="1. Trigger an empty clipslot and it starts recording at next bar. If trigger it again (or if it reaches the maxbar length on the object)  playback will start "/>
   <comment type="patch/comment" x="630" y="378" text="2. Trigger a full clipslot and it will start playing at next bar. if already playing, it will restart"/>
   <comment type="patch/comment" x="630" y="378" text="3. click stop to stop at next bar"/>
   <comment type="patch/comment" x="630" y="392" text="4. overdub toggles overdubon/off - I don&apos;t think it currently let&apos;s you overdub into an empty slot"/>
   <comment type="patch/comment" x="630" y="406" text="5. record button forces record at beginning of next bar, even if slot is full/playing"/>
   <comment type="patch/comment" x="630" y="420" text="6. quantize toggles on /off quantize. quantize amount can be set in the object. so far you can do 1/4, 1/8, 1/16, 1/32. planning to add triplets at some point"/>
   <comment type="patch/comment" x="630" y="434" text="7. clear clears the selected slot. you can clear a slot while another slot is playing"/>
   <comment type="patch/comment" x="28" y="448" text="measures length of a midi sync pulse in K cycles "/>
   <comment type="patch/comment" x="14" y="462" text="and puts out average length of a beat. updates each bar"/>
   <comment type="patch/comment" x="406" y="462" text="rough bpm"/>
   <comment type="patch/comment" x="532" y="462" text="quantize"/>
   <comment type="patch/comment" x="644" y="462" text="clear"/>
   <comment type="patch/comment" x="742" y="462" text="slot empty/full"/>
   <comment type="patch/comment" x="840" y="462" text="clipslot"/>
   <comment type="patch/comment" x="910" y="462" text="trigger"/>
   <comment type="patch/comment" x="994" y="462" text="stop"/>
   <comment type="patch/comment" x="1078" y="462" text="overdub"/>
   <comment type="patch/comment" x="1162" y="462" text="record"/>
   <comment type="patch/comment" x="1260" y="462" text="metronom vol"/>
   <comment type="patch/comment" x="1414" y="462" text="save loops to SDcard (axo table files, not midi files)"/>
   <patchobj type="patch/object" uuid="3914464d-774e-4973-b888-9dc1d6e0561e" name="clock_1" x="56" y="476">
      <params/>
      <attribs/>
      <object id="patch/object" uuid="3914464d-774e-4973-b888-9dc1d6e0561e">
         <sDescription>Midi clock slave</sDescription>
         <author>Johannes Taelman</author>
         <license>BSD</license>
         <helpPatch>midi_in.axh</helpPatch>
         <inlets/>
         <outlets>
            <bool32 name="active" description="Song is playing"/>
            <int32 name="kbeat" description="average length of a beat at k rate"/>
            <bool32.pulse name="start" description="start trigger"/>
            <bool32.pulse name="stop" description="stop trigger"/>
            <bool32.pulse name="1ppq" description="beat trigger, 1ppq"/>
            <int32 name="bpm" description="rough bpm"/>
         </outlets>
         <displays/>
         <params/>
         <attribs/>
         <includes/>
         <code.declaration><![CDATA[int32_t _active;
int32_t _pos;
int32_t prevpos;
int tap;
int prevtap;
int tapped;
int tapV[24];
int start;
int stop;
int t;
int pos1ppq;
int firsttap;
int secondtap;
int taptotal;
int tapdiv;
int beattotal;
int beatdiv;
int beatavg;
int beatV[4];
int avg;
int beat;
int prevbeat;
int beattrig;
int outcount;
int beatcount;
int prevpos1;
int tick;]]></code.declaration>
         <code.init><![CDATA[_active = 0;
_pos = -1;
t=-1;
firsttap=0;
beat=-1;
outcount=-1;]]></code.init>
         <code.krate><![CDATA[outlet_active = _active;
outlet_start=start;
if (_pos>=0){
pos1ppq = _pos/24;
}
else if (_pos<0){
pos1ppq = -1;	
}

if (t>=0){
t+=1;
}
if (start){
	tap=-1;
	}
	

if ((_pos!=prevpos)&&(_pos!=(-1))){
	prevpos=_pos;
	if ((t>0)&&(tap>=0)){
		tapV[tap]=t;
		if ((tap>=1)&&!firsttap){
			taptotal=tapV[tap]+tapV[prevtap];
			tapdiv=tap+1;
			avg=(taptotal/tapdiv)*24;
			beatavg=avg<<2;
		}
	}
	prevtap=tap;
	tap+=1;
	if (tap>=24){
	if (!firsttap){
		beat=0;
	}
	firsttap=1;
	tapdiv=24;
	taptotal=tapV[0]+tapV[1]+tapV[2]+tapV[3]+tapV[4]+tapV[5]+tapV[6]+tapV[7]+tapV[8]+tapV[9]+tapV[10]+tapV[11]+tapV[12]+tapV[13]+tapV[14]+tapV[15]+tapV[16]+tapV[17]+tapV[18]+tapV[19]+tapV[20]+tapV[21]+tapV[22]+tapV[23];
	avg=((taptotal*24)/tapdiv);
	
	tap=0;
	tapped=1;	
	
	}
	t=0;
}
if (tapped){
	beatV[beat]=avg;
	if ((beat>=1)&&!secondtap){
			beattotal=beatV[beat]+beatV[prevbeat];
			beatdiv=beat+1;
			beatavg=(beattotal/beatdiv);
			
		}
	
	prevbeat=beat;
	beat+=1;
	if (beat>=4){
		secondtap=1;
		outcount=0;
		beatcount=0;
		beat=0;
		beattotal=beatV[0]+beatV[1]+beatV[2]+beatV[3];
		beatdiv=4;
		beatavg=beattotal/beatdiv;
	}
}
if (outcount>=0){
outcount+=1;
}
if (outcount==beatavg){
	outcount=0;
	if (beatcount<=3){
	
	beattrig=1;
	}
	beatcount+=1;
}
if (start){
	outcount=0;
	beattrig=1;
	beatcount=0;
}
if ((pos1ppq!=prevpos1) && (pos1ppq!=(-1))){
	prevpos1=pos1ppq;
	tick=1;
}

//outlet_pos1ppq=pos1ppq;
outlet_stop=stop;
outlet_1ppq=tapped;
outlet_kbeat=beatavg;

outlet_bpm=180000/beatavg;

tapped=0;
beattrig=0;
start=0;
tick=0;
stop=0;]]></code.krate>
         <code.midihandler><![CDATA[if (status == MIDI_TIMING_CLOCK) {
	if ((_pos==0)&&_active){
  	start=1;
  }
  _pos++;
  
  
} else if (status == MIDI_START) {
  _active = 1;
  _pos = 0;
  
} else if (status == MIDI_STOP) {
  _active = 0;
  stop=1;
  _pos = -1;
  tap=-1;
  outcount=-1;
  
}]]></code.midihandler>
      </object>
   </patchobj>
   <obj type="disp/i" uuid="5e35fd0c62d81e70017289250cf28edd26e19e4a" name="i_2" x="406" y="476">
      <params/>
      <attribs/>
   </obj>
   <obj type="ctrl/toggle" uuid="42b8134fa729d54bfc8d62d6ef3fa99498c1de99" name="toggle_2" x="518" y="476">
      <params>
         <bool32.tgl name="b" value="1"/>
      </params>
      <attribs/>
   </obj>
   <obj type="ctrl/button" uuid="ef3d13774349df85aa9bfecf30dbc91ab8488b3f" name="button_8" x="644" y="476">
      <params>
         <bool32.mom name="b" value="0"/>
      </params>
      <attribs/>
   </obj>
   <obj type="disp/bool" uuid="a0ee71d48208b71752cbb8c05e55145106ef3946" name="bool_5" x="756" y="476">
      <params/>
      <attribs/>
   </obj>
   <obj type="ctrl/i" uuid="a3786816db6ea5bc6ac4193a5cccdb2c83b83496" name="i_15" x="840" y="476">
      <params>
         <int32 name="value" value="4"/>
      </params>
      <attribs/>
   </obj>
   <obj type="ctrl/button" uuid="ef3d13774349df85aa9bfecf30dbc91ab8488b3f" name="button_7" x="910" y="476">
      <params>
         <bool32.mom name="b" value="0"/>
      </params>
      <attribs/>
   </obj>
   <obj type="ctrl/button" uuid="ef3d13774349df85aa9bfecf30dbc91ab8488b3f" name="button_2" x="994" y="476">
      <params>
         <bool32.mom name="b" value="0"/>
      </params>
      <attribs/>
   </obj>
   <obj type="ctrl/button" uuid="ef3d13774349df85aa9bfecf30dbc91ab8488b3f" name="button_4" x="1078" y="476">
      <params>
         <bool32.mom name="b" value="0"/>
      </params>
      <attribs/>
   </obj>
   <obj type="ctrl/button" uuid="ef3d13774349df85aa9bfecf30dbc91ab8488b3f" name="button_5" x="1162" y="476">
      <params>
         <bool32.mom name="b" value="0"/>
      </params>
      <attribs/>
   </obj>
   <obj type="ctrl/dial p" uuid="cc5d2846c3d50e425f450c4b9851371b54f4d674" name="dial_1" x="1260" y="476">
      <params>
         <frac32.u.map name="value" value="12.5"/>
      </params>
      <attribs/>
   </obj>
   <obj type="ctrl/button" uuid="ef3d13774349df85aa9bfecf30dbc91ab8488b3f" name="button_1" x="1414" y="476">
      <params>
         <bool32.mom name="b" value="0"/>
      </params>
      <attribs/>
   </obj>
   <comment type="patch/comment" x="224" y="560" text="note recording/playback and clock"/>
   <patchobj type="patch/object" uuid="d2e7db3f-0ba6-43fb-848f-afa25d0caebd" name="1_1" x="224" y="574">
      <params>
         <bool32.tgl name="quantize" value="0"/>
         <int32.hradio name="quantization" value="2"/>
      </params>
      <attribs>
         <combo attributeName="input" selection="din"/>
         <combo attributeName="output" selection="internal port 1"/>
         <spinner attributeName="channel" value="7"/>
         <objref attributeName="table" obj="midiloop"/>
         <combo attributeName="size" selection="16384"/>
         <spinner attributeName="maxbar" value="8"/>
         <spinner attributeName="maxslots" value="7"/>
      </attribs>
      <object id="patch/object" uuid="d2e7db3f-0ba6-43fb-848f-afa25d0caebd">
         <sDescription>writes and outputs 4 values to a table.</sDescription>
         <author>robert schirmer</author>
         <license>who cares</license>
         <inlets>
            <int32 name="kbeat" description="k rate time of one beat"/>
            <int32 name="offset" description="sets an offset for writing to the table"/>
            <bool32.rising name="1ppq" description="clock for transport quantize - 4 trigs=1bar"/>
            <bool32 name="quantize" description="turn on quantize (turn off parameter if using inlet)"/>
            <bool32.rising name="restart" description="restart/reset clock"/>
            <int32 name="slot" description="select slot"/>
            <bool32.rising name="trigger" description="trigger slot. if empty, slot starts recording at beginning of next bar. if slot is full, slot starts playing at next bar. if already playing, it will restart."/>
            <bool32.rising name="stop" description="stops at next bar"/>
            <bool32.rising name="clearslot" description="clear selected slot"/>
            <bool32.rising name="record" description="forces record at next bar, even if slot is full"/>
            <bool32.rising name="overdub" description="trigger to toggle overdub on/off"/>
            <bool32.rising name="clearplay" description="clear all playvoices - tops playback immediately"/>
         </inlets>
         <outlets>
            <bool32.pulse name="bartrig" description="simply sends a trigger every bar"/>
            <bool32 name="overdub" description="feedback output for overdub"/>
            <bool32 name="record" description="feedback output for record"/>
            <bool32 name="play" description="feedback output for play"/>
            <int32 name="maxnotes" description="maximum amount of notes for each slot - depends on &quot;size&quot; and &quot;maxslots&quot; attributes"/>
            <int32 name="slotnotes" description="amount of notes recorded in current slot"/>
            <bool32 name="full"/>
            <int32 name="currentslot"/>
            <bool32 name="wait"/>
            <int32 name="playstate"/>
            <int32 name="offset"/>
            <int32 name="synclock"/>
         </outlets>
         <displays/>
         <params>
            <bool32.tgl name="quantize"/>
            <int32.hradio name="quantization" description="1/4, 1/8th, 1/16th, 1/32nd">
               <MaxValue i="4"/>
            </int32.hradio>
         </params>
         <attribs>
            <combo name="input">
               <MenuEntries>
                  <string>omni</string>
                  <string>din</string>
                  <string>usb host port 1</string>
                  <string>usb host port 2</string>
                  <string>usb host port 3</string>
                  <string>usb host port 4</string>
                  <string>internal port 1</string>
                  <string>internal port 2</string>
                  <string>usb device port 1</string>
               </MenuEntries>
               <CEntries>
                  <string>true</string>
                  <string>dev == MIDI_DEVICE_DIN &amp;&amp; port == 1</string>
                  <string>dev == MIDI_DEVICE_USB_HOST &amp;&amp; port == 1</string>
                  <string>dev == MIDI_DEVICE_USB_HOST &amp;&amp; port == 2</string>
                  <string>dev == MIDI_DEVICE_USB_HOST &amp;&amp; port == 3</string>
                  <string>dev == MIDI_DEVICE_USB_HOST &amp;&amp; port == 4</string>
                  <string>dev == MIDI_DEVICE_INTERNAL &amp;&amp; port == 1</string>
                  <string>dev == MIDI_DEVICE_INTERNAL &amp;&amp; port == 2</string>
                  <string>dev == MIDI_DEVICE_USB_DEVICE &amp;&amp; port == 1</string>
               </CEntries>
            </combo>
            <combo name="output">
               <MenuEntries>
                  <string>din</string>
                  <string>usb host port 1</string>
                  <string>usb host port 2</string>
                  <string>usb host port 3</string>
                  <string>usb host port 4</string>
                  <string>internal port 1</string>
                  <string>internal port 2</string>
                  <string>usb device port 1</string>
               </MenuEntries>
               <CEntries>
                  <string>MIDI_DEVICE_DIN, 1</string>
                  <string>MIDI_DEVICE_USB_HOST, 1</string>
                  <string>MIDI_DEVICE_USB_HOST, 2</string>
                  <string>MIDI_DEVICE_USB_HOST, 3</string>
                  <string>MIDI_DEVICE_USB_HOST, 4</string>
                  <string>MIDI_DEVICE_INTERNAL, 1</string>
                  <string>MIDI_DEVICE_INTERNAL, 2</string>
                  <string>MIDI_DEVICE_USB_DEVICE, 1</string>
               </CEntries>
            </combo>
            <spinner name="channel" description="midi channel" MinValue="1" MaxValue="16" DefaultValue="1"/>
            <objref name="table" description="table must be same size or greater than attribute size"/>
            <combo name="size" description="total size on table">
               <MenuEntries>
                  <string>2</string>
                  <string>4</string>
                  <string>8</string>
                  <string>16</string>
                  <string>32</string>
                  <string>64</string>
                  <string>128</string>
                  <string>256</string>
                  <string>512</string>
                  <string>1024</string>
                  <string>2048</string>
                  <string>4096</string>
                  <string>8192</string>
                  <string>16384</string>
                  <string>32768</string>
                  <string>65536</string>
                  <string>131072</string>
                  <string>262144</string>
                  <string>524288</string>
                  <string>1048576</string>
                  <string>2097152</string>
                  <string>4194304</string>
               </MenuEntries>
               <CEntries>
                  <string>1</string>
                  <string>2</string>
                  <string>3</string>
                  <string>4</string>
                  <string>5</string>
                  <string>6</string>
                  <string>7</string>
                  <string>8</string>
                  <string>9</string>
                  <string>10</string>
                  <string>11</string>
                  <string>12</string>
                  <string>13</string>
                  <string>14</string>
                  <string>15</string>
                  <string>16</string>
                  <string>17</string>
                  <string>18</string>
                  <string>19</string>
                  <string>20</string>
                  <string>21</string>
                  <string>22</string>
               </CEntries>
            </combo>
            <spinner name="maxbar" description="maximum amount of bars per slot" MinValue="1" MaxValue="30000" DefaultValue="1"/>
            <spinner name="maxslots" description="maximum amount of slots" MinValue="1" MaxValue="32" DefaultValue="1"/>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[int inputoffset;
int countoffset;
int controloffset;
int size;
int on;
int off; 
int notecount;
int noteon[9];
int cltrig;
int gate[9];
int vel[9];
int init;
int prevslot;
int offsethold;
int outgateB[15];
int outend[15];
int lastP[15];
int synclocko;
int gtrig[9];
int goffset[9];
int gvel[9];
int gnote[9];
int gstart[9];
int gend[9];
int gon[9];
int Pmax[15];
int Phold[15];
int Plength[15];
int Pstart[15];
int Pend[15];
int Pnote[15];
int Pvel[15];
int outnote[15];
int outvel[15];
int outgate[15];
int prevCstart;
int prevoutgate[15];
int Pscan;
int prevPscan;
int Cvel;
int Cnote;
int Cstart;
int Cend;
int barcount;
int offset;
int kcount;
int prevkcount;
int restart;
int kbeat;
int prevPcount;
int prevCend;
int transportQ;
int currentin;
int notescan;
int stage;

int clear;
int g1outS;
int g1outE;
int g1outV;
int g1outN;
int barhold;
int prevmaxbar;

int prevsin;
int prevrec;
int kbar;
int busy;
int startpos;
int Pstartpos;
int play;
int synclock;
int prevsynclock;
int kquantclock;
int quantclock;
int quantize;
int quantizeon;
int recording;
int stophold;
int pltrig;
int playhold;
int rechold;
int barrecord;
int Pnotecount;
int Rnotecount;
int playscan;
int prevplayscan;
int inscan;
int rec;
int halfsync;
int Pindex;
int assigned;
int early;
int trigr;
int rectime;
int temp;
int Quant[4];
int prevPgate;
int prevPindex;
int delme;
int holdscan;
int voices;
int temp2;
int currentslot;
int wait;
int dialclock;
int ppq;
int cptrig;
int trigtrig;
int full;
int clearoffset;
int prevppq;
int currentbar;
int maxbar;
int maxppq;
int lengthcnt;
int notend;
int scan;
int scanmax;
int prevscan;
int mute[15];
int Cindex[15];
int playingscan;
int Cindexx;
int prevCnote;
int tempS;
int tempE;
int tempV;
int tempN;
int test;
int overdub;
int maxnotes;
int prevRnote;
int dubtrig;
int clearmax;
int playreset;
int prebarC;
int prebartrig;
int prebarmax;
int reclight;
int recend;
int recpause;
int slotsize;
int playstate;
bool bartrig;
bool strig;
bool sttrig;
bool ctrig;]]></code.declaration>
         <code.init><![CDATA[kcount=-1;
barcount=-1;
Plength[1]=-1;
clear=-1;
prevPcount=-1;
Pscan=0;
prevPscan=-1;
prevPindex=-1;
Pindex=-1;
assigned=1;
Quant[0]=1;
Quant[1]=2;
Quant[2]=4;
Quant[3]=8;
init=1;]]></code.init>
         <code.krate><![CDATA[// can prob take out input offset, and just use control offset (bar storage and number of notes)

controloffset=8;

size=(1<<attr_size);
slotsize= (((1<<attr_size)-32)/attr_maxslots)+8;
outlet_offset=size+inlet_offset;


//per slot
//maxnotes=((size-32)/attr_maxslots)>>3;
maxnotes=(slotsize-8)>>3;
// recall total note count
 Rnotecount=attr_table.array[countoffset];
 
 maxbar=attr_table.array[countoffset +1];
if (init){
	currentslot=inlet_slot;
	offset=inlet_offset+32+((controloffset+slotsize)*inlet_slot) +controloffset;
		countoffset=inlet_offset+32+((controloffset+slotsize)*inlet_slot);
		init=0;
}



if ((kcount>=0)&&(synclock<383)){
	kcount+=1;
}
//Rnotecount is stored at inlet_offset - 7 spare global data values

if (inlet_overdub&&!dubtrig){
	dubtrig=1;
	overdub=!overdub;
	if (overdub){
		recording=1;
	}
	if (!overdub){
		recording=0;
	}
}
if (!inlet_overdub){
	dubtrig=0;
}

if (inlet_clearslot&&!cltrig){
	cltrig=1;
	//attr_table.array[countoffset]=0;
  	//attr_table.array[countoffset+1]=0;
  	clearoffset=inlet_offset+32+((controloffset+slotsize)*inlet_slot);
  	attr_table.array[clearoffset]=0;
  	attr_table.array[clearoffset + 1]=0;
	clearmax=Rnotecount+controloffset;
	clear=0;
	if (inlet_slot==currentslot){
		play=0;
		if (!overdub){
		recording=0;
		}
		
		reclight=0;
	}
	//Rnotecount=0;
	//playreset=1;
	//restart=1;
	//play=0;
//	recording=0;
	
}
if (!inlet_clearslot){
	cltrig=0;
}

if (inlet_clearplay&&!cptrig){
cptrig=1;
playreset=1;
play=0;

	
}
if (!inlet_clearplay){
	cptrig=0;
}
quantizeon=param_quantize+inlet_quantize;
maxppq=maxbar<<9;
kbar=(inlet_kbeat)<<2;
kbeat=inlet_kbeat;
if (!quantizeon){
prebarmax=kbar-(voices<<2);
}
else if (quantizeon){
prebarmax=kbar-kbar/16;
}

transportQ=1;


quantize=Quant[param_quantization];


if (dialclock<0x07FFFFFF){
dialclock+=(0x07FFFFFF/(kbeat));

}
if (inlet_slot!=prevslot){
	prevslot=inlet_slot;
	offsethold=1;
	if (reclight){
		attr_table.array[countoffset+1]=currentbar+1;
//		maxbar==currentbar+1;
	}
		
	
	
}
	

//clock trigger
if (inlet_1ppq&&!ctrig){
	barcount+=1;
	dialclock=0;
	if (barcount>=4){
		prebarC=0;
		barcount=0;
		bartrig=1;
		
		if (stophold){
			play=0;
			playreset=1;
			stophold=0;
		}
		if (playhold){
			restart=1;
			play=1;
			playhold=0;
		}
		if (rechold){
			
			rec=1;
			reclight=1;
			if (!play){
				play=1;
			}
			restart=1;
			rechold=0;
		}
		if (barhold){
			reclight=0;
			barhold=0;
			barrecord=0;
			maxbar=currentbar+1;
			restart=1;
			if (!overdub){
				recording=0;currentbar=0;
			}
		}
		
		//restart=1;
		currentbar+=1;
		if (currentbar>=maxbar){
			
			if (barrecord&&(maxbar==attr_maxbar)){
				barhold=0;
				reclight=0;
			barrecord=0;
			maxbar=currentbar;
			restart=1;
			if (!overdub){
				recording=0;currentbar=0;
			}
			}
			currentbar=0;
			restart=1;
		}
	}
	ctrig=1;
	}
if (!inlet_1ppq){
	ctrig=0;
}

if ((prebarC<prebarmax)&&(prebarC>=0)){
prebarC+=1;

if (prebarC>=prebarmax){
	if ((offsethold) &&(rechold || playhold || barhold))
	{
		offsethold=0;
		offset=inlet_offset+32+((controloffset+slotsize)*inlet_slot) +controloffset;
		countoffset=inlet_offset+32+((controloffset+slotsize)*inlet_slot);
		 Rnotecount=attr_table.array[countoffset];
		 currentslot=inlet_slot;
		  prevPindex=-1;
	Pindex=-1;
		
	}
	if (((currentbar+1)>=maxbar) || playhold || rechold || barhold){
	prebartrig=1;
	
	playreset=1;
	
	if ((barhold) || (barrecord&&(maxbar==(attr_maxbar-1)))){
		playreset=1;
		recend=1;
		gate[0]=0;
		gate[1]=0;
		gate[2]=0;
		gate[3]=0;
		gate[4]=0;
		gate[5]=0;
		gate[6]=0;
		gate[7]=0;
		gate[8]=0;
		gate[9]=0;
		
	}
	if (rechold){
	clearmax=Rnotecount+controloffset;
	clearoffset=offset-controloffset;
	clear=0;
	Rnotecount=0;
	recording=1;
	}
	}
	prebarC=-1;
}

}


full=attr_table.array[inlet_offset+inlet_slot];
//transport
if (inlet_restart&&!strig){
	playreset=1;
	restart=1;
	strig=1;
	bartrig=1;
	barcount=0;
	prebarC=0;
	currentbar=0;
	}
if (!inlet_restart){
	strig=0;
}






if (inlet_trigger&&!trigtrig){
	trigtrig=1;
	if (!full){
		rechold=1;
		}
	else if (full){
		if (barrecord){
			barhold=1;
			}
		if (!barrecord){
				playhold=1;
			}
		}
	}

	

if (!inlet_trigger){
	trigtrig=0;
}

if (inlet_stop&&!sttrig){
	
		stophold=1;
	
	if (playhold){
		playhold=0;
	}
	sttrig=1;
	
}
if (!inlet_stop){
	sttrig=0;
}

//	if (inlet_play&&!pltrig){
//		if (!barrecord){
//			
//				playhold=1;
//			
//		}
//		else if (barrecord){
//			barhold=1;
//		}
//		pltrig=1;
//	}
//	if (!inlet_play){
//		pltrig=0;
//	}





//128ppq
ppq=dialclock>>20;

if (ppq!=prevppq){
	synclock+=1;
	prevppq=ppq;
}

if (restart){
	Pnotecount=0;
	kcount=0;
	restart=0;
	synclock=0;
quantclock=0;
kquantclock=0;
currentbar=0;




}

if (playreset){
	if (!(clear>=0)){
		Pindex=0;
		}
	
	playreset=0;
	holdscan=0;
	stage=0;
	
	Pstart[0]=0;
	Pstart[1]=0;
	Pstart[2]=0;
	Pstart[3]=0;
	Pstart[4]=0;
	Pstart[5]=0;
	Pstart[6]=0;
	Pstart[7]=0;
	Pstart[8]=0;
	Pstart[9]=0;
	Pstart[10]=0;
	Pstart[11]=0;
	Pstart[12]=0;
	Pstart[13]=0;
	Pstart[14]=0;
	Pstart[15]=0;
	
	Phold[0]=0;
	Plength[0]=-1;
	
	Phold[1]=0;
	Plength[1]=-1;
	
	Phold[2]=0;
	Plength[2]=-1;
	
	Phold[3]=0;
	Plength[3]=-1;
	
	Phold[4]=0;
	Plength[4]=-1;
	
	Phold[5]=0;
	Plength[5]=-1;
	
	Phold[6]=0;
	Plength[6]=-1;
	
	Phold[7]=0;
	Plength[7]=-1;
	
	Phold[8]=0;
	Plength[8]=-1;
	
	Phold[9]=0;
	Plength[9]=-1;
	
	Phold[10]=0;
	Plength[10]=-1;
	
	Phold[11]=0;
	Plength[11]=-1;
	
	Phold[12]=0;
	Plength[12]=-1;
	
	Phold[13]=0;
	Plength[13]=-1;
	
	Phold[14]=0;
	Plength[14]=-1;
	
	
	
	outgate[0]=0;
	outgate[1]=0;
	outgate[2]=0;
	outgate[3]=0;
	outgate[4]=0;
	outgate[5]=0;
	outgate[6]=0;
	outgate[7]=0;
	outgate[8]=0;
	outgate[9]=0;
	outgate[10]=0;
	outgate[11]=0;
	outgate[12]=0;
	outgate[13]=0;
	outgate[14]=0;
	
}





quantclock=synclock/(128/quantize);

halfsync=(128/quantize)>>1;
kquantclock=quantclock*(128/quantize);


if (synclock<(kquantclock+halfsync)){
	early=0;
}
if (synclock>=(kquantclock+halfsync)){
	early=1;
}

if (inlet_record&&!trigr){
	trigr=1;
	if (!barrecord){
		rechold=1;
		
	}
	else if (barrecord){
		barhold=1;
	}
	
}
if (!inlet_record){
	trigr=0;
}




if (rec){
	rec=0;
	currentbar=0;
	barrecord=1;
	maxbar=attr_maxbar;
	Pnotecount=0;
	Pscan=0;
	attr_table.array[currentslot+inlet_offset]=1;
	Rnotecount=0;
	
	prevPindex=-1;
	Pindex=-1;
	
	
	}
	


if (clear>=0){
	if (clear<=clearmax){
		//attr_table.array[inlet_offset+((controloffset+slotsize)*inlet_slot)]=0;
			attr_table.array[clearoffset+(clear<<3) +0]=0;
			attr_table.array[clearoffset+(clear<<3) +1]=0;
			attr_table.array[clearoffset+(clear<<3) +2]=0;
			attr_table.array[clearoffset+(clear<<3) +3]=0;
			if (clearoffset==(offset-controloffset)){
				if (clear<voices){
					Pstart[clear]=0;
					Phold[clear]=0;
					Plength[clear]=-1;
					outgate[clear]=0;
				}
			}
			
			
			clear+=1;
		
			if (clear>=clearmax){
				attr_table.array[inlet_slot+inlet_offset]=0;
				clear=-1;
				}
		}
}



//  recording voice 0 **************************************************************
if (gate[0]&&!gtrig[0]){

	gtrig[0]=1;
	if (quantizeon){
	if (early){
		goffset[0]= ( halfsync - (synclock-(kquantclock+halfsync)));
	}
	if (!early){
		goffset[0]=-(synclock-kquantclock);
	}
	}
	else if (!quantizeon){
		goffset[0]=0;
	}
	if ((synclock+goffset[0])<maxppq){
		gstart[0]=synclock+goffset[0];
		}
	else if ((synclock+goffset[0])>=maxppq){
			gstart[0]=0;
		}
	gnote[0]=noteon[0];
	gvel[0]=vel[0];
	if (recording){
		gon[0]=1;
		
	}
	
	
}

if (!gate[0]&&gtrig[0]){
	gtrig[0]=0;
	if (gon[0]){
		gon[0]=0;
		gend[0]=synclock+goffset[0];
		//stamp note
		if (Rnotecount<maxnotes){
			attr_table.array[offset+(Rnotecount<<3) +0]=gstart[0]+1;
			attr_table.array[offset+(Rnotecount<<3) +1]=gend[0]+1;
			attr_table.array[offset+(Rnotecount<<3) +2]=gnote[0];
			attr_table.array[offset+(Rnotecount<<3) +3]=gvel[0];
			Rnotecount+=1;
			}
		}
	}

//  recording voice 1 **************************************************************
if (gate[1]&&!gtrig[1]){

	gtrig[1]=1;
	if (quantizeon){
	if (early){
		goffset[1]= ( halfsync - (synclock-(kquantclock+halfsync)));
	}
	if (!early){
		goffset[1]=-(synclock-kquantclock);
	}
	}
	else if (!quantizeon){
		goffset[1]=0;
	}
	if ((synclock+goffset[1])<maxppq){
		gstart[1]=synclock+goffset[1];
		}
	else if ((synclock+goffset[1])>=maxppq){
			gstart[1]=0;
		}
	gnote[1]=noteon[1];
	gvel[1]=vel[1];
	if (recording){
		gon[1]=1;
		
	}
	
	
}

if (!gate[1]&&gtrig[1]){
	gtrig[1]=0;
	if (gon[1]){
		gon[1]=0;
		gend[1]=synclock+goffset[1];
		//stamp note
		if (Rnotecount<maxnotes){
			attr_table.array[offset+(Rnotecount<<3) +0]=gstart[1]+1;
			attr_table.array[offset+(Rnotecount<<3) +1]=gend[1]+1;
			attr_table.array[offset+(Rnotecount<<3) +2]=gnote[1];
			attr_table.array[offset+(Rnotecount<<3) +3]=gvel[1];
			Rnotecount+=1;
			}
		}
	}


//  recording voice 1 **************************************************************
if (gate[2]&&!gtrig[2]){

	gtrig[2]=1;
	if (quantizeon){
	if (early){
		goffset[2]= ( halfsync - (synclock-(kquantclock+halfsync)));
	}
	if (!early){
		goffset[2]=-(synclock-kquantclock);
	}
	}
	else if (!quantizeon){
		goffset[2]=0;
	}
	if ((synclock+goffset[2])<maxppq){
		gstart[2]=synclock+goffset[2];
		}
	else if ((synclock+goffset[2])>=maxppq){
			gstart[2]=0;
		}
	gnote[2]=noteon[2];
	gvel[2]=vel[2];
	if (recording){
		gon[2]=1;
		
	}
	
	
}

if (!gate[2]&&gtrig[2]){
	gtrig[2]=0;
	if (gon[2]){
		gon[2]=0;
		gend[2]=synclock+goffset[2];
		//stamp note
		if (Rnotecount<maxnotes){
			attr_table.array[offset+(Rnotecount<<3) +0]=gstart[2]+1;
			attr_table.array[offset+(Rnotecount<<3) +1]=gend[2]+1;
			attr_table.array[offset+(Rnotecount<<3) +2]=gnote[2];
			attr_table.array[offset+(Rnotecount<<3) +3]=gvel[2];
			Rnotecount+=1;
			}
		}
	}

//  recording voice 1 **************************************************************
if (gate[3]&&!gtrig[3]){

	gtrig[3]=1;
	if (quantizeon){
	if (early){
		goffset[3]= ( halfsync - (synclock-(kquantclock+halfsync)));
	}
	if (!early){
		goffset[3]=-(synclock-kquantclock);
	}
	}
	else if (!quantizeon){
		goffset[3]=0;
	}
	if ((synclock+goffset[3])<maxppq){
		gstart[3]=synclock+goffset[3];
		}
	else if ((synclock+goffset[3])>=maxppq){
			gstart[3]=0;
		}
	gnote[3]=noteon[3];
	gvel[3]=vel[3];
	if (recording){
		gon[3]=1;
		
	}
	
	
}

if (!gate[3]&&gtrig[3]){
	gtrig[3]=0;
	if (gon[3]){
		gon[3]=0;
		gend[3]=synclock+goffset[3];
		//stamp note
		if (Rnotecount<maxnotes){
			attr_table.array[offset+(Rnotecount<<3) +0]=gstart[3]+1;
			attr_table.array[offset+(Rnotecount<<3) +1]=gend[3]+1;
			attr_table.array[offset+(Rnotecount<<3) +2]=gnote[3];
			attr_table.array[offset+(Rnotecount<<3) +3]=gvel[3];
			Rnotecount+=1;
			}
		}
	}


//  recording voice 1 **************************************************************
if (gate[4]&&!gtrig[4]){

	gtrig[4]=1;
	if (quantizeon){
	if (early){
		goffset[4]= ( halfsync - (synclock-(kquantclock+halfsync)));
	}
	if (!early){
		goffset[4]=-(synclock-kquantclock);
	}
	}
	else if (!quantizeon){
		goffset[4]=0;
	}
	if ((synclock+goffset[4])<maxppq){
		gstart[4]=synclock+goffset[4];
		}
	else if ((synclock+goffset[4])>=maxppq){
			gstart[4]=0;
		}
	gnote[4]=noteon[4];
	gvel[4]=vel[4];
	if (recording){
		gon[4]=1;
		
	}
	
	
}

if (!gate[4]&&gtrig[4]){
	gtrig[4]=0;
	if (gon[4]){
		gon[4]=0;
		gend[4]=synclock+goffset[4];
		//stamp note
		if (Rnotecount<maxnotes){
			attr_table.array[offset+(Rnotecount<<3) +0]=gstart[4]+1;
			attr_table.array[offset+(Rnotecount<<3) +1]=gend[4]+1;
			attr_table.array[offset+(Rnotecount<<3) +2]=gnote[4];
			attr_table.array[offset+(Rnotecount<<3) +3]=gvel[4];
			Rnotecount+=1;
			}
		}
	}

//  recording voice 1 **************************************************************
if (gate[5]&&!gtrig[5]){

	gtrig[5]=1;
	if (quantizeon){
	if (early){
		goffset[5]= ( halfsync - (synclock-(kquantclock+halfsync)));
	}
	if (!early){
		goffset[5]=-(synclock-kquantclock);
	}
	}
	else if (!quantizeon){
		goffset[5]=0;
	}
	if ((synclock+goffset[5])<maxppq){
		gstart[5]=synclock+goffset[5];
		}
	else if ((synclock+goffset[5])>=maxppq){
			gstart[5]=0;
		}
	gnote[5]=noteon[5];
	gvel[5]=vel[5];
	if (recording){
		gon[5]=1;
		
	}
	
	
}

if (!gate[5]&&gtrig[5]){
	gtrig[5]=0;
	if (gon[5]){
		gon[5]=0;
		gend[5]=synclock+goffset[5];
		//stamp note
		if (Rnotecount<maxnotes){
			attr_table.array[offset+(Rnotecount<<3) +0]=gstart[5]+1;
			attr_table.array[offset+(Rnotecount<<3) +1]=gend[5]+1;
			attr_table.array[offset+(Rnotecount<<3) +2]=gnote[5];
			attr_table.array[offset+(Rnotecount<<3) +3]=gvel[5];
			Rnotecount+=1;
			}
		}
	}

//  recording voice 1 **************************************************************
if (gate[6]&&!gtrig[6]){

	gtrig[6]=1;
	if (quantizeon){
	if (early){
		goffset[6]= ( halfsync - (synclock-(kquantclock+halfsync)));
	}
	if (!early){
		goffset[6]=-(synclock-kquantclock);
	}
	}
	else if (!quantizeon){
		goffset[6]=0;
	}
	if ((synclock+goffset[6])<maxppq){
		gstart[6]=synclock+goffset[6];
		}
	else if ((synclock+goffset[6])>=maxppq){
			gstart[6]=0;
		}
	gnote[6]=noteon[6];
	gvel[6]=vel[6];
	if (recording){
		gon[6]=1;
		
	}
	
	
}

if (!gate[6]&&gtrig[6]){
	gtrig[6]=0;
	if (gon[6]){
		gon[6]=0;
		gend[6]=synclock+goffset[6];
		//stamp note
		if (Rnotecount<maxnotes){
			attr_table.array[offset+(Rnotecount<<3) +0]=gstart[6]+1;
			attr_table.array[offset+(Rnotecount<<3) +1]=gend[6]+1;
			attr_table.array[offset+(Rnotecount<<3) +2]=gnote[6];
			attr_table.array[offset+(Rnotecount<<3) +3]=gvel[6];
			Rnotecount+=1;
			}
		}
	}

//  recording voice 1 **************************************************************
if (gate[7]&&!gtrig[7]){

	gtrig[7]=1;
	if (quantizeon){
	if (early){
		goffset[7]= ( halfsync - (synclock-(kquantclock+halfsync)));
	}
	if (!early){
		goffset[7]=-(synclock-kquantclock);
	}
	}
	else if (!quantizeon){
		goffset[7]=0;
	}
	if ((synclock+goffset[7])<maxppq){
		gstart[7]=synclock+goffset[7];
		}
	else if ((synclock+goffset[7])>=maxppq){
			gstart[7]=0;
		}
	gnote[7]=noteon[7];
	gvel[7]=vel[7];
	if (recording){
		gon[7]=1;
		
	}
	
	
}

if (!gate[7]&&gtrig[7]){
	gtrig[7]=0;
	if (gon[7]){
		gon[7]=0;
		gend[7]=synclock+goffset[7];
		//stamp note
		if (Rnotecount<maxnotes){
			attr_table.array[offset+(Rnotecount<<3) +0]=gstart[7]+1;
			attr_table.array[offset+(Rnotecount<<3) +1]=gend[7]+1;
			attr_table.array[offset+(Rnotecount<<3) +2]=gnote[7];
			attr_table.array[offset+(Rnotecount<<3) +3]=gvel[7];
			Rnotecount+=1;
			}
		}
	}


//  recording voice 1 **************************************************************
if (gate[8]&&!gtrig[8]){

	gtrig[8]=1;
	if (quantizeon){
	if (early){
		goffset[8]= ( halfsync - (synclock-(kquantclock+halfsync)));
	}
	if (!early){
		goffset[8]=-(synclock-kquantclock);
	}
	}
	else if (!quantizeon){
		goffset[8]=0;
	}
	if ((synclock+goffset[8])<maxppq){
		gstart[8]=synclock+goffset[8];
		}
	else if ((synclock+goffset[8])>=maxppq){
			gstart[8]=0;
		}
	gnote[8]=noteon[8];
	gvel[8]=vel[8];
	if (recording){
		gon[8]=1;
		
	}
	
	
}

if (!gate[8]&&gtrig[8]){
	gtrig[8]=0;
	if (gon[8]){
		gon[8]=0;
		gend[8]=synclock+goffset[8];
		//stamp note
		if (Rnotecount<maxnotes){
			attr_table.array[offset+(Rnotecount<<3) +0]=gstart[8]+1;
			attr_table.array[offset+(Rnotecount<<3) +1]=gend[8]+1;
			attr_table.array[offset+(Rnotecount<<3) +2]=gnote[8];
			attr_table.array[offset+(Rnotecount<<3) +3]=gvel[8];
			Rnotecount+=1;
			}
		}
	}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// assign notes to players
if (Pindex>Rnotecount){
	Pindex=0;
}
if ((Pindex!=prevPindex)&&(Pindex>=0)){
	
	prevCstart=Cstart;
	prevCnote=Cnote;
	prevPindex=Pindex;
	if (Pindex==0){
		prevCstart=0;
		prevCnote=0;
	}
	prevCend=Cend;
	Cstart=attr_table.array[offset+(Pindex<<3) +0];
	Cend=attr_table.array[offset+(Pindex<<3) +1];
	Cnote=attr_table.array[offset+(Pindex<<3) +2];
	Cvel=attr_table.array[offset+(Pindex<<3) +3];
	Cindexx=Pindex;

	if ((Cstart>0)&&(Cstart>=prevCstart)){
	assigned=0;
	stage=1;
	holdscan=0;
	}
	else if ((Cstart==0) || (Cstart<prevCstart)){
		Pindex+=1;
		assigned=1;
	}
	if ((Cnote==prevCnote)&&(Cstart==prevCstart)){
		Pindex+=1;
		assigned=1;
	}
	
}
voices=15;
	if (!assigned){
//	check if there's an empty player, if there is, use it
			if (!Phold[holdscan]){
				//Pindex+=1;
		assigned=1;
				assigned=1;
				Phold[holdscan]=1;
				Pstart[holdscan]=Cstart;
				Pend[holdscan]=Cend;
				Pnote[holdscan]=Cnote;
				Pvel[holdscan]=Cvel;
				Cindex[holdscan]=Cindexx;
				holdscan=0;
				Pindex+=1;
				}
			else {
				holdscan+=1;
				if ((holdscan>=voices) || (holdscan>=Rnotecount)){
					holdscan=0;
					}
				}
	}

//check if incoming note is same as playing - 
if (playscan!=prevplayscan){
	if ((gate[inscan] && Phold[playscan] && !outgate[playscan]) && (noteon[inscan]==Pnote[playscan])) {
		mute[playscan]=1;
		}
	if (((!gate[inscan]) && Phold[playscan] && !outgate[playscan]) && (noteon[inscan]==Pnote[playscan])) {
		mute[playscan]=0;
		}
	if ((Phold[playscan] && Phold[playingscan]) && (Pnote[playscan]==Pnote[playingscan])){
			if ((Pstart[playscan]<=Pend[playingscan]) && (Pstart[playscan]>Pstart[playingscan])) {
				test=1;
				attr_table.array[offset+(Cindex[playingscan]<<3) +1]=Pstart[playscan]-2;
				Pmax[playingscan]=(Pstart[playscan]-2)-Pstart[playingscan];
			}
		}
	prevplayscan=playscan;
	}
	
playscan+=1;

if (playscan>=voices){
	playscan=0;
	playingscan+=1;
	inscan+=1;
	if (inscan>8){
		inscan=0;
		}
	if (playingscan>=voices){
		playingscan=0;
		}
	}

	//playback  ===========================================================================	
if (synclock!=prevsynclock){
	if (play){
		
		// play voice 0 **********************************************
		//length
		if (Plength[0]>=0){
			Plength[0]+=1;
			if (Plength[0]>=Pmax[0]){
				Plength[0]=-1;
				Phold[0]=0;
				outgate[0]=0;
				outend[0]=0;
				//clear
				Pstart[0]=0;
				Pend[0]=0;
			}
		}
		//trigger
		if (((synclock)==(Pstart[0]-1))&&(Pstart[0]>0)){
			if (!mute[0]){
				Plength[0]=0;
				if (Pend[0]>Pstart[0]){
					Pmax[0]=Pend[0]-Pstart[0];
				}
				else if (Pend[0]<=Pstart[0]){
					Pmax[0]=(maxppq+Pend[0])-Pstart[0];
				}
				outend[0]=Pend[0];
				outnote[0]=Pnote[0];
				outvel[0]=Pvel[0];
				outgate[0]=1;
				outgateB[0]=0;
				}
			else if (mute[0]){
				Plength[0]=-1;
				Phold[0]=0;
				outgate[0]=0;
				outend[0]=0;
				//clear
				Pstart[0]=0;
				Pend[0]=0;
				mute[0]=0;
				if (overdub&&!reclight){
					attr_table.array[offset+(Cindex[0]<<3) +0]=0;
					attr_table.array[offset+(Cindex[0]<<3) +1]=0;
					attr_table.array[offset+(Cindex[0]<<3) +2]=0;
					attr_table.array[offset+(Cindex[0]<<3) +3]=0;
					}
				}
			}

		// play voice 1 **********************************************
		//length
		if (Plength[1]>=0){
			Plength[1]+=1;
			if (Plength[1]>=Pmax[1]){
				Plength[1]=-1;
				Phold[1]=0;
				outgate[1]=0;
				//clear
				outend[1]=0;
				Pstart[1]=0;
				Pend[1]=0;
				Pnote[1]=0;
				Pvel[1]=0;
				
			}
		}
		//trigger
		if (((synclock)==(Pstart[1]-1))&&(Pstart[1]>0)){
			if (!mute[1]){
				Plength[1]=0;
				if (Pend[1]>Pstart[1]){
					Pmax[1]=Pend[1]-Pstart[1];
				}
				else if (Pend[1]<=Pstart[1]){
					Pmax[1]=(maxppq+Pend[1])-Pstart[1];
				}
				outend[1]=Pend[1];
				outnote[1]=Pnote[1];
				outvel[1]=Pvel[1];
				outgate[1]=1;
				outgateB[1]=0;
				}
			else if (mute[1]){
				Plength[1]=-1;
					Phold[1]=0;
					outgate[1]=0;
					outend[1]=0;
					//clear
					Pstart[1]=0;
					Pend[1]=0;
					mute[1]=0;
					if (overdub&&!reclight){
						attr_table.array[offset+(Cindex[1]<<3) +0]=0;
					attr_table.array[offset+(Cindex[1]<<3) +1]=0;
					attr_table.array[offset+(Cindex[1]<<3) +2]=0;
					attr_table.array[offset+(Cindex[1]<<3) +3]=0;
					}
				}
			}

		// play voice 1 **********************************************
		//length
		if (Plength[2]>=0){
			Plength[2]+=1;
			if (Plength[2]>=Pmax[2]){
				Plength[2]=-1;
				Phold[2]=0;
				outgate[2]=0;
				//clear
				outend[2]=0;
				Pstart[2]=0;
				Pend[2]=0;
				Pnote[2]=0;
				Pvel[2]=0;
				
			}
		}
		//trigger
		if (((synclock)==(Pstart[2]-1))&&(Pstart[2]>0)){
		if (!mute[2]){
			Plength[2]=0;
			if (Pend[2]>Pstart[2]){
				Pmax[2]=Pend[2]-Pstart[2];
			}
			else if (Pend[2]<=Pstart[2]){
				Pmax[2]=(maxppq+Pend[2])-Pstart[2];
			}
			outend[2]=Pend[2];
			outnote[2]=Pnote[2];
			outvel[2]=Pvel[2];
			outgate[2]=1;
			outgateB[2]=0;
			}
		else if (mute[2]){
			Plength[2]=-1;
			Phold[2]=0;
			outgate[2]=0;
			outend[2]=0;
			//clear
			Pstart[2]=0;
			Pend[2]=0;
			mute[2]=0;

			if (overdub&&!reclight){
				attr_table.array[offset+(Cindex[2]<<3) +0]=0;
			attr_table.array[offset+(Cindex[2]<<3) +1]=0;
			attr_table.array[offset+(Cindex[2]<<3) +2]=0;
			attr_table.array[offset+(Cindex[2]<<3) +3]=0;
			}
		}
			}

		// play voice 1 **********************************************
		//length
		if (Plength[3]>=0){
			Plength[3]+=1;
			if (Plength[3]>=Pmax[3]){
				Plength[3]=-1;
				Phold[3]=0;
				outgate[3]=0;
				//clear
				outend[3]=0;
				Pstart[3]=0;
				Pend[3]=0;
				Pnote[3]=0;
				Pvel[3]=0;
				
			}
		}
		//trigger
		if (((synclock)==(Pstart[3]-1))&&(Pstart[3]>0)){
		if (!mute[3]){
			Plength[3]=0;
			if (Pend[3]>Pstart[3]){
				Pmax[3]=Pend[3]-Pstart[3];
			}
			else if (Pend[3]<=Pstart[3]){
				Pmax[3]=(maxppq+Pend[3])-Pstart[3];
			}
			outend[3]=Pend[3];
			outnote[3]=Pnote[3];
			outvel[3]=Pvel[3];
			outgate[3]=1;
			outgateB[3]=0;
			}
		else if (mute[3]){
			Plength[3]=-1;
				Phold[3]=0;
				outgate[3]=0;
				outend[3]=0;
				//clear
				Pstart[3]=0;
				Pend[3]=0;
				mute[3]=0;
				if (overdub&&!reclight){
					attr_table.array[offset+(Cindex[3]<<3) +0]=0;
				attr_table.array[offset+(Cindex[3]<<3) +1]=0;
				attr_table.array[offset+(Cindex[3]<<3) +2]=0;
				attr_table.array[offset+(Cindex[3]<<3) +3]=0;
				}

			
		}
		
		
		}

		// play voice 1 **********************************************
		//length
		if (Plength[4]>=0){
			Plength[4]+=1;
			if (Plength[4]>=Pmax[4]){
				Plength[4]=-1;
				Phold[4]=0;
				outgate[4]=0;
				//clear
				outend[4]=0;
				Pstart[4]=0;
				Pend[4]=0;
				Pnote[4]=0;
				Pvel[4]=0;
				
			}
		}
		//trigger
		if (((synclock)==(Pstart[4]-1))&&(Pstart[4]>0)){
		if (!mute[4]){
			Plength[4]=0;
			if (Pend[4]>Pstart[4]){
				Pmax[4]=Pend[4]-Pstart[4];
			}
			else if (Pend[4]<=Pstart[4]){
				Pmax[4]=(maxppq+Pend[4])-Pstart[4];
			}
			outend[4]=Pend[4];
			outnote[4]=Pnote[4];
			outvel[4]=Pvel[4];
			outgate[4]=1;
			outgateB[4]=0;
			}
		else if (mute[4]){
			Plength[4]=-1;
				Phold[4]=0;
				outgate[4]=0;
				outend[4]=0;
				//clear
				Pstart[4]=0;
				Pend[4]=0;
				mute[4]=0;

				if (overdub&&!reclight){
					attr_table.array[offset+(Cindex[4]<<3) +0]=0;
				attr_table.array[offset+(Cindex[4]<<3) +1]=0;
				attr_table.array[offset+(Cindex[4]<<3) +2]=0;
				attr_table.array[offset+(Cindex[4]<<3) +3]=0;
				}

			
		}
		
		
		}

		// play voice 1 **********************************************
		//length
		if (Plength[5]>=0){
			Plength[5]+=1;
			if (Plength[5]>=Pmax[5]){
				Plength[5]=-1;
				Phold[5]=0;
				outgate[5]=0;
				//clear
				outend[5]=0;
				Pstart[5]=0;
				Pend[5]=0;
				Pnote[5]=0;
				Pvel[5]=0;
				
			}
		}
		//trigger
		if (((synclock)==(Pstart[5]-1))&&(Pstart[5]>0)){
		if (!mute[5]){
			Plength[5]=0;
			if (Pend[5]>Pstart[5]){
				Pmax[5]=Pend[5]-Pstart[5];
			}
			else if (Pend[5]<=Pstart[5]){
				Pmax[5]=(maxppq+Pend[5])-Pstart[5];
			}
			outend[5]=Pend[5];
			outnote[5]=Pnote[5];
			outvel[5]=Pvel[5];
			outgate[5]=1;
			outgateB[5]=0;
			}
		else if (mute[5]){
			Plength[5]=-1;
				Phold[5]=0;
				outgate[5]=0;
				outend[5]=0;
				//clear
				Pstart[5]=0;
				Pend[5]=0;
				mute[5]=0;

				if (overdub&&!reclight){
					attr_table.array[offset+(Cindex[5]<<3) +0]=0;
				attr_table.array[offset+(Cindex[5]<<3) +1]=0;
				attr_table.array[offset+(Cindex[5]<<3) +2]=0;
				attr_table.array[offset+(Cindex[5]<<3) +3]=0;
				}

			
		}
		
		
		}

		// play voice 1 **********************************************
		//length
		if (Plength[6]>=0){
			Plength[6]+=1;
			if (Plength[6]>=Pmax[6]){
				Plength[6]=-1;
				Phold[6]=0;
				outgate[6]=0;
				//clear
				outend[6]=0;
				Pstart[6]=0;
				Pend[6]=0;
				Pnote[6]=0;
				Pvel[6]=0;
				
			}
		}
		//trigger
		if (((synclock)==(Pstart[6]-1))&&(Pstart[6]>0)){
		if (!mute[6]){
			Plength[6]=0;
			if (Pend[6]>Pstart[6]){
				Pmax[6]=Pend[6]-Pstart[6];
			}
			else if (Pend[6]<=Pstart[6]){
				Pmax[6]=(maxppq+Pend[6])-Pstart[6];
			}
			outend[6]=Pend[6];
			outnote[6]=Pnote[6];
			outvel[6]=Pvel[6];
			outgate[6]=1;
			outgateB[6]=0;
			}
		else if (mute[6]){
			Plength[6]=-1;
				Phold[6]=0;
				outgate[6]=0;
				outend[6]=0;
				//clear
				Pstart[6]=0;
				Pend[6]=0;
				mute[6]=0;

				if (overdub&&!reclight){
					attr_table.array[offset+(Cindex[6]<<3) +0]=0;
				attr_table.array[offset+(Cindex[6]<<3) +1]=0;
				attr_table.array[offset+(Cindex[6]<<3) +2]=0;
				attr_table.array[offset+(Cindex[6]<<3) +3]=0;
				}

			
		}
		
		
		}
		// play voice 1 **********************************************
		//length
		if (Plength[7]>=0){
			Plength[7]+=1;
			if (Plength[7]>=Pmax[7]){
				Plength[7]=-1;
				Phold[7]=0;
				outgate[7]=0;
				//clear
				outend[7]=0;
				Pstart[7]=0;
				Pend[7]=0;
				Pnote[7]=0;
				Pvel[7]=0;
				
			}
		}
		//trigger
		if (((synclock)==(Pstart[7]-1))&&(Pstart[7]>0)){
		if (!mute[7]){
			Plength[7]=0;
			if (Pend[7]>Pstart[7]){
				Pmax[7]=Pend[7]-Pstart[7];
			}
			else if (Pend[7]<=Pstart[7]){
				Pmax[7]=(maxppq+Pend[7])-Pstart[7];
			}
			outend[7]=Pend[7];
			outnote[7]=Pnote[7];
			outvel[7]=Pvel[7];
			outgate[7]=1;
			outgateB[7]=0;
			}
		else if (mute[7]){
			Plength[7]=-1;
				Phold[7]=0;
				outgate[7]=0;
				outend[7]=0;
				//clear
				Pstart[7]=0;
				Pend[7]=0;
				mute[7]=0;

				if (overdub&&!reclight){
					attr_table.array[offset+(Cindex[7]<<3) +0]=0;
				attr_table.array[offset+(Cindex[7]<<3) +1]=0;
				attr_table.array[offset+(Cindex[7]<<3) +2]=0;
				attr_table.array[offset+(Cindex[7]<<3) +3]=0;
				}

			
		}
		
		
		}


		// play voice 1 **********************************************
		//length
		if (Plength[8]>=0){
			Plength[8]+=1;
			if (Plength[8]>=Pmax[8]){
				Plength[8]=-1;
				Phold[8]=0;
				outgate[8]=0;
				//clear
				outend[8]=0;
				Pstart[8]=0;
				Pend[8]=0;
				Pnote[8]=0;
				Pvel[8]=0;
				
			}
		}
		//trigger
		if (((synclock)==(Pstart[8]-1))&&(Pstart[8]>0)){
		if (!mute[8]){
			Plength[8]=0;
			if (Pend[8]>Pstart[8]){
				Pmax[8]=Pend[8]-Pstart[8];
			}
			else if (Pend[8]<=Pstart[8]){
				Pmax[8]=(maxppq+Pend[8])-Pstart[8];
			}
			outend[8]=Pend[8];
			outnote[8]=Pnote[8];
			outvel[8]=Pvel[8];
			outgate[8]=1;
			outgateB[8]=0;
			}
		else if (mute[8]){
			Plength[8]=-1;
				Phold[8]=0;
				outgate[8]=0;
				outend[8]=0;
				//clear
				Pstart[8]=0;
				Pend[8]=0;
				mute[8]=0;

				if (overdub&&!reclight){
					attr_table.array[offset+(Cindex[8]<<3) +0]=0;
				attr_table.array[offset+(Cindex[8]<<3) +1]=0;
				attr_table.array[offset+(Cindex[8]<<3) +2]=0;
				attr_table.array[offset+(Cindex[8]<<3) +3]=0;
				}

			
		}
		
		
		}

		// play voice 1 **********************************************
		//length
		if (Plength[9]>=0){
			Plength[9]+=1;
			if (Plength[9]>=Pmax[9]){
				Plength[9]=-1;
				Phold[9]=0;
				outgate[9]=0;
				//clear
				outend[9]=0;
				Pstart[9]=0;
				Pend[9]=0;
				Pnote[9]=0;
				Pvel[9]=0;
				
			}
		}
		//trigger
		if (((synclock)==(Pstart[9]-1))&&(Pstart[9]>0)){
			
		if (!mute[9]){
			Plength[9]=0;
			if (Pend[9]>Pstart[9]){
				Pmax[9]=Pend[9]-Pstart[9];
			}
			else if (Pend[9]<=Pstart[9]){
				Pmax[9]=(maxppq+Pend[9])-Pstart[9];
			}
			outend[9]=Pend[9];
			outnote[9]=Pnote[9];
			outvel[9]=Pvel[9];
			outgate[9]=1;
			outgateB[9]=0;
			}
		else if (mute[9]){
			Plength[9]=-1;
				Phold[9]=0;
				outgate[9]=0;
				outend[9]=0;
				//clear
				Pstart[9]=0;
				Pend[9]=0;
				mute[9]=0;

				if (overdub&&!reclight){
					attr_table.array[offset+(Cindex[9]<<3) +0]=0;
				attr_table.array[offset+(Cindex[9]<<3) +1]=0;
				attr_table.array[offset+(Cindex[9]<<3) +2]=0;
				attr_table.array[offset+(Cindex[9]<<3) +3]=0;
				}
		}
		}
		

		// play voice 1 **********************************************
		//length
		if (Plength[10]>=0){
			Plength[10]+=1;
			if (Plength[10]>=Pmax[10]){
				Plength[10]=-1;
				Phold[10]=0;
				outgate[10]=0;
				//clear
				outend[10]=0;
				Pstart[10]=0;
				Pend[10]=0;
				Pnote[10]=0;
				Pvel[10]=0;
				
			}
		}
		//trigger
		if (((synclock)==(Pstart[10]-1))&&(Pstart[10]>0)){
		if (!mute[10]){
			Plength[10]=0;
			if (Pend[10]>Pstart[10]){
				Pmax[10]=Pend[10]-Pstart[10];
			}
			else if (Pend[10]<=Pstart[10]){
				Pmax[10]=(maxppq+Pend[10])-Pstart[10];
			}
			outend[10]=Pend[10];
			outnote[10]=Pnote[10];
			outvel[10]=Pvel[10];
			outgate[10]=1;
			outgateB[10]=0;
			}
		else if (mute[10]){
			Plength[10]=-1;
				Phold[10]=0;
				outgate[10]=0;
				outend[10]=0;
				//clear
				Pstart[10]=0;
				Pend[10]=0;
				mute[10]=0;

				if (overdub&&!reclight){
					attr_table.array[offset+(Cindex[10]<<3) +0]=0;
				attr_table.array[offset+(Cindex[10]<<3) +1]=0;
				attr_table.array[offset+(Cindex[10]<<3) +2]=0;
				attr_table.array[offset+(Cindex[10]<<3) +3]=0;
				}

			
		}
		
		
		}

		// play voice 1 **********************************************
		//length
		if (Plength[11]>=0){
			Plength[11]+=1;
			if (Plength[11]>=Pmax[11]){
				Plength[11]=-1;
				Phold[11]=0;
				outgate[11]=0;
				//clear
				outend[11]=0;
				Pstart[11]=0;
				Pend[11]=0;
				Pnote[11]=0;
				Pvel[11]=0;
				
			}
		}
		//trigger
		if (((synclock)==(Pstart[11]-1))&&(Pstart[11]>0)){
		if (!mute[11]){
			Plength[11]=0;
			if (Pend[11]>Pstart[11]){
				Pmax[11]=Pend[11]-Pstart[11];
			}
			else if (Pend[11]<=Pstart[11]){
				Pmax[11]=(maxppq+Pend[11])-Pstart[11];
			}
			outend[11]=Pend[11];
			outnote[11]=Pnote[11];
			outvel[11]=Pvel[11];
			outgate[11]=1;
			outgateB[11]=0;
			}
		else if (mute[11]){
			Plength[11]=-1;
				Phold[11]=0;
				outgate[11]=0;
				outend[11]=0;
				//clear
				Pstart[11]=0;
				Pend[11]=0;
				mute[11]=0;

				if (overdub&&!reclight){
					attr_table.array[offset+(Cindex[11]<<3) +0]=0;
				attr_table.array[offset+(Cindex[11]<<3) +1]=0;
				attr_table.array[offset+(Cindex[11]<<3) +2]=0;
				attr_table.array[offset+(Cindex[11]<<3) +3]=0;
				}

			
		}
		
		
		}

		// play voice 1 **********************************************
		//length
		if (Plength[12]>=0){
			Plength[12]+=1;
			if (Plength[12]>=Pmax[12]){
				Plength[12]=-1;
				Phold[12]=0;
				outgate[12]=0;
				//clear
				outend[12]=0;
				Pstart[12]=0;
				Pend[12]=0;
				Pnote[12]=0;
				Pvel[12]=0;
				
			}
		}
		//trigger
		if (((synclock)==(Pstart[12]-1))&&(Pstart[12]>0)){
		if (!mute[12]){
			Plength[12]=0;
			if (Pend[12]>Pstart[12]){
				Pmax[12]=Pend[12]-Pstart[12];
			}
			else if (Pend[12]<=Pstart[12]){
				Pmax[12]=(maxppq+Pend[12])-Pstart[12];
			}
			outend[12]=Pend[12];
			outnote[12]=Pnote[12];
			outvel[12]=Pvel[12];
			outgate[12]=1;
			outgateB[12]=0;
			}
		else if (mute[12]){
			Plength[12]=-1;
				Phold[12]=0;
				outgate[12]=0;
				outend[12]=0;
				//clear
				Pstart[12]=0;
				Pend[12]=0;
				mute[12]=0;

				if (overdub&&!reclight){
					attr_table.array[offset+(Cindex[12]<<3) +0]=0;
				attr_table.array[offset+(Cindex[12]<<3) +1]=0;
				attr_table.array[offset+(Cindex[12]<<3) +2]=0;
				attr_table.array[offset+(Cindex[12]<<3) +3]=0;
				}

			
		}
		
		
		}

		// play voice 1 **********************************************
		//length
		if (Plength[13]>=0){
			Plength[13]+=1;
			if (Plength[13]>=Pmax[13]){
				Plength[13]=-1;
				Phold[13]=0;
				outgate[13]=0;
				//clear
				outend[13]=0;
				Pstart[13]=0;
				Pend[13]=0;
				Pnote[13]=0;
				Pvel[13]=0;
				
			}
		}
		//trigger
		if (((synclock)==(Pstart[13]-1))&&(Pstart[13]>0)){
			//Pindex+=1;
		if (!mute[13]){
			Plength[13]=0;
			if (Pend[13]>Pstart[13]){
				Pmax[13]=Pend[13]-Pstart[13];
			}
			else if (Pend[13]<=Pstart[13]){
				Pmax[13]=(maxppq+Pend[13])-Pstart[13];
			}
			outend[13]=Pend[13];
			outnote[13]=Pnote[13];
			outvel[13]=Pvel[13];
			outgate[13]=1;
			outgateB[13]=0;
			}
		else if (mute[13]){
			Plength[13]=-1;
				Phold[13]=0;
				outgate[13]=0;
				outend[13]=0;
				//clear
				Pstart[13]=0;
				Pend[13]=0;
				mute[13]=0;

				if (overdub&&!reclight){
					attr_table.array[offset+(Cindex[13]<<3) +0]=0;
				attr_table.array[offset+(Cindex[13]<<3) +1]=0;
				attr_table.array[offset+(Cindex[13]<<3) +2]=0;
				attr_table.array[offset+(Cindex[13]<<3) +3]=0;
				}

			
		}
		
		
		}
		// play voice 1 **********************************************
		//length
		if (Plength[14]>=0){
			Plength[14]+=1;
			if (Plength[14]>=Pmax[14]){
				Plength[14]=-1;
				Phold[14]=0;
				outgate[14]=0;
				//clear
				outend[14]=0;
				Pstart[14]=0;
				Pend[14]=0;
				Pnote[14]=0;
				Pvel[14]=0;
				
			}
		}
		//trigger
		if (((synclock)==(Pstart[14]-1))&&(Pstart[14]>0)){
			//Pindex+=1;
		if (!mute[14]){
			Plength[14]=0;
			if (Pend[14]>Pstart[14]){
				Pmax[14]=Pend[14]-Pstart[14];
			}
			else if (Pend[14]<=Pstart[14]){
				Pmax[14]=(maxppq+Pend[14])-Pstart[14];
			}
			outend[14]=Pend[14];
			outnote[14]=Pnote[14];
			outvel[14]=Pvel[14];
			outgate[14]=1;
			outgateB[14]=0;
			}
		else if (mute[14]){
			Plength[14]=-1;
				Phold[14]=0;
				outgate[14]=0;
				outend[14]=0;
				//clear
				Pstart[14]=0;
				Pend[14]=0;
				mute[14]=0;

				if (overdub&&!reclight){
					attr_table.array[offset+(Cindex[14]<<3) +0]=0;
				attr_table.array[offset+(Cindex[14]<<3) +1]=0;
				attr_table.array[offset+(Cindex[14]<<3) +2]=0;
				attr_table.array[offset+(Cindex[14]<<3) +3]=0;
				}

			
		}
		
		
		}

		

		/////////////////////////
	}
prevsynclock=synclock;
}



// reorder notes for overdubbing
if (scan!=prevscan){
	
	if (scan!=(Rnotecount+2)){
			//scan counting down from last note! 
	
		//swap backwards, earlier earlier - notes in ascending order
		
		if (  ((attr_table.array[offset+(scan<<3) +0])>(attr_table.array[offset+(prevscan<<3) +0]))
			&&
			((attr_table.array[offset+(scan<<3) +0]) !=0 )
			&&
			((attr_table.array[offset+(prevscan<<3) +0]) !=0 ) )
		
			
			{
				tempS=attr_table.array[offset+(prevscan<<3) +0];
				tempE=attr_table.array[offset+(prevscan<<3) +1];
				tempN=attr_table.array[offset+(prevscan<<3) +2];
				tempV=attr_table.array[offset+(prevscan<<3) +3];
	
				attr_table.array[offset+(prevscan<<3) +0] = attr_table.array[offset+(scan<<3) +0];
				attr_table.array[offset+(prevscan<<3) +1] = attr_table.array[offset+(scan<<3) +1];
				attr_table.array[offset+(prevscan<<3) +2] = attr_table.array[offset+(scan<<3) +2];
				attr_table.array[offset+(prevscan<<3) +3] = attr_table.array[offset+(scan<<3) +3];
	
				attr_table.array[offset+(scan<<3) +0]=tempS;
				attr_table.array[offset+(scan<<3) +1]=tempE;
				attr_table.array[offset+(scan<<3) +2]=tempN;
				attr_table.array[offset+(scan<<3) +3]=tempV;
				busy=1;
			}

			//if two notes at same position and same note, delete old note
		else if (((attr_table.array[offset+(scan<<3) +0])==(attr_table.array[offset+(prevscan<<3) +0]))
			&& ((attr_table.array[offset+(scan<<3) +2])==(attr_table.array[offset+(prevscan<<3) +2]))
			&&
			((attr_table.array[offset+(scan<<3) +0]) !=0 )
			&&
			((attr_table.array[offset+(prevscan<<3) +0]) !=0 ) )
				{
				attr_table.array[offset+(scan<<3) +0]=0;
				attr_table.array[offset+(scan<<3) +1]=0;
				attr_table.array[offset+(scan<<3) +2]=0;
				attr_table.array[offset+(scan<<3) +3]=0;
				busy=1;
				}
				//swap 0 values other way to move deleted notes out of list
		if ( ((attr_table.array[offset+(scan<<3) +0]) ==0 ) && ((attr_table.array[offset+(prevscan<<3) +0]) !=0 ) ){
				attr_table.array[offset+(scan<<3) +0] = attr_table.array[offset+(prevscan<<3) +0];
				attr_table.array[offset+(scan<<3) +1] = attr_table.array[offset+(prevscan<<3) +1];
				attr_table.array[offset+(scan<<3) +2] = attr_table.array[offset+(prevscan<<3) +2];
				attr_table.array[offset+(scan<<3) +3] = attr_table.array[offset+(prevscan<<3) +3];
				attr_table.array[offset+(prevscan<<3) +0]=0;
				attr_table.array[offset+(prevscan<<3) +1]=0;
				attr_table.array[offset+(prevscan<<3) +2]=0;
				attr_table.array[offset+(prevscan<<3) +3]=0;
				busy=1;
					}
	}
	prevscan=scan;
	
}

scan-=1;
scanmax=Rnotecount;
if (scan<0){
	scan=Rnotecount;
	prevscan=Rnotecount+1;
}






//triggermidi voice 0 ===========================================
if (outgateB[0]!=prevoutgate[0]){
	

	if (outgateB[0]){
		MidiSend3((midi_device_t) attr_output, MIDI_NOTE_ON + (attr_channel-1),outnote[0],outvel[0]);  
	}
	else if (!outgateB[0]){
		MidiSend3((midi_device_t) attr_output, MIDI_NOTE_OFF + (attr_channel-1),outnote[0],outvel[0]);
	}
	
	prevoutgate[0]=outgateB[0];
}

//triggermidi voice 1  ============================================
if (outgateB[1]!=prevoutgate[1]){
	

	if (outgateB[1]){
		MidiSend3((midi_device_t) attr_output, MIDI_NOTE_ON + (attr_channel-1),outnote[1],outvel[1]);  
	}
	else if (!outgateB[1]){
		MidiSend3((midi_device_t) attr_output, MIDI_NOTE_OFF + (attr_channel-1),outnote[1],outvel[1]);
	}
	
	prevoutgate[1]=outgateB[1];
}

//triggermidi voice 1  ============================================
if (outgateB[2]!=prevoutgate[2]){
	

	if (outgateB[2]){
		MidiSend3((midi_device_t) attr_output, MIDI_NOTE_ON + (attr_channel-1),outnote[2],outvel[2]);  
	}
	else if (!outgateB[2]){
		MidiSend3((midi_device_t) attr_output, MIDI_NOTE_OFF + (attr_channel-1),outnote[2],outvel[2]);
	}
	
	prevoutgate[2]=outgateB[2];
}

//triggermidi voice 1  ============================================
if (outgateB[3]!=prevoutgate[3]){
	

	if (outgateB[3]){
		MidiSend3((midi_device_t) attr_output, MIDI_NOTE_ON + (attr_channel-1),outnote[3],outvel[3]);  
	}
	else if (!outgateB[3]){
		MidiSend3((midi_device_t) attr_output, MIDI_NOTE_OFF + (attr_channel-1),outnote[3],outvel[3]);
	}
	
	prevoutgate[3]=outgateB[3];
}

//triggermidi voice 1  ============================================
if (outgateB[4]!=prevoutgate[4]){
	

	if (outgateB[4]){
		MidiSend3((midi_device_t) attr_output, MIDI_NOTE_ON + (attr_channel-1),outnote[4],outvel[4]);  
	}
	else if (!outgateB[4]){
		MidiSend3((midi_device_t) attr_output, MIDI_NOTE_OFF + (attr_channel-1),outnote[4],outvel[4]);
	}
	
	prevoutgate[4]=outgateB[4];
}

//triggermidi voice 1  ============================================
if (outgateB[5]!=prevoutgate[5]){
	

	if (outgateB[5]){
		MidiSend3((midi_device_t) attr_output, MIDI_NOTE_ON + (attr_channel-1),outnote[5],outvel[5]);  
	}
	else if (!outgateB[5]){
		MidiSend3((midi_device_t) attr_output, MIDI_NOTE_OFF + (attr_channel-1),outnote[5],outvel[5]);
	}
	
	prevoutgate[5]=outgateB[5];
}

//triggermidi voice 1  ============================================
if (outgateB[6]!=prevoutgate[6]){
	

	if (outgateB[6]){
		MidiSend3((midi_device_t) attr_output, MIDI_NOTE_ON + (attr_channel-1),outnote[6],outvel[6]);  
	}
	else if (!outgateB[6]){
		MidiSend3((midi_device_t) attr_output, MIDI_NOTE_OFF + (attr_channel-1),outnote[6],outvel[6]);
	}
	
	prevoutgate[6]=outgateB[6];
}

//triggermidi voice 1  ============================================
if (outgateB[7]!=prevoutgate[7]){
	

	if (outgateB[7]){
		MidiSend3((midi_device_t) attr_output, MIDI_NOTE_ON + (attr_channel-1),outnote[7],outvel[7]);  
	}
	else if (!outgateB[7]){
		MidiSend3((midi_device_t) attr_output, MIDI_NOTE_OFF + (attr_channel-1),outnote[7],outvel[7]);
	}
	
	prevoutgate[7]=outgateB[7];
}

//triggermidi voice 1  ============================================
if (outgateB[8]!=prevoutgate[8]){
	

	if (outgateB[8]){
		MidiSend3((midi_device_t) attr_output, MIDI_NOTE_ON + (attr_channel-1),outnote[8],outvel[8]);  
	}
	else if (!outgateB[8]){
		MidiSend3((midi_device_t) attr_output, MIDI_NOTE_OFF + (attr_channel-1),outnote[8],outvel[8]);
	}
	
	prevoutgate[8]=outgateB[8];
}

//triggermidi voice 1  ============================================
if (outgateB[9]!=prevoutgate[9]){
	

	if (outgateB[9]){
		MidiSend3((midi_device_t) attr_output, MIDI_NOTE_ON + (attr_channel-1),outnote[9],outvel[9]);  
	}
	else if (!outgateB[9]){
		MidiSend3((midi_device_t) attr_output, MIDI_NOTE_OFF + (attr_channel-1),outnote[9],outvel[9]);
	}
	
	prevoutgate[9]=outgateB[9];
}

//triggermidi voice 1  ============================================
if (outgateB[10]!=prevoutgate[10]){
	

	if (outgateB[10]){
		MidiSend3((midi_device_t) attr_output, MIDI_NOTE_ON + (attr_channel-1),outnote[10],outvel[10]);  
	}
	else if (!outgateB[10]){
		MidiSend3((midi_device_t) attr_output, MIDI_NOTE_OFF + (attr_channel-1),outnote[10],outvel[10]);
	}
	
	prevoutgate[10]=outgateB[10];
}

//triggermidi voice 1  ============================================
if (outgateB[11]!=prevoutgate[11]){
	

	if (outgateB[11]){
		MidiSend3((midi_device_t) attr_output, MIDI_NOTE_ON + (attr_channel-1),outnote[11],outvel[11]);  
	}
	else if (!outgateB[11]){
		MidiSend3((midi_device_t) attr_output, MIDI_NOTE_OFF + (attr_channel-1),outnote[11],outvel[11]);
	}
	
	prevoutgate[11]=outgateB[11];
}

//triggermidi voice 1  ============================================
if (outgateB[12]!=prevoutgate[12]){
	

	if (outgateB[12]){
		MidiSend3((midi_device_t) attr_output, MIDI_NOTE_ON + (attr_channel-1),outnote[12],outvel[12]);  
	}
	else if (!outgateB[12]){
		MidiSend3((midi_device_t) attr_output, MIDI_NOTE_OFF + (attr_channel-1),outnote[12],outvel[12]);
	}
	
	prevoutgate[12]=outgateB[12];
}

//triggermidi voice 1  ============================================
if (outgateB[13]!=prevoutgate[13]){
	

	if (outgateB[13]){
		MidiSend3((midi_device_t) attr_output, MIDI_NOTE_ON + (attr_channel-1),outnote[13],outvel[13]);  
	}
	else if (!outgateB[13]){
		MidiSend3((midi_device_t) attr_output, MIDI_NOTE_OFF + (attr_channel-1),outnote[13],outvel[13]);
	}
	
	prevoutgate[13]=outgateB[13];
}

//triggermidi voice 1  ============================================
if (outgateB[14]!=prevoutgate[14]){
	

	if (outgateB[14]){
		MidiSend3((midi_device_t) attr_output, MIDI_NOTE_ON + (attr_channel-1),outnote[14],outvel[14]);  
	}
	else if (!outgateB[14]){
		MidiSend3((midi_device_t) attr_output, MIDI_NOTE_OFF + (attr_channel-1),outnote[14],outvel[14]);
	}
	
	prevoutgate[14]=outgateB[14];
}





outlet_bartrig=bartrig;
if (stophold||playhold||rechold||barhold){
	wait=1;
}
if (!stophold&&!playhold&&!rechold&&!barhold){
	wait=0;
	
}


if (Rnotecount!=prevRnote){

	prevRnote=Rnotecount;
 attr_table.array[countoffset]=Rnotecount;
}
if (maxbar!=prevmaxbar){

	prevmaxbar=maxbar;
 attr_table.array[countoffset+1]=maxbar;
}
if (!reclight){
outlet_overdub=overdub;
}
if (reclight){
outlet_overdub=0;
}
outlet_record=reclight;
outlet_play=play;
outlet_maxnotes=maxnotes;
outlet_slotnotes=Rnotecount;
outlet_currentslot=currentslot;
outlet_full=full;
outlet_wait=wait;
if (play){
	synclocko=synclock;
}
else {synclocko=-1;}

outlet_synclock=synclocko;
if (!wait&&!play&&!reclight){
	playstate=0;
	}
else if (play&&!reclight&&!wait) {
	playstate=1;
}
else if (play&&reclight&&!wait){
	playstate=2;
}
if (wait){
	playstate=3;
}
outlet_playstate=playstate;

outgateB[0]=outgate[0];
outgateB[1]=outgate[1];
outgateB[2]=outgate[2];
outgateB[3]=outgate[3];
outgateB[4]=outgate[4];
outgateB[5]=outgate[5];
outgateB[6]=outgate[6];
outgateB[7]=outgate[7];
outgateB[8]=outgate[8];
outgateB[9]=outgate[9];
outgateB[10]=outgate[10];
outgateB[11]=outgate[11];
outgateB[12]=outgate[12];
outgateB[13]=outgate[13];
outgateB[14]=outgate[14];


prebartrig=0;
bartrig=0;
recend=0;
busy=0;]]></code.krate>
         <code.midihandler><![CDATA[if (attr_input){
if ((status == MIDI_NOTE_ON + (attr_channel-1)) && (data2)) {

currentin=data1;
	
	
	if (!gate[0]){
		gate[0]=1;
		vel[0]=data2;
		noteon[0]=data1;
	}
	else if (!gate[1]){
		gate[1]=1;
		vel[1]=data2;
		noteon[1]=data1;
	}
	else if (!gate[2]){
		gate[2]=1;
		vel[2]=data2;
		noteon[2]=data1;
	}
	else if (!gate[3]){
		gate[3]=1;
		vel[3]=data2;
		noteon[3]=data1;
	}
	else if (!gate[4]){
		gate[4]=1;
		vel[4]=data2;
		noteon[4]=data1;
	}
	else if (!gate[5]){
		gate[5]=1;
		vel[5]=data2;
		noteon[5]=data1;
	}
	else if (!gate[6]){
		gate[6]=1;
		vel[6]=data2;
		noteon[6]=data1;
	}
	else if (!gate[7]){
		gate[7]=1;
		vel[7]=data2;
		noteon[7]=data1;
	}
	else if (!gate[8]){
		gate[8]=1;
		vel[8]=data2;
		noteon[8]=data1;
	}
	
	
	
	



	
	on=1;
	
	
	


} else if (((status == MIDI_NOTE_ON + (attr_channel-1)) && (!data2))||
          (status == MIDI_NOTE_OFF + (attr_channel-1))) {
          	off=1;
          	

          	if ((gate[0]>0) && (noteon[0]==(data1))){
          		gate[0]=0;
          		
          		
          	}

          	else if ((gate[1]>0) && (noteon[1]==(data1))){
          		gate[1]=0;
          		
          		
          		
          	}

          	else if ((gate[2]>0) && (noteon[2]==(data1))){
          		gate[2]=0;
          		
          		
          	}

          	else if ((gate[3]>0) && (noteon[3]==(data1))){
          		gate[3]=0;
          		
          		
          	}
          	else if ((gate[4]>0) && (noteon[4]==(data1))){
          		gate[4]=0;
          		
          		
          	}
          	else if ((gate[5]>0) && (noteon[5]==(data1))){
          		gate[5]=0;
          		
          		
          	}
          	else if ((gate[6]>0) && (noteon[6]==(data1))){
          		gate[6]=0;
          		
          		
          	}
          	else if ((gate[7]>0) && (noteon[7]==(data1))){
          		gate[7]=0;
          		
          		
          	}
          	else if ((gate[8]>0) && (noteon[8]==(data1))){
          		gate[8]=0;
          		
          		
          	}
          	
          	
          	
          	
			
          }

          	

}]]></code.midihandler>
      </object>
   </patchobj>
   <comment type="patch/comment" x="518" y="588" text="waiting"/>
   <comment type="patch/comment" x="616" y="588" text="overdub"/>
   <comment type="patch/comment" x="714" y="588" text="record"/>
   <comment type="patch/comment" x="812" y="588" text="play"/>
   <comment type="patch/comment" x="924" y="588" text="playing slot"/>
   <obj type="disp/bool" uuid="a0ee71d48208b71752cbb8c05e55145106ef3946" name="bool_27" x="518" y="602">
      <params/>
      <attribs/>
   </obj>
   <obj type="disp/bool" uuid="a0ee71d48208b71752cbb8c05e55145106ef3946" name="bool_3" x="616" y="602">
      <params/>
      <attribs/>
   </obj>
   <obj type="disp/bool" uuid="a0ee71d48208b71752cbb8c05e55145106ef3946" name="bool_4" x="714" y="602">
      <params/>
      <attribs/>
   </obj>
   <obj type="disp/bool" uuid="a0ee71d48208b71752cbb8c05e55145106ef3946" name="bool_26" x="812" y="602">
      <params/>
      <attribs/>
   </obj>
   <obj type="disp/i" uuid="5e35fd0c62d81e70017289250cf28edd26e19e4a" name="i_1" x="938" y="602">
      <params/>
      <attribs/>
   </obj>
   <obj type="string/c" uuid="4aa90a90c435a742ddfa152d232883fc5b2f1b3" name="c_1" x="1428" y="630">
      <params/>
      <attribs>
         <table attributeName="str" table="/midiloop"/>
      </attribs>
   </obj>
   <comment type="patch/comment" x="630" y="686" text="max notes per slot"/>
   <comment type="patch/comment" x="742" y="686" text="amount of notesrecorded in slot"/>
   <comment type="patch/comment" x="938" y="686" text="128ppq clock that follows the clip"/>
   <comment type="patch/comment" x="1148" y="686" text="playstate - 0=stopped, 1=play, 2= record, 3= waiting"/>
   <obj type="disp/i" uuid="5e35fd0c62d81e70017289250cf28edd26e19e4a" name="i_16" x="630" y="700">
      <params/>
      <attribs/>
   </obj>
   <obj type="disp/i" uuid="5e35fd0c62d81e70017289250cf28edd26e19e4a" name="i_9" x="770" y="700">
      <params/>
      <attribs/>
   </obj>
   <obj type="disp/i" uuid="5e35fd0c62d81e70017289250cf28edd26e19e4a" name="i_10" x="980" y="700">
      <params/>
      <attribs/>
   </obj>
   <obj type="disp/i" uuid="5e35fd0c62d81e70017289250cf28edd26e19e4a" name="i_3" x="1148" y="700">
      <params/>
      <attribs/>
   </obj>
   <obj type="table/save" uuid="3e4108b607d56d9e1cd10abb898b58eea11e53b2" name="save_1" x="1456" y="700">
      <params/>
      <attribs>
         <objref attributeName="table" obj="midiloop"/>
      </attribs>
   </obj>
   <comment type="patch/comment" x="462" y="798" text="cc , channel touch, bend rcording/playback"/>
   <patchobj type="patch/object" uuid="fe4a74a0-f685-4f99-b2bf-4a4aeff9878b" name="1_2" x="462" y="812">
      <params/>
      <attribs>
         <combo attributeName="input" selection="din"/>
         <combo attributeName="output" selection="internal port 1"/>
         <spinner attributeName="channel" value="7"/>
         <spinner attributeName="maxbar" value="8"/>
         <objref attributeName="table" obj="midiloop"/>
         <spinner attributeName="maxslots" value="7"/>
      </attribs>
      <object id="patch/object" uuid="fe4a74a0-f685-4f99-b2bf-4a4aeff9878b">
         <sDescription>object that records pitch bend, after touch and midi CCs.
for use with the midi looper objects.
could be used standalone, inlet stepunQCC expects a clock running at 96ppq</sDescription>
         <author>Mattilyn Mattroe</author>
         <license>if you use the object to play a wedding in september you have to come round and fix the dodgy extractor fan in my bathroom. otherwise, do as you will</license>
         <helpPatch>midi looper help.axh</helpPatch>
         <inlets>
            <int32 name="offset"/>
            <int32 name="slot"/>
            <int32 name="synclock"/>
            <bool32 name="rec"/>
            <bool32 name="play"/>
            <bool32 name="reset"/>
            <bool32 name="overdub"/>
            <bool32 name="clear"/>
            <int32 name="cslot"/>
         </inlets>
         <outlets>
            <int32 name="offset"/>
         </outlets>
         <displays/>
         <params/>
         <attribs>
            <combo name="input">
               <MenuEntries>
                  <string>omni</string>
                  <string>din</string>
                  <string>usb host port 1</string>
                  <string>usb host port 2</string>
                  <string>usb host port 3</string>
                  <string>usb host port 4</string>
                  <string>internal port 1</string>
                  <string>internal port 2</string>
                  <string>usb device port 1</string>
               </MenuEntries>
               <CEntries>
                  <string>true</string>
                  <string>dev == MIDI_DEVICE_DIN &amp;&amp; port == 1</string>
                  <string>dev == MIDI_DEVICE_USB_HOST &amp;&amp; port == 1</string>
                  <string>dev == MIDI_DEVICE_USB_HOST &amp;&amp; port == 2</string>
                  <string>dev == MIDI_DEVICE_USB_HOST &amp;&amp; port == 3</string>
                  <string>dev == MIDI_DEVICE_USB_HOST &amp;&amp; port == 4</string>
                  <string>dev == MIDI_DEVICE_INTERNAL &amp;&amp; port == 1</string>
                  <string>dev == MIDI_DEVICE_INTERNAL &amp;&amp; port == 2</string>
                  <string>dev == MIDI_DEVICE_USB_DEVICE &amp;&amp; port == 1</string>
               </CEntries>
            </combo>
            <combo name="output">
               <MenuEntries>
                  <string>din</string>
                  <string>usb host port 1</string>
                  <string>usb host port 2</string>
                  <string>usb host port 3</string>
                  <string>usb host port 4</string>
                  <string>internal port 1</string>
                  <string>internal port 2</string>
                  <string>usb device port 1</string>
               </MenuEntries>
               <CEntries>
                  <string>MIDI_DEVICE_DIN, 1</string>
                  <string>MIDI_DEVICE_USB_HOST, 1</string>
                  <string>MIDI_DEVICE_USB_HOST, 2</string>
                  <string>MIDI_DEVICE_USB_HOST, 3</string>
                  <string>MIDI_DEVICE_USB_HOST, 4</string>
                  <string>MIDI_DEVICE_INTERNAL, 1</string>
                  <string>MIDI_DEVICE_INTERNAL, 2</string>
                  <string>MIDI_DEVICE_USB_DEVICE, 1</string>
               </CEntries>
            </combo>
            <spinner name="channel" MinValue="1" MaxValue="16" DefaultValue="1"/>
            <spinner name="maxbar" MinValue="1" MaxValue="32" DefaultValue="0"/>
            <objref name="table"/>
            <spinner name="maxslots" MinValue="1" MaxValue="32" DefaultValue="1"/>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[int cc;
int ccv;
int bendA;
int bendB;
int touch;

int Occ;
int Occv;
int OccB;
int OccvB;
int OccC;
int OccvC;


int ObendA;
int ObendB;
int Otouch;
int prevstep;
int voice;
int slotsize;
int play;
int rec;
int offset;
int clear;
int ctrig;


int resetrig;]]></code.declaration>
         <code.init><![CDATA[voice=512*attr_maxbar;
slotsize=(voice*9);
clear=-1;]]></code.init>
         <code.krate><![CDATA[offset=inlet_offset + (slotsize*inlet_slot);
outlet_offset=inlet_offset + (slotsize*attr_maxslots);
Occ=attr_table.array[inlet_synclock+offset];
Occv=attr_table.array[inlet_synclock+offset+voice];
OccB=attr_table.array[inlet_synclock+offset+voice+voice];
OccvB=attr_table.array[inlet_synclock+offset+voice+voice+voice];
OccC=attr_table.array[inlet_synclock+offset+voice+voice+voice+voice];
OccvC=attr_table.array[inlet_synclock+offset+voice+voice+voice+voice+voice];
ObendA=attr_table.array[inlet_synclock+offset+voice+voice+voice+voice+voice+voice];
ObendB=attr_table.array[inlet_synclock+offset+voice+voice+voice+voice+voice+voice+voice];
Otouch=attr_table.array[inlet_synclock+offset+voice+voice+voice+voice+voice+voice+voice+voice];
if (inlet_clear&&!ctrig){
	clear=0;
	ctrig=1;
}
if (!inlet_clear){
	ctrig=0;
}
if ((clear>=0)&& (clear<slotsize)){
	attr_table.array[clear+inlet_offset + (slotsize*inlet_cslot)]= 0;
	
	
	clear+=1;
	if (clear>=slotsize){
		clear=-1;
	}
}
if (inlet_synclock!=prevstep){
//play
	if (inlet_play){
		if (Occv>0){
			MidiSend3((midi_device_t) attr_output, MIDI_CONTROL_CHANGE + (attr_channel-1),(Occ-1),(Occv-1));
		}
		if (OccvB>0){
			MidiSend3((midi_device_t) attr_output, MIDI_CONTROL_CHANGE + (attr_channel-1),(OccB-1),(OccvB-1));
		}
		if (OccvC>0){
			MidiSend3((midi_device_t) attr_output, MIDI_CONTROL_CHANGE + (attr_channel-1),(OccC-1),(OccvC-1));
		}
		
		if ((ObendA>0)||(ObendB>0)){
			MidiSend3((midi_device_t) attr_output, MIDI_PITCH_BEND + (attr_channel-1),(ObendA-1),(ObendB-1));
			}
		if (Otouch>0){
			MidiSend2((midi_device_t) attr_output, MIDI_CHANNEL_PRESSURE + (attr_channel-1),(Otouch-1)); 
			}
		}

//record
	if (inlet_rec){
			attr_table.array[inlet_synclock+offset]= 0;
			attr_table.array[inlet_synclock+offset+voice]= 0;
			attr_table.array[inlet_synclock+offset+voice+voice]= 0;
			attr_table.array[inlet_synclock+offset+voice+voice+voice]= 0;
			attr_table.array[inlet_synclock+offset+voice+voice+voice+voice]= 0;
			attr_table.array[inlet_synclock+offset+voice+voice+voice+voice+voice]= 0;
			attr_table.array[inlet_synclock+offset+voice+voice+voice+voice+voice+voice]= 0;
			attr_table.array[inlet_synclock+offset+voice+voice+voice+voice+voice+voice+voice]= 0;
			attr_table.array[inlet_synclock+offset+voice+voice+voice+voice+voice+voice+voice+voice]= 0;
			
		}
//overdub
	if ((inlet_rec || inlet_overdub) && (inlet_play)){
		
			if (ccv>0){
				if (Occv && (Occ==cc))   {
					attr_table.array[inlet_synclock+offset]= cc;
					attr_table.array[inlet_synclock+offset+voice]= ccv;
					}
				else if (OccvB && (OccB==cc)){
					attr_table.array[inlet_synclock+offset+voice+voice]= cc;
					attr_table.array[inlet_synclock+offset+voice+voice+voice]= ccv;
				}
				else if (OccvC && (OccC==cc)){
					attr_table.array[inlet_synclock+offset+voice+voice+voice+voice]= cc;
					attr_table.array[inlet_synclock+offset+voice+voice+voice+voice+voice]= ccv;
				}
				else if (!Occv)   {
					attr_table.array[inlet_synclock+offset]= cc;
					attr_table.array[inlet_synclock+offset+voice]= ccv;
					}
				else if (!OccvB){
					attr_table.array[inlet_synclock+offset+voice+voice]= cc;
					attr_table.array[inlet_synclock+offset+voice+voice+voice]= ccv;
				}
				else if (!OccvC){
					attr_table.array[inlet_synclock+offset+voice+voice+voice+voice]= cc;
					attr_table.array[inlet_synclock+offset+voice+voice+voice+voice+voice]= ccv;
				}
				}
			if ((bendA>0)||(bendB>0)){
					attr_table.array[inlet_synclock+offset+voice+voice+voice+voice+voice+voice]= bendA;
					attr_table.array[inlet_synclock+offset+voice+voice+voice+voice+voice+voice+voice]= bendB;
				}
			
			if (touch>0){
					attr_table.array[inlet_synclock+offset+voice+voice+voice+voice+voice+voice+voice+voice]= touch;
				}
		}

	cc=0;
	ccv=0;
	bendA=0;
	bendB=0;
	touch=0;
	prevstep=inlet_synclock;
	}


//reset bend & touch
	if ((inlet_reset || (inlet_synclock<1))&&!resetrig){
		MidiSend3((midi_device_t) attr_output, MIDI_PITCH_BEND+ (attr_channel-1),0,64);
		MidiSend2((midi_device_t) attr_output, MIDI_CHANNEL_PRESSURE + (attr_channel-1),0); 
		resetrig=1;
		
		}

if (!inlet_reset && (inlet_synclock>0)){
	resetrig=0;
	}]]></code.krate>
         <code.midihandler><![CDATA[if(attr_input) {
       
if (status == MIDI_CONTROL_CHANGE+(attr_channel-1)){
	cc=data1+1;
	ccv=data2+1;

	
	}

if (status == MIDI_PITCH_BEND +(attr_channel-1)){
	bendA=data1+1;
	bendB=data2+1;

	
	}
if (status == MIDI_CHANNEL_PRESSURE+(attr_channel-1)){
	touch=data1+1;

	
	}
	
}]]></code.midihandler>
      </object>
   </patchobj>
   <comment type="patch/comment" x="700" y="826" text="polytouch recording"/>
   <comment type="patch/comment" x="910" y="826" text="total size on table"/>
   <patchobj type="patch/object" uuid="ff5f58fd-7957-4f21-a1ac-1d7ca63ec6bf" name="1_7" x="700" y="840">
      <params/>
      <attribs>
         <combo attributeName="input" selection="din"/>
         <combo attributeName="output" selection="internal port 1"/>
         <spinner attributeName="channel" value="7"/>
         <spinner attributeName="maxbar" value="8"/>
         <objref attributeName="table" obj="midiloop"/>
         <spinner attributeName="maxslots" value="7"/>
      </attribs>
      <object id="patch/object" uuid="ff5f58fd-7957-4f21-a1ac-1d7ca63ec6bf">
         <sDescription>object that records pitch bend, after touch and midi CCs.
for use with the midi looper objects.
could be used standalone, inlet stepunQCC expects a clock running at 96ppq</sDescription>
         <author>Mattilyn Mattroe</author>
         <license>if you use the object to play a wedding in september you have to come round and fix the dodgy extractor fan in my bathroom. otherwise, do as you will</license>
         <helpPatch>midi looper help.axh</helpPatch>
         <inlets>
            <int32 name="offset"/>
            <int32 name="slot"/>
            <int32 name="synclock"/>
            <bool32 name="rec"/>
            <bool32 name="play"/>
            <bool32 name="reset"/>
            <bool32 name="overdub"/>
            <bool32 name="clear"/>
            <int32 name="cslot"/>
         </inlets>
         <outlets>
            <int32 name="offset"/>
         </outlets>
         <displays/>
         <params/>
         <attribs>
            <combo name="input">
               <MenuEntries>
                  <string>omni</string>
                  <string>din</string>
                  <string>usb host port 1</string>
                  <string>usb host port 2</string>
                  <string>usb host port 3</string>
                  <string>usb host port 4</string>
                  <string>internal port 1</string>
                  <string>internal port 2</string>
                  <string>usb device port 1</string>
               </MenuEntries>
               <CEntries>
                  <string>true</string>
                  <string>dev == MIDI_DEVICE_DIN &amp;&amp; port == 1</string>
                  <string>dev == MIDI_DEVICE_USB_HOST &amp;&amp; port == 1</string>
                  <string>dev == MIDI_DEVICE_USB_HOST &amp;&amp; port == 2</string>
                  <string>dev == MIDI_DEVICE_USB_HOST &amp;&amp; port == 3</string>
                  <string>dev == MIDI_DEVICE_USB_HOST &amp;&amp; port == 4</string>
                  <string>dev == MIDI_DEVICE_INTERNAL &amp;&amp; port == 1</string>
                  <string>dev == MIDI_DEVICE_INTERNAL &amp;&amp; port == 2</string>
                  <string>dev == MIDI_DEVICE_USB_DEVICE &amp;&amp; port == 1</string>
               </CEntries>
            </combo>
            <combo name="output">
               <MenuEntries>
                  <string>din</string>
                  <string>usb host port 1</string>
                  <string>usb host port 2</string>
                  <string>usb host port 3</string>
                  <string>usb host port 4</string>
                  <string>internal port 1</string>
                  <string>internal port 2</string>
                  <string>usb device port 1</string>
               </MenuEntries>
               <CEntries>
                  <string>MIDI_DEVICE_DIN, 1</string>
                  <string>MIDI_DEVICE_USB_HOST, 1</string>
                  <string>MIDI_DEVICE_USB_HOST, 2</string>
                  <string>MIDI_DEVICE_USB_HOST, 3</string>
                  <string>MIDI_DEVICE_USB_HOST, 4</string>
                  <string>MIDI_DEVICE_INTERNAL, 1</string>
                  <string>MIDI_DEVICE_INTERNAL, 2</string>
                  <string>MIDI_DEVICE_USB_DEVICE, 1</string>
               </CEntries>
            </combo>
            <spinner name="channel" MinValue="1" MaxValue="16" DefaultValue="1"/>
            <spinner name="maxbar" MinValue="1" MaxValue="32" DefaultValue="0"/>
            <objref name="table"/>
            <spinner name="maxslots" MinValue="1" MaxValue="32" DefaultValue="1"/>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[int note;
int touch;





int intouch[8];
int Tnote[8];
int Ttouch[8];
int Onote[8];
int Otouch[8];
int poly;

int prevstep;
int voice;
int slotsize;
int play;
int rec;
int offset;
int clear;
int ctrig;


int resetrig;]]></code.declaration>
         <code.init><![CDATA[voice=512*attr_maxbar;
slotsize=(voice*16);
clear=-1;]]></code.init>
         <code.krate><![CDATA[offset=inlet_offset + (slotsize*inlet_slot);
outlet_offset=inlet_offset + (slotsize*attr_maxslots)+slotsize;
Onote[0]=attr_table.array[inlet_synclock+offset];
Otouch[0]=attr_table.array[inlet_synclock+offset+voice];
Onote[1]=attr_table.array[inlet_synclock+offset+voice+voice];
Otouch[1]=attr_table.array[inlet_synclock+offset+voice+voice+voice];
Onote[2]=attr_table.array[inlet_synclock+offset+voice+voice+voice+voice];
Otouch[2]=attr_table.array[inlet_synclock+offset+voice+voice+voice+voice+voice];
Onote[3]=attr_table.array[inlet_synclock+offset+voice+voice+voice+voice+voice+voice];
Otouch[3]=attr_table.array[inlet_synclock+offset+voice+voice+voice+voice+voice+voice+voice];
Onote[4]=attr_table.array[inlet_synclock+offset+voice+voice+voice+voice+voice+voice+voice+voice];
Otouch[4]=attr_table.array[inlet_synclock+offset+voice+voice+voice+voice+voice+voice+voice+voice+voice];
Onote[5]=attr_table.array[inlet_synclock+offset+voice+voice+voice+voice+voice+voice+voice+voice+voice+voice];
Otouch[5]=attr_table.array[inlet_synclock+offset+voice+voice+voice+voice+voice+voice+voice+voice+voice+voice+voice];
Onote[6]=attr_table.array[inlet_synclock+offset+voice+voice+voice+voice+voice+voice+voice+voice+voice+voice+voice+voice];
Otouch[6]=attr_table.array[inlet_synclock+offset+voice+voice+voice+voice+voice+voice+voice+voice+voice+voice+voice+voice+voice];
Onote[7]=attr_table.array[inlet_synclock+offset+voice+voice+voice+voice+voice+voice+voice+voice+voice+voice+voice+voice+voice+voice];
Otouch[7]=attr_table.array[inlet_synclock+offset+voice+voice+voice+voice+voice+voice+voice+voice+voice+voice+voice+voice+voice+voice+voice];

if (inlet_clear&&!ctrig){
	clear=0;
	ctrig=1;
}
if (!inlet_clear){
	ctrig=0;
}
if ((clear>=0)&& (clear<slotsize)){
	attr_table.array[clear+inlet_offset + (slotsize*inlet_cslot)]= 0;
	
	
	clear+=1;
	if (clear>=slotsize){
		clear=-1;
	}
}
if (inlet_synclock!=prevstep){
//play
	if (inlet_play&&!inlet_rec){
		if (Otouch[0]>0){
			
			MidiSend3((midi_device_t) attr_output, MIDI_POLY_PRESSURE + (attr_channel-1),(Onote[0]-1),(Otouch[0]-1)); 
		}
		if (Otouch[1]>0){
			MidiSend3((midi_device_t) attr_output, MIDI_POLY_PRESSURE + (attr_channel-1),(Onote[1]-1),(Otouch[1]-1));
		}
		if (Otouch[2]>0){
			MidiSend3((midi_device_t) attr_output, MIDI_POLY_PRESSURE + (attr_channel-1),(Onote[2]-1),(Otouch[2]-1));
		}
		if (Otouch[3]>0){
			MidiSend3((midi_device_t) attr_output, MIDI_POLY_PRESSURE + (attr_channel-1),(Onote[3]-1),(Otouch[3]-1));
		}
		if (Otouch[4]>0){
			MidiSend3((midi_device_t) attr_output, MIDI_POLY_PRESSURE + (attr_channel-1),(Onote[4]-1),(Otouch[4]-1));
		}
		if (Otouch[5]>0){
			MidiSend3((midi_device_t) attr_output, MIDI_POLY_PRESSURE+ (attr_channel-1),(Onote[5]-1),(Otouch[5]-1));
		}
		if (Otouch[6]>0){
			MidiSend3((midi_device_t) attr_output, MIDI_POLY_PRESSURE + (attr_channel-1),(Onote[6]-1),(Otouch[6]-1));
		}
		if (Otouch[7]>0){
			MidiSend3((midi_device_t) attr_output, MIDI_POLY_PRESSURE + (attr_channel-1),(Onote[7]-1),(Otouch[7]-1));
		}
		
	
		
		}

//record
	if (inlet_rec){
			attr_table.array[inlet_synclock+offset]= 0;
			attr_table.array[inlet_synclock+offset+voice]= 0;
			attr_table.array[inlet_synclock+offset+voice+voice]= 0;
			attr_table.array[inlet_synclock+offset+voice+voice+voice]= 0;
			attr_table.array[inlet_synclock+offset+voice+voice+voice+voice]= 0;
			attr_table.array[inlet_synclock+offset+voice+voice+voice+voice+voice]= 0;
			attr_table.array[inlet_synclock+offset+voice+voice+voice+voice+voice+voice]= 0;
			attr_table.array[inlet_synclock+offset+voice+voice+voice+voice+voice+voice+voice]= 0;
			attr_table.array[inlet_synclock+offset+voice+voice+voice+voice+voice+voice+voice+voice]= 0;
			attr_table.array[inlet_synclock+offset+voice+voice+voice+voice+voice+voice+voice+voice+voice]= 0;
			attr_table.array[inlet_synclock+offset+voice+voice+voice+voice+voice+voice+voice+voice+voice+voice]= 0;
			attr_table.array[inlet_synclock+offset+voice+voice+voice+voice+voice+voice+voice+voice+voice+voice+voice]= 0;
			attr_table.array[inlet_synclock+offset+voice+voice+voice+voice+voice+voice+voice+voice+voice+voice+voice+voice]= 0;
			attr_table.array[inlet_synclock+offset+voice+voice+voice+voice+voice+voice+voice+voice+voice+voice+voice+voice+voice]= 0;
		
			
		}
//overdub
	if ((inlet_rec || inlet_overdub) && (inlet_play)){
		
			if (Ttouch[0]) {
					attr_table.array[inlet_synclock+offset]= Tnote[0];
					attr_table.array[inlet_synclock+offset+voice]= Ttouch[0];
					}
			if (Ttouch[1]) {
					attr_table.array[inlet_synclock+offset+voice+voice]= Tnote[1];
					attr_table.array[inlet_synclock+offset+voice+voice+voice]= Ttouch[1];
					}
			if (Ttouch[2]) {
					attr_table.array[inlet_synclock+offset+voice+voice+voice+voice]= Tnote[2];
					attr_table.array[inlet_synclock+offset+voice+voice+voice+voice+voice]= Ttouch[2];
					}
			if (Ttouch[3]) {
					attr_table.array[inlet_synclock+offset+voice+voice+voice+voice+voice+voice]= Tnote[3];
					attr_table.array[inlet_synclock+offset+voice+voice+voice+voice+voice+voice+voice]= Ttouch[3];
					}
			if (Ttouch[4]) {
					attr_table.array[inlet_synclock+offset+voice+voice+voice+voice+voice+voice+voice+voice]= Tnote[4];
					attr_table.array[inlet_synclock+offset+voice+voice+voice+voice+voice+voice+voice+voice+voice]= Ttouch[4];
					}
			if (Ttouch[5]) {
					attr_table.array[inlet_synclock+offset+voice+voice+voice+voice+voice+voice+voice+voice]= Tnote[5];
					attr_table.array[inlet_synclock+offset+voice+voice+voice+voice+voice+voice+voice+voice+voice]= Ttouch[5];
					}
			if (Ttouch[6]) {
					attr_table.array[inlet_synclock+offset+voice+voice+voice+voice+voice+voice+voice+voice+voice+voice]= Tnote[6];
					attr_table.array[inlet_synclock+offset+voice+voice+voice+voice+voice+voice+voice+voice+voice+voice+voice]= Ttouch[6];
					}
			if (Ttouch[7]) {
					attr_table.array[inlet_synclock+offset+voice+voice+voice+voice+voice+voice+voice+voice+voice+voice+voice+voice]= Tnote[7];
					attr_table.array[inlet_synclock+offset+voice+voice+voice+voice+voice+voice+voice+voice+voice+voice+voice+voice+voice]= Ttouch[7];
					}
			
			
			
			
		}

	
	
	Ttouch[0]=0;
	Ttouch[1]=0;
	Ttouch[2]=0;
	Ttouch[3]=0;
	Ttouch[4]=0;
	Ttouch[5]=0;
	Ttouch[6]=0;
	Ttouch[7]=0;
	
	touch=0;
	prevstep=inlet_synclock;
	}



//reset bend & touch
	if ((inlet_reset || (inlet_synclock<1))&&!resetrig){
		
		MidiSend2((midi_device_t) attr_output, MIDI_CHANNEL_PRESSURE + (attr_channel-1),0); 
		resetrig=1;

		MidiSend3((midi_device_t) attr_output, MIDI_POLY_PRESSURE + (attr_channel-1),(Onote[0]-1),0); 
		MidiSend3((midi_device_t) attr_output, MIDI_POLY_PRESSURE + (attr_channel-1),(Onote[1]-1),0); 
		MidiSend3((midi_device_t) attr_output, MIDI_POLY_PRESSURE + (attr_channel-1),(Onote[2]-1),0); 
		MidiSend3((midi_device_t) attr_output, MIDI_POLY_PRESSURE + (attr_channel-1),(Onote[3]-1),0); 
		MidiSend3((midi_device_t) attr_output, MIDI_POLY_PRESSURE + (attr_channel-1),(Onote[4]-1),0); 
		MidiSend3((midi_device_t) attr_output, MIDI_POLY_PRESSURE + (attr_channel-1),(Onote[5]-1),0); 
		MidiSend3((midi_device_t) attr_output, MIDI_POLY_PRESSURE + (attr_channel-1),(Onote[6]-1),0); 
		MidiSend3((midi_device_t) attr_output, MIDI_POLY_PRESSURE + (attr_channel-1),(Onote[7]-1),0); 
		
		}

if (!inlet_reset && (inlet_synclock>0)){
	resetrig=0;
	}]]></code.krate>
         <code.midihandler><![CDATA[if(attr_input) {

if (status == (attr_channel-1) + MIDI_POLY_PRESSURE){
	if ((Onote[0]==(data1+1)) && (Otouch[0])){
		Tnote[0]=data1+1;
		Ttouch[0]=data2+1;
		
	}
	else if ((Onote[1]==(data1+1)) && (Otouch[1])){
		Tnote[1]=data1+1;
		Ttouch[1]=data2+1;
		
	}
	else if ((Onote[2]==(data1+1)) && (Otouch[2])){
		Tnote[2]=data1+1;
		Ttouch[2]=data2+1;
		
	}
	else if ((Onote[3]==(data1+1)) && (Otouch[3])){
		Tnote[3]=data1+1;
		Ttouch[3]=data2+1;
		
	}
	else if ((Onote[4]==(data1+1)) && (Otouch[4])){
		Tnote[4]=data1+1;
		Ttouch[4]=data2+1;
		
	}
	else if ((Onote[5]==(data1+1)) && (Otouch[5])){
		Tnote[5]=data1+1;
		Ttouch[5]=data2+1;
		
	}
	else if ((Onote[6]==(data1+1)) && (Otouch[6])){
		Tnote[6]=data1+1;
		Ttouch[6]=data2+1;
		
	}
	else if ((Onote[7]==(data1+1)) && (Otouch[7])){
		Tnote[7]=data1+1;
		Ttouch[7]=data2+1;
		
	}
	else if (Tnote[0]==(data1+1)){
		Tnote[0]=data1+1;
		Ttouch[0]=data2+1;
		
	}
	else if (Tnote[1]==(data1+1)){
		Tnote[1]=data1+1;
		Ttouch[1]=data2+1;
		
	}
	else if (Tnote[2]==(data1+1)){
		Tnote[2]=data1+1;
		Ttouch[2]=data2+1;
		
	}
	else if (Tnote[3]==(data1+1)){
		Tnote[3]=data1+1;
		Ttouch[3]=data2+1;
		
	}
	else if (Tnote[4]==(data1+1)){
		Tnote[4]=data1+1;
		Ttouch[4]=data2+1;
		
	}
	else if (Tnote[5]==(data1+1)){
		Tnote[5]=data1+1;
		Ttouch[5]=data2+1;
		
	}
	else if (Tnote[6]==(data1+1)){
		Tnote[6]=data1+1;
		Ttouch[6]=data2+1;
		
	}
	else if (Tnote[7]==(data1+1)){
		Tnote[7]=data1+1;
		Ttouch[7]=data2+1;
		
	}
	else	if (!Ttouch[0]){
		Tnote[0]=data1+1;
		Ttouch[0]=data2+1;
		
	}
	else if (!Ttouch[1]){
		Tnote[1]=data1+1;
		Ttouch[1]=data2+1;
		
	}
	else if (!Ttouch[2]){
		Tnote[2]=data1+1;
		Ttouch[2]=data2+1;
		
	}
	else if (!Ttouch[3]){
		Tnote[3]=data1+1;
		Ttouch[3]=data2+1;
		
	}
	else if (!Ttouch[4]){
		Tnote[4]=data1+1;
		Ttouch[4]=data2+1;
		
	}
	else if (!Ttouch[5]){
		Tnote[5]=data1+1;
		Ttouch[5]=data2+1;
		
	}
	else if (!Ttouch[6]){
		Tnote[6]=data1+1;
		Ttouch[6]=data2+1;
		
	}
	else if (!Ttouch[7]){
		Tnote[7]=data1+1;
		Ttouch[7]=data2+1;
		
	}
	

	
	}



	
}]]></code.midihandler>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="f286242b-4a12-46f8-995e-6eeb6ad540dd" name="i_4" x="910" y="840">
      <params/>
      <attribs/>
      <object id="patch/object" uuid="f286242b-4a12-46f8-995e-6eeb6ad540dd">
         <sDescription>display integer</sDescription>
         <author>Johannes Taelman</author>
         <license>BSD</license>
         <helpPatch>disp.axh</helpPatch>
         <inlets>
            <int32 name="in" description="input"/>
         </inlets>
         <outlets/>
         <displays>
            <int32.label name="v" noLabel="true"/>
         </displays>
         <params/>
         <attribs/>
         <includes/>
         <code.krate><![CDATA[disp_v=inlet_in;
]]></code.krate>
      </object>
   </patchobj>
   <comment type="patch/comment" x="1064" y="840" text="simple test synth"/>
   <patcher type="patch/patcher" uuid="2059b016-6133-41d2-9413-33e52e63244e" name="patcher_1" x="1064" y="854">
      <params>
         <frac32.s.map name="filter:pitch" value="15.0"/>
         <frac32.u.map name="filter:reso" value="11.5"/>
         <frac32.s.map name="adsr:a" value="-52.0"/>
         <frac32.s.map name="adsr:d" value="-4.0"/>
         <frac32.u.map name="adsr:s" value="14.0"/>
         <frac32.s.map name="adsr:r" value="-10.0"/>
         <frac32.u.map name="vol" value="7.0"/>
      </params>
      <attribs>
         <combo attributeName="poly" selection="16"/>
         <combo attributeName="midichannel" selection="7"/>
         <combo attributeName="mididevice" selection="omni"/>
         <combo attributeName="midiport" selection="omni"/>
      </attribs>
      <subpatch appVersion="1.0.12">
         <obj type="midi/in/keyb touch" uuid="edfcb4cfd5b2064e95f5a7ee644bca56252ec11f" name="keyb_1" x="280" y="126">
            <params/>
            <attribs/>
         </obj>
         <obj type="midi/in/bend" uuid="7bd8cace52a8c26ed61d80f65e238408d5d621f4" name="bend_1" x="434" y="126">
            <params/>
            <attribs/>
         </obj>
         <obj type="math/*c" uuid="7d5ef61c3bcd571ee6bbd8437ef3612125dfb225" name="*c_2" x="532" y="126">
            <params>
               <frac32.u.map name="amp" value="12.0"/>
            </params>
            <attribs/>
         </obj>
         <obj type="math/+" uuid="44553fdc8628c67ab535845ed1be304ad6c9553b" name="+_1" x="700" y="154">
            <params/>
            <attribs/>
         </obj>
         <obj type="osc/square cheap" uuid="58dc60ffca7e6c5029f12ec68787945c669b7a8f" name="square_1" x="826" y="210">
            <params>
               <frac32.s.map name="pitch" value="0.0"/>
            </params>
            <attribs/>
         </obj>
         <obj type="filter/lp m" uuid="1aa1bc51da479ed92429af700591f9d7b9f45f22" name="filter" x="1008" y="210">
            <params>
               <frac32.s.map name="pitch" onParent="true" value="0.0"/>
               <frac32.u.map name="reso" onParent="true" value="0.0"/>
            </params>
            <attribs/>
         </obj>
         <obj type="env/adsr" uuid="d1dbcc5fa6f87b98a6a91c87fd44acee5e690bac" name="adsr" x="1148" y="210">
            <params>
               <frac32.s.map name="a" onParent="true" value="-64.0"/>
               <frac32.s.map name="d" onParent="true" value="-34.0"/>
               <frac32.u.map name="s" onParent="true" value="23.5"/>
               <frac32.s.map name="r" onParent="true" value="-10.0"/>
            </params>
            <attribs/>
         </obj>
         <obj type="gain/vca" uuid="a9f2dcd18043e2f47364e45cb8814f63c2a37c0d" name="vca_6" x="1246" y="210">
            <params/>
            <attribs/>
         </obj>
         <obj type="math/*c" uuid="7a66f52a9594e7e9eb31328ea725cb3641a80b55" name="vol" x="1316" y="210">
            <params>
               <frac32.u.map name="amp" onParent="true" value="36.5"/>
            </params>
            <attribs/>
         </obj>
         <obj type="audio/out left" uuid="b11a3c09b2fdd575ea8212f2ce7743d5269253b1" name="out_4" x="1428" y="210">
            <params/>
            <attribs/>
         </obj>
         <nets>
            <net>
               <source obj="vca_6" outlet="o"/>
               <dest obj="vol" inlet="in"/>
            </net>
            <net>
               <source obj="vol" outlet="out"/>
               <dest obj="out_4" inlet="wave"/>
            </net>
            <net>
               <source obj="square_1" outlet="wave"/>
               <dest obj="filter" inlet="in"/>
            </net>
            <net>
               <source obj="adsr" outlet="env"/>
               <dest obj="vca_6" inlet="v"/>
            </net>
            <net>
               <source obj="keyb_1" outlet="gate"/>
               <dest obj="adsr" inlet="gate"/>
            </net>
            <net>
               <source obj="keyb_1" outlet="note"/>
               <dest obj="+_1" inlet="in1"/>
            </net>
            <net>
               <source obj="+_1" outlet="out"/>
               <dest obj="square_1" inlet="pitch"/>
            </net>
            <net>
               <source obj="*c_2" outlet="out"/>
               <dest obj="+_1" inlet="in2"/>
            </net>
            <net>
               <source obj="filter" outlet="out"/>
               <dest obj="vca_6" inlet="a"/>
            </net>
            <net>
               <source obj="bend_1" outlet="bend"/>
               <dest obj="*c_2" inlet="in"/>
            </net>
            <net>
               <source obj="keyb_1" outlet="touch"/>
               <dest obj="filter" inlet="pitch"/>
            </net>
         </nets>
         <settings>
            <subpatchmode>polyphonic</subpatchmode>
            <MidiChannel>7</MidiChannel>
            <HasMidiChannelSelector>true</HasMidiChannelSelector>
            <NPresets>8</NPresets>
            <NPresetEntries>32</NPresetEntries>
            <NModulationSources>8</NModulationSources>
            <NModulationTargetsPerSource>8</NModulationTargetsPerSource>
         </settings>
         <notes><![CDATA[]]></notes>
         <windowPos>
            <x>-8</x>
            <y>-8</y>
            <width>1616</width>
            <height>876</height>
         </windowPos>
      </subpatch>
   </patcher>
   <obj type="noise/pink" uuid="72c03a2468ee865f248733fcf9b12d4cf42b5a61" name="pink_1" x="1400" y="896">
      <params/>
      <attribs/>
   </obj>
   <comment type="patch/comment" x="1288" y="938" text="metronom"/>
   <obj type="env/d" uuid="190ae648e41832b41adbedb465317c18a010aefe" name="d_1" x="1288" y="952">
      <params>
         <frac32.s.map name="d" value="-46.0"/>
      </params>
      <attribs/>
   </obj>
   <obj type="gain/vca" uuid="a9f2dcd18043e2f47364e45cb8814f63c2a37c0d" name="vca_4" x="1400" y="952">
      <params/>
      <attribs/>
   </obj>
   <obj type="gain/vca" uuid="a9f2dcd18043e2f47364e45cb8814f63c2a37c0d" name="vca_1" x="1470" y="952">
      <params/>
      <attribs/>
   </obj>
   <obj type="audio/out left" uuid="b11a3c09b2fdd575ea8212f2ce7743d5269253b1" name="out_2" x="1582" y="952">
      <params/>
      <attribs/>
   </obj>
   <comment type="patch/comment" x="1288" y="1036" text="bar pulse"/>
   <obj type="env/d" uuid="190ae648e41832b41adbedb465317c18a010aefe" name="d_2" x="1288" y="1050">
      <params>
         <frac32.s.map name="d" value="-23.0"/>
      </params>
      <attribs/>
   </obj>
   <obj type="gain/vca" uuid="a9f2dcd18043e2f47364e45cb8814f63c2a37c0d" name="vca_5" x="1400" y="1050">
      <params/>
      <attribs/>
   </obj>
   <obj type="gain/vca" uuid="a9f2dcd18043e2f47364e45cb8814f63c2a37c0d" name="vca_2" x="1470" y="1050">
      <params/>
      <attribs/>
   </obj>
   <obj type="audio/out left" uuid="b11a3c09b2fdd575ea8212f2ce7743d5269253b1" name="out_3" x="1582" y="1050">
      <params/>
      <attribs/>
   </obj>
   <nets>
      <net>
         <source obj="pink_1" outlet="out"/>
         <dest obj="vca_4" inlet="a"/>
         <dest obj="vca_5" inlet="a"/>
      </net>
      <net>
         <source obj="d_1" outlet="env"/>
         <dest obj="vca_4" inlet="v"/>
      </net>
      <net>
         <source obj="d_2" outlet="env"/>
         <dest obj="vca_5" inlet="v"/>
      </net>
      <net>
         <source obj="button_5" outlet="o"/>
         <dest obj="1_1" inlet="record"/>
      </net>
      <net>
         <source obj="button_2" outlet="o"/>
         <dest obj="1_1" inlet="stop"/>
      </net>
      <net>
         <source obj="button_4" outlet="o"/>
         <dest obj="1_1" inlet="overdub"/>
      </net>
      <net>
         <source obj="1_1" outlet="overdub"/>
         <dest obj="bool_3" inlet="in"/>
         <dest obj="1_7" inlet="overdub"/>
         <dest obj="1_2" inlet="overdub"/>
      </net>
      <net>
         <source obj="1_1" outlet="record"/>
         <dest obj="bool_4" inlet="in"/>
         <dest obj="1_7" inlet="rec"/>
         <dest obj="1_2" inlet="rec"/>
      </net>
      <net>
         <source obj="1_1" outlet="maxnotes"/>
         <dest obj="i_16" inlet="in"/>
      </net>
      <net>
         <source obj="1_1" outlet="play"/>
         <dest obj="bool_26" inlet="in"/>
         <dest obj="1_7" inlet="play"/>
         <dest obj="1_2" inlet="play"/>
      </net>
      <net>
         <source obj="1_1" outlet="slotnotes"/>
         <dest obj="i_9" inlet="in"/>
      </net>
      <net>
         <source obj="i_15" outlet="out"/>
         <dest obj="1_7" inlet="cslot"/>
         <dest obj="1_2" inlet="cslot"/>
         <dest obj="1_1" inlet="slot"/>
      </net>
      <net>
         <source obj="button_8" outlet="o"/>
         <dest obj="1_7" inlet="clear"/>
         <dest obj="1_2" inlet="clear"/>
         <dest obj="1_1" inlet="clearslot"/>
      </net>
      <net>
         <source obj="button_7" outlet="o"/>
         <dest obj="1_1" inlet="trigger"/>
      </net>
      <net>
         <source obj="clock_1" outlet="kbeat"/>
         <dest obj="1_1" inlet="kbeat"/>
      </net>
      <net>
         <source obj="1_1" outlet="bartrig"/>
         <dest obj="d_2" inlet="trig"/>
      </net>
      <net>
         <source obj="toggle_1" outlet="o"/>
         <dest obj="clock_3" inlet="run"/>
         <dest obj="clock_3" inlet="rst"/>
      </net>
      <net>
         <source obj="clock_1" outlet="stop"/>
         <dest obj="1_1" inlet="clearplay"/>
      </net>
      <net>
         <source obj="clock_1" outlet="1ppq"/>
         <dest obj="d_1" inlet="trig"/>
         <dest obj="1_1" inlet="1ppq"/>
      </net>
      <net>
         <source obj="clock_1" outlet="start"/>
         <dest obj="1_7" inlet="reset"/>
         <dest obj="1_2" inlet="reset"/>
         <dest obj="1_1" inlet="restart"/>
      </net>
      <net>
         <source obj="toggle_2" outlet="o"/>
         <dest obj="1_1" inlet="quantize"/>
      </net>
      <net>
         <source obj="vca_4" outlet="o"/>
         <dest obj="vca_1" inlet="a"/>
      </net>
      <net>
         <source obj="vca_1" outlet="o"/>
         <dest obj="out_2" inlet="wave"/>
      </net>
      <net>
         <source obj="vca_5" outlet="o"/>
         <dest obj="vca_2" inlet="a"/>
      </net>
      <net>
         <source obj="vca_2" outlet="o"/>
         <dest obj="out_3" inlet="wave"/>
      </net>
      <net>
         <source obj="dial_1" outlet="out"/>
         <dest obj="vca_1" inlet="v"/>
         <dest obj="vca_2" inlet="v"/>
      </net>
      <net>
         <source obj="1_1" outlet="full"/>
         <dest obj="bool_5" inlet="in"/>
      </net>
      <net>
         <source obj="1_1" outlet="synclock"/>
         <dest obj="i_10" inlet="in"/>
         <dest obj="1_7" inlet="synclock"/>
         <dest obj="1_2" inlet="synclock"/>
      </net>
      <net>
         <source obj="1_1" outlet="wait"/>
         <dest obj="bool_27" inlet="in"/>
      </net>
      <net>
         <source obj="1_1" outlet="currentslot"/>
         <dest obj="i_1" inlet="in"/>
         <dest obj="1_7" inlet="slot"/>
         <dest obj="1_2" inlet="slot"/>
      </net>
      <net>
         <source obj="clock_1" outlet="bpm"/>
         <dest obj="i_2" inlet="in"/>
      </net>
      <net>
         <source obj="1_1" outlet="playstate"/>
         <dest obj="i_3" inlet="in"/>
      </net>
      <net>
         <source obj="1_1" outlet="offset"/>
         <dest obj="1_2" inlet="offset"/>
      </net>
      <net>
         <source obj="1_2" outlet="offset"/>
         <dest obj="1_7" inlet="offset"/>
      </net>
      <net>
         <source obj="1_7" outlet="offset"/>
         <dest obj="i_4" inlet="in"/>
      </net>
      <net>
         <source obj="c_1" outlet="out"/>
         <dest obj="save_1" inlet="filename"/>
      </net>
      <net>
         <source obj="button_1" outlet="o"/>
         <dest obj="save_1" inlet="trig"/>
      </net>
   </nets>
   <settings>
      <subpatchmode>no</subpatchmode>
      <MidiChannel>1</MidiChannel>
      <NPresets>8</NPresets>
      <NPresetEntries>32</NPresetEntries>
      <NModulationSources>8</NModulationSources>
      <NModulationTargetsPerSource>8</NModulationTargetsPerSource>
   </settings>
   <notes><![CDATA[]]></notes>
   <windowPos>
      <x>-8</x>
      <y>-8</y>
      <width>1616</width>
      <height>876</height>
   </windowPos>
</patch-1.0>