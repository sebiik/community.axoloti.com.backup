<patch-1.0 appVersion="1.0.12">
   <obj type="lfo/square" uuid="de6909eb64db13af5b43f979a4c130024b3a4793" name="square_1" x="0" y="0">
      <params>
         <frac32.s.map name="pitch" value="-38.0"/>
      </params>
      <attribs/>
   </obj>
   <obj type="lfo/square" uuid="de6909eb64db13af5b43f979a4c130024b3a4793" name="square_2" x="98" y="0">
      <params>
         <frac32.s.map name="pitch" value="-26.0"/>
      </params>
      <attribs/>
   </obj>
   <patchobj type="patch/object" uuid="faea3b49-257f-4d72-8148-72d0e8130b24" name="counter_9" x="196" y="0">
      <params>
         <int32 name="maximum" value="1"/>
      </params>
      <attribs/>
      <object id="patch/object" uuid="faea3b49-257f-4d72-8148-72d0e8130b24">
         <sDescription>cyclic up counter</sDescription>
         <author>Johannes Taelman</author>
         <license>BSD</license>
         <helpPatch>counter.axh</helpPatch>
         <inlets>
            <bool32.rising name="trig" description="trigger"/>
            <bool32.rising name="r" description="reset"/>
         </inlets>
         <outlets>
            <int32 name="o" description="output"/>
            <bool32.pulse name="c" description="carry pulse"/>
         </outlets>
         <displays/>
         <params>
            <int32 name="maximum" noLabel="true">
               <MinValue i="0"/>
               <MaxValue i="65536"/>
            </int32>
         </params>
         <attribs/>
         <includes/>
         <code.declaration><![CDATA[   int ntrig;
   int rtrig;
   int count;
]]></code.declaration>
         <code.init><![CDATA[count=-1;
   ntrig = 0;
   rtrig = 0;]]></code.init>
         <code.krate><![CDATA[outlet_c=0;
if ((inlet_trig>0) && !ntrig) {
   count += 1; if (count>=param_maximum) {count = 0; outlet_c = 1;}
   ntrig=1;
}
else if (!(inlet_trig>0)) ntrig=0;
if ((inlet_r>0) && !rtrig) {count=0; rtrig = 1;}
else if (!(inlet_r>0)) rtrig=0;
outlet_o= count;
]]></code.krate>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="faea3b49-257f-4d72-8148-72d0e8130b24" name="counter_7" x="280" y="0">
      <params>
         <int32 name="maximum" value="4"/>
      </params>
      <attribs/>
      <object id="patch/object" uuid="faea3b49-257f-4d72-8148-72d0e8130b24">
         <sDescription>cyclic up counter</sDescription>
         <author>Johannes Taelman</author>
         <license>BSD</license>
         <helpPatch>counter.axh</helpPatch>
         <inlets>
            <bool32.rising name="trig" description="trigger"/>
            <bool32.rising name="r" description="reset"/>
         </inlets>
         <outlets>
            <int32 name="o" description="output"/>
            <bool32.pulse name="c" description="carry pulse"/>
         </outlets>
         <displays/>
         <params>
            <int32 name="maximum" noLabel="true">
               <MinValue i="0"/>
               <MaxValue i="65536"/>
            </int32>
         </params>
         <attribs/>
         <includes/>
         <code.declaration><![CDATA[   int ntrig;
   int rtrig;
   int count;
]]></code.declaration>
         <code.init><![CDATA[count=-1;
   ntrig = 0;
   rtrig = 0;]]></code.init>
         <code.krate><![CDATA[outlet_c=0;
if ((inlet_trig>0) && !ntrig) {
   count += 1; if (count>=param_maximum) {count = 0; outlet_c = 1;}
   ntrig=1;
}
else if (!(inlet_trig>0)) ntrig=0;
if ((inlet_r>0) && !rtrig) {count=0; rtrig = 1;}
else if (!(inlet_r>0)) rtrig=0;
outlet_o= count;
]]></code.krate>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="faea3b49-257f-4d72-8148-72d0e8130b24" name="counter_11" x="364" y="0">
      <params>
         <int32 name="maximum" value="8"/>
      </params>
      <attribs/>
      <object id="patch/object" uuid="faea3b49-257f-4d72-8148-72d0e8130b24">
         <sDescription>cyclic up counter</sDescription>
         <author>Johannes Taelman</author>
         <license>BSD</license>
         <helpPatch>counter.axh</helpPatch>
         <inlets>
            <bool32.rising name="trig" description="trigger"/>
            <bool32.rising name="r" description="reset"/>
         </inlets>
         <outlets>
            <int32 name="o" description="output"/>
            <bool32.pulse name="c" description="carry pulse"/>
         </outlets>
         <displays/>
         <params>
            <int32 name="maximum" noLabel="true">
               <MinValue i="0"/>
               <MaxValue i="65536"/>
            </int32>
         </params>
         <attribs/>
         <includes/>
         <code.declaration><![CDATA[   int ntrig;
   int rtrig;
   int count;
]]></code.declaration>
         <code.init><![CDATA[count=-1;
   ntrig = 0;
   rtrig = 0;]]></code.init>
         <code.krate><![CDATA[outlet_c=0;
if ((inlet_trig>0) && !ntrig) {
   count += 1; if (count>=param_maximum) {count = 0; outlet_c = 1;}
   ntrig=1;
}
else if (!(inlet_trig>0)) ntrig=0;
if ((inlet_r>0) && !rtrig) {count=0; rtrig = 1;}
else if (!(inlet_r>0)) rtrig=0;
outlet_o= count;
]]></code.krate>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="faea3b49-257f-4d72-8148-72d0e8130b24" name="counter_1" x="448" y="0">
      <params>
         <int32 name="maximum" value="16"/>
      </params>
      <attribs/>
      <object id="patch/object" uuid="faea3b49-257f-4d72-8148-72d0e8130b24">
         <sDescription>cyclic up counter</sDescription>
         <author>Johannes Taelman</author>
         <license>BSD</license>
         <helpPatch>counter.axh</helpPatch>
         <inlets>
            <bool32.rising name="trig" description="trigger"/>
            <bool32.rising name="r" description="reset"/>
         </inlets>
         <outlets>
            <int32 name="o" description="output"/>
            <bool32.pulse name="c" description="carry pulse"/>
         </outlets>
         <displays/>
         <params>
            <int32 name="maximum" noLabel="true">
               <MinValue i="0"/>
               <MaxValue i="65536"/>
            </int32>
         </params>
         <attribs/>
         <includes/>
         <code.declaration><![CDATA[   int ntrig;
   int rtrig;
   int count;
]]></code.declaration>
         <code.init><![CDATA[count=-1;
   ntrig = 0;
   rtrig = 0;]]></code.init>
         <code.krate><![CDATA[outlet_c=0;
if ((inlet_trig>0) && !ntrig) {
   count += 1; if (count>=param_maximum) {count = 0; outlet_c = 1;}
   ntrig=1;
}
else if (!(inlet_trig>0)) ntrig=0;
if ((inlet_r>0) && !rtrig) {count=0; rtrig = 1;}
else if (!(inlet_r>0)) rtrig=0;
outlet_o= count;
]]></code.krate>
      </object>
   </patchobj>
   <obj type="logic/counter" uuid="7a141ba82230e54e5f5cd12da5dbe5a74ba854a5" name="counter_13" x="532" y="0">
      <params>
         <int32 name="maximum" value="4"/>
      </params>
      <attribs/>
   </obj>
   <patchobj type="patch/object" uuid="57c0b500-d00d-4ddd-a195-538a03ae1704" name="burst generator" x="658" y="0">
      <params>
         <int32 name="length" value="32"/>
         <frac32.u.map name="chance" value="64.0"/>
         <int32 name="max" value="15"/>
         <int32 name="min" value="2"/>
      </params>
      <attribs/>
      <object id="patch/object" uuid="57c0b500-d00d-4ddd-a195-538a03ae1704">
         <sDescription>Gate burst generator
min/max controls set the minimum and maximum trigger length (after how many input-triggers it retriggers).
Minimum is 2 (up and down cost 2 triggers).
So connect this to a clock that&apos;s running twice, tripple or four times the base tempo.</sDescription>
         <author>Remco van der Most</author>
         <license>BSD</license>
         <helpPatch>counter.axh</helpPatch>
         <inlets>
            <bool32.rising name="trig" description="trigger"/>
            <bool32 name="rnd"/>
            <bool32.rising name="r" description="reset"/>
         </inlets>
         <outlets>
            <bool32 name="gate"/>
         </outlets>
         <displays/>
         <params>
            <int32 name="length" noLabel="true">
               <MinValue i="0"/>
               <MaxValue i="65536"/>
            </int32>
            <frac32.u.map name="chance"/>
            <int32 name="max">
               <MinValue i="2"/>
               <MaxValue i="16"/>
            </int32>
            <int32 name="min">
               <MinValue i="2"/>
               <MaxValue i="16"/>
            </int32>
         </params>
         <attribs/>
         <includes/>
         <code.declaration><![CDATA[int ntrig;
   int rtrig,DO=1;
   int count;
int cnt[64],CNT;
int step,rnd;]]></code.declaration>
         <code.init><![CDATA[count=0;
   ntrig = 0;
   rtrig = 0;
   step=1;]]></code.init>
         <code.krate><![CDATA[int RND=inlet_rnd||DO;
if(RND&&!rnd){
	DO=0;
	rnd=1;
	for(int i=0;i<8;i++){
		cnt[i]=(int32_t)(GenerateRandomNumber()>>1);
	}
}
else if(rnd&&!RND){rnd=0;}

if ((inlet_trig>0) && !ntrig) {
if((count%step)<1)
{
	if((GenerateRandomNumber()>>5)<param_chance)
	{	int dif=param_max-param_min;
		int dir=dif>=0?1:-1;
		dif=(dif>0?dif:-dif)+1;
		step=(cnt[CNT]%(dif))*dir+param_min;
		CNT=(CNT+1)&63;
	}
}
count+=1;
count=count>=param_length?0:count;
   ntrig=1;
}
else if (!(inlet_trig>0)) {ntrig=0;}


if ((inlet_r>0) && !rtrig) {
	count=0;
	CNT=0;
	rtrig = 1;}
else if (!(inlet_r>0)) rtrig=0;

if(step&1){
	if(step<5)
	{
		//outlet_gate=(count%step)>(step>>1);
		outlet_gate=((count%step)<(step-1+(1>>1)));
	}
	else
	{
		outlet_gate=!((count%step)>(step>>1));
	}
}
else{
	if(step<5)
	{
	outlet_gate=((count%step)<(step-1+(1>>1)));
	}
	else
	{
		outlet_gate=((count%step)>=(step>>1));
	}
}]]></code.krate>
      </object>
   </patchobj>
   <comment type="patch/comment" x="742" y="0" text="gate-burst generator for creating rhythmic, arpeggio-style/gated variations easily"/>
   <comment type="patch/comment" x="1232" y="70" text="audio-rate modulations to prevent alliasing"/>
   <patchobj type="patch/object" uuid="dec13069-087a-465c-836b-c1577851ac25" name="sine_1" x="924" y="84">
      <params>
         <frac32.s.map name="pitch" value="-64.0"/>
      </params>
      <attribs/>
      <object id="patch/object" uuid="dec13069-087a-465c-836b-c1577851ac25">
         <sDescription>sine wave oscillator</sDescription>
         <author>Johannes Taelman</author>
         <license>BSD</license>
         <helpPatch>osc.axh</helpPatch>
         <inlets>
            <frac32.bipolar name="pitch" description="pitch"/>
            <frac32buffer name="freq" description="frequency"/>
            <frac32buffer name="phase" description="phase"/>
         </inlets>
         <outlets>
            <frac32buffer.bipolar name="wave" description="sine wave"/>
         </outlets>
         <displays/>
         <params>
            <frac32.s.map.pitch name="pitch" noLabel="true"/>
         </params>
         <attribs/>
         <includes/>
         <code.declaration><![CDATA[uint32_t Phase;]]></code.declaration>
         <code.init><![CDATA[Phase = 0;]]></code.init>
         <code.krate><![CDATA[int32_t freq;
   MTOFEXTENDED(param_pitch + inlet_pitch,freq);
freq=freq>>13;]]></code.krate>
         <code.srate><![CDATA[Phase += freq + inlet_freq;
int32_t r;
int32_t p2 = Phase + (inlet_phase<<4);
SINE2TINTERP(p2,r)
outlet_wave= (r>>4);
]]></code.srate>
      </object>
   </patchobj>
   <obj type="math/*c" uuid="7a66f52a9594e7e9eb31328ea725cb3641a80b55" name="*c_1" x="1022" y="84">
      <params>
         <frac32.u.map name="amp" value="1.0099997520446777"/>
      </params>
      <attribs/>
   </obj>
   <obj type="math/inv" uuid="7f4c6cf4dcf79f9b0aa81c2eaf540405875714a3" name="inv_1" x="1120" y="84">
      <params/>
      <attribs/>
   </obj>
   <patchobj type="patch/object" uuid="dec13069-087a-465c-836b-c1577851ac25" name="sine_3" x="1176" y="84">
      <params>
         <frac32.s.map name="pitch" value="-64.0"/>
      </params>
      <attribs/>
      <object id="patch/object" uuid="dec13069-087a-465c-836b-c1577851ac25">
         <sDescription>sine wave oscillator</sDescription>
         <author>Johannes Taelman</author>
         <license>BSD</license>
         <helpPatch>osc.axh</helpPatch>
         <inlets>
            <frac32.bipolar name="pitch" description="pitch"/>
            <frac32buffer name="freq" description="frequency"/>
            <frac32buffer name="phase" description="phase"/>
         </inlets>
         <outlets>
            <frac32buffer.bipolar name="wave" description="sine wave"/>
         </outlets>
         <displays/>
         <params>
            <frac32.s.map.pitch name="pitch" noLabel="true"/>
         </params>
         <attribs/>
         <includes/>
         <code.declaration><![CDATA[uint32_t Phase;]]></code.declaration>
         <code.init><![CDATA[Phase = 0;]]></code.init>
         <code.krate><![CDATA[int32_t freq;
   MTOFEXTENDED(param_pitch + inlet_pitch,freq);
freq=freq>>8;]]></code.krate>
         <code.srate><![CDATA[Phase += freq + inlet_freq;
int32_t r;
int32_t p2 = Phase + (inlet_phase<<4);
SINE2TINTERP(p2,r)
outlet_wave= (r>>4);
]]></code.srate>
      </object>
   </patchobj>
   <obj type="math/*c" uuid="7a66f52a9594e7e9eb31328ea725cb3641a80b55" name="*c_2" x="1274" y="84">
      <params>
         <frac32.u.map name="amp" value="1.0"/>
      </params>
      <attribs/>
   </obj>
   <obj type="math/inv" uuid="7f4c6cf4dcf79f9b0aa81c2eaf540405875714a3" name="inv_3" x="1372" y="84">
      <params/>
      <attribs/>
   </obj>
   <patchobj type="patch/object" uuid="dec13069-087a-465c-836b-c1577851ac25" name="sine_7" x="1428" y="84">
      <params>
         <frac32.s.map name="pitch" value="-47.989999771118164"/>
      </params>
      <attribs/>
      <object id="patch/object" uuid="dec13069-087a-465c-836b-c1577851ac25">
         <sDescription>sine wave oscillator</sDescription>
         <author>Johannes Taelman</author>
         <license>BSD</license>
         <helpPatch>osc.axh</helpPatch>
         <inlets>
            <frac32.bipolar name="pitch" description="pitch"/>
            <frac32buffer name="freq" description="frequency"/>
            <frac32buffer name="phase" description="phase"/>
         </inlets>
         <outlets>
            <frac32buffer.bipolar name="wave" description="sine wave"/>
         </outlets>
         <displays/>
         <params>
            <frac32.s.map.pitch name="pitch" noLabel="true"/>
         </params>
         <attribs/>
         <includes/>
         <code.declaration><![CDATA[uint32_t Phase;]]></code.declaration>
         <code.init><![CDATA[Phase = 0;]]></code.init>
         <code.krate><![CDATA[int32_t freq;
   MTOFEXTENDED(param_pitch + inlet_pitch,freq);
freq=freq>>8;]]></code.krate>
         <code.srate><![CDATA[Phase += freq + inlet_freq;
int32_t r;
int32_t p2 = Phase + (inlet_phase<<4);
SINE2TINTERP(p2,r)
outlet_wave= (r>>5)+(1<<26);]]></code.srate>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="09dff1d6-cc86-4f97-a36c-562ed92e5e4b" name="*c_9" x="1554" y="84">
      <params>
         <frac32.u.map name="amp" value="45.264999866485596"/>
      </params>
      <attribs/>
      <object id="patch/object" uuid="09dff1d6-cc86-4f97-a36c-562ed92e5e4b">
         <sDescription>Multiply (attenuate) with a constant value</sDescription>
         <author>Johannes Taelman</author>
         <license>BSD</license>
         <helpPatch>math.axh</helpPatch>
         <inlets>
            <frac32buffer name="in" description="input"/>
         </inlets>
         <outlets>
            <frac32buffer name="out" description="output"/>
            <frac32buffer name="iout"/>
         </outlets>
         <displays/>
         <params>
            <frac32.u.map.gain name="amp" noLabel="true"/>
         </params>
         <attribs/>
         <includes/>
         <code.srate><![CDATA[outlet_out= ___SMMUL(param_amp,inlet_in)<<1;
outlet_iout=(param_amp>>4)-outlet_out;]]></code.srate>
      </object>
   </patchobj>
   <obj type="logic/counter" uuid="7a141ba82230e54e5f5cd12da5dbe5a74ba854a5" name="counter_10" x="196" y="98">
      <params>
         <int32 name="maximum" value="8"/>
      </params>
      <attribs/>
   </obj>
   <obj type="logic/counter" uuid="7a141ba82230e54e5f5cd12da5dbe5a74ba854a5" name="counter_8" x="280" y="98">
      <params>
         <int32 name="maximum" value="8"/>
      </params>
      <attribs/>
   </obj>
   <obj type="logic/counter" uuid="7a141ba82230e54e5f5cd12da5dbe5a74ba854a5" name="counter_12" x="364" y="98">
      <params>
         <int32 name="maximum" value="8"/>
      </params>
      <attribs/>
   </obj>
   <obj type="logic/counter" uuid="7a141ba82230e54e5f5cd12da5dbe5a74ba854a5" name="counter_6" x="448" y="98">
      <params>
         <int32 name="maximum" value="8"/>
      </params>
      <attribs/>
   </obj>
   <comment type="patch/comment" x="14" y="168" text="pattern generator that re-uses old values and value-differences to create new patterns"/>
   <patchobj type="patch/object" uuid="1871c4dc-c217-48a8-9946-feb70a269ef2" name="recycle" x="14" y="182">
      <params>
         <bool32.tgl name="evolve" value="1"/>
         <frac32.u.map name="randomstart" value="6.0"/>
         <frac32.u.map name="update" value="5.5"/>
         <frac32.u.map name="differents" value="64.0"/>
         <frac32.u.map name="movefollow" value="34.0"/>
         <frac32.u.map name="copyformer" value="8.5"/>
         <frac32.u.map name="turn" value="3.5"/>
         <frac32.u.map name="asOffset" value="8.5"/>
         <frac32.u.map name="invert" value="3.5"/>
         <bool32.tgl name="pendulum" value="1"/>
         <frac32.u.map name="maxchange" value="64.0"/>
         <frac32.u.map name="glide" value="64.0"/>
         <frac32.s.map name="rate" value="-37.0"/>
         <int2x16 name="gliderange" value="-362432528"/>
         <int2x16 name="countselect" value="-1083517064"/>
         <bool32.mom name="rndg" value="0"/>
         <bool32.mom name="rndc" value="0"/>
      </params>
      <attribs>
         <combo attributeName="size" selection="8"/>
      </attribs>
      <object id="patch/object" uuid="1871c4dc-c217-48a8-9946-feb70a269ef2">
         <sDescription>allocate 16bit table in SDRAM memory, -128.00 .. 127.99</sDescription>
         <author>Johannes Taelman</author>
         <license>BSD</license>
         <helpPatch>table.axh</helpPatch>
         <inlets>
            <int32 name="maincount"/>
            <int32 name="count1"/>
            <int32 name="count2"/>
            <int32 name="count3"/>
            <int32 name="count4"/>
            <bool32 name="rnd"/>
            <bool32 name="shuffle"/>
         </inlets>
         <outlets>
            <frac32 name="o1"/>
            <frac32 name="o2"/>
            <frac32 name="o3"/>
            <frac32 name="o4"/>
            <frac32 name="o5"/>
            <frac32 name="o6"/>
            <frac32 name="o7"/>
            <frac32 name="o8"/>
            <frac32 name="o9"/>
            <frac32 name="o10"/>
            <frac32 name="o11"/>
            <frac32 name="o12"/>
            <frac32 name="o13"/>
            <frac32 name="o14"/>
            <frac32 name="o15"/>
            <frac32 name="o16"/>
         </outlets>
         <displays/>
         <params>
            <bool32.tgl name="evolve"/>
            <frac32.u.map name="randomstart" description="chance that the sequence offset doesn&apos;t start at zero but any other random value"/>
            <frac32.u.map name="update" description="chance that at the change of the counter, the current step is being randomised using the settings below"/>
            <frac32.u.map name="differents" description="amount of steps that may be used to hold different random values, after this the step-values are re-used."/>
            <frac32.u.map name="movefollow" description="chance that the difference between two former steps is re-used to generate the new value from the one before."/>
            <frac32.u.map name="copyformer" description="chance of re-using a formerly generated value"/>
            <frac32.u.map name="turn" description="chance that the move-follow value is inverted (repeating random)"/>
            <frac32.u.map name="asOffset" description="chance that the current step offsets the entire sequence (non-repeating random)"/>
            <frac32.u.map name="invert" description="chance that the sequence swaps low/high (non-repeating random)"/>
            <bool32.tgl name="pendulum" description="wraps the generated sequence as a pendulum instead of a hard high-&gt;low wrap"/>
            <frac32.u.map name="maxchange" description="attenuates the difference with the former step"/>
            <frac32.u.map name="glide" description="chance of gliding the output (dependent on whether mode of the channel is either 1 or 3)"/>
            <frac32.s.map name="rate" description="glide rate"/>
            <int2x16 name="gliderange" description="0=stepped count1, 1=glided count 1, 2=stepped count2, 3=glided count2"/>
            <int2x16 name="countselect"/>
            <bool32.mom name="rndg"/>
            <bool32.mom name="rndc"/>
         </params>
         <attribs>
            <combo name="size">
               <MenuEntries>
                  <string>2</string>
                  <string>4</string>
                  <string>8</string>
                  <string>16</string>
                  <string>32</string>
                  <string>64</string>
                  <string>128</string>
                  <string>256</string>
                  <string>512</string>
                  <string>1024</string>
                  <string>2048</string>
                  <string>4096</string>
                  <string>8192</string>
                  <string>16384</string>
                  <string>32768</string>
                  <string>65536</string>
                  <string>131072</string>
                  <string>262144</string>
                  <string>524288</string>
                  <string>1048576</string>
                  <string>2097152</string>
                  <string>4194304</string>
               </MenuEntries>
               <CEntries>
                  <string>1</string>
                  <string>2</string>
                  <string>3</string>
                  <string>4</string>
                  <string>5</string>
                  <string>6</string>
                  <string>7</string>
                  <string>8</string>
                  <string>9</string>
                  <string>10</string>
                  <string>11</string>
                  <string>12</string>
                  <string>13</string>
                  <string>14</string>
                  <string>15</string>
                  <string>16</string>
                  <string>17</string>
                  <string>18</string>
                  <string>19</string>
                  <string>20</string>
                  <string>21</string>
                  <string>22</string>
               </CEntries>
            </combo>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[static const uint32_t LENGTHPOW = (attr_size);
static const uint32_t LENGTH = (1<<attr_size);
static const uint32_t LENGTHMASK = ((1<<attr_size)-1);
static const uint32_t BITS = 16;
static const uint32_t GAIN = 12;
uint16_t *array,ofs[16];
int rnd,prv[16],INV[16],rg,rc,C[16];
int32_t O[16],P[16];//,goal,former;]]></code.declaration>
         <code.init><![CDATA[static uint16_t _array[attr_poly][LENGTH*16] __attribute__ ((section (".sdram")));
array = &_array[parent->polyIndex][0];
{ 
  int i;
  for(i=0;i<LENGTH*16;i++) array[i]=(uint16_t)(GenerateRandomNumber()>>16);
}]]></code.init>
         <code.krate><![CDATA[int rndc=param_rndc||inlet_shuffle;
int rndg=param_rndg||inlet_shuffle;
if(rndc&&!rc){
	rc=1;
	PExParameterChange(&parent->PExch[PARAM_INDEX_attr_legal_name_countselect],(uint32_t)(GenerateRandomNumber()),0xFFFD);
		
}
else if(!rndc){rc=0;}
if(rndg&&!rg){
	rg=1;
	PExParameterChange(&parent->PExch[PARAM_INDEX_attr_legal_name_gliderange],(uint32_t)(GenerateRandomNumber()),0xFFFD);
}
else if(!rndg){rg=0;}
int cnt=inlet_maincount&LENGTHMASK;
int c[4];
c[0]=inlet_count1&LENGTHMASK;
c[1]=inlet_count2&LENGTHMASK;
c[2]=inlet_count3&LENGTHMASK;
c[3]=inlet_count4&LENGTHMASK;

for(int i=0;i<16;i++){
	C[i]=c[((param_countselect>>(i*2))&3)];
}

int32_t rate;
MTOF(param_rate,rate)
rate=rate>>2;
int diff=___SMMUL(param_differents,LENGTH<<5)+1;
if(inlet_rnd&&!rnd){
	rnd=1;
	for(int j=0;j<16;j++)
	{
		int k=j<<LENGTHPOW;
		int CNT=0,stmp,ctmp;
		for(int i=0;i<LENGTH;i++)
		{
			if(i<diff)
			{
			if((((int32_t)(GenerateRandomNumber()>>5)<param_movefollow)&&(i>1))||(CNT>0))
			{
				if(CNT==0){
				stmp=GenerateRandomNumber()%i;
				ctmp=GenerateRandomNumber()%i;
				CNT=(int32_t)(GenerateRandomNumber());
				CNT=___SMMUL(CNT,CNT)>>27;
				}
				else{CNT-=1;}
				if((int32_t)(GenerateRandomNumber()>>5)<param_copyformer)
				{
					array[i+k]=array[i-1-ctmp+k]+(array[i-stmp+k]-array[i-stmp-1+k])*((int32_t)(GenerateRandomNumber()>>5)<param_turn?-1:1);	
				}
				else
				{
					
					array[i+k]=array[i-1+k]+(array[i-stmp+k]-array[i-stmp-1+k])*((int32_t)(GenerateRandomNumber()>>5)<param_turn?-1:1);
				}
			}
			else
			{
				if(((int32_t)(GenerateRandomNumber()>>5)<param_copyformer)&&(i>1))
				{
					int ctmp=GenerateRandomNumber()%i;
					array[i+k]=array[i-1-ctmp+k];
				}
				else{
				array[i+k]=(uint16_t)(GenerateRandomNumber()>>16);
				}
			}
			}
			else{
				array[i+k]=array[k+(GenerateRandomNumber()%diff)];
			}
		}
	}
}
else if(!inlet_rnd){rnd=0;}



		
for(int j=0;j<16;j++)
{
	if(!(C[j]==prv[j])){
	int i=C[j];
	int k=j<<LENGTHPOW;
	int CNT=0,stmp,ctmp;
	if((int32_t)(GenerateRandomNumber()>>5)<param_asOffset){
		ofs[j]=array[i]-array[(i-1)&LENGTHPOW];
		
	}
	if((int32_t)(GenerateRandomNumber()>>5)<param_invert){
		INV[j]=INV[j]>0?0:1;
		
	}
	if(cnt==0){
		ofs[j]=(int32_t)(GenerateRandomNumber()>>5)<param_randomstart?GenerateRandomNumber():(param_evolve>0?ofs[j]:0);
	}
		if((int32_t)(GenerateRandomNumber()>>5)<param_update){
		
		{
			if(i<diff)
			{
			if((((int32_t)(GenerateRandomNumber()>>5)<param_movefollow)&&(i>1))||(CNT>0))
			{
				if(CNT==0){
				stmp=GenerateRandomNumber()%i;
				ctmp=GenerateRandomNumber()%i;
				CNT=(int32_t)(GenerateRandomNumber());
				CNT=___SMMUL(CNT,CNT)>>27;
				//CNT=CNT>4?4:CNT;
				}
				else{CNT-=1;}
				if((int32_t)(GenerateRandomNumber()>>5)<param_copyformer)
				{
					array[i+k]=array[i-1-ctmp+k]+(array[i-stmp+k]-array[i-stmp-1+k])*((int32_t)(GenerateRandomNumber()>>5)<param_turn?-1:1);	
				}
				else
				{
					
					array[i+k]=array[i-1+k]+(array[i-stmp+k]-array[i-stmp-1+k])*((int32_t)(GenerateRandomNumber()>>5)<param_turn?-1:1);
				}
			}
			else
			{
				if(((int32_t)(GenerateRandomNumber()>>5)<param_copyformer)&&(i>1))
				{
					int ctmp=GenerateRandomNumber()%i;
					array[i+k]=array[i-1-ctmp+k];
				}
				else{
				array[i+k]=(uint16_t)(GenerateRandomNumber()>>16);
				}
			}
			}
			else{
				array[i+k]=array[k+(GenerateRandomNumber()%diff)];
			}
		}
	}
	}
}


for(int i=0;i<16;i++){
if(!(C[i]==prv[i])){
int pos=C[i];
int32_t former=O[i];
int32_t goal=((array[pos+(i<<LENGTHPOW)]+ofs[i])&((1<<16)-1))<<11+param_pendulum;

if(param_pendulum){
goal=(__USAT(goal,27)<<1)-goal;
}
if(INV[i]){
goal=(1<<27)-goal;
}
if(cnt>0){
int32_t df=goal-former;
df=___SMMUL(df<<2,param_maxchange<<3);
goal=former+df;
}
O[i]=goal;

	if(!(((int32_t)(GenerateRandomNumber()>>5)<param_glide)&&((param_gliderange>>(i*2))&3))){
		P[i]=O[i];
	}
	
	}
}
for(int i=0;i<16;i++){
P[i]+=___SMMUL(O[i]-P[i],rate)>>((param_gliderange>>(i*2))&3);
prv[i]=C[i];
}
outlet_o1=P[0];
outlet_o2=P[1];
outlet_o3=P[2];
outlet_o4=P[3];
outlet_o5=P[4];
outlet_o6=P[5];
outlet_o7=P[6];
outlet_o8=P[7];
outlet_o9=P[8];
outlet_o10=P[9];
outlet_o11=P[10];
outlet_o12=P[11];
outlet_o13=P[12];
outlet_o14=P[13];
outlet_o15=P[14];
outlet_o16=P[15];]]></code.krate>
      </object>
   </patchobj>
   <obj type="mix/mix 2 g" uuid="a68d65dda222bc916b36b283cc06d2edd719bf3b" name="mix_3" x="266" y="182">
      <params>
         <frac32.u.map name="gain1" value="15.0"/>
         <frac32.u.map name="gain2" value="18.5"/>
      </params>
      <attribs/>
   </obj>
   <obj type="ctrl/i" uuid="a3786816db6ea5bc6ac4193a5cccdb2c83b83496" name="i_3" x="364" y="182">
      <params>
         <int32 name="value" value="17"/>
      </params>
      <attribs/>
   </obj>
   <obj type="harmony/note scale" uuid="d5343a4fea87a3e4f4dae20287226084550ea8d3" name="note_3" x="420" y="182">
      <params>
         <bin12 name="b12" value="2741"/>
      </params>
      <attribs/>
   </obj>
   <obj type="logic/latch" uuid="14750683752bd43205826430adb7168dae3cc2c" name="latch_1" x="574" y="182">
      <params/>
      <attribs/>
   </obj>
   <obj type="conv/interp" uuid="d68c1a8709d8b55e3de8715d727ec0a2d8569d9a" name="interp_1" x="644" y="182">
      <params/>
      <attribs/>
   </obj>
   <patchobj type="patch/object" uuid="dec13069-087a-465c-836b-c1577851ac25" name="sine_4" x="924" y="210">
      <params>
         <frac32.s.map name="pitch" value="-64.0"/>
      </params>
      <attribs/>
      <object id="patch/object" uuid="dec13069-087a-465c-836b-c1577851ac25">
         <sDescription>sine wave oscillator</sDescription>
         <author>Johannes Taelman</author>
         <license>BSD</license>
         <helpPatch>osc.axh</helpPatch>
         <inlets>
            <frac32.bipolar name="pitch" description="pitch"/>
            <frac32buffer name="freq" description="frequency"/>
            <frac32buffer name="phase" description="phase"/>
         </inlets>
         <outlets>
            <frac32buffer.bipolar name="wave" description="sine wave"/>
         </outlets>
         <displays/>
         <params>
            <frac32.s.map.pitch name="pitch" noLabel="true"/>
         </params>
         <attribs/>
         <includes/>
         <code.declaration><![CDATA[uint32_t Phase;]]></code.declaration>
         <code.init><![CDATA[Phase = 0;]]></code.init>
         <code.krate><![CDATA[int32_t freq;
   MTOFEXTENDED(param_pitch + inlet_pitch,freq);
freq=freq>>11;]]></code.krate>
         <code.srate><![CDATA[Phase += freq + inlet_freq;
int32_t r;
int32_t p2 = Phase + (inlet_phase<<4);
SINE2TINTERP(p2,r)
outlet_wave= (r>>4);
]]></code.srate>
      </object>
   </patchobj>
   <obj type="math/*c" uuid="7a66f52a9594e7e9eb31328ea725cb3641a80b55" name="*c_5" x="1022" y="210">
      <params>
         <frac32.u.map name="amp" value="2.5"/>
      </params>
      <attribs/>
   </obj>
   <obj type="math/inv" uuid="7f4c6cf4dcf79f9b0aa81c2eaf540405875714a3" name="inv_4" x="1120" y="210">
      <params/>
      <attribs/>
   </obj>
   <patchobj type="patch/object" uuid="dec13069-087a-465c-836b-c1577851ac25" name="sine_2" x="1176" y="210">
      <params>
         <frac32.s.map name="pitch" value="-64.0"/>
      </params>
      <attribs/>
      <object id="patch/object" uuid="dec13069-087a-465c-836b-c1577851ac25">
         <sDescription>sine wave oscillator</sDescription>
         <author>Johannes Taelman</author>
         <license>BSD</license>
         <helpPatch>osc.axh</helpPatch>
         <inlets>
            <frac32.bipolar name="pitch" description="pitch"/>
            <frac32buffer name="freq" description="frequency"/>
            <frac32buffer name="phase" description="phase"/>
         </inlets>
         <outlets>
            <frac32buffer.bipolar name="wave" description="sine wave"/>
         </outlets>
         <displays/>
         <params>
            <frac32.s.map.pitch name="pitch" noLabel="true"/>
         </params>
         <attribs/>
         <includes/>
         <code.declaration><![CDATA[uint32_t Phase;]]></code.declaration>
         <code.init><![CDATA[Phase = 0;]]></code.init>
         <code.krate><![CDATA[int32_t freq;
   MTOFEXTENDED(param_pitch + inlet_pitch,freq);
freq=freq>>8;]]></code.krate>
         <code.srate><![CDATA[Phase += freq + inlet_freq;
int32_t r;
int32_t p2 = Phase + (inlet_phase<<4);
SINE2TINTERP(p2,r)
outlet_wave= (r>>4);
]]></code.srate>
      </object>
   </patchobj>
   <obj type="math/*c" uuid="7a66f52a9594e7e9eb31328ea725cb3641a80b55" name="*c_3" x="1274" y="210">
      <params>
         <frac32.u.map name="amp" value="1.5"/>
      </params>
      <attribs/>
   </obj>
   <obj type="math/inv" uuid="7f4c6cf4dcf79f9b0aa81c2eaf540405875714a3" name="inv_2" x="1372" y="210">
      <params/>
      <attribs/>
   </obj>
   <patchobj type="patch/object" uuid="dec13069-087a-465c-836b-c1577851ac25" name="sine_5" x="1428" y="210">
      <params>
         <frac32.s.map name="pitch" value="-48.209999561309814"/>
      </params>
      <attribs/>
      <object id="patch/object" uuid="dec13069-087a-465c-836b-c1577851ac25">
         <sDescription>sine wave oscillator</sDescription>
         <author>Johannes Taelman</author>
         <license>BSD</license>
         <helpPatch>osc.axh</helpPatch>
         <inlets>
            <frac32.bipolar name="pitch" description="pitch"/>
            <frac32buffer name="freq" description="frequency"/>
            <frac32buffer name="phase" description="phase"/>
         </inlets>
         <outlets>
            <frac32buffer.bipolar name="wave" description="sine wave"/>
         </outlets>
         <displays/>
         <params>
            <frac32.s.map.pitch name="pitch" noLabel="true"/>
         </params>
         <attribs/>
         <includes/>
         <code.declaration><![CDATA[uint32_t Phase;]]></code.declaration>
         <code.init><![CDATA[Phase = 0;]]></code.init>
         <code.krate><![CDATA[int32_t freq;
   MTOFEXTENDED(param_pitch + inlet_pitch,freq);
freq=freq>>8;]]></code.krate>
         <code.srate><![CDATA[Phase += freq + inlet_freq;
int32_t r;
int32_t p2 = Phase + (inlet_phase<<4);
SINE2TINTERP(p2,r)
outlet_wave= (r>>5)+(1<<26);]]></code.srate>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="09dff1d6-cc86-4f97-a36c-562ed92e5e4b" name="*c_4" x="1554" y="210">
      <params>
         <frac32.u.map name="amp" value="45.959999561309814"/>
      </params>
      <attribs/>
      <object id="patch/object" uuid="09dff1d6-cc86-4f97-a36c-562ed92e5e4b">
         <sDescription>Multiply (attenuate) with a constant value</sDescription>
         <author>Johannes Taelman</author>
         <license>BSD</license>
         <helpPatch>math.axh</helpPatch>
         <inlets>
            <frac32buffer name="in" description="input"/>
         </inlets>
         <outlets>
            <frac32buffer name="out" description="output"/>
            <frac32buffer name="iout"/>
         </outlets>
         <displays/>
         <params>
            <frac32.u.map.gain name="amp" noLabel="true"/>
         </params>
         <attribs/>
         <includes/>
         <code.srate><![CDATA[outlet_out= ___SMMUL(param_amp,inlet_in)<<1;
outlet_iout=(param_amp>>4)-outlet_out;]]></code.srate>
      </object>
   </patchobj>
   <comment type="patch/comment" x="560" y="308" text="voice"/>
   <patchobj type="patch/object" uuid="065a1f22-0c8e-4800-9f93-8204bc28bbeb" name="envelope" x="378" y="322">
      <params>
         <frac32.s.map name="a" value="32.0"/>
         <frac32.s.map name="d" value="-15.0"/>
         <frac32.s.map name="skew" value="-20.0"/>
         <frac32.u.map name="shift" value="23.0"/>
         <frac32.u.map name="expo" value="32.0"/>
      </params>
      <attribs/>
      <object id="patch/object" uuid="065a1f22-0c8e-4800-9f93-8204bc28bbeb">
         <sDescription>Attack/decay envelope, linear attack, linear to exponential decay with skew and shift function for start-mid-end decay rate for different tail shapes.</sDescription>
         <author>Remco van der Most</author>
         <license>BSD</license>
         <helpPatch>env.axh</helpPatch>
         <inlets>
            <bool32.rising name="trig" description="trigger"/>
            <frac32 name="a"/>
            <frac32 name="d"/>
            <frac32 name="skew"/>
            <frac32 name="shift"/>
            <frac32 name="expo"/>
         </inlets>
         <outlets>
            <frac32buffer name="env"/>
         </outlets>
         <displays/>
         <params>
            <frac32.s.map.klineartime.exp name="a"/>
            <frac32.s.map.klineartime.exp name="d"/>
            <frac32.s.map name="skew"/>
            <frac32.u.map name="shift"/>
            <frac32.u.map name="expo"/>
         </params>
         <attribs/>
         <includes/>
         <code.declaration><![CDATA[int8_t stage;
int ntrig;
int32_t val;]]></code.declaration>
         <code.init><![CDATA[ntrig = 0;
val = 0;]]></code.init>
         <code.srate><![CDATA[if ((inlet_trig>0) && !ntrig)
{
	ntrig = 1;
	stage = 1;
} 
else if (!(inlet_trig>0))
{
	ntrig = 0;
}
if (stage == 0)
{
	int32_t t,d,D1,D2,D3,shift,skew;
	shift=__USAT(param_shift+inlet_shift,27);
	skew=__SSAT(param_skew+inlet_skew,28);
	d=__SSAT(param_d+inlet_d,28);
	
	D1=d+skew-(___SMMUL(shift<<1,skew)<<5);
	D2=d+(___SMMUL(__USAT(shift<<1,27),skew)<<5);
	D3=d-skew;
	
	D1=D2+___SMMUL(D1-D2<<1,val);
	D2=D3+___SMMUL(D2-D3<<1,val);
	D1=D2+___SMMUL(D1-D2<<1,val);
	
	MTOF(-(D1),t);
	d=t>>4;
	t=t>>6;
	t+=___SMMUL((___SMMUL(val,d))-t,param_expo)<<5;
	
	val = __USAT(val-t,31);
} 
else 
{
	int32_t t,a;
	MTOF(-param_a,t);
	a=t>>4;
	t=t>>6;
	
	a=___SMMUL((___SMMUL(((1<<31)-1)-val,a))-t,__USAT(param_expo+inlet_expo,27))<<5;
	t+=a-(a>>8);
	
	val = val + t;
	
	if(val<0)
	{
		val =0x7FFFFFFF;
		stage = 0;
	}
	
}

outlet_env = val>>4;]]></code.srate>
      </object>
   </patchobj>
   <obj type="filter/lp1 m" uuid="18b561d14f9175f5380e6a1d9d55ca41e0e61974" name="lp1_1" x="476" y="322">
      <params>
         <frac32.u.map name="freq" value="0.0"/>
      </params>
      <attribs/>
   </obj>
   <patchobj type="patch/object" uuid="6c5df040-d406-487c-b662-6a36d833f286" name="sine_6" x="546" y="322">
      <params>
         <frac32.s.map name="pitch" value="-36.0"/>
      </params>
      <attribs/>
      <object id="patch/object" uuid="6c5df040-d406-487c-b662-6a36d833f286">
         <sDescription>sine wave oscillator</sDescription>
         <author>Johannes Taelman</author>
         <license>BSD</license>
         <helpPatch>osc.axh</helpPatch>
         <inlets>
            <frac32buffer name="pitch"/>
            <frac32buffer name="freq" description="frequency"/>
            <frac32buffer name="phase" description="phase"/>
         </inlets>
         <outlets>
            <frac32buffer.bipolar name="wave" description="sine wave"/>
         </outlets>
         <displays/>
         <params>
            <frac32.s.map.pitch name="pitch" noLabel="true"/>
         </params>
         <attribs/>
         <includes/>
         <code.declaration><![CDATA[uint32_t Phase;]]></code.declaration>
         <code.init><![CDATA[Phase = 0;]]></code.init>
         <code.srate><![CDATA[int32_t freq;
   MTOFEXTENDED(param_pitch + inlet_pitch,freq);

Phase += freq + inlet_freq;
int32_t r;
int32_t p2 = Phase + (inlet_phase<<4);
SINE2TINTERP(p2,r)
outlet_wave= (r>>4);]]></code.srate>
      </object>
   </patchobj>
   <obj type="math/*" uuid="dc7fbdd46e5e6d4b8de62ee63fd6321639b2f167" name="*_1" x="644" y="322">
      <params/>
      <attribs/>
   </obj>
   <obj type="math/*c" uuid="7a66f52a9594e7e9eb31328ea725cb3641a80b55" name="*c_7" x="700" y="322">
      <params>
         <frac32.u.map name="amp" value="6.5"/>
      </params>
      <attribs/>
   </obj>
   <obj type="delay/write sdram" uuid="5ae03f8d7b815edcfc40585d8bbac2ed48460fba" name="predelay" x="798" y="322">
      <params/>
      <attribs>
         <combo attributeName="size" selection="512 (10.66ms)"/>
      </attribs>
   </obj>
   <patchobj type="patch/object" uuid="dec13069-087a-465c-836b-c1577851ac25" name="sine_8" x="1260" y="336">
      <params>
         <frac32.s.map name="pitch" value="-34.0"/>
      </params>
      <attribs/>
      <object id="patch/object" uuid="dec13069-087a-465c-836b-c1577851ac25">
         <sDescription>sine wave oscillator</sDescription>
         <author>Johannes Taelman</author>
         <license>BSD</license>
         <helpPatch>osc.axh</helpPatch>
         <inlets>
            <frac32.bipolar name="pitch" description="pitch"/>
            <frac32buffer name="freq" description="frequency"/>
            <frac32buffer name="phase" description="phase"/>
         </inlets>
         <outlets>
            <frac32buffer.bipolar name="wave" description="sine wave"/>
         </outlets>
         <displays/>
         <params>
            <frac32.s.map.pitch name="pitch" noLabel="true"/>
         </params>
         <attribs/>
         <includes/>
         <code.declaration><![CDATA[uint32_t Phase;]]></code.declaration>
         <code.init><![CDATA[Phase = 0;]]></code.init>
         <code.krate><![CDATA[int32_t freq;
   MTOFEXTENDED(param_pitch + inlet_pitch,freq);
freq=freq>>8;]]></code.krate>
         <code.srate><![CDATA[Phase += freq + inlet_freq;
int32_t r;
int32_t p2 = Phase + (inlet_phase<<4);
SINE2TINTERP(p2,r)
outlet_wave= (r>>5)+(1<<26);]]></code.srate>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="09dff1d6-cc86-4f97-a36c-562ed92e5e4b" name="*c_8" x="1386" y="336">
      <params>
         <frac32.u.map name="amp" value="13.0"/>
      </params>
      <attribs/>
      <object id="patch/object" uuid="09dff1d6-cc86-4f97-a36c-562ed92e5e4b">
         <sDescription>Multiply (attenuate) with a constant value</sDescription>
         <author>Johannes Taelman</author>
         <license>BSD</license>
         <helpPatch>math.axh</helpPatch>
         <inlets>
            <frac32buffer name="in" description="input"/>
         </inlets>
         <outlets>
            <frac32buffer name="out" description="output"/>
            <frac32buffer name="iout"/>
         </outlets>
         <displays/>
         <params>
            <frac32.u.map.gain name="amp" noLabel="true"/>
         </params>
         <attribs/>
         <includes/>
         <code.srate><![CDATA[outlet_out= ___SMMUL(param_amp,inlet_in)<<1;
outlet_iout=(param_amp>>4)-outlet_out;]]></code.srate>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="5622932a-a3fb-45da-927f-d2650b884e1f" name="read predelay left (room pos)" x="910" y="350">
      <params>
         <frac32.u.map name="time" value="0.029999732971191406"/>
      </params>
      <attribs>
         <objref attributeName="delayname" obj="predelay"/>
      </attribs>
      <object id="patch/object" uuid="5622932a-a3fb-45da-927f-d2650b884e1f">
         <sDescription>delay read, linear interpolated</sDescription>
         <author>Johannes Taelman</author>
         <license>BSD</license>
         <helpPatch>delay.axh</helpPatch>
         <inlets>
            <frac32buffer name="interpSmall" description="delay time (fraction of total delayline size)"/>
            <frac32buffer name="interpBig"/>
         </inlets>
         <outlets>
            <frac32buffer name="out" description="wave"/>
         </outlets>
         <displays/>
         <params>
            <frac32.u.map name="time" noLabel="true"/>
         </params>
         <attribs>
            <objref name="delayname"/>
         </attribs>
         <includes/>
         <code.srate><![CDATA[int32_t D=__USAT(inlet_interpBig+param_time,27);
	int32_t S,MX;
	S=D>>27-attr_delayname.LENGTHPOW;
	MX=((uint32_t)D<<5+attr_delayname.LENGTHPOW)>>1;

	
	int32_t T =  __USAT(inlet_interpSmall,27);
		int32_t s,mx;
		s=T>>19;
		mx=((uint32_t)T<<13)>>1;
      T = attr_delayname.writepos - s -S- BUFSIZE + buffer_index -1;
      int32_t a1 = attr_delayname.array[T&attr_delayname.LENGTHMASK]<<14;
      int32_t a2 = attr_delayname.array[(T-1)&attr_delayname.LENGTHMASK]<<14;
      a1+=___SMMUL(a2-a1,mx)<<1;
      
      T = attr_delayname.writepos - s -S- BUFSIZE + buffer_index -2;
      int32_t b1 = attr_delayname.array[T&attr_delayname.LENGTHMASK]<<14;
      int32_t b2 = attr_delayname.array[(T-1)&attr_delayname.LENGTHMASK]<<14;
	 b1+=___SMMUL(b2-b1,mx)<<1;
	
	 a1+=___SMMUL(b1-a1,MX)<<1;
      outlet_out= a1;]]></code.srate>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="5622932a-a3fb-45da-927f-d2650b884e1f" name="read predelay right (room pos)" x="1064" y="350">
      <params>
         <frac32.u.map name="time" value="0.0"/>
      </params>
      <attribs>
         <objref attributeName="delayname" obj="predelay"/>
      </attribs>
      <object id="patch/object" uuid="5622932a-a3fb-45da-927f-d2650b884e1f">
         <sDescription>delay read, linear interpolated</sDescription>
         <author>Johannes Taelman</author>
         <license>BSD</license>
         <helpPatch>delay.axh</helpPatch>
         <inlets>
            <frac32buffer name="interpSmall" description="delay time (fraction of total delayline size)"/>
            <frac32buffer name="interpBig"/>
         </inlets>
         <outlets>
            <frac32buffer name="out" description="wave"/>
         </outlets>
         <displays/>
         <params>
            <frac32.u.map name="time" noLabel="true"/>
         </params>
         <attribs>
            <objref name="delayname"/>
         </attribs>
         <includes/>
         <code.srate><![CDATA[int32_t D=__USAT(inlet_interpBig+param_time,27);
	int32_t S,MX;
	S=D>>27-attr_delayname.LENGTHPOW;
	MX=((uint32_t)D<<5+attr_delayname.LENGTHPOW)>>1;

	
	int32_t T =  __USAT(inlet_interpSmall,27);
		int32_t s,mx;
		s=T>>19;
		mx=((uint32_t)T<<13)>>1;
      T = attr_delayname.writepos - s -S- BUFSIZE + buffer_index -1;
      int32_t a1 = attr_delayname.array[T&attr_delayname.LENGTHMASK]<<14;
      int32_t a2 = attr_delayname.array[(T-1)&attr_delayname.LENGTHMASK]<<14;
      a1+=___SMMUL(a2-a1,mx)<<1;
      
      T = attr_delayname.writepos - s -S- BUFSIZE + buffer_index -2;
      int32_t b1 = attr_delayname.array[T&attr_delayname.LENGTHMASK]<<14;
      int32_t b2 = attr_delayname.array[(T-1)&attr_delayname.LENGTHMASK]<<14;
	 b1+=___SMMUL(b2-b1,mx)<<1;
	
	 a1+=___SMMUL(b1-a1,MX)<<1;
      outlet_out= a1;]]></code.srate>
      </object>
   </patchobj>
   <comment type="patch/comment" x="784" y="532" text="readout from delay buffer for feedback path"/>
   <comment type="patch/comment" x="1022" y="532" text="bit of filtering (alliasing is caused by 16bit buffer)"/>
   <comment type="patch/comment" x="1302" y="532" text="feedback amount for delay"/>
   <comment type="patch/comment" x="1484" y="532" text="main delay buffer (stereo pingpong with readouts)"/>
   <patchobj type="patch/object" uuid="dec13069-087a-465c-836b-c1577851ac25" name="sine_9" x="546" y="546">
      <params>
         <frac32.s.map name="pitch" value="-56.0"/>
      </params>
      <attribs/>
      <object id="patch/object" uuid="dec13069-087a-465c-836b-c1577851ac25">
         <sDescription>sine wave oscillator</sDescription>
         <author>Johannes Taelman</author>
         <license>BSD</license>
         <helpPatch>osc.axh</helpPatch>
         <inlets>
            <frac32.bipolar name="pitch" description="pitch"/>
            <frac32buffer name="freq" description="frequency"/>
            <frac32buffer name="phase" description="phase"/>
         </inlets>
         <outlets>
            <frac32buffer.bipolar name="wave" description="sine wave"/>
         </outlets>
         <displays/>
         <params>
            <frac32.s.map.pitch name="pitch" noLabel="true"/>
         </params>
         <attribs/>
         <includes/>
         <code.declaration><![CDATA[uint32_t Phase;]]></code.declaration>
         <code.init><![CDATA[Phase = 0;]]></code.init>
         <code.krate><![CDATA[int32_t freq;
   MTOFEXTENDED(param_pitch + inlet_pitch,freq);
freq=freq>>8;]]></code.krate>
         <code.srate><![CDATA[Phase += freq + inlet_freq;
int32_t r;
int32_t p2 = Phase + (inlet_phase<<4);
SINE2TINTERP(p2,r)
outlet_wave= (r>>5)+(1<<26);]]></code.srate>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="09dff1d6-cc86-4f97-a36c-562ed92e5e4b" name="*c_6" x="644" y="546">
      <params>
         <frac32.u.map name="amp" value="0.059999942779541016"/>
      </params>
      <attribs/>
      <object id="patch/object" uuid="09dff1d6-cc86-4f97-a36c-562ed92e5e4b">
         <sDescription>Multiply (attenuate) with a constant value</sDescription>
         <author>Johannes Taelman</author>
         <license>BSD</license>
         <helpPatch>math.axh</helpPatch>
         <inlets>
            <frac32buffer name="in" description="input"/>
         </inlets>
         <outlets>
            <frac32buffer name="out" description="output"/>
            <frac32buffer name="iout"/>
         </outlets>
         <displays/>
         <params>
            <frac32.u.map.gain name="amp" noLabel="true"/>
         </params>
         <attribs/>
         <includes/>
         <code.srate><![CDATA[int32_t o= ___SMMUL(param_amp,inlet_in)<<1;
outlet_out=o;
outlet_iout=(param_amp>>4)-o;]]></code.srate>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="5622932a-a3fb-45da-927f-d2650b884e1f" name="read_3" x="742" y="546">
      <params>
         <frac32.u.map name="time" value="27.0"/>
      </params>
      <attribs>
         <objref attributeName="delayname" obj="delay_record_right"/>
      </attribs>
      <object id="patch/object" uuid="5622932a-a3fb-45da-927f-d2650b884e1f">
         <sDescription>delay read, linear interpolated</sDescription>
         <author>Johannes Taelman</author>
         <license>BSD</license>
         <helpPatch>delay.axh</helpPatch>
         <inlets>
            <frac32buffer name="interpSmall" description="delay time (fraction of total delayline size)"/>
            <frac32buffer name="interpBig"/>
         </inlets>
         <outlets>
            <frac32buffer name="out" description="wave"/>
         </outlets>
         <displays/>
         <params>
            <frac32.u.map name="time" noLabel="true"/>
         </params>
         <attribs>
            <objref name="delayname"/>
         </attribs>
         <includes/>
         <code.srate><![CDATA[int32_t D=__USAT(inlet_interpBig+param_time,27);
	int32_t S,MX;
	S=D>>27-attr_delayname.LENGTHPOW;
	MX=((uint32_t)D<<5+attr_delayname.LENGTHPOW)>>1;

	
	int32_t T =  __USAT(inlet_interpSmall,27);
		int32_t s,mx;
		s=T>>19;
		mx=((uint32_t)T<<13)>>1;
      T = attr_delayname.writepos - s -S- BUFSIZE + buffer_index -1;
      int32_t a1 = attr_delayname.array[T&attr_delayname.LENGTHMASK]<<14;
      int32_t a2 = attr_delayname.array[(T-1)&attr_delayname.LENGTHMASK]<<14;
      a1+=___SMMUL(a2-a1,mx)<<1;
      
      T = attr_delayname.writepos - s -S- BUFSIZE + buffer_index -2;
      int32_t b1 = attr_delayname.array[T&attr_delayname.LENGTHMASK]<<14;
      int32_t b2 = attr_delayname.array[(T-1)&attr_delayname.LENGTHMASK]<<14;
	 b1+=___SMMUL(b2-b1,mx)<<1;
	
	 a1+=___SMMUL(b1-a1,MX)<<1;
      outlet_out= a1;]]></code.srate>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="5622932a-a3fb-45da-927f-d2650b884e1f" name="read_4" x="896" y="546">
      <params>
         <frac32.u.map name="time" value="27.0"/>
      </params>
      <attribs>
         <objref attributeName="delayname" obj="delay_record_left"/>
      </attribs>
      <object id="patch/object" uuid="5622932a-a3fb-45da-927f-d2650b884e1f">
         <sDescription>delay read, linear interpolated</sDescription>
         <author>Johannes Taelman</author>
         <license>BSD</license>
         <helpPatch>delay.axh</helpPatch>
         <inlets>
            <frac32buffer name="interpSmall" description="delay time (fraction of total delayline size)"/>
            <frac32buffer name="interpBig"/>
         </inlets>
         <outlets>
            <frac32buffer name="out" description="wave"/>
         </outlets>
         <displays/>
         <params>
            <frac32.u.map name="time" noLabel="true"/>
         </params>
         <attribs>
            <objref name="delayname"/>
         </attribs>
         <includes/>
         <code.srate><![CDATA[int32_t D=__USAT(inlet_interpBig+param_time,27);
	int32_t S,MX;
	S=D>>27-attr_delayname.LENGTHPOW;
	MX=((uint32_t)D<<5+attr_delayname.LENGTHPOW)>>1;

	
	int32_t T =  __USAT(inlet_interpSmall,27);
		int32_t s,mx;
		s=T>>19;
		mx=((uint32_t)T<<13)>>1;
      T = attr_delayname.writepos - s -S- BUFSIZE + buffer_index -1;
      int32_t a1 = attr_delayname.array[T&attr_delayname.LENGTHMASK]<<14;
      int32_t a2 = attr_delayname.array[(T-1)&attr_delayname.LENGTHMASK]<<14;
      a1+=___SMMUL(a2-a1,mx)<<1;
      
      T = attr_delayname.writepos - s -S- BUFSIZE + buffer_index -2;
      int32_t b1 = attr_delayname.array[T&attr_delayname.LENGTHMASK]<<14;
      int32_t b2 = attr_delayname.array[(T-1)&attr_delayname.LENGTHMASK]<<14;
	 b1+=___SMMUL(b2-b1,mx)<<1;
	
	 a1+=___SMMUL(b1-a1,MX)<<1;
      outlet_out= a1;]]></code.srate>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="36b4fb93-9cd5-4f78-9b2b-351ee070a39c" name="lp1_2" x="1064" y="546">
      <params>
         <frac32.s.map name="freq" value="64.0"/>
      </params>
      <attribs/>
      <object id="patch/object" uuid="36b4fb93-9cd5-4f78-9b2b-351ee070a39c">
         <sDescription>1st order lowpass filter</sDescription>
         <author>Johannes Taelman</author>
         <license>BSD</license>
         <helpPatch>filter.axh</helpPatch>
         <inlets>
            <frac32buffer name="in" description="input"/>
         </inlets>
         <outlets>
            <frac32buffer name="out" description="output"/>
         </outlets>
         <displays/>
         <params>
            <frac32.s.map.pitch name="freq" noLabel="true"/>
         </params>
         <attribs/>
         <includes/>
         <code.declaration><![CDATA[int32_t val;
]]></code.declaration>
         <code.init><![CDATA[val = 0;
]]></code.init>
         <code.krate><![CDATA[int32_t f;
   MTOF(param_freq,f);
]]></code.krate>
         <code.srate><![CDATA[val = ___SMMLA((inlet_in-val)<<1,f,val);
   val = ___SMMLA((inlet_in-val)<<1,f,val);
   outlet_out= val;]]></code.srate>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="36b4fb93-9cd5-4f78-9b2b-351ee070a39c" name="lp1_3" x="1162" y="546">
      <params>
         <frac32.s.map name="freq" value="64.0"/>
      </params>
      <attribs/>
      <object id="patch/object" uuid="36b4fb93-9cd5-4f78-9b2b-351ee070a39c">
         <sDescription>1st order lowpass filter</sDescription>
         <author>Johannes Taelman</author>
         <license>BSD</license>
         <helpPatch>filter.axh</helpPatch>
         <inlets>
            <frac32buffer name="in" description="input"/>
         </inlets>
         <outlets>
            <frac32buffer name="out" description="output"/>
         </outlets>
         <displays/>
         <params>
            <frac32.s.map.pitch name="freq" noLabel="true"/>
         </params>
         <attribs/>
         <includes/>
         <code.declaration><![CDATA[int32_t val;
]]></code.declaration>
         <code.init><![CDATA[val = 0;
]]></code.init>
         <code.krate><![CDATA[int32_t f;
   MTOF(param_freq,f);
]]></code.krate>
         <code.srate><![CDATA[val = ___SMMLA((inlet_in-val)<<1,f,val);
   val = ___SMMLA((inlet_in-val)<<1,f,val);
   outlet_out= val;]]></code.srate>
      </object>
   </patchobj>
   <obj type="mix/mix 1 sq" uuid="cf790039775b62697a4b34e7a5389a5a8cc36e30" name="mix_1" x="1288" y="546">
      <params>
         <frac32.u.map name="gain1" value="56.0"/>
      </params>
      <attribs/>
   </obj>
   <obj type="mix/mix 1 sq" uuid="cf790039775b62697a4b34e7a5389a5a8cc36e30" name="mix_2" x="1386" y="546">
      <params>
         <frac32.u.map name="gain1" value="56.0"/>
      </params>
      <attribs/>
   </obj>
   <obj type="delay/write sdram" uuid="5ae03f8d7b815edcfc40585d8bbac2ed48460fba" name="delay_record_left" x="1498" y="546">
      <params/>
      <attribs>
         <combo attributeName="size" selection="131072 (2.73s)"/>
      </attribs>
   </obj>
   <obj type="delay/write sdram" uuid="5ae03f8d7b815edcfc40585d8bbac2ed48460fba" name="delay_record_right" x="1610" y="546">
      <params/>
      <attribs>
         <combo attributeName="size" selection="131072 (2.73s)"/>
      </attribs>
   </obj>
   <comment type="patch/comment" x="812" y="672" text="readout from delay buffer for output path"/>
   <comment type="patch/comment" x="1358" y="672" text="mix amount of delay with dry signal"/>
   <comment type="patch/comment" x="1666" y="672" text="delay input stereo scatter"/>
   <patchobj type="patch/object" uuid="dec13069-087a-465c-836b-c1577851ac25" name="sine_10" x="546" y="686">
      <params>
         <frac32.s.map name="pitch" value="-61.66999959945679"/>
      </params>
      <attribs/>
      <object id="patch/object" uuid="dec13069-087a-465c-836b-c1577851ac25">
         <sDescription>sine wave oscillator</sDescription>
         <author>Johannes Taelman</author>
         <license>BSD</license>
         <helpPatch>osc.axh</helpPatch>
         <inlets>
            <frac32.bipolar name="pitch" description="pitch"/>
            <frac32buffer name="freq" description="frequency"/>
            <frac32buffer name="phase" description="phase"/>
         </inlets>
         <outlets>
            <frac32buffer.bipolar name="wave" description="sine wave"/>
         </outlets>
         <displays/>
         <params>
            <frac32.s.map.pitch name="pitch" noLabel="true"/>
         </params>
         <attribs/>
         <includes/>
         <code.declaration><![CDATA[uint32_t Phase;]]></code.declaration>
         <code.init><![CDATA[Phase = 0;]]></code.init>
         <code.krate><![CDATA[int32_t freq;
   MTOFEXTENDED(param_pitch + inlet_pitch,freq);
freq=freq>>8;]]></code.krate>
         <code.srate><![CDATA[Phase += freq + inlet_freq;
int32_t r;
int32_t p2 = Phase + (inlet_phase<<4);
SINE2TINTERP(p2,r)
outlet_wave= (r>>5)+(1<<26);]]></code.srate>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="09dff1d6-cc86-4f97-a36c-562ed92e5e4b" name="*c_10" x="644" y="686">
      <params>
         <frac32.u.map name="amp" value="0.06499910354614258"/>
      </params>
      <attribs/>
      <object id="patch/object" uuid="09dff1d6-cc86-4f97-a36c-562ed92e5e4b">
         <sDescription>Multiply (attenuate) with a constant value</sDescription>
         <author>Johannes Taelman</author>
         <license>BSD</license>
         <helpPatch>math.axh</helpPatch>
         <inlets>
            <frac32buffer name="in" description="input"/>
         </inlets>
         <outlets>
            <frac32buffer name="out" description="output"/>
            <frac32buffer name="iout"/>
         </outlets>
         <displays/>
         <params>
            <frac32.u.map.gain name="amp" noLabel="true"/>
         </params>
         <attribs/>
         <includes/>
         <code.srate><![CDATA[int32_t o= ___SMMUL(param_amp,inlet_in)<<1;
outlet_out=o;
outlet_iout=(param_amp>>4)-o;]]></code.srate>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="5622932a-a3fb-45da-927f-d2650b884e1f" name="read_7" x="742" y="686">
      <params>
         <frac32.u.map name="time" value="21.0"/>
      </params>
      <attribs>
         <objref attributeName="delayname" obj="delay_record_right"/>
      </attribs>
      <object id="patch/object" uuid="5622932a-a3fb-45da-927f-d2650b884e1f">
         <sDescription>delay read, linear interpolated</sDescription>
         <author>Johannes Taelman</author>
         <license>BSD</license>
         <helpPatch>delay.axh</helpPatch>
         <inlets>
            <frac32buffer name="interpSmall" description="delay time (fraction of total delayline size)"/>
            <frac32buffer name="interpBig"/>
         </inlets>
         <outlets>
            <frac32buffer name="out" description="wave"/>
         </outlets>
         <displays/>
         <params>
            <frac32.u.map name="time" noLabel="true"/>
         </params>
         <attribs>
            <objref name="delayname"/>
         </attribs>
         <includes/>
         <code.srate><![CDATA[int32_t D=__USAT(inlet_interpBig+param_time,27);
	int32_t S,MX;
	S=D>>27-attr_delayname.LENGTHPOW;
	MX=((uint32_t)D<<5+attr_delayname.LENGTHPOW)>>1;

	
	int32_t T =  __USAT(inlet_interpSmall,27);
		int32_t s,mx;
		s=T>>19;
		mx=((uint32_t)T<<13)>>1;
      T = attr_delayname.writepos - s -S- BUFSIZE + buffer_index -1;
      int32_t a1 = attr_delayname.array[T&attr_delayname.LENGTHMASK]<<14;
      int32_t a2 = attr_delayname.array[(T-1)&attr_delayname.LENGTHMASK]<<14;
      a1+=___SMMUL(a2-a1,mx)<<1;
      
      T = attr_delayname.writepos - s -S- BUFSIZE + buffer_index -2;
      int32_t b1 = attr_delayname.array[T&attr_delayname.LENGTHMASK]<<14;
      int32_t b2 = attr_delayname.array[(T-1)&attr_delayname.LENGTHMASK]<<14;
	 b1+=___SMMUL(b2-b1,mx)<<1;
	
	 a1+=___SMMUL(b1-a1,MX)<<1;
      outlet_out= a1;]]></code.srate>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="5622932a-a3fb-45da-927f-d2650b884e1f" name="read_8" x="896" y="686">
      <params>
         <frac32.u.map name="time" value="21.0"/>
      </params>
      <attribs>
         <objref attributeName="delayname" obj="delay_record_left"/>
      </attribs>
      <object id="patch/object" uuid="5622932a-a3fb-45da-927f-d2650b884e1f">
         <sDescription>delay read, linear interpolated</sDescription>
         <author>Johannes Taelman</author>
         <license>BSD</license>
         <helpPatch>delay.axh</helpPatch>
         <inlets>
            <frac32buffer name="interpSmall" description="delay time (fraction of total delayline size)"/>
            <frac32buffer name="interpBig"/>
         </inlets>
         <outlets>
            <frac32buffer name="out" description="wave"/>
         </outlets>
         <displays/>
         <params>
            <frac32.u.map name="time" noLabel="true"/>
         </params>
         <attribs>
            <objref name="delayname"/>
         </attribs>
         <includes/>
         <code.srate><![CDATA[int32_t D=__USAT(inlet_interpBig+param_time,27);
	int32_t S,MX;
	S=D>>27-attr_delayname.LENGTHPOW;
	MX=((uint32_t)D<<5+attr_delayname.LENGTHPOW)>>1;

	
	int32_t T =  __USAT(inlet_interpSmall,27);
		int32_t s,mx;
		s=T>>19;
		mx=((uint32_t)T<<13)>>1;
      T = attr_delayname.writepos - s -S- BUFSIZE + buffer_index -1;
      int32_t a1 = attr_delayname.array[T&attr_delayname.LENGTHMASK]<<14;
      int32_t a2 = attr_delayname.array[(T-1)&attr_delayname.LENGTHMASK]<<14;
      a1+=___SMMUL(a2-a1,mx)<<1;
      
      T = attr_delayname.writepos - s -S- BUFSIZE + buffer_index -2;
      int32_t b1 = attr_delayname.array[T&attr_delayname.LENGTHMASK]<<14;
      int32_t b2 = attr_delayname.array[(T-1)&attr_delayname.LENGTHMASK]<<14;
	 b1+=___SMMUL(b2-b1,mx)<<1;
	
	 a1+=___SMMUL(b1-a1,MX)<<1;
      outlet_out= a1;]]></code.srate>
      </object>
   </patchobj>
   <obj type="ctrl/dial p" uuid="cc5d2846c3d50e425f450c4b9851371b54f4d674" name="headsize" x="1064" y="686">
      <params>
         <frac32.u.map name="value" value="10.0"/>
      </params>
      <attribs/>
   </obj>
   <patchobj type="patch/object" uuid="8d639b2f-e8b7-4957-b2ed-0deb09c9431e" name="L-&gt;R delayed mix" x="1134" y="686">
      <params/>
      <attribs>
         <combo attributeName="size" selection="512 (10.66ms)"/>
      </attribs>
      <object id="patch/object" uuid="8d639b2f-e8b7-4957-b2ed-0deb09c9431e">
         <sDescription>delayline definition, read it with &quot;delay/read&quot; objects referencing the instance name of this object</sDescription>
         <author>Johannes Taelman</author>
         <license>BSD</license>
         <helpPatch>delay.axh</helpPatch>
         <inlets>
            <frac32buffer name="in" description="wave input"/>
            <frac32 name="time"/>
         </inlets>
         <outlets>
            <frac32buffer name="out"/>
         </outlets>
         <displays/>
         <params/>
         <attribs>
            <combo name="size">
               <MenuEntries>
                  <string>256 (5.33ms)</string>
                  <string>512 (10.66ms)</string>
                  <string>1024 (21.33ms)</string>
                  <string>2048 (42.66ms)</string>
                  <string>4096 (85.33ms)</string>
                  <string>8192 (170ms)</string>
                  <string>16384 (341ms)</string>
                  <string>32768 (682ms)</string>
                  <string>65536 (1.36s)</string>
                  <string>131072 (2.73s)</string>
                  <string>262144 (5.46s)</string>
                  <string>524288 (10.9s)</string>
                  <string>1048576 (21.8s)</string>
                  <string>2097152 (43.7s)</string>
               </MenuEntries>
               <CEntries>
                  <string>8</string>
                  <string>9</string>
                  <string>10</string>
                  <string>11</string>
                  <string>12</string>
                  <string>13</string>
                  <string>14</string>
                  <string>15</string>
                  <string>16</string>
                  <string>17</string>
                  <string>18</string>
                  <string>19</string>
                  <string>20</string>
                  <string>21</string>
               </CEntries>
            </combo>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[static const uint32_t LENGTHPOW = (attr_size);
static const uint32_t LENGTH = (1<<attr_size);
static const uint32_t LENGTHMASK = ((1<<attr_size)-1);
int16_t *array;
uint32_t writepos;]]></code.declaration>
         <code.init><![CDATA[static int16_t _array[attr_poly][1<<attr_size]  __attribute__ ((section (".sdram")));
array = &_array[parent->polyIndex][0];
   int i;
   writepos = 0;
   for(i=0;i<LENGTH;i++) array[i] = 0;]]></code.init>
         <code.srate><![CDATA[writepos = (writepos + 1)&LENGTHMASK;
   array[writepos] = __SSAT(inlet_in>>14,16);
   outlet_out=array[(writepos-(__USAT(inlet_time,27)>>27-LENGTHPOW))&LENGTHMASK]<<14;]]></code.srate>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="8d639b2f-e8b7-4957-b2ed-0deb09c9431e" name="R-&gt;L delayed mix" x="1246" y="686">
      <params/>
      <attribs>
         <combo attributeName="size" selection="512 (10.66ms)"/>
      </attribs>
      <object id="patch/object" uuid="8d639b2f-e8b7-4957-b2ed-0deb09c9431e">
         <sDescription>delayline definition, read it with &quot;delay/read&quot; objects referencing the instance name of this object</sDescription>
         <author>Johannes Taelman</author>
         <license>BSD</license>
         <helpPatch>delay.axh</helpPatch>
         <inlets>
            <frac32buffer name="in" description="wave input"/>
            <frac32 name="time"/>
         </inlets>
         <outlets>
            <frac32buffer name="out"/>
         </outlets>
         <displays/>
         <params/>
         <attribs>
            <combo name="size">
               <MenuEntries>
                  <string>256 (5.33ms)</string>
                  <string>512 (10.66ms)</string>
                  <string>1024 (21.33ms)</string>
                  <string>2048 (42.66ms)</string>
                  <string>4096 (85.33ms)</string>
                  <string>8192 (170ms)</string>
                  <string>16384 (341ms)</string>
                  <string>32768 (682ms)</string>
                  <string>65536 (1.36s)</string>
                  <string>131072 (2.73s)</string>
                  <string>262144 (5.46s)</string>
                  <string>524288 (10.9s)</string>
                  <string>1048576 (21.8s)</string>
                  <string>2097152 (43.7s)</string>
               </MenuEntries>
               <CEntries>
                  <string>8</string>
                  <string>9</string>
                  <string>10</string>
                  <string>11</string>
                  <string>12</string>
                  <string>13</string>
                  <string>14</string>
                  <string>15</string>
                  <string>16</string>
                  <string>17</string>
                  <string>18</string>
                  <string>19</string>
                  <string>20</string>
                  <string>21</string>
               </CEntries>
            </combo>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[static const uint32_t LENGTHPOW = (attr_size);
static const uint32_t LENGTH = (1<<attr_size);
static const uint32_t LENGTHMASK = ((1<<attr_size)-1);
int16_t *array;
uint32_t writepos;]]></code.declaration>
         <code.init><![CDATA[static int16_t _array[attr_poly][1<<attr_size]  __attribute__ ((section (".sdram")));
array = &_array[parent->polyIndex][0];
   int i;
   writepos = 0;
   for(i=0;i<LENGTH;i++) array[i] = 0;]]></code.init>
         <code.srate><![CDATA[writepos = (writepos + 1)&LENGTHMASK;
   array[writepos] = __SSAT(inlet_in>>14,16);
   outlet_out=array[(writepos-(__USAT(inlet_time,27)>>27-LENGTHPOW))&LENGTHMASK]<<14;]]></code.srate>
      </object>
   </patchobj>
   <obj type="mix/mix 2 sq" uuid="9b03da12a01f39ecd48d16285e7d10acb8e1267c" name="mix_4" x="1358" y="686">
      <params>
         <frac32.u.map name="gain1" value="52.0"/>
         <frac32.u.map name="gain2" value="33.0"/>
      </params>
      <attribs/>
   </obj>
   <obj type="mix/mix 2 sq" uuid="9b03da12a01f39ecd48d16285e7d10acb8e1267c" name="mix_5" x="1456" y="686">
      <params>
         <frac32.u.map name="gain1" value="52.0"/>
         <frac32.u.map name="gain2" value="33.0"/>
      </params>
      <attribs/>
   </obj>
   <obj type="audio/out stereo" uuid="a1ca7a567f535acc21055669829101d3ee7f0189" name="out_1" x="1554" y="686">
      <params/>
      <attribs/>
   </obj>
   <patchobj type="patch/object" uuid="2b6e9d3e-762f-48b8-befd-28527c74cded" name="stereo scatter_1" x="1666" y="686">
      <params>
         <frac32.u.map name="scatter" value="14.0"/>
         <int32.hradio name="mode" value="1"/>
      </params>
      <attribs>
         <objref attributeName="del1" obj="delay_record_left"/>
         <objref attributeName="del2" obj="delay_record_right"/>
      </attribs>
      <object id="patch/object" uuid="2b6e9d3e-762f-48b8-befd-28527c74cded">
         <sDescription>modulatable nested scatter/allpass function for delaylines.
Can be used with the factory delayline module to add diffusion to a delay</sDescription>
         <author>Remco van der Most</author>
         <license>BSD</license>
         <helpPatch>delay.axh</helpPatch>
         <inlets/>
         <outlets/>
         <displays/>
         <params>
            <frac32.u.map name="scatter"/>
            <int32.hradio name="mode" description="off,scatter,allpass">
               <MaxValue i="2"/>
            </int32.hradio>
         </params>
         <attribs>
            <objref name="del1"/>
            <objref name="del2"/>
         </attribs>
         <includes/>
         <code.krate><![CDATA[int32_t scatter=__USAT(param_scatter,27)<<4;


int32_t POS1=attr_del1.writepos-BUFSIZE-1-1;
int32_t POS2=attr_del2.writepos-BUFSIZE-1-1;]]></code.krate>
         <code.srate><![CDATA[if(param_mode>0){
int32_t p1=(POS1+buffer_index)&attr_del1.LENGTHMASK;
int32_t p2=(POS2+buffer_index)&attr_del2.LENGTHMASK;



int32_t in=attr_del1.array[p1]<<14;
int32_t t1,t2,t3;
t2=___SMMUL(in,scatter)<<1;
t3=attr_del2.array[p2]<<14;
t1=___SMMUL(t3,scatter)<<1;

attr_del2.array[p2] = __SSAT(in-t1>>14,16);
attr_del1.array[p1]=__SSAT(___SMMUL(in-t1<<1,scatter)+t3>>14,16);


}]]></code.srate>
      </object>
   </patchobj>
   <comment type="patch/comment" x="308" y="784" text="adding early reflections to delay buffer from audio input"/>
   <patchobj type="patch/object" uuid="52770f49-321b-44ba-9ef5-bdab934b7067" name="early reflections" x="322" y="798">
      <params>
         <frac32.u.map name="spread" value="36.5"/>
         <frac32.s.map name="expo" value="-18.0"/>
         <frac32.s.map name="curve" value="-27.0"/>
         <frac32.s.map name="damp" value="26.0"/>
         <frac32.s.map name="vol" value="25.0"/>
      </params>
      <attribs>
         <combo attributeName="size" selection="32768 (682ms)"/>
         <objref attributeName="delay" obj="delay_record_left"/>
      </attribs>
      <object id="patch/object" uuid="52770f49-321b-44ba-9ef5-bdab934b7067">
         <sDescription>Nested early reflections module.
Put the name of a delayline module into the reference box to add early reflections to the delayline.</sDescription>
         <author>Remco van der Most</author>
         <license>BSD</license>
         <helpPatch>delay.axh</helpPatch>
         <inlets>
            <frac32buffer name="in" description="wave input"/>
         </inlets>
         <outlets/>
         <displays/>
         <params>
            <frac32.u.map name="spread" description="main spread size of delaytimes"/>
            <frac32.s.map name="expo" description="exponential spreading of delaytimes"/>
            <frac32.s.map name="curve" description="S-curve/inv-S-curve spreading of delaytimes"/>
            <frac32.s.map name="damp" description="volume shape of early reflections"/>
            <frac32.s.map name="vol" description="main volume reflections"/>
         </params>
         <attribs>
            <combo name="size">
               <MenuEntries>
                  <string>256 (5.33ms)</string>
                  <string>512 (10.66ms)</string>
                  <string>1024 (21.33ms)</string>
                  <string>2048 (42.66ms)</string>
                  <string>4096 (85.33ms)</string>
                  <string>8192 (170ms)</string>
                  <string>16384 (341ms)</string>
                  <string>32768 (682ms)</string>
                  <string>65536 (1.36s)</string>
                  <string>131072 (2.73s)</string>
                  <string>262144 (5.46s)</string>
                  <string>524288 (10.9s)</string>
                  <string>1048576 (21.8s)</string>
                  <string>2097152 (43.7s)</string>
               </MenuEntries>
               <CEntries>
                  <string>8</string>
                  <string>9</string>
                  <string>10</string>
                  <string>11</string>
                  <string>12</string>
                  <string>13</string>
                  <string>14</string>
                  <string>15</string>
                  <string>16</string>
                  <string>17</string>
                  <string>18</string>
                  <string>19</string>
                  <string>20</string>
                  <string>21</string>
               </CEntries>
            </combo>
            <objref name="delay"/>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[static const uint32_t LENGTHPOW = (attr_size);
static const uint32_t LENGTH = (1<<attr_size);
static const uint32_t LENGTHMASK = ((1<<attr_size)-1);
int16_t *array;
uint32_t writepos;]]></code.declaration>
         <code.init><![CDATA[static int16_t _array[attr_poly][1<<attr_size]  __attribute__ ((section (".sdram")));
array = &_array[parent->polyIndex][0];
   int i;
   writepos = 0;
   for(i=0;i<LENGTH;i++) array[i] = 0;]]></code.init>
         <code.krate><![CDATA[int32_t d[3],t[3];
for(int i=0;i<3;i++)
{
	
	int32_t T=(1<<25)*(1+i);
	T=T+((i-1)*param_curve>>2);
	if(param_expo>0)
	{
		T+=___SMMUL((1<<27)-T,param_expo)<<5;
	}
	else
	{
		T-=___SMMUL(T,-param_expo)<<5;
	}

	t[i]=___SMMUL(param_spread,T)>>22-LENGTHPOW;

	int32_t D=param_vol;
	if(i==0)
	{
		D-=___SMMUL(D,param_damp+(1<<27))<<3;
	}
	else if(i==1)
	{
		D=___SMMUL(D,(1<<28)-((param_damp>0?param_damp:-param_damp)>>1))<<4;
	}
	else
	{
		D-=___SMMUL(D,-param_damp+(1<<27))<<3;
	}
	d[i]=D;
}

int32_t POS=attr_delay.writepos-BUFSIZE-2;]]></code.krate>
         <code.srate><![CDATA[array[writepos] = __SSAT(inlet_in>>14,16);


attr_delay.array[(POS+buffer_index)&attr_delay.LENGTHMASK]=__SSAT((___SMMUL(array[(writepos-t[0])&LENGTHMASK]<<5,d[0])+___SMMUL(array[(writepos-t[1])&LENGTHMASK]<<5,d[1])+___SMMUL(array[(writepos-t[2])&LENGTHMASK]<<5,d[2]))+attr_delay.array[(POS+buffer_index)&attr_delay.LENGTHMASK],16);
writepos = (writepos + 1)&LENGTHMASK;]]></code.srate>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="52770f49-321b-44ba-9ef5-bdab934b7067" name="early reflections__" x="462" y="798">
      <params>
         <frac32.u.map name="spread" value="35.5"/>
         <frac32.s.map name="expo" value="-14.0"/>
         <frac32.s.map name="curve" value="-21.0"/>
         <frac32.s.map name="damp" value="26.0"/>
         <frac32.s.map name="vol" value="25.0"/>
      </params>
      <attribs>
         <combo attributeName="size" selection="32768 (682ms)"/>
         <objref attributeName="delay" obj="delay_record_right"/>
      </attribs>
      <object id="patch/object" uuid="52770f49-321b-44ba-9ef5-bdab934b7067">
         <sDescription>delayline definition, read it with &quot;delay/read&quot; objects referencing the instance name of this object</sDescription>
         <author>Johannes Taelman</author>
         <license>BSD</license>
         <helpPatch>delay.axh</helpPatch>
         <inlets>
            <frac32buffer name="in" description="wave input"/>
         </inlets>
         <outlets/>
         <displays/>
         <params>
            <frac32.u.map name="spread" description="main spread size of delaytimes"/>
            <frac32.s.map name="expo" description="exponential spreading of delaytimes"/>
            <frac32.s.map name="curve" description="S-curve/inv-S-curve spreading of delaytimes"/>
            <frac32.s.map name="damp" description="volume shape of early reflections"/>
            <frac32.s.map name="vol" description="main volume reflections"/>
         </params>
         <attribs>
            <combo name="size">
               <MenuEntries>
                  <string>256 (5.33ms)</string>
                  <string>512 (10.66ms)</string>
                  <string>1024 (21.33ms)</string>
                  <string>2048 (42.66ms)</string>
                  <string>4096 (85.33ms)</string>
                  <string>8192 (170ms)</string>
                  <string>16384 (341ms)</string>
                  <string>32768 (682ms)</string>
                  <string>65536 (1.36s)</string>
                  <string>131072 (2.73s)</string>
                  <string>262144 (5.46s)</string>
                  <string>524288 (10.9s)</string>
                  <string>1048576 (21.8s)</string>
                  <string>2097152 (43.7s)</string>
               </MenuEntries>
               <CEntries>
                  <string>8</string>
                  <string>9</string>
                  <string>10</string>
                  <string>11</string>
                  <string>12</string>
                  <string>13</string>
                  <string>14</string>
                  <string>15</string>
                  <string>16</string>
                  <string>17</string>
                  <string>18</string>
                  <string>19</string>
                  <string>20</string>
                  <string>21</string>
               </CEntries>
            </combo>
            <objref name="delay"/>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[static const uint32_t LENGTHPOW = (attr_size);
static const uint32_t LENGTH = (1<<attr_size);
static const uint32_t LENGTHMASK = ((1<<attr_size)-1);
int16_t *array;
uint32_t writepos;]]></code.declaration>
         <code.init><![CDATA[static int16_t _array[attr_poly][1<<attr_size]  __attribute__ ((section (".sdram")));
array = &_array[parent->polyIndex][0];
   int i;
   writepos = 0;
   for(i=0;i<LENGTH;i++) array[i] = 0;]]></code.init>
         <code.krate><![CDATA[int32_t d[3],t[3];
for(int i=0;i<3;i++)
{
	
	int32_t T=(1<<25)*(1+i);
	T=T+((i-1)*param_curve>>2);
	if(param_expo>0)
	{
		T+=___SMMUL((1<<27)-T,param_expo)<<5;
	}
	else
	{
		T-=___SMMUL(T,-param_expo)<<5;
	}

	t[i]=___SMMUL(param_spread,T)>>22-LENGTHPOW;

	int32_t D=param_vol;
	if(i==0)
	{
		D-=___SMMUL(D,param_damp+(1<<27))<<3;
	}
	else if(i==1)
	{
		D=___SMMUL(D,(1<<28)-((param_damp>0?param_damp:-param_damp)>>1))<<4;
	}
	else
	{
		D-=___SMMUL(D,-param_damp+(1<<27))<<3;
	}
	d[i]=D;
}

int32_t POS=attr_delay.writepos-BUFSIZE-2;]]></code.krate>
         <code.srate><![CDATA[array[writepos] = __SSAT(inlet_in>>14,16);


attr_delay.array[(POS+buffer_index)&attr_delay.LENGTHMASK]=__SSAT((___SMMUL(array[(writepos-t[0])&LENGTHMASK]<<5,d[0])+___SMMUL(array[(writepos-t[1])&LENGTHMASK]<<5,d[1])+___SMMUL(array[(writepos-t[2])&LENGTHMASK]<<5,d[2]))+attr_delay.array[(POS+buffer_index)&attr_delay.LENGTHMASK],16);
writepos = (writepos + 1)&LENGTHMASK;]]></code.srate>
      </object>
   </patchobj>
   <comment type="patch/comment" x="658" y="840" text="nested scatter/allpass delays (read from and write to main delay buffer for adding reverb and reflections)"/>
   <comment type="patch/comment" x="1330" y="840" text="nested scatter/allpass delays (read from and write to main delay buffer for adding reverb and reflections)"/>
   <patchobj type="patch/object" uuid="2b6e9d3e-762f-48b8-befd-28527c74cded" name="nested_1" x="602" y="854">
      <params>
         <frac32.u.map name="scatter" value="46.5"/>
         <frac32.u.map name="size" value="39.94499969482422"/>
         <int32.hradio name="mode" value="2"/>
      </params>
      <attribs>
         <combo attributeName="size" selection="16384 (341ms)"/>
         <objref attributeName="delayname" obj="delay_record_left"/>
      </attribs>
      <object id="patch/object" uuid="2b6e9d3e-762f-48b8-befd-28527c74cded">
         <sDescription>modulatable nested scatter/allpass function for delaylines.
Can be used with the factory delayline module to add diffusion to a delay</sDescription>
         <author>Remco van der Most</author>
         <license>BSD</license>
         <helpPatch>delay.axh</helpPatch>
         <inlets>
            <frac32buffer name="size"/>
         </inlets>
         <outlets/>
         <displays/>
         <params>
            <frac32.u.map name="scatter"/>
            <frac32.u.map name="size"/>
            <int32.hradio name="mode" description="off,scatter,allpass">
               <MaxValue i="3"/>
            </int32.hradio>
         </params>
         <attribs>
            <combo name="size">
               <MenuEntries>
                  <string>256 (5.33ms)</string>
                  <string>512 (10.66ms)</string>
                  <string>1024 (21.33ms)</string>
                  <string>2048 (42.66ms)</string>
                  <string>4096 (85.33ms)</string>
                  <string>8192 (170ms)</string>
                  <string>16384 (341ms)</string>
                  <string>32768 (682ms)</string>
                  <string>65536 (1.36s)</string>
                  <string>131072 (2.73s)</string>
                  <string>262144 (5.46s)</string>
                  <string>524288 (10.9s)</string>
                  <string>1048576 (21.8s)</string>
                  <string>2097152 (43.7s)</string>
               </MenuEntries>
               <CEntries>
                  <string>8</string>
                  <string>9</string>
                  <string>10</string>
                  <string>11</string>
                  <string>12</string>
                  <string>13</string>
                  <string>14</string>
                  <string>15</string>
                  <string>16</string>
                  <string>17</string>
                  <string>18</string>
                  <string>19</string>
                  <string>20</string>
                  <string>21</string>
               </CEntries>
            </combo>
            <objref name="delayname"/>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[static const uint32_t LENGTHPOW = (attr_size);
static const uint32_t LENGTH = (1<<attr_size);
static const uint32_t LENGTHMASK = ((1<<attr_size)-1);
int16_t *array;
uint32_t writepos;]]></code.declaration>
         <code.init><![CDATA[static int16_t _array[attr_poly][1<<attr_size]  __attribute__ ((section (".sdram")));
array = &_array[parent->polyIndex][0];
   int i;
   writepos = 0;
   for(i=0;i<LENGTH;i++) array[i] = 0;]]></code.init>
         <code.krate><![CDATA[int32_t scatter=__USAT(param_scatter,27)<<4;
int32_t wp=0;

int32_t POS=attr_delayname.writepos-BUFSIZE-1-1;]]></code.krate>
         <code.srate><![CDATA[if(param_mode>0){
int32_t p=(POS+buffer_index)&attr_delayname.LENGTHMASK;
int32_t sz=__USAT(param_size+inlet_size,27);
int32_t size=sz>>27-LENGTHPOW;
int32_t mix=((uint32_t)sz<<5+LENGTHPOW)>>1;

int32_t in=attr_delayname.array[p]<<14;
int32_t t1,t2,t3;
t2=___SMMUL(in,scatter)<<1;
t3=array[(writepos-size)&LENGTHMASK]<<14;
t3+=___SMMUL((array[(writepos-size-1)&LENGTHMASK]<<14)-t3,mix)<<1;
t1=___SMMUL(t3,scatter)<<1;

array[writepos] = __SSAT(in+(param_mode>1?0:t2)-t1>>14,16);
if(param_mode==1){
attr_delayname.array[p] = __SSAT(t2+t3-t1>>14,16);
}
else{
attr_delayname.array[p]=__SSAT(___SMMUL(in-t1<<1,scatter)+t3>>14,16);
}

writepos = (writepos + 1)&LENGTHMASK;
}]]></code.srate>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="2b6e9d3e-762f-48b8-befd-28527c74cded" name="nested_2" x="756" y="854">
      <params>
         <frac32.u.map name="scatter" value="45.5"/>
         <frac32.u.map name="size" value="33.10499954223633"/>
         <int32.hradio name="mode" value="2"/>
      </params>
      <attribs>
         <combo attributeName="size" selection="16384 (341ms)"/>
         <objref attributeName="delayname" obj="delay_record_right"/>
      </attribs>
      <object id="patch/object" uuid="2b6e9d3e-762f-48b8-befd-28527c74cded">
         <sDescription>modulatable nested scatter/allpass function for delaylines.
Can be used with the factory delayline module to add diffusion to a delay</sDescription>
         <author>Remco van der Most</author>
         <license>BSD</license>
         <helpPatch>delay.axh</helpPatch>
         <inlets>
            <frac32buffer name="size"/>
         </inlets>
         <outlets/>
         <displays/>
         <params>
            <frac32.u.map name="scatter"/>
            <frac32.u.map name="size"/>
            <int32.hradio name="mode" description="off,scatter,allpass">
               <MaxValue i="3"/>
            </int32.hradio>
         </params>
         <attribs>
            <combo name="size">
               <MenuEntries>
                  <string>256 (5.33ms)</string>
                  <string>512 (10.66ms)</string>
                  <string>1024 (21.33ms)</string>
                  <string>2048 (42.66ms)</string>
                  <string>4096 (85.33ms)</string>
                  <string>8192 (170ms)</string>
                  <string>16384 (341ms)</string>
                  <string>32768 (682ms)</string>
                  <string>65536 (1.36s)</string>
                  <string>131072 (2.73s)</string>
                  <string>262144 (5.46s)</string>
                  <string>524288 (10.9s)</string>
                  <string>1048576 (21.8s)</string>
                  <string>2097152 (43.7s)</string>
               </MenuEntries>
               <CEntries>
                  <string>8</string>
                  <string>9</string>
                  <string>10</string>
                  <string>11</string>
                  <string>12</string>
                  <string>13</string>
                  <string>14</string>
                  <string>15</string>
                  <string>16</string>
                  <string>17</string>
                  <string>18</string>
                  <string>19</string>
                  <string>20</string>
                  <string>21</string>
               </CEntries>
            </combo>
            <objref name="delayname"/>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[static const uint32_t LENGTHPOW = (attr_size);
static const uint32_t LENGTH = (1<<attr_size);
static const uint32_t LENGTHMASK = ((1<<attr_size)-1);
int16_t *array;
uint32_t writepos;]]></code.declaration>
         <code.init><![CDATA[static int16_t _array[attr_poly][1<<attr_size]  __attribute__ ((section (".sdram")));
array = &_array[parent->polyIndex][0];
   int i;
   writepos = 0;
   for(i=0;i<LENGTH;i++) array[i] = 0;]]></code.init>
         <code.krate><![CDATA[int32_t scatter=__USAT(param_scatter,27)<<4;
int32_t wp=0;

int32_t POS=attr_delayname.writepos-BUFSIZE-1-1;]]></code.krate>
         <code.srate><![CDATA[if(param_mode>0){
int32_t p=(POS+buffer_index)&attr_delayname.LENGTHMASK;
int32_t sz=__USAT(param_size+inlet_size,27);
int32_t size=sz>>27-LENGTHPOW;
int32_t mix=((uint32_t)sz<<5+LENGTHPOW)>>1;

int32_t in=attr_delayname.array[p]<<14;
int32_t t1,t2,t3;
t2=___SMMUL(in,scatter)<<1;
t3=array[(writepos-size)&LENGTHMASK]<<14;
t3+=___SMMUL((array[(writepos-size-1)&LENGTHMASK]<<14)-t3,mix)<<1;
t1=___SMMUL(t3,scatter)<<1;

array[writepos] = __SSAT(in+(param_mode>1?0:t2)-t1>>14,16);
if(param_mode==1){
attr_delayname.array[p] = __SSAT(t2+t3-t1>>14,16);
}
else{
attr_delayname.array[p]=__SSAT(___SMMUL(in-t1<<1,scatter)+t3>>14,16);
}

writepos = (writepos + 1)&LENGTHMASK;
}]]></code.srate>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="2b6e9d3e-762f-48b8-befd-28527c74cded" name="nested_3" x="910" y="854">
      <params>
         <frac32.u.map name="scatter" value="48.0"/>
         <frac32.u.map name="size" value="36.05999994277954"/>
         <int32.hradio name="mode" value="1"/>
         <int32.hradio name="select" value="0"/>
      </params>
      <attribs>
         <combo attributeName="size" selection="4096 (85.33ms)"/>
         <objref attributeName="del1" obj="delay_record_left"/>
         <objref attributeName="del2" obj="nested_1"/>
      </attribs>
      <object id="patch/object" uuid="2b6e9d3e-762f-48b8-befd-28527c74cded">
         <sDescription>modulatable nested scatter/allpass function for delaylines.
Can be used with the factory delayline module to add diffusion to a delay</sDescription>
         <author>Remco van der Most</author>
         <license>BSD</license>
         <helpPatch>delay.axh</helpPatch>
         <inlets>
            <frac32buffer name="size"/>
         </inlets>
         <outlets/>
         <displays/>
         <params>
            <frac32.u.map name="scatter"/>
            <frac32.u.map name="size"/>
            <int32.hradio name="mode" description="off,scatter,allpass">
               <MaxValue i="3"/>
            </int32.hradio>
            <int32.hradio name="select">
               <MaxValue i="2"/>
            </int32.hradio>
         </params>
         <attribs>
            <combo name="size">
               <MenuEntries>
                  <string>256 (5.33ms)</string>
                  <string>512 (10.66ms)</string>
                  <string>1024 (21.33ms)</string>
                  <string>2048 (42.66ms)</string>
                  <string>4096 (85.33ms)</string>
                  <string>8192 (170ms)</string>
                  <string>16384 (341ms)</string>
                  <string>32768 (682ms)</string>
                  <string>65536 (1.36s)</string>
                  <string>131072 (2.73s)</string>
                  <string>262144 (5.46s)</string>
                  <string>524288 (10.9s)</string>
                  <string>1048576 (21.8s)</string>
                  <string>2097152 (43.7s)</string>
               </MenuEntries>
               <CEntries>
                  <string>8</string>
                  <string>9</string>
                  <string>10</string>
                  <string>11</string>
                  <string>12</string>
                  <string>13</string>
                  <string>14</string>
                  <string>15</string>
                  <string>16</string>
                  <string>17</string>
                  <string>18</string>
                  <string>19</string>
                  <string>20</string>
                  <string>21</string>
               </CEntries>
            </combo>
            <objref name="del1"/>
            <objref name="del2"/>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[static const uint32_t LENGTHPOW = (attr_size);
static const uint32_t LENGTH = (1<<attr_size);
static const uint32_t LENGTHMASK = ((1<<attr_size)-1);
int16_t *array;
uint32_t writepos;]]></code.declaration>
         <code.init><![CDATA[static int16_t _array[attr_poly][1<<attr_size]  __attribute__ ((section (".sdram")));
array = &_array[parent->polyIndex][0];
   int i;
   writepos = 0;
   for(i=0;i<LENGTH;i++) array[i] = 0;]]></code.init>
         <code.krate><![CDATA[int32_t scatter=__USAT(param_scatter,27)<<4;
int32_t wp=0;

int32_t POS;

switch(param_select)
{
	case 0: POS=attr_del1.writepos-BUFSIZE-1-1; break;
	case 1: POS=attr_del2.writepos-BUFSIZE-1-1; break;
}]]></code.krate>
         <code.srate><![CDATA[if(param_mode>0){
int32_t p=(POS+buffer_index);
switch(param_select)
{
	case 0: p=p&attr_del1.LENGTHMASK; break;
	case 1: p=p&attr_del2.LENGTHMASK; break;
}

int32_t sz=__USAT(param_size+inlet_size,27);
int32_t size=sz>>27-LENGTHPOW;
int32_t mix=((uint32_t)sz<<5+LENGTHPOW)>>1;

int32_t in;
switch(param_select)
{
	case 0:	in=attr_del1.array[p]<<14;break;
	case 1:	in=attr_del2.array[p]<<14;break;

}
int32_t t1,t2,t3;
t2=___SMMUL(in,scatter)<<1;
t3=array[(writepos-size)&LENGTHMASK]<<14;
t3+=___SMMUL((array[(writepos-size-1)&LENGTHMASK]<<14)-t3,mix)<<1;
t1=___SMMUL(t3,scatter)<<1;

array[writepos] = __SSAT(in+(param_mode>1?0:t2)-t1>>14,16);
int32_t out;
if(param_mode==1){
	out = __SSAT(t2+t3-t1>>14,16);
}
else{
	out=__SSAT(___SMMUL(in-t1<<1,scatter)+t3>>14,16);
}

switch(param_select)
{
	case 0: attr_del1.array[p]=out; break;
	case 1: attr_del2.array[p]=out; break;

}

writepos = (writepos + 1)&LENGTHMASK;

}]]></code.srate>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="2b6e9d3e-762f-48b8-befd-28527c74cded" name="nested_4" x="1036" y="854">
      <params>
         <frac32.u.map name="scatter" value="48.0"/>
         <frac32.u.map name="size" value="40.5"/>
         <int32.hradio name="mode" value="1"/>
         <int32.hradio name="select" value="0"/>
      </params>
      <attribs>
         <combo attributeName="size" selection="4096 (85.33ms)"/>
         <objref attributeName="del1" obj="delay_record_right"/>
         <objref attributeName="del2" obj="nested_2"/>
      </attribs>
      <object id="patch/object" uuid="2b6e9d3e-762f-48b8-befd-28527c74cded">
         <sDescription>modulatable nested scatter/allpass function for delaylines.
Can be used with the factory delayline module to add diffusion to a delay</sDescription>
         <author>Remco van der Most</author>
         <license>BSD</license>
         <helpPatch>delay.axh</helpPatch>
         <inlets>
            <frac32buffer name="size"/>
         </inlets>
         <outlets/>
         <displays/>
         <params>
            <frac32.u.map name="scatter"/>
            <frac32.u.map name="size"/>
            <int32.hradio name="mode" description="off,scatter,allpass">
               <MaxValue i="3"/>
            </int32.hradio>
            <int32.hradio name="select">
               <MaxValue i="2"/>
            </int32.hradio>
         </params>
         <attribs>
            <combo name="size">
               <MenuEntries>
                  <string>256 (5.33ms)</string>
                  <string>512 (10.66ms)</string>
                  <string>1024 (21.33ms)</string>
                  <string>2048 (42.66ms)</string>
                  <string>4096 (85.33ms)</string>
                  <string>8192 (170ms)</string>
                  <string>16384 (341ms)</string>
                  <string>32768 (682ms)</string>
                  <string>65536 (1.36s)</string>
                  <string>131072 (2.73s)</string>
                  <string>262144 (5.46s)</string>
                  <string>524288 (10.9s)</string>
                  <string>1048576 (21.8s)</string>
                  <string>2097152 (43.7s)</string>
               </MenuEntries>
               <CEntries>
                  <string>8</string>
                  <string>9</string>
                  <string>10</string>
                  <string>11</string>
                  <string>12</string>
                  <string>13</string>
                  <string>14</string>
                  <string>15</string>
                  <string>16</string>
                  <string>17</string>
                  <string>18</string>
                  <string>19</string>
                  <string>20</string>
                  <string>21</string>
               </CEntries>
            </combo>
            <objref name="del1"/>
            <objref name="del2"/>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[static const uint32_t LENGTHPOW = (attr_size);
static const uint32_t LENGTH = (1<<attr_size);
static const uint32_t LENGTHMASK = ((1<<attr_size)-1);
int16_t *array;
uint32_t writepos;]]></code.declaration>
         <code.init><![CDATA[static int16_t _array[attr_poly][1<<attr_size]  __attribute__ ((section (".sdram")));
array = &_array[parent->polyIndex][0];
   int i;
   writepos = 0;
   for(i=0;i<LENGTH;i++) array[i] = 0;]]></code.init>
         <code.krate><![CDATA[int32_t scatter=__USAT(param_scatter,27)<<4;
int32_t wp=0;

int32_t POS;

switch(param_select)
{
	case 0: POS=attr_del1.writepos-BUFSIZE-1-1; break;
	case 1: POS=attr_del2.writepos-BUFSIZE-1-1; break;
}]]></code.krate>
         <code.srate><![CDATA[if(param_mode>0){
int32_t p=(POS+buffer_index);
switch(param_select)
{
	case 0: p=p&attr_del1.LENGTHMASK; break;
	case 1: p=p&attr_del2.LENGTHMASK; break;
}

int32_t sz=__USAT(param_size+inlet_size,27);
int32_t size=sz>>27-LENGTHPOW;
int32_t mix=((uint32_t)sz<<5+LENGTHPOW)>>1;

int32_t in;
switch(param_select)
{
	case 0:	in=attr_del1.array[p]<<14;break;
	case 1:	in=attr_del2.array[p]<<14;break;

}
int32_t t1,t2,t3;
t2=___SMMUL(in,scatter)<<1;
t3=array[(writepos-size)&LENGTHMASK]<<14;
t3+=___SMMUL((array[(writepos-size-1)&LENGTHMASK]<<14)-t3,mix)<<1;
t1=___SMMUL(t3,scatter)<<1;

array[writepos] = __SSAT(in+(param_mode>1?0:t2)-t1>>14,16);
int32_t out;
if(param_mode==1){
	out = __SSAT(t2+t3-t1>>14,16);
}
else{
	out=__SSAT(___SMMUL(in-t1<<1,scatter)+t3>>14,16);
}

switch(param_select)
{
	case 0: attr_del1.array[p]=out; break;
	case 1: attr_del2.array[p]=out; break;

}

writepos = (writepos + 1)&LENGTHMASK;

}]]></code.srate>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="2b6e9d3e-762f-48b8-befd-28527c74cded" name="stereo scatter_2" x="1176" y="854">
      <params>
         <frac32.u.map name="scatter" value="24.5"/>
         <int32.hradio name="mode" value="1"/>
      </params>
      <attribs>
         <objref attributeName="del1" obj="nested_3"/>
         <objref attributeName="del2" obj="nested_4"/>
      </attribs>
      <object id="patch/object" uuid="2b6e9d3e-762f-48b8-befd-28527c74cded">
         <sDescription>modulatable nested scatter/allpass function for delaylines.
Can be used with the factory delayline module to add diffusion to a delay</sDescription>
         <author>Remco van der Most</author>
         <license>BSD</license>
         <helpPatch>delay.axh</helpPatch>
         <inlets/>
         <outlets/>
         <displays/>
         <params>
            <frac32.u.map name="scatter"/>
            <int32.hradio name="mode" description="off,scatter,allpass">
               <MaxValue i="2"/>
            </int32.hradio>
         </params>
         <attribs>
            <objref name="del1"/>
            <objref name="del2"/>
         </attribs>
         <includes/>
         <code.krate><![CDATA[int32_t scatter=__USAT(param_scatter,27)<<4;


int32_t POS1=attr_del1.writepos-BUFSIZE-1-1;
int32_t POS2=attr_del2.writepos-BUFSIZE-1-1;]]></code.krate>
         <code.srate><![CDATA[if(param_mode>0){
int32_t p1=(POS1+buffer_index)&attr_del1.LENGTHMASK;
int32_t p2=(POS2+buffer_index)&attr_del2.LENGTHMASK;



int32_t in=attr_del1.array[p1]<<14;
int32_t t1,t2,t3;
t2=___SMMUL(in,scatter)<<1;
t3=attr_del2.array[p2]<<14;
t1=___SMMUL(t3,scatter)<<1;

attr_del2.array[p2] = __SSAT(in-t1>>14,16);
attr_del1.array[p1]=__SSAT(___SMMUL(in-t1<<1,scatter)+t3>>14,16);


}]]></code.srate>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="2b6e9d3e-762f-48b8-befd-28527c74cded" name="nested_5" x="1316" y="854">
      <params>
         <frac32.u.map name="scatter" value="58.0"/>
         <frac32.u.map name="size" value="24.864999771118164"/>
         <int32.hradio name="mode" value="2"/>
         <int32.hradio name="select" value="1"/>
      </params>
      <attribs>
         <combo attributeName="size" selection="2048 (42.66ms)"/>
         <objref attributeName="del1" obj="delay_record_left"/>
         <objref attributeName="del2" obj="nested_1"/>
         <objref attributeName="del3" obj="nested_3"/>
      </attribs>
      <object id="patch/object" uuid="2b6e9d3e-762f-48b8-befd-28527c74cded">
         <sDescription>modulatable nested scatter/allpass function for delaylines.
Can be used with the factory delayline module to add diffusion to a delay</sDescription>
         <author>Remco van der Most</author>
         <license>BSD</license>
         <helpPatch>delay.axh</helpPatch>
         <inlets>
            <frac32buffer name="size"/>
         </inlets>
         <outlets/>
         <displays/>
         <params>
            <frac32.u.map name="scatter"/>
            <frac32.u.map name="size"/>
            <int32.hradio name="mode" description="off,scatter,allpass">
               <MaxValue i="3"/>
            </int32.hradio>
            <int32.hradio name="select">
               <MaxValue i="3"/>
            </int32.hradio>
         </params>
         <attribs>
            <combo name="size">
               <MenuEntries>
                  <string>256 (5.33ms)</string>
                  <string>512 (10.66ms)</string>
                  <string>1024 (21.33ms)</string>
                  <string>2048 (42.66ms)</string>
                  <string>4096 (85.33ms)</string>
                  <string>8192 (170ms)</string>
                  <string>16384 (341ms)</string>
                  <string>32768 (682ms)</string>
                  <string>65536 (1.36s)</string>
                  <string>131072 (2.73s)</string>
                  <string>262144 (5.46s)</string>
                  <string>524288 (10.9s)</string>
                  <string>1048576 (21.8s)</string>
                  <string>2097152 (43.7s)</string>
               </MenuEntries>
               <CEntries>
                  <string>8</string>
                  <string>9</string>
                  <string>10</string>
                  <string>11</string>
                  <string>12</string>
                  <string>13</string>
                  <string>14</string>
                  <string>15</string>
                  <string>16</string>
                  <string>17</string>
                  <string>18</string>
                  <string>19</string>
                  <string>20</string>
                  <string>21</string>
               </CEntries>
            </combo>
            <objref name="del1"/>
            <objref name="del2"/>
            <objref name="del3"/>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[static const uint32_t LENGTHPOW = (attr_size);
static const uint32_t LENGTH = (1<<attr_size);
static const uint32_t LENGTHMASK = ((1<<attr_size)-1);
int16_t *array;
uint32_t writepos;]]></code.declaration>
         <code.init><![CDATA[static int16_t _array[attr_poly][1<<attr_size]  __attribute__ ((section (".sdram")));
array = &_array[parent->polyIndex][0];
   int i;
   writepos = 0;
   for(i=0;i<LENGTH;i++) array[i] = 0;]]></code.init>
         <code.krate><![CDATA[int32_t scatter=__USAT(param_scatter,27)<<4;
int32_t wp=0;

int32_t POS;

switch(param_select)
{
	case 0: POS=attr_del1.writepos-BUFSIZE-1-1; break;
	case 1: POS=attr_del2.writepos-BUFSIZE-1-1; break;
	case 2: POS=attr_del3.writepos-BUFSIZE-1-1; break;
}]]></code.krate>
         <code.srate><![CDATA[if(param_mode>0){

int32_t p=(POS+buffer_index);
switch(param_select)
{
	case 0: p=p&attr_del1.LENGTHMASK; break;
	case 1: p=p&attr_del2.LENGTHMASK; break;
	case 2: p=p&attr_del3.LENGTHMASK; break;
}
	
int32_t sz=__USAT(param_size+inlet_size,27);
int32_t size=sz>>27-LENGTHPOW;
int32_t mix=((uint32_t)sz<<5+LENGTHPOW)>>1;

int32_t in;
switch(param_select)
{
	case 0:	in=attr_del1.array[p]<<14;break;
	case 1:	in=attr_del2.array[p]<<14;break;
	case 2:	in=attr_del3.array[p]<<14;break;
}
int32_t t1,t2,t3;
t2=___SMMUL(in,scatter)<<1;
t3=array[(writepos-size)&LENGTHMASK]<<14;
t3+=___SMMUL((array[(writepos-size-1)&LENGTHMASK]<<14)-t3,mix)<<1;
t1=___SMMUL(t3,scatter)<<1;

array[writepos] = __SSAT(in+(param_mode>1?0:t2)-t1>>14,16);
int32_t out;
if(param_mode==1){
	out = __SSAT(t2+t3-t1>>14,16);
}
else{
	out=__SSAT(___SMMUL(in-t1<<1,scatter)+t3>>14,16);
}

switch(param_select)
{
	case 0: attr_del1.array[p]=out; break;
	case 1: attr_del2.array[p]=out; break;
	case 2: attr_del3.array[p]=out; break;
}

writepos = (writepos + 1)&LENGTHMASK;

}]]></code.srate>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="2b6e9d3e-762f-48b8-befd-28527c74cded" name="nested_6" x="1442" y="854">
      <params>
         <frac32.u.map name="scatter" value="58.0"/>
         <frac32.u.map name="size" value="25.199999809265137"/>
         <int32.hradio name="mode" value="2"/>
         <int32.hradio name="select" value="1"/>
      </params>
      <attribs>
         <combo attributeName="size" selection="2048 (42.66ms)"/>
         <objref attributeName="del1" obj="delay_record_right"/>
         <objref attributeName="del2" obj="nested_2"/>
         <objref attributeName="del3" obj="nested_4"/>
      </attribs>
      <object id="patch/object" uuid="2b6e9d3e-762f-48b8-befd-28527c74cded">
         <sDescription>modulatable nested scatter/allpass function for delaylines.
Can be used with the factory delayline module to add diffusion to a delay</sDescription>
         <author>Remco van der Most</author>
         <license>BSD</license>
         <helpPatch>delay.axh</helpPatch>
         <inlets>
            <frac32buffer name="size"/>
         </inlets>
         <outlets/>
         <displays/>
         <params>
            <frac32.u.map name="scatter"/>
            <frac32.u.map name="size"/>
            <int32.hradio name="mode" description="off,scatter,allpass">
               <MaxValue i="3"/>
            </int32.hradio>
            <int32.hradio name="select">
               <MaxValue i="3"/>
            </int32.hradio>
         </params>
         <attribs>
            <combo name="size">
               <MenuEntries>
                  <string>256 (5.33ms)</string>
                  <string>512 (10.66ms)</string>
                  <string>1024 (21.33ms)</string>
                  <string>2048 (42.66ms)</string>
                  <string>4096 (85.33ms)</string>
                  <string>8192 (170ms)</string>
                  <string>16384 (341ms)</string>
                  <string>32768 (682ms)</string>
                  <string>65536 (1.36s)</string>
                  <string>131072 (2.73s)</string>
                  <string>262144 (5.46s)</string>
                  <string>524288 (10.9s)</string>
                  <string>1048576 (21.8s)</string>
                  <string>2097152 (43.7s)</string>
               </MenuEntries>
               <CEntries>
                  <string>8</string>
                  <string>9</string>
                  <string>10</string>
                  <string>11</string>
                  <string>12</string>
                  <string>13</string>
                  <string>14</string>
                  <string>15</string>
                  <string>16</string>
                  <string>17</string>
                  <string>18</string>
                  <string>19</string>
                  <string>20</string>
                  <string>21</string>
               </CEntries>
            </combo>
            <objref name="del1"/>
            <objref name="del2"/>
            <objref name="del3"/>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[static const uint32_t LENGTHPOW = (attr_size);
static const uint32_t LENGTH = (1<<attr_size);
static const uint32_t LENGTHMASK = ((1<<attr_size)-1);
int16_t *array;
uint32_t writepos;]]></code.declaration>
         <code.init><![CDATA[static int16_t _array[attr_poly][1<<attr_size]  __attribute__ ((section (".sdram")));
array = &_array[parent->polyIndex][0];
   int i;
   writepos = 0;
   for(i=0;i<LENGTH;i++) array[i] = 0;]]></code.init>
         <code.krate><![CDATA[int32_t scatter=__USAT(param_scatter,27)<<4;
int32_t wp=0;

int32_t POS;

switch(param_select)
{
	case 0: POS=attr_del1.writepos-BUFSIZE-1-1; break;
	case 1: POS=attr_del2.writepos-BUFSIZE-1-1; break;
	case 2: POS=attr_del3.writepos-BUFSIZE-1-1; break;
}]]></code.krate>
         <code.srate><![CDATA[if(param_mode>0){

int32_t p=(POS+buffer_index);
switch(param_select)
{
	case 0: p=p&attr_del1.LENGTHMASK; break;
	case 1: p=p&attr_del2.LENGTHMASK; break;
	case 2: p=p&attr_del3.LENGTHMASK; break;
}
	
int32_t sz=__USAT(param_size+inlet_size,27);
int32_t size=sz>>27-LENGTHPOW;
int32_t mix=((uint32_t)sz<<5+LENGTHPOW)>>1;

int32_t in;
switch(param_select)
{
	case 0:	in=attr_del1.array[p]<<14;break;
	case 1:	in=attr_del2.array[p]<<14;break;
	case 2:	in=attr_del3.array[p]<<14;break;
}
int32_t t1,t2,t3;
t2=___SMMUL(in,scatter)<<1;
t3=array[(writepos-size)&LENGTHMASK]<<14;
t3+=___SMMUL((array[(writepos-size-1)&LENGTHMASK]<<14)-t3,mix)<<1;
t1=___SMMUL(t3,scatter)<<1;

array[writepos] = __SSAT(in+(param_mode>1?0:t2)-t1>>14,16);
int32_t out;
if(param_mode==1){
	out = __SSAT(t2+t3-t1>>14,16);
}
else{
	out=__SSAT(___SMMUL(in-t1<<1,scatter)+t3>>14,16);
}

switch(param_select)
{
	case 0: attr_del1.array[p]=out; break;
	case 1: attr_del2.array[p]=out; break;
	case 2: attr_del3.array[p]=out; break;
}

writepos = (writepos + 1)&LENGTHMASK;

}]]></code.srate>
      </object>
   </patchobj>
   <obj type="conv/unipolar2bipolar" uuid="efc8ee28c508740c5edf7995eaaa07a6d6818e5e" name="unipolar2bipolar_1" x="56" y="1022">
      <params/>
      <attribs/>
   </obj>
   <obj type="math/*c" uuid="7d5ef61c3bcd571ee6bbd8437ef3612125dfb225" name="*c_11" x="182" y="1022">
      <params>
         <frac32.u.map name="amp" value="21.0"/>
      </params>
      <attribs/>
   </obj>
   <comment type="patch/comment" x="826" y="1092" text=" pitchshift after scattering"/>
   <obj type="conv/unipolar2bipolar" uuid="efc8ee28c508740c5edf7995eaaa07a6d6818e5e" name="unipolar2bipolar_2" x="56" y="1106">
      <params/>
      <attribs/>
   </obj>
   <obj type="math/*c" uuid="7d5ef61c3bcd571ee6bbd8437ef3612125dfb225" name="*c_12" x="182" y="1106">
      <params>
         <frac32.u.map name="amp" value="21.0"/>
      </params>
      <attribs/>
   </obj>
   <obj type="ctrl/i" uuid="a3786816db6ea5bc6ac4193a5cccdb2c83b83496" name="i_4" x="392" y="1106">
      <params>
         <int32 name="value" value="27"/>
      </params>
      <attribs/>
   </obj>
   <obj type="math/inv" uuid="565521d3699b36d8095aa1c79b9ad0046fb133ce" name="inv_5" x="448" y="1106">
      <params/>
      <attribs/>
   </obj>
   <obj type="harmony/note scale" uuid="d5343a4fea87a3e4f4dae20287226084550ea8d3" name="note_4" x="504" y="1106">
      <params>
         <bin12 name="b12" value="2741"/>
      </params>
      <attribs/>
   </obj>
   <obj type="math/smooth" uuid="6c5d08c282bb08bff24af85b4891447f99bcbc97" name="smooth_1" x="658" y="1106">
      <params>
         <frac32.u.map name="time" value="63.0"/>
      </params>
      <attribs/>
   </obj>
   <patchobj type="patch/object" uuid="5622932a-a3fb-45da-927f-d2650b884e1f" name="pitchshift right" x="742" y="1106">
      <params>
         <frac32.s.map name="pitch" value="4.0"/>
         <int32.hradio name="select" value="2"/>
      </params>
      <attribs>
         <objref attributeName="del1" obj="delay_record_left"/>
         <objref attributeName="del2" obj="nested_1"/>
         <objref attributeName="del3" obj="nested_3"/>
         <objref attributeName="del4" obj="nested_7"/>
         <combo attributeName="windowsize" selection="262144 (5.46s)"/>
      </attribs>
      <object id="patch/object" uuid="5622932a-a3fb-45da-927f-d2650b884e1f">
         <sDescription>delay read, linear interpolated</sDescription>
         <author>Johannes Taelman</author>
         <license>BSD</license>
         <helpPatch>delay.axh</helpPatch>
         <inlets>
            <frac32 name="pitch"/>
         </inlets>
         <outlets/>
         <displays/>
         <params>
            <frac32.s.map name="pitch"/>
            <int32.hradio name="select">
               <MaxValue i="4"/>
            </int32.hradio>
         </params>
         <attribs>
            <objref name="del1"/>
            <objref name="del2"/>
            <objref name="del3"/>
            <objref name="del4"/>
            <combo name="windowsize">
               <MenuEntries>
                  <string>256 (5.33ms)</string>
                  <string>512 (10.66ms)</string>
                  <string>1024 (21.33ms)</string>
                  <string>2048 (42.66ms)</string>
                  <string>4096 (85.33ms)</string>
                  <string>8192 (170ms)</string>
                  <string>16384 (341ms)</string>
                  <string>32768 (682ms)</string>
                  <string>65536 (1.36s)</string>
                  <string>131072 (2.73s)</string>
                  <string>262144 (5.46s)</string>
                  <string>524288 (10.9s)</string>
                  <string>1048576 (21.8s)</string>
                  <string>2097152 (43.7s)</string>
               </MenuEntries>
               <CEntries>
                  <string>8</string>
                  <string>9</string>
                  <string>10</string>
                  <string>11</string>
                  <string>12</string>
                  <string>13</string>
                  <string>14</string>
                  <string>15</string>
                  <string>16</string>
                  <string>17</string>
                  <string>18</string>
                  <string>19</string>
                  <string>20</string>
                  <string>21</string>
               </CEntries>
            </combo>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[static const uint32_t LENGTHPOW = (attr_windowsize);
static const uint32_t LENGTH = (1<<attr_windowsize);
static const uint32_t LENGTHMASK = ((1<<attr_windowsize)-1);
int16_t *array;
uint32_t writepos;

uint32_t phs;]]></code.declaration>
         <code.init><![CDATA[static int16_t _array[attr_poly][1<<attr_windowsize]  __attribute__ ((section (".sdram")));
array = &_array[parent->polyIndex][0];
   int i;
   writepos = 0;
   for(i=0;i<LENGTH;i++) array[i] = 0;]]></code.init>
         <code.krate><![CDATA[int32_t rate;
int32_t base;
MTOFEXTENDED(param_pitch+inlet_pitch-(1<<27),rate)
MTOFEXTENDED(0-(1<<27),base)
float32_t ratio=(float32_t)rate/base;

rate=((int64_t)((int64_t)(1<<34-LENGTHPOW)*ratio-(1<<34-LENGTHPOW)));

int32_t window;
MTOFEXTENDED((1<<27),window)]]></code.krate>
         <code.srate><![CDATA[phs-=rate;
int32_t r;
SINE2TINTERP(phs+(1<<30),r)
r=(r>>1)+(1<<30);
uint32_t wp;
switch(param_select)
   {
   	case 0: 	wp=(attr_del1.writepos - BUFSIZE + buffer_index-2)&attr_del1.LENGTHMASK;break;
   	case 1: 	wp=(attr_del2.writepos - BUFSIZE + buffer_index-2)&attr_del2.LENGTHMASK;break;
   	case 2: 	wp=(attr_del3.writepos - BUFSIZE + buffer_index-2)&attr_del3.LENGTHMASK;break;
   	case 3: 	wp=(attr_del4.writepos - BUFSIZE + buffer_index-2)&attr_del4.LENGTHMASK;break;
   }
   writepos = (writepos + 1)&LENGTHMASK;
   
   switch(param_select)
   {
   	case 0: 	array[writepos] = attr_del1.array[wp];break;
   	case 1: 	array[writepos] = attr_del2.array[wp];break;
   	case 2: 	array[writepos] = attr_del3.array[wp];break;
   	case 3: 	array[writepos] = attr_del4.array[wp];break;
   }
   
	int32_t p1=___SMMUL(phs>>1,window);
	int32_t T =  p1;
	int32_t s,mx;
	s=T>>31-LENGTHPOW;
	mx=((uint32_t)T<<LENGTHPOW+1)>>1;
     T = writepos - s -1;
     int32_t a1 = array[T&LENGTHMASK]<<14;
     int32_t a2 = array[(T-1)&LENGTHMASK]<<14;
     a1+=___SMMUL(a2-a1,mx)<<1;

     p1=___SMMUL(((uint32_t)phs+(1<<31))>>1,window);
	T =  p1;
	s=T>>31-LENGTHPOW;
	mx=((uint32_t)T<<LENGTHPOW+1)>>1;
     T = writepos - s  -1;
     int32_t b1 = array[T&LENGTHMASK]<<14;
     int32_t b2 = array[(T-1)&LENGTHMASK]<<14;
     b1+=___SMMUL(b2-b1,mx)<<1;
	
	a1+=___SMMUL(b1-a1,r)<<1;
switch(param_select)
{
     case 0: attr_del1.array[wp]= a1>>14;break;
     case 1: attr_del2.array[wp]= a1>>14;break;
     case 2: attr_del3.array[wp]= a1>>14;break;
     case 3: attr_del4.array[wp]= a1>>14;break;
}]]></code.srate>
      </object>
   </patchobj>
   <obj type="harmony/note scale" uuid="d5343a4fea87a3e4f4dae20287226084550ea8d3" name="note_6" x="882" y="1106">
      <params>
         <bin12 name="b12" value="2741"/>
      </params>
      <attribs/>
   </obj>
   <obj type="math/smooth" uuid="6c5d08c282bb08bff24af85b4891447f99bcbc97" name="smooth_3" x="1036" y="1106">
      <params>
         <frac32.u.map name="time" value="63.0"/>
      </params>
      <attribs/>
   </obj>
   <patchobj type="patch/object" uuid="5622932a-a3fb-45da-927f-d2650b884e1f" name="pitchshift right_" x="1120" y="1106">
      <params>
         <frac32.s.map name="pitch" value="4.0"/>
         <int32.hradio name="select" value="1"/>
      </params>
      <attribs>
         <objref attributeName="del1" obj="delay_record_right"/>
         <objref attributeName="del2" obj="nested_2"/>
         <objref attributeName="del3" obj="nested_4"/>
         <objref attributeName="del4" obj="nested_8"/>
         <combo attributeName="windowsize" selection="262144 (5.46s)"/>
      </attribs>
      <object id="patch/object" uuid="5622932a-a3fb-45da-927f-d2650b884e1f">
         <sDescription>delay read, linear interpolated</sDescription>
         <author>Johannes Taelman</author>
         <license>BSD</license>
         <helpPatch>delay.axh</helpPatch>
         <inlets>
            <frac32 name="pitch"/>
         </inlets>
         <outlets/>
         <displays/>
         <params>
            <frac32.s.map name="pitch"/>
            <int32.hradio name="select">
               <MaxValue i="4"/>
            </int32.hradio>
         </params>
         <attribs>
            <objref name="del1"/>
            <objref name="del2"/>
            <objref name="del3"/>
            <objref name="del4"/>
            <combo name="windowsize">
               <MenuEntries>
                  <string>256 (5.33ms)</string>
                  <string>512 (10.66ms)</string>
                  <string>1024 (21.33ms)</string>
                  <string>2048 (42.66ms)</string>
                  <string>4096 (85.33ms)</string>
                  <string>8192 (170ms)</string>
                  <string>16384 (341ms)</string>
                  <string>32768 (682ms)</string>
                  <string>65536 (1.36s)</string>
                  <string>131072 (2.73s)</string>
                  <string>262144 (5.46s)</string>
                  <string>524288 (10.9s)</string>
                  <string>1048576 (21.8s)</string>
                  <string>2097152 (43.7s)</string>
               </MenuEntries>
               <CEntries>
                  <string>8</string>
                  <string>9</string>
                  <string>10</string>
                  <string>11</string>
                  <string>12</string>
                  <string>13</string>
                  <string>14</string>
                  <string>15</string>
                  <string>16</string>
                  <string>17</string>
                  <string>18</string>
                  <string>19</string>
                  <string>20</string>
                  <string>21</string>
               </CEntries>
            </combo>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[static const uint32_t LENGTHPOW = (attr_windowsize);
static const uint32_t LENGTH = (1<<attr_windowsize);
static const uint32_t LENGTHMASK = ((1<<attr_windowsize)-1);
int16_t *array;
uint32_t writepos;

uint32_t phs;]]></code.declaration>
         <code.init><![CDATA[static int16_t _array[attr_poly][1<<attr_windowsize]  __attribute__ ((section (".sdram")));
array = &_array[parent->polyIndex][0];
   int i;
   writepos = 0;
   for(i=0;i<LENGTH;i++) array[i] = 0;]]></code.init>
         <code.krate><![CDATA[int32_t rate;
int32_t base;
MTOFEXTENDED(param_pitch+inlet_pitch-(1<<27),rate)
MTOFEXTENDED(0-(1<<27),base)
float32_t ratio=(float32_t)rate/base;

rate=((int64_t)((int64_t)(1<<34-LENGTHPOW)*ratio-(1<<34-LENGTHPOW)));

int32_t window;
MTOFEXTENDED((1<<27),window)]]></code.krate>
         <code.srate><![CDATA[phs-=rate;
int32_t r;
SINE2TINTERP(phs+(1<<30),r)
r=(r>>1)+(1<<30);
uint32_t wp;
switch(param_select)
   {
   	case 0: 	wp=(attr_del1.writepos - BUFSIZE + buffer_index-2)&attr_del1.LENGTHMASK;break;
   	case 1: 	wp=(attr_del2.writepos - BUFSIZE + buffer_index-2)&attr_del2.LENGTHMASK;break;
   	case 2: 	wp=(attr_del3.writepos - BUFSIZE + buffer_index-2)&attr_del3.LENGTHMASK;break;
   	case 3: 	wp=(attr_del4.writepos - BUFSIZE + buffer_index-2)&attr_del4.LENGTHMASK;break;
   }
   writepos = (writepos + 1)&LENGTHMASK;
   
   switch(param_select)
   {
   	case 0: 	array[writepos] = attr_del1.array[wp];break;
   	case 1: 	array[writepos] = attr_del2.array[wp];break;
   	case 2: 	array[writepos] = attr_del3.array[wp];break;
   	case 3: 	array[writepos] = attr_del4.array[wp];break;
   }
   
	int32_t p1=___SMMUL(phs>>1,window);
	int32_t T =  p1;
	int32_t s,mx;
	s=T>>31-LENGTHPOW;
	mx=((uint32_t)T<<LENGTHPOW+1)>>1;
     T = writepos - s -1;
     int32_t a1 = array[T&LENGTHMASK]<<14;
     int32_t a2 = array[(T-1)&LENGTHMASK]<<14;
     a1+=___SMMUL(a2-a1,mx)<<1;

     p1=___SMMUL(((uint32_t)phs+(1<<31))>>1,window);
	T =  p1;
	s=T>>31-LENGTHPOW;
	mx=((uint32_t)T<<LENGTHPOW+1)>>1;
     T = writepos - s  -1;
     int32_t b1 = array[T&LENGTHMASK]<<14;
     int32_t b2 = array[(T-1)&LENGTHMASK]<<14;
     b1+=___SMMUL(b2-b1,mx)<<1;
	
	a1+=___SMMUL(b1-a1,r)<<1;
switch(param_select)
{
     case 0: attr_del1.array[wp]= a1>>14;break;
     case 1: attr_del2.array[wp]= a1>>14;break;
     case 2: attr_del3.array[wp]= a1>>14;break;
     case 3: attr_del4.array[wp]= a1>>14;break;
}]]></code.srate>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="2b6e9d3e-762f-48b8-befd-28527c74cded" name="nested_7" x="1260" y="1106">
      <params>
         <frac32.u.map name="scatter" value="53.5"/>
         <frac32.u.map name="size" value="22.044999599456787"/>
         <int32.hradio name="mode" value="1"/>
         <int32.hradio name="select" value="3"/>
      </params>
      <attribs>
         <combo attributeName="size" selection="16384 (341ms)"/>
         <objref attributeName="del1" obj="delay_record_left"/>
         <objref attributeName="del2" obj="nested_1"/>
         <objref attributeName="del3" obj="nested_3"/>
         <objref attributeName="del4" obj="delay_record_left"/>
      </attribs>
      <object id="patch/object" uuid="2b6e9d3e-762f-48b8-befd-28527c74cded">
         <sDescription>modulatable nested scatter/allpass function for delaylines.
Can be used with the factory delayline module to add diffusion to a delay</sDescription>
         <author>Remco van der Most</author>
         <license>BSD</license>
         <helpPatch>delay.axh</helpPatch>
         <inlets>
            <frac32buffer name="size"/>
         </inlets>
         <outlets/>
         <displays/>
         <params>
            <frac32.u.map name="scatter"/>
            <frac32.u.map name="size"/>
            <int32.hradio name="mode" description="off,scatter,allpass">
               <MaxValue i="3"/>
            </int32.hradio>
            <int32.hradio name="select">
               <MaxValue i="4"/>
            </int32.hradio>
         </params>
         <attribs>
            <combo name="size">
               <MenuEntries>
                  <string>256 (5.33ms)</string>
                  <string>512 (10.66ms)</string>
                  <string>1024 (21.33ms)</string>
                  <string>2048 (42.66ms)</string>
                  <string>4096 (85.33ms)</string>
                  <string>8192 (170ms)</string>
                  <string>16384 (341ms)</string>
                  <string>32768 (682ms)</string>
                  <string>65536 (1.36s)</string>
                  <string>131072 (2.73s)</string>
                  <string>262144 (5.46s)</string>
                  <string>524288 (10.9s)</string>
                  <string>1048576 (21.8s)</string>
                  <string>2097152 (43.7s)</string>
               </MenuEntries>
               <CEntries>
                  <string>8</string>
                  <string>9</string>
                  <string>10</string>
                  <string>11</string>
                  <string>12</string>
                  <string>13</string>
                  <string>14</string>
                  <string>15</string>
                  <string>16</string>
                  <string>17</string>
                  <string>18</string>
                  <string>19</string>
                  <string>20</string>
                  <string>21</string>
               </CEntries>
            </combo>
            <objref name="del1"/>
            <objref name="del2"/>
            <objref name="del3"/>
            <objref name="del4"/>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[static const uint32_t LENGTHPOW = (attr_size);
static const uint32_t LENGTH = (1<<attr_size);
static const uint32_t LENGTHMASK = ((1<<attr_size)-1);
int16_t *array;
uint32_t writepos;]]></code.declaration>
         <code.init><![CDATA[static int16_t _array[attr_poly][1<<attr_size]  __attribute__ ((section (".sdram")));
array = &_array[parent->polyIndex][0];
   int i;
   writepos = 0;
   for(i=0;i<LENGTH;i++) array[i] = 0;]]></code.init>
         <code.krate><![CDATA[int32_t scatter=__USAT(param_scatter,27)<<4;
int32_t wp=0;

int32_t POS;

switch(param_select)
{
	case 0: POS=attr_del1.writepos-BUFSIZE-1-1; break;
	case 1: POS=attr_del2.writepos-BUFSIZE-1-1; break;
	case 2: POS=attr_del3.writepos-BUFSIZE-1-1; break;
	case 3: POS=attr_del4.writepos-BUFSIZE-1-1; break;
}]]></code.krate>
         <code.srate><![CDATA[if(param_mode>0){

int32_t p=(POS+buffer_index);
switch(param_select)
{
	case 0: p=p&attr_del1.LENGTHMASK; break;
	case 1: p=p&attr_del2.LENGTHMASK; break;
	case 2: p=p&attr_del3.LENGTHMASK; break;
	case 3: p=p&attr_del4.LENGTHMASK; break;
}
	
int32_t sz=__USAT(param_size+inlet_size,27);
int32_t size=sz>>27-LENGTHPOW;
int32_t mix=((uint32_t)sz<<5+LENGTHPOW)>>1;

int32_t in;
switch(param_select)
{
	case 0:	in=attr_del1.array[p]<<14;break;
	case 1:	in=attr_del2.array[p]<<14;break;
	case 2:	in=attr_del3.array[p]<<14;break;
	case 3:	in=attr_del4.array[p]<<14;break;
}
int32_t t1,t2,t3;
t2=___SMMUL(in,scatter)<<1;
t3=array[(writepos-size)&LENGTHMASK]<<14;
t3+=___SMMUL((array[(writepos-size-1)&LENGTHMASK]<<14)-t3,mix)<<1;
t1=___SMMUL(t3,scatter)<<1;

array[writepos] = __SSAT(in+(param_mode>1?0:t2)-t1>>14,16);
int32_t out;
if(param_mode==1){
	out = __SSAT(t2+t3-t1>>14,16);
}
else{
	out=__SSAT(___SMMUL(in-t1<<1,scatter)+t3>>14,16);
}

switch(param_select)
{
	case 0: attr_del1.array[p]=out; break;
	case 1: attr_del2.array[p]=out; break;
	case 2: attr_del3.array[p]=out; break;
	case 3: attr_del4.array[p]=out; break;
}

writepos = (writepos + 1)&LENGTHMASK;

}]]></code.srate>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="2b6e9d3e-762f-48b8-befd-28527c74cded" name="nested_8" x="1386" y="1106">
      <params>
         <frac32.u.map name="scatter" value="53.5"/>
         <frac32.u.map name="size" value="23.8149995803833"/>
         <int32.hradio name="mode" value="2"/>
         <int32.hradio name="select" value="3"/>
      </params>
      <attribs>
         <combo attributeName="size" selection="16384 (341ms)"/>
         <objref attributeName="del1" obj="delay_record_right"/>
         <objref attributeName="del2" obj="nested_2"/>
         <objref attributeName="del3" obj="nested_4"/>
         <objref attributeName="del4" obj="delay_record_right"/>
      </attribs>
      <object id="patch/object" uuid="2b6e9d3e-762f-48b8-befd-28527c74cded">
         <sDescription>modulatable nested scatter/allpass function for delaylines.
Can be used with the factory delayline module to add diffusion to a delay</sDescription>
         <author>Remco van der Most</author>
         <license>BSD</license>
         <helpPatch>delay.axh</helpPatch>
         <inlets>
            <frac32buffer name="size"/>
         </inlets>
         <outlets/>
         <displays/>
         <params>
            <frac32.u.map name="scatter"/>
            <frac32.u.map name="size"/>
            <int32.hradio name="mode" description="off,scatter,allpass">
               <MaxValue i="3"/>
            </int32.hradio>
            <int32.hradio name="select">
               <MaxValue i="4"/>
            </int32.hradio>
         </params>
         <attribs>
            <combo name="size">
               <MenuEntries>
                  <string>256 (5.33ms)</string>
                  <string>512 (10.66ms)</string>
                  <string>1024 (21.33ms)</string>
                  <string>2048 (42.66ms)</string>
                  <string>4096 (85.33ms)</string>
                  <string>8192 (170ms)</string>
                  <string>16384 (341ms)</string>
                  <string>32768 (682ms)</string>
                  <string>65536 (1.36s)</string>
                  <string>131072 (2.73s)</string>
                  <string>262144 (5.46s)</string>
                  <string>524288 (10.9s)</string>
                  <string>1048576 (21.8s)</string>
                  <string>2097152 (43.7s)</string>
               </MenuEntries>
               <CEntries>
                  <string>8</string>
                  <string>9</string>
                  <string>10</string>
                  <string>11</string>
                  <string>12</string>
                  <string>13</string>
                  <string>14</string>
                  <string>15</string>
                  <string>16</string>
                  <string>17</string>
                  <string>18</string>
                  <string>19</string>
                  <string>20</string>
                  <string>21</string>
               </CEntries>
            </combo>
            <objref name="del1"/>
            <objref name="del2"/>
            <objref name="del3"/>
            <objref name="del4"/>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[static const uint32_t LENGTHPOW = (attr_size);
static const uint32_t LENGTH = (1<<attr_size);
static const uint32_t LENGTHMASK = ((1<<attr_size)-1);
int16_t *array;
uint32_t writepos;]]></code.declaration>
         <code.init><![CDATA[static int16_t _array[attr_poly][1<<attr_size]  __attribute__ ((section (".sdram")));
array = &_array[parent->polyIndex][0];
   int i;
   writepos = 0;
   for(i=0;i<LENGTH;i++) array[i] = 0;]]></code.init>
         <code.krate><![CDATA[int32_t scatter=__USAT(param_scatter,27)<<4;
int32_t wp=0;

int32_t POS;

switch(param_select)
{
	case 0: POS=attr_del1.writepos-BUFSIZE-1-1; break;
	case 1: POS=attr_del2.writepos-BUFSIZE-1-1; break;
	case 2: POS=attr_del3.writepos-BUFSIZE-1-1; break;
	case 3: POS=attr_del4.writepos-BUFSIZE-1-1; break;
}]]></code.krate>
         <code.srate><![CDATA[if(param_mode>0){

int32_t p=(POS+buffer_index);
switch(param_select)
{
	case 0: p=p&attr_del1.LENGTHMASK; break;
	case 1: p=p&attr_del2.LENGTHMASK; break;
	case 2: p=p&attr_del3.LENGTHMASK; break;
	case 3: p=p&attr_del4.LENGTHMASK; break;
}
	
int32_t sz=__USAT(param_size+inlet_size,27);
int32_t size=sz>>27-LENGTHPOW;
int32_t mix=((uint32_t)sz<<5+LENGTHPOW)>>1;

int32_t in;
switch(param_select)
{
	case 0:	in=attr_del1.array[p]<<14;break;
	case 1:	in=attr_del2.array[p]<<14;break;
	case 2:	in=attr_del3.array[p]<<14;break;
	case 3:	in=attr_del4.array[p]<<14;break;
}
int32_t t1,t2,t3;
t2=___SMMUL(in,scatter)<<1;
t3=array[(writepos-size)&LENGTHMASK]<<14;
t3+=___SMMUL((array[(writepos-size-1)&LENGTHMASK]<<14)-t3,mix)<<1;
t1=___SMMUL(t3,scatter)<<1;

array[writepos] = __SSAT(in+(param_mode>1?0:t2)-t1>>14,16);
int32_t out;
if(param_mode==1){
	out = __SSAT(t2+t3-t1>>14,16);
}
else{
	out=__SSAT(___SMMUL(in-t1<<1,scatter)+t3>>14,16);
}

switch(param_select)
{
	case 0: attr_del1.array[p]=out; break;
	case 1: attr_del2.array[p]=out; break;
	case 2: attr_del3.array[p]=out; break;
	case 3: attr_del4.array[p]=out; break;
}

writepos = (writepos + 1)&LENGTHMASK;

}]]></code.srate>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="2b6e9d3e-762f-48b8-befd-28527c74cded" name="stereo scatter_3" x="1512" y="1106">
      <params>
         <frac32.u.map name="scatter" value="20.5"/>
         <int32.hradio name="mode" value="1"/>
      </params>
      <attribs>
         <objref attributeName="del1" obj="delay_record_left"/>
         <objref attributeName="del2" obj="delay_record_right"/>
      </attribs>
      <object id="patch/object" uuid="2b6e9d3e-762f-48b8-befd-28527c74cded">
         <sDescription>modulatable nested scatter/allpass function for delaylines.
Can be used with the factory delayline module to add diffusion to a delay</sDescription>
         <author>Remco van der Most</author>
         <license>BSD</license>
         <helpPatch>delay.axh</helpPatch>
         <inlets/>
         <outlets/>
         <displays/>
         <params>
            <frac32.u.map name="scatter"/>
            <int32.hradio name="mode" description="off,scatter,allpass">
               <MaxValue i="2"/>
            </int32.hradio>
         </params>
         <attribs>
            <objref name="del1"/>
            <objref name="del2"/>
         </attribs>
         <includes/>
         <code.krate><![CDATA[int32_t scatter=__USAT(param_scatter,27)<<4;


int32_t POS1=attr_del1.writepos-BUFSIZE-1-1;
int32_t POS2=attr_del2.writepos-BUFSIZE-1-1;]]></code.krate>
         <code.srate><![CDATA[if(param_mode>0){
int32_t p1=(POS1+buffer_index)&attr_del1.LENGTHMASK;
int32_t p2=(POS2+buffer_index)&attr_del2.LENGTHMASK;



int32_t in=attr_del1.array[p1]<<14;
int32_t t1,t2,t3;
t2=___SMMUL(in,scatter)<<1;
t3=attr_del2.array[p2]<<14;
t1=___SMMUL(t3,scatter)<<1;

attr_del2.array[p2] = __SSAT(in-t1>>14,16);
attr_del1.array[p1]=__SSAT(___SMMUL(in-t1<<1,scatter)+t3>>14,16);


}]]></code.srate>
      </object>
   </patchobj>
   <nets>
      <net>
         <source obj="square_1" outlet="wave"/>
         <dest obj="counter_7" inlet="trig"/>
         <dest obj="counter_9" inlet="trig"/>
         <dest obj="counter_11" inlet="trig"/>
         <dest obj="counter_1" inlet="trig"/>
         <dest obj="square_2" inlet="reset"/>
      </net>
      <net>
         <source obj="counter_1" outlet="o"/>
         <dest obj="recycle" inlet="maincount"/>
      </net>
      <net>
         <source obj="counter_1" outlet="c"/>
         <dest obj="counter_6" inlet="trig"/>
         <dest obj="counter_13" inlet="trig"/>
      </net>
      <net>
         <source obj="counter_7" outlet="c"/>
         <dest obj="counter_8" inlet="trig"/>
      </net>
      <net>
         <source obj="counter_9" outlet="c"/>
         <dest obj="counter_10" inlet="trig"/>
      </net>
      <net>
         <source obj="counter_11" outlet="c"/>
         <dest obj="counter_12" inlet="trig"/>
      </net>
      <net>
         <source obj="counter_10" outlet="o"/>
         <dest obj="recycle" inlet="count1"/>
      </net>
      <net>
         <source obj="counter_8" outlet="o"/>
         <dest obj="recycle" inlet="count2"/>
      </net>
      <net>
         <source obj="counter_12" outlet="o"/>
         <dest obj="recycle" inlet="count3"/>
      </net>
      <net>
         <source obj="counter_6" outlet="o"/>
         <dest obj="recycle" inlet="count4"/>
      </net>
      <net>
         <source obj="i_3" outlet="out"/>
         <dest obj="note_3" inlet="offset"/>
      </net>
      <net>
         <source obj="mix_3" outlet="out"/>
         <dest obj="note_3" inlet="note"/>
      </net>
      <net>
         <source obj="note_3" outlet="note"/>
         <dest obj="latch_1" inlet="i"/>
      </net>
      <net>
         <source obj="recycle" outlet="o1"/>
         <dest obj="mix_3" inlet="in1"/>
         <dest obj="sine_10" inlet="pitch"/>
      </net>
      <net>
         <source obj="recycle" outlet="o2"/>
         <dest obj="mix_3" inlet="in2"/>
      </net>
      <net>
         <source obj="latch_1" outlet="o"/>
         <dest obj="interp_1" inlet="i"/>
      </net>
      <net>
         <source obj="mix_1" outlet="out"/>
         <dest obj="delay_record_left" inlet="in"/>
      </net>
      <net>
         <source obj="mix_2" outlet="out"/>
         <dest obj="delay_record_right" inlet="in"/>
      </net>
      <net>
         <source obj="sine_1" outlet="wave"/>
         <dest obj="*c_1" inlet="in"/>
      </net>
      <net>
         <source obj="*c_1" outlet="out"/>
         <dest obj="inv_1" inlet="in"/>
         <dest obj="nested_1" inlet="size"/>
      </net>
      <net>
         <source obj="sine_2" outlet="wave"/>
         <dest obj="*c_3" inlet="in"/>
      </net>
      <net>
         <source obj="*c_3" outlet="out"/>
         <dest obj="inv_2" inlet="in"/>
         <dest obj="nested_7" inlet="size"/>
      </net>
      <net>
         <source obj="sine_3" outlet="wave"/>
         <dest obj="*c_2" inlet="in"/>
      </net>
      <net>
         <source obj="inv_1" outlet="out"/>
         <dest obj="nested_2" inlet="size"/>
      </net>
      <net>
         <source obj="inv_2" outlet="out"/>
         <dest obj="nested_8" inlet="size"/>
      </net>
      <net>
         <source obj="*c_2" outlet="out"/>
         <dest obj="inv_3" inlet="in"/>
         <dest obj="nested_5" inlet="size"/>
      </net>
      <net>
         <source obj="inv_3" outlet="out"/>
         <dest obj="nested_6" inlet="size"/>
      </net>
      <net>
         <source obj="sine_4" outlet="wave"/>
         <dest obj="*c_5" inlet="in"/>
      </net>
      <net>
         <source obj="*c_5" outlet="out"/>
         <dest obj="inv_4" inlet="in"/>
         <dest obj="nested_3" inlet="size"/>
      </net>
      <net>
         <source obj="inv_4" outlet="out"/>
         <dest obj="nested_4" inlet="size"/>
      </net>
      <net>
         <source obj="burst generator" outlet="gate"/>
         <dest obj="envelope" inlet="trig"/>
         <dest obj="latch_1" inlet="trig"/>
      </net>
      <net>
         <source obj="counter_6" outlet="c"/>
         <dest obj="burst generator" inlet="rnd"/>
         <dest obj="recycle" inlet="rnd"/>
      </net>
      <net>
         <source obj="square_2" outlet="wave"/>
         <dest obj="burst generator" inlet="trig"/>
      </net>
      <net>
         <source obj="envelope" outlet="env"/>
         <dest obj="*_1" inlet="a"/>
      </net>
      <net>
         <source obj="recycle" outlet="o8"/>
         <dest obj="envelope" inlet="a"/>
      </net>
      <net>
         <source obj="recycle" outlet="o9"/>
         <dest obj="envelope" inlet="d"/>
      </net>
      <net>
         <source obj="recycle" outlet="o10"/>
         <dest obj="envelope" inlet="skew"/>
      </net>
      <net>
         <source obj="recycle" outlet="o11"/>
         <dest obj="envelope" inlet="shift"/>
         <dest obj="unipolar2bipolar_2" inlet="i"/>
      </net>
      <net>
         <source obj="recycle" outlet="o12"/>
         <dest obj="envelope" inlet="expo"/>
      </net>
      <net>
         <source obj="mix_4" outlet="out"/>
         <dest obj="out_1" inlet="left"/>
      </net>
      <net>
         <source obj="mix_5" outlet="out"/>
         <dest obj="out_1" inlet="right"/>
      </net>
      <net>
         <source obj="sine_5" outlet="wave"/>
         <dest obj="*c_4" inlet="in"/>
      </net>
      <net>
         <source obj="*c_4" outlet="out"/>
         <dest obj="read_7" inlet="interpSmall"/>
      </net>
      <net>
         <source obj="sine_6" outlet="wave"/>
         <dest obj="*_1" inlet="b"/>
      </net>
      <net>
         <source obj="sine_7" outlet="wave"/>
         <dest obj="*c_9" inlet="in"/>
      </net>
      <net>
         <source obj="read_3" outlet="out"/>
         <dest obj="lp1_2" inlet="in"/>
      </net>
      <net>
         <source obj="interp_1" outlet="o"/>
         <dest obj="lp1_1" inlet="in"/>
      </net>
      <net>
         <source obj="lp1_1" outlet="out"/>
         <dest obj="sine_6" inlet="pitch"/>
      </net>
      <net>
         <source obj="*_1" outlet="result"/>
         <dest obj="*c_7" inlet="in"/>
      </net>
      <net>
         <source obj="recycle" outlet="o13"/>
         <dest obj="lp1_1" inlet="freq"/>
      </net>
      <net>
         <source obj="lp1_2" outlet="out"/>
         <dest obj="mix_1" inlet="in1"/>
      </net>
      <net>
         <source obj="lp1_3" outlet="out"/>
         <dest obj="mix_2" inlet="in1"/>
      </net>
      <net>
         <source obj="recycle" outlet="o3"/>
         <dest obj="sine_1" inlet="pitch"/>
         <dest obj="unipolar2bipolar_1" inlet="i"/>
      </net>
      <net>
         <source obj="recycle" outlet="o4"/>
         <dest obj="sine_4" inlet="pitch"/>
      </net>
      <net>
         <source obj="recycle" outlet="o5"/>
         <dest obj="sine_3" inlet="pitch"/>
      </net>
      <net>
         <source obj="recycle" outlet="o6"/>
         <dest obj="sine_2" inlet="pitch"/>
      </net>
      <net>
         <source obj="recycle" outlet="o7"/>
         <dest obj="sine_5" inlet="pitch"/>
      </net>
      <net>
         <source obj="recycle" outlet="o14"/>
         <dest obj="sine_7" inlet="pitch"/>
      </net>
      <net>
         <source obj="*c_4" outlet="iout"/>
         <dest obj="read_8" inlet="interpSmall"/>
      </net>
      <net>
         <source obj="*c_9" outlet="out"/>
         <dest obj="read_3" inlet="interpSmall"/>
      </net>
      <net>
         <source obj="*c_9" outlet="iout"/>
         <dest obj="read_4" inlet="interpSmall"/>
      </net>
      <net>
         <source obj="read_4" outlet="out"/>
         <dest obj="lp1_3" inlet="in"/>
      </net>
      <net>
         <source obj="sine_9" outlet="wave"/>
         <dest obj="*c_6" inlet="in"/>
      </net>
      <net>
         <source obj="*c_6" outlet="out"/>
         <dest obj="read_4" inlet="interpBig"/>
      </net>
      <net>
         <source obj="*c_6" outlet="iout"/>
         <dest obj="read_3" inlet="interpBig"/>
      </net>
      <net>
         <source obj="sine_10" outlet="wave"/>
         <dest obj="*c_10" inlet="in"/>
      </net>
      <net>
         <source obj="read_7" outlet="out"/>
         <dest obj="mix_4" inlet="in1"/>
         <dest obj="L-&gt;R delayed mix" inlet="in"/>
      </net>
      <net>
         <source obj="read_8" outlet="out"/>
         <dest obj="mix_5" inlet="in1"/>
         <dest obj="R-&gt;L delayed mix" inlet="in"/>
      </net>
      <net>
         <source obj="*c_10" outlet="out"/>
         <dest obj="read_7" inlet="interpBig"/>
      </net>
      <net>
         <source obj="*c_10" outlet="iout"/>
         <dest obj="read_8" inlet="interpBig"/>
      </net>
      <net>
         <source obj="*c_7" outlet="out"/>
         <dest obj="predelay" inlet="in"/>
      </net>
      <net>
         <source obj="sine_8" outlet="wave"/>
         <dest obj="*c_8" inlet="in"/>
      </net>
      <net>
         <source obj="*c_8" outlet="out"/>
         <dest obj="read predelay left (room pos)" inlet="interpSmall"/>
      </net>
      <net>
         <source obj="*c_8" outlet="iout"/>
         <dest obj="read predelay right (room pos)" inlet="interpSmall"/>
      </net>
      <net>
         <source obj="read predelay left (room pos)" outlet="out"/>
         <dest obj="mix_1" inlet="bus_in"/>
         <dest obj="early reflections" inlet="in"/>
         <dest obj="mix_4" inlet="bus_in"/>
      </net>
      <net>
         <source obj="read predelay right (room pos)" outlet="out"/>
         <dest obj="mix_2" inlet="bus_in"/>
         <dest obj="early reflections__" inlet="in"/>
         <dest obj="mix_5" inlet="bus_in"/>
      </net>
      <net>
         <source obj="L-&gt;R delayed mix" outlet="out"/>
         <dest obj="mix_5" inlet="in2"/>
      </net>
      <net>
         <source obj="R-&gt;L delayed mix" outlet="out"/>
         <dest obj="mix_4" inlet="in2"/>
      </net>
      <net>
         <source obj="headsize" outlet="out"/>
         <dest obj="L-&gt;R delayed mix" inlet="time"/>
         <dest obj="R-&gt;L delayed mix" inlet="time"/>
      </net>
      <net>
         <source obj="recycle" outlet="o15"/>
         <dest obj="sine_8" inlet="pitch"/>
      </net>
      <net>
         <source obj="recycle" outlet="o16"/>
         <dest obj="sine_9" inlet="pitch"/>
      </net>
      <net>
         <source obj="i_4" outlet="out"/>
         <dest obj="note_4" inlet="offset"/>
         <dest obj="note_6" inlet="offset"/>
      </net>
      <net>
         <source obj="unipolar2bipolar_1" outlet="o"/>
         <dest obj="*c_11" inlet="in"/>
      </net>
      <net>
         <source obj="*c_11" outlet="out"/>
         <dest obj="note_4" inlet="note"/>
         <dest obj="inv_5" inlet="in"/>
      </net>
      <net>
         <source obj="note_4" outlet="note"/>
         <dest obj="smooth_1" inlet="in"/>
      </net>
      <net>
         <source obj="smooth_1" outlet="out"/>
         <dest obj="pitchshift right" inlet="pitch"/>
      </net>
      <net>
         <source obj="note_6" outlet="note"/>
         <dest obj="smooth_3" inlet="in"/>
      </net>
      <net>
         <source obj="smooth_3" outlet="out"/>
         <dest obj="pitchshift right_" inlet="pitch"/>
      </net>
      <net>
         <source obj="counter_13" outlet="c"/>
         <dest obj="burst generator" inlet="r"/>
      </net>
      <net>
         <source obj="unipolar2bipolar_2" outlet="o"/>
         <dest obj="*c_12" inlet="in"/>
      </net>
      <net>
         <source obj="*c_12" outlet="out"/>
         <dest obj="note_6" inlet="note"/>
      </net>
   </nets>
   <settings>
      <subpatchmode>no</subpatchmode>
   </settings>
   <notes><![CDATA[]]></notes>
   <windowPos>
      <x>-13</x>
      <y>-8</y>
      <width>1857</width>
      <height>1096</height>
   </windowPos>
</patch-1.0>