<patch-1.0 appVersion="1.0.12">
   <comment type="patch/comment" x="294" y="28" text="1 track midi looper with lauchpad mini control."/>
   <comment type="patch/comment" x="1022" y="42" text="buffer info -"/>
   <comment type="patch/comment" x="238" y="56" text=" channel 1 reserved for launchapd. The looper is set up to record channel 2 from DIN and play out to DIN. adjust outputs/channel in objects below"/>
   <patchobj type="patch/object" uuid="3f275239-b947-4f84-ae3e-8dd26944e667" name="buffer_1" x="1022" y="56">
      <params>
         <bool32.mom name="reset" value="0"/>
      </params>
      <attribs>
         <combo attributeName="device" selection="usb host"/>
      </attribs>
      <object id="patch/object" uuid="3f275239-b947-4f84-ae3e-8dd26944e667">
         <sDescription>constant</sDescription>
         <author>Johannes Taelman</author>
         <license>BSD</license>
         <helpPatch>i.axh</helpPatch>
         <inlets/>
         <outlets>
            <bool32 name="out"/>
         </outlets>
         <displays>
            <int32.label name="out"/>
            <int32.label name="max"/>
            <bool32 name="empty"/>
         </displays>
         <params>
            <bool32.mom name="reset" noLabel="true"/>
         </params>
         <attribs>
            <combo name="device">
               <MenuEntries>
                  <string>din</string>
                  <string>usb host</string>
                  <string>internal</string>
                  <string>usb device</string>
               </MenuEntries>
               <CEntries>
                  <string>MIDI_DEVICE_DIN</string>
                  <string>MIDI_DEVICE_USB_HOST</string>
                  <string>MIDI_DEVICE_INTERNAL</string>
                  <string>MIDI_DEVICE_USB_DEVICE</string>
               </CEntries>
            </combo>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[int out;
int prev;]]></code.declaration>
         <code.krate><![CDATA[if (param_reset){
	disp_out=0;
	prev=0;
}
out= (MidiGetOutputBufferPending(attr_device));
if (out>0){
	disp_out=out;
}
if (out==0){
	disp_empty=1;
}
else {disp_empty=0;}
outlet_out=!disp_out;
if (out>=prev){
	prev=out;
}
disp_max=prev;]]></code.krate>
      </object>
   </patchobj>
   <comment type="patch/comment" x="462" y="98" text=" start/stop transport"/>
   <comment type="patch/comment" x="42" y="112" text="192ppq clock"/>
   <comment type="patch/comment" x="462" y="112" text="(if using external midi clock leave off)"/>
   <comment type="patch/comment" x="672" y="112" text="internal clock speed"/>
   <comment type="patch/comment" x="798" y="112" text="metronom vol"/>
   <patchobj type="patch/object" uuid="a326166e-4741-4e9d-82a1-68806cc34bf5" name="mclock_1" x="42" y="126">
      <params>
         <int32 name="clockdiv" value="16"/>
         <int32 name="clocklength" value="16"/>
      </params>
      <attribs>
         <combo attributeName="clockin" selection="omni"/>
      </attribs>
      <object id="patch/object" uuid="a326166e-4741-4e9d-82a1-68806cc34bf5">
         <sDescription>Midi clock slave</sDescription>
         <author>Johannes Taelman</author>
         <license>BSD</license>
         <helpPatch>midi_in.axh</helpPatch>
         <inlets/>
         <outlets>
            <bool32 name="active"/>
            <int32 name="kbeat"/>
            <bool32.pulse name="start"/>
            <bool32.pulse name="stop"/>
            <int32 name="192ppq"/>
            <int32 name="bar192ppq"/>
            <int32 name="clock"/>
            <bool32.pulse name="trig"/>
            <int32 name="count" description="rough bpm"/>
            <bool32 name="pulse"/>
            <bool32.pulse name="bartrig"/>
            <int32 name="bpm"/>
         </outlets>
         <displays/>
         <params>
            <int32 name="clockdiv">
               <MinValue i="1"/>
               <MaxValue i="300"/>
            </int32>
            <int32 name="clocklength">
               <MinValue i="0"/>
               <MaxValue i="3000000"/>
            </int32>
         </params>
         <attribs>
            <combo name="clockin">
               <MenuEntries>
                  <string>omni</string>
                  <string>din</string>
                  <string>usb host port 1</string>
                  <string>usb host port 2</string>
                  <string>usb host port 3</string>
                  <string>usb host port 4</string>
                  <string>internal port 1</string>
                  <string>internal port 2</string>
                  <string>usb device port 1</string>
               </MenuEntries>
               <CEntries>
                  <string>true</string>
                  <string>dev == MIDI_DEVICE_DIN &amp;&amp; port == 1</string>
                  <string>dev == MIDI_DEVICE_USB_HOST &amp;&amp; port == 1</string>
                  <string>dev == MIDI_DEVICE_USB_HOST &amp;&amp; port == 2</string>
                  <string>dev == MIDI_DEVICE_USB_HOST &amp;&amp; port == 3</string>
                  <string>dev == MIDI_DEVICE_USB_HOST &amp;&amp; port == 4</string>
                  <string>dev == MIDI_DEVICE_INTERNAL &amp;&amp; port == 1</string>
                  <string>dev == MIDI_DEVICE_INTERNAL &amp;&amp; port == 2</string>
                  <string>dev == MIDI_DEVICE_USB_DEVICE &amp;&amp; port == 1</string>
               </CEntries>
            </combo>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[int32_t _active;
int32_t _pos;
int active;
int init;
int drift;
int driftV;
int unsynced;
int otrig;
int start;
int stop;
int newpos;
int tap;
int ppq192;
int ktick;
int newtick;
int stepos;
int prevpos;
int dialclock;
int clock192;
int x;
int xtick;
int syncV;
int bar192;
int count;
int bartrig;
int prevcount;
int resync;
int kbeat;
int k;
int prevc;
int incount;
int divclock;
int Otrig;
int prevdiv;
int Oclock;
int length;
int pulse;]]></code.declaration>
         <code.init><![CDATA[_active = 0;
_pos = -1;



stepos=-1;
init=1;

resync=45;]]></code.init>
         <code.krate><![CDATA[//create extra ticks sync
dialclock+=(1<<27)/ktick;
if (dialclock>=((1<<27)-1)){
	dialclock=(1<<27)-1;
}


//new 24ppq clock so matches ktick
newtick+=1;
if ((newtick>=ktick)&&(ktick>0) && (stepos>=0)){
	newtick=0;
	if (!unsynced){
	newpos+=1;
	}
	dialclock=0;
}

//create extra ticks
ppq192=dialclock/ ((1<<27)/8);
//stop too many extra ticks
if (ppq192>=7){
	ppq192=7;
}


///measure 24ppq pulse
x+=1;
if ((stepos!=prevpos) && (stepos>=0)){
	if (stepos==0){
		newtick=0;
		newpos=0;
		}
	
	prevpos=stepos;
	if (stepos>0){
		ktick=x;
		}
	if (unsynced){
		newpos=stepos;
		driftV=0;
		drift=0;
		newtick=0;
		dialclock=0;
		unsynced=0;
		ppq192=0;
	}
	x=0;
}

if (stepos>=0){
clock192=(newpos<<3)+ppq192;
bar192=clock192-((clock192/768)*768);
count=bar192/192;
divclock=clock192/(768/param_clockdiv);
}

else {
	clock192=-1;
	newpos=-1;
	bar192=-1;
	count=-1;
	divclock=-1;
}
incount=(stepos/24);
k+=1;
if ((incount!=prevc)&&(stepos>=0)){
	
	if (stepos>0){
		kbeat=k;
	}
	prevc=incount;
	k=0;
}


//clock difference
syncV=newpos-stepos;

//if clock is different, time it
if (syncV!=0){
	drift+=1;
	driftV=drift;
	if (!otrig){
		otrig=1;
		drift=0;
	}
}
if (syncV==0){
	driftV=drift;
	otrig=0;
}
//if clocks are different for long enough, unsync is on, resync is triggered
if ((driftV>resync) && (stepos>0)){
	unsynced=1;
}


if (count!=prevcount){
	if (count==0){
		bartrig=1;
	}
	if (stepos>=0){
	pulse=1;
	}
	prevcount=count;
}
if (start){
	active=1;
}
if (stop){
	active=0;
}
length=param_clocklength;
if (divclock!=prevdiv){
	if (divclock>=0){
		Oclock+=1;
		Otrig=1;
	}
	if ((Oclock>=length)|| (start)){
		Oclock=0;
	}
	prevdiv=divclock;
}
if (stepos<0){
	Oclock=-1;
}
outlet_active=active;
outlet_kbeat=kbeat;
outlet_bar192ppq=bar192;
outlet_192ppq=clock192;
outlet_count=count;
outlet_pulse=pulse;
outlet_clock=Oclock;
outlet_trig=Otrig;

outlet_start=start;
outlet_stop=stop;
outlet_bpm=180000/kbeat;
// bpm back to kbeat
// kbeat=180000/bpm;
outlet_bartrig=bartrig;

pulse=0;
Otrig=0;
bartrig=0;
start=0;
stop=0;]]></code.krate>
         <code.midihandler><![CDATA[if (attr_clockin){
	if ((status == MIDI_TIMING_CLOCK) &&_active) {
		if ((_pos==0)&&_active){
	  	start=1;
	  	
	  }
	  _pos++;
	  stepos++;
	  
	  
	} else if (status == MIDI_START) {
	  _active = 1;
	  _pos = 0;
	  stepos=-1;
	  
	} else if (status == MIDI_STOP) {
	  _active = 0;
	  stop=1;
	  _pos = -1;
	  stepos=-1;
	
	  
	}
}]]></code.midihandler>
      </object>
   </patchobj>
   <obj type="ctrl/toggle" uuid="42b8134fa729d54bfc8d62d6ef3fa99498c1de99" name="toggle_1" x="518" y="126">
      <params>
         <bool32.tgl name="b" value="0"/>
      </params>
      <attribs/>
   </obj>
   <obj type="ctrl/dial p" uuid="cc5d2846c3d50e425f450c4b9851371b54f4d674" name="dial_2" x="686" y="126">
      <params>
         <frac32.u.map name="value" value="18.5"/>
      </params>
      <attribs/>
   </obj>
   <obj type="ctrl/dial p" uuid="cc5d2846c3d50e425f450c4b9851371b54f4d674" name="dial_1" x="798" y="126">
      <params>
         <frac32.u.map name="value" value="8.5"/>
      </params>
      <attribs/>
   </obj>
   <comment type="patch/comment" x="1120" y="126" text="out = last amount of notes in buffer when buffer&gt;0"/>
   <comment type="patch/comment" x="1120" y="140" text="max = largest amount of notes in buffer (reset with paramater button)"/>
   <comment type="patch/comment" x="1120" y="154" text="empty = buffer empty"/>
   <comment type="patch/comment" x="1302" y="182" text="data storage"/>
   <obj type="table/alloc 16b sdram load" uuid="e6b85dad3ab43565cda93ea4c43c73b668b1cd43" name="midiloopA" x="1302" y="196">
      <params/>
      <attribs>
         <combo attributeName="size" selection="262144"/>
         <file attributeName="filename" file="/JOANx"/>
      </attribs>
   </obj>
   <comment type="patch/comment" x="462" y="238" text="internal clock"/>
   <comment type="patch/comment" x="434" y="252" text="same as factory but with inlet for speed (dial scaled a bit for more usable range)"/>
   <obj type="math/*c" uuid="7d5ef61c3bcd571ee6bbd8437ef3612125dfb225" name="*c_1" x="462" y="266">
      <params>
         <frac32.u.map name="amp" value="32.0"/>
      </params>
      <attribs/>
   </obj>
   <obj type="math/+c" uuid="13eec32bd8ad57dd0bb18a02566cc0a117d320e3" name="+c_1" x="560" y="266">
      <params>
         <frac32.u.map name="c" value="8.0"/>
      </params>
      <attribs/>
   </obj>
   <patchobj type="patch/object" uuid="275db011-dcb7-4112-bf40-6c64411dba0a" name="clock_4" x="616" y="266">
      <params/>
      <attribs/>
      <object id="patch/object" uuid="275db011-dcb7-4112-bf40-6c64411dba0a">
         <sDescription>Midi clock master, als outputs Midi clock, start, stop, and continue messages. Sends to midi/in/* objects only.</sDescription>
         <author>Johannes Taelman</author>
         <license>BSD</license>
         <inlets>
            <bool32 name="run" description="Run"/>
            <bool32.rising name="rst" description="Reset"/>
            <frac32.positive name="speed"/>
         </inlets>
         <outlets>
            <bool32 name="active" description="Song is playing"/>
            <int32 name="pos4ppq" description="Position in 4 counts per quarter"/>
            <int32 name="pos24ppq" description="Position in 24 counts per quarter"/>
         </outlets>
         <displays/>
         <params/>
         <attribs/>
         <includes/>
         <code.declaration><![CDATA[bool _active;
int32_t _posfrac;
int32_t _pos24ppq;
bool rstp;]]></code.declaration>
         <code.init><![CDATA[_active = 0;
_posfrac = 0;
_pos24ppq = 0;
rstp = 0;]]></code.init>
         <code.krate><![CDATA[if (inlet_rst & !rstp){
   rstp = 1;
   _posfrac = 0;
   _pos24ppq = 0;
} else if (!inlet_rst){
   rstp = 0;
}
if (inlet_run && !_active) {
  _active = 1;
  if (_pos24ppq) {
    PatchMidiInHandler(MIDI_DEVICE_INTERNAL, 0,MIDI_CONTINUE,0,0);
  } else {
    PatchMidiInHandler(MIDI_DEVICE_INTERNAL, 0,MIDI_START,0,0);
    PatchMidiInHandler(MIDI_DEVICE_INTERNAL, 0,MIDI_TIMING_CLOCK,0,0);
  }
} else if (!inlet_run && _active){
  _active = 0;
  PatchMidiInHandler(MIDI_DEVICE_INTERNAL, 0,MIDI_STOP,0,0);
}if (_active) {
  _posfrac += inlet_speed;
  if (_posfrac & 1<<31) {
    _posfrac &= (1<<31)-1;
    _pos24ppq++;
    PatchMidiInHandler(MIDI_DEVICE_INTERNAL, 0,MIDI_TIMING_CLOCK,0,0);
  }
}
outlet_pos4ppq = _pos24ppq/6;
outlet_pos24ppq = _pos24ppq;]]></code.krate>
      </object>
   </patchobj>
   <comment type="patch/comment" x="168" y="294" text="delayed bang"/>
   <comment type="patch/comment" x="252" y="294" text="top button input + lights "/>
   <patchobj type="patch/object" uuid="2f9bba32-d740-4003-ad25-e348072ce954" name="loadbang_1" x="182" y="308">
      <params/>
      <attribs/>
      <object id="patch/object" uuid="2f9bba32-d740-4003-ad25-e348072ce954">
         <sDescription>Generates a single pulse when a patcher is loaded.
similar to PD / Max/Msp &apos;loadbang&apos;</sDescription>
         <author>robert schirmer</author>
         <license>BSD</license>
         <helpPatch>patching.axh</helpPatch>
         <inlets/>
         <outlets>
            <bool32.pulse name="trig"/>
         </outlets>
         <displays/>
         <params/>
         <attribs/>
         <includes/>
         <code.declaration><![CDATA[int ntrig;
int init;]]></code.declaration>
         <code.init><![CDATA[init=0;]]></code.init>
         <code.krate><![CDATA[if (init<1500){
init+=1;
if (init==1500){
	init=2000;
	ntrig=1;
}
}
outlet_trig=ntrig;
ntrig=0;]]></code.krate>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="76eda282-ad11-4c3b-b68d-ec828bc7ee4a" name="mlpad_1" x="252" y="308">
      <params/>
      <attribs>
         <combo attributeName="lightout" selection="usb host port 1"/>
         <combo attributeName="input" selection="usb host port 1"/>
      </attribs>
      <object id="patch/object" uuid="76eda282-ad11-4c3b-b68d-ec828bc7ee4a">
         <sDescription>outputs the state of the top-row buttons of a &apos;novation launchpad&apos;.
DOES NOT work with the &apos;LP mark 1&apos;.</sDescription>
         <author>Robert Schirmer</author>
         <license>BSD</license>
         <helpPatch>launchpad.axh</helpPatch>
         <inlets>
            <bool32 name="refresh"/>
         </inlets>
         <outlets>
            <bool32 name="clearshift"/>
            <bool32 name="overdub"/>
            <bool32 name="quantize"/>
            <bool32 name="save"/>
            <bool32 name="init"/>
            <bool32 name="refreshtrig"/>
         </outlets>
         <displays/>
         <params/>
         <attribs>
            <combo name="lightout">
               <MenuEntries>
                  <string>din</string>
                  <string>usb host port 1</string>
                  <string>usb host port 2</string>
                  <string>usb host port 3</string>
                  <string>usb host port 4</string>
                  <string>internal port 1</string>
                  <string>internal port 2</string>
                  <string>usb device port 1</string>
               </MenuEntries>
               <CEntries>
                  <string>MIDI_DEVICE_DIN, 1</string>
                  <string>MIDI_DEVICE_USB_HOST, 1</string>
                  <string>MIDI_DEVICE_USB_HOST, 2</string>
                  <string>MIDI_DEVICE_USB_HOST, 3</string>
                  <string>MIDI_DEVICE_USB_HOST, 4</string>
                  <string>MIDI_DEVICE_INTERNAL, 1</string>
                  <string>MIDI_DEVICE_INTERNAL, 2</string>
                  <string>MIDI_DEVICE_USB_DEVICE, 1</string>
               </CEntries>
            </combo>
            <combo name="input">
               <MenuEntries>
                  <string>omni</string>
                  <string>din</string>
                  <string>usb host port 1</string>
                  <string>usb host port 2</string>
                  <string>usb host port 3</string>
                  <string>usb host port 4</string>
                  <string>internal port 1</string>
                  <string>internal port 2</string>
                  <string>usb device port 1</string>
               </MenuEntries>
               <CEntries>
                  <string>true</string>
                  <string>dev == MIDI_DEVICE_DIN &amp;&amp; port == 1</string>
                  <string>dev == MIDI_DEVICE_USB_HOST &amp;&amp; port == 1</string>
                  <string>dev == MIDI_DEVICE_USB_HOST &amp;&amp; port == 2</string>
                  <string>dev == MIDI_DEVICE_USB_HOST &amp;&amp; port == 3</string>
                  <string>dev == MIDI_DEVICE_USB_HOST &amp;&amp; port == 4</string>
                  <string>dev == MIDI_DEVICE_INTERNAL &amp;&amp; port == 1</string>
                  <string>dev == MIDI_DEVICE_INTERNAL &amp;&amp; port == 2</string>
                  <string>dev == MIDI_DEVICE_USB_DEVICE &amp;&amp; port == 1</string>
               </CEntries>
            </combo>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[int quantize;


int init;




int clearshift;
int colour;

int overdub;
int save;
int control[3];
int Pcontrol[3];
int colourON[3];
int colourOFF[3];
int button[3];
int i;
int rtrig;
int dubtrig;]]></code.declaration>
         <code.init><![CDATA[quantize=1;
overdub=0;
clearshift=0;

colourON[0]=3;
colourON[1]=3;
colourON[2]=51;

colourOFF[0]=1;
colourOFF[1]=16;
colourOFF[2]=17;

button[0]=111;
button[1]=110;
button[2]=109;

control[0]=clearshift;
control[1]=overdub;
control[2]=quantize;

Pcontrol[0]=clearshift;
Pcontrol[1]=overdub;
Pcontrol[2]=quantize;]]></code.init>
         <code.krate><![CDATA[control[0]=clearshift;
control[1]=overdub;
control[2]=quantize;


if (inlet_refresh&&!rtrig){
	rtrig=1;
}


for (i = 0;i<3;i++){
	//refresh
	if (rtrig){
		Pcontrol[i]=-1;
		}

	
	if (control[i]!=Pcontrol[i]){
		if (control[i]){
			colour=colourON[i];
		}
		else {
			colour=colourOFF[i];
		}
		MidiSend3((midi_device_t) attr_lightout, MIDI_CONTROL_CHANGE+0 ,button[i],colour);
		Pcontrol[i]=control[i];
	}
	
}
//send save/init message to other axos
if (clearshift&&save){
	MidiSend3((midi_device_t) MIDI_DEVICE_DIN, 1, MIDI_CONTROL_CHANGE+14 ,0,127);
	MidiSend3((midi_device_t) MIDI_DEVICE_USB_HOST, 1, MIDI_CONTROL_CHANGE+14 ,0,127);
}
if (init&&clearshift){
	MidiSend3((midi_device_t) MIDI_DEVICE_DIN, 1, MIDI_CONTROL_CHANGE+14 ,1,127);
	MidiSend3((midi_device_t) MIDI_DEVICE_USB_HOST, 1, MIDI_CONTROL_CHANGE+14 ,1,127);
}

outlet_clearshift=clearshift;
outlet_quantize=quantize;
outlet_overdub=dubtrig;
outlet_save=save;
outlet_init=init;
outlet_refreshtrig=rtrig;

rtrig=0;
save=0;
init=0;
dubtrig=0;]]></code.krate>
         <code.midihandler><![CDATA[if (attr_input){
	if (status == 0 + MIDI_CONTROL_CHANGE){
		//shift button
		if (data1==111){
			clearshift=data2;
			}
			
		//overdub/save
		if ((data1==110)&&data2){
			
			if (!clearshift){
				dubtrig=1;
				if (!overdub){
					overdub=1;
				}
				else {
					overdub=0;
				}
			}
			else if (clearshift){
				save=1;
			}
		}
		//quantize
		if ((data1==109)&&data2){
			if (!quantize){
				quantize=1;
			}
			else {
				quantize=0;
			}
		}
	}
	//load init patch
	if ((status == MIDI_NOTE_ON+0) && (data1==8)) {
		if (clearshift){
			init=1;
		}
	
	}
	

	if ((status == 5 + MIDI_CONTROL_CHANGE)&&(data1==0)){
		rtrig=1;
	}



}]]></code.midihandler>
      </object>
   </patchobj>
   <comment type="patch/comment" x="952" y="308" text="*****column 2***************************************"/>
   <comment type="patch/comment" x="924" y="322" text="column input for barlength"/>
   <comment type="patch/comment" x="1078" y="322" text="column lights for barlength"/>
   <patchobj type="patch/object" uuid="90929d94-c60c-4c41-8cc0-3216bf6fc6d6" name="1_5" x="952" y="336">
      <params/>
      <attribs>
         <spinner attributeName="column" value="2"/>
         <combo attributeName="input" selection="usb host port 1"/>
      </attribs>
      <object id="patch/object" uuid="90929d94-c60c-4c41-8cc0-3216bf6fc6d6">
         <sDescription>outputs the state of the top-row buttons of a &apos;novation launchpad&apos;.
DOES NOT work with the &apos;LP mark 1&apos;.</sDescription>
         <author>Robert Schirmer</author>
         <license>BSD</license>
         <helpPatch>launchpad.axh</helpPatch>
         <inlets>
            <bool32 name="clearshift"/>
         </inlets>
         <outlets>
            <int32 name="pad"/>
            <int32 name="barlength"/>
         </outlets>
         <displays/>
         <params/>
         <attribs>
            <spinner name="column" MinValue="1" MaxValue="8" DefaultValue="1"/>
            <combo name="input">
               <MenuEntries>
                  <string>omni</string>
                  <string>din</string>
                  <string>usb host port 1</string>
                  <string>usb host port 2</string>
                  <string>usb host port 3</string>
                  <string>usb host port 4</string>
                  <string>internal port 1</string>
                  <string>internal port 2</string>
                  <string>usb device port 1</string>
               </MenuEntries>
               <CEntries>
                  <string>true</string>
                  <string>dev == MIDI_DEVICE_DIN &amp;&amp; port == 1</string>
                  <string>dev == MIDI_DEVICE_USB_HOST &amp;&amp; port == 1</string>
                  <string>dev == MIDI_DEVICE_USB_HOST &amp;&amp; port == 2</string>
                  <string>dev == MIDI_DEVICE_USB_HOST &amp;&amp; port == 3</string>
                  <string>dev == MIDI_DEVICE_USB_HOST &amp;&amp; port == 4</string>
                  <string>dev == MIDI_DEVICE_INTERNAL &amp;&amp; port == 1</string>
                  <string>dev == MIDI_DEVICE_INTERNAL &amp;&amp; port == 2</string>
                  <string>dev == MIDI_DEVICE_USB_DEVICE &amp;&amp; port == 1</string>
               </CEntries>
            </combo>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[int note;
int clipslot;
int trigger;
int stop;
int ccdub;
int shift;
int outbar;
int barlength[4];
bool chold;
bool ccb;]]></code.declaration>
         <code.init><![CDATA[ccb=0;
barlength[0]=1;
barlength[1]=2;
barlength[2]=4;
barlength[3]=8;
clipslot=3;]]></code.init>
         <code.krate><![CDATA[outlet_pad = clipslot;


if (clipslot<4){
	outbar=barlength[clipslot];
}
outlet_barlength=outbar;]]></code.krate>
         <code.midihandler><![CDATA[if (attr_input){
if ((status == MIDI_NOTE_ON + 0) && (data2)) {
		if ((data1==(0+(attr_column-1))) )   {
			note=data1;
			clipslot=0;	
			trigger=1;
		}
		if (data1==(16+(attr_column-1))){
			note=data1;
			clipslot=1;	
			trigger=1;
		}
		if (data1==(32+(attr_column-1))){
			note=data1;
			clipslot=2;	
			trigger=1;
		}
		if (data1==(48+(attr_column-1))){
			note=data1;
			clipslot=3;	
			trigger=1;
		}
		
		
	}






}]]></code.midihandler>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="b120a19c-ada4-4a82-924d-f2d98b78daa3" name="step_1" x="1078" y="336">
      <params/>
      <attribs>
         <combo attributeName="device" selection="usb host port / LP"/>
         <combo attributeName="color" selection="orange W"/>
         <spinner attributeName="column" value="2"/>
      </attribs>
      <object id="patch/object" uuid="b120a19c-ada4-4a82-924d-f2d98b78daa3">
         <sDescription>display a step counter on a novation launchpad</sDescription>
         <author>Robert Schirmer</author>
         <license>BSD</license>
         <helpPatch>launchpad.axh</helpPatch>
         <rotatedParams>true</rotatedParams>
         <inlets>
            <int32 name="pad" description="current step"/>
            <bool32.rising name="redraw"/>
         </inlets>
         <outlets/>
         <displays/>
         <params/>
         <attribs>
            <combo name="device">
               <MenuEntries>
                  <string>usb host port / LP</string>
               </MenuEntries>
               <CEntries>
                  <string>MIDI_DEVICE_USB_HOST, 1</string>
               </CEntries>
            </combo>
            <combo name="color">
               <MenuEntries>
                  <string>off</string>
                  <string>red W</string>
                  <string>red M</string>
                  <string>red S</string>
                  <string>orange W</string>
                  <string>orange S</string>
                  <string>green W</string>
                  <string>green M</string>
                  <string>green S</string>
                  <string>lime 1 W</string>
                  <string>lime 1 S</string>
                  <string>lime 2</string>
                  <string>yellow W</string>
                  <string>yellow M</string>
                  <string>yellow S</string>
               </MenuEntries>
               <CEntries>
                  <string>0</string>
                  <string>1</string>
                  <string>2</string>
                  <string>3</string>
                  <string>18</string>
                  <string>35</string>
                  <string>16</string>
                  <string>32</string>
                  <string>48</string>
                  <string>33</string>
                  <string>50</string>
                  <string>49</string>
                  <string>17</string>
                  <string>34</string>
                  <string>51</string>
               </CEntries>
            </combo>
            <spinner name="column" MinValue="1" MaxValue="8" DefaultValue="1"/>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[int ntrig;

int prev;
int init;
int32_t map[64];
int32_t v;]]></code.declaration>
         <code.init><![CDATA[map[0] = 0+(attr_column-1);
map[1] = 16+(attr_column-1);
map[2] = 32+(attr_column-1);
map[3] = 48+(attr_column-1);
map[4] = 64+(attr_column-1);
map[5] = 80+(attr_column-1);
map[6] = 96+(attr_column-1);
map[7] = 112+(attr_column-1);
map[8] = 104+(attr_column-1);
init=1;]]></code.init>
         <code.krate><![CDATA[if ((inlet_redraw > 0) && !ntrig){
	init=0;
	MidiSend3((midi_device_t) attr_device, MIDI_NOTE_ON ,map[inlet_pad],(attr_color));
	ntrig = 1;
}
	
if (!(inlet_redraw > 0 )) ntrig = 0;

if ((inlet_pad  != prev)&&(inlet_pad<4)&& !init) {
  MidiSend3((midi_device_t) attr_device, MIDI_NOTE_ON ,map[(inlet_pad)],(attr_color));
  
 
     	MidiSend3((midi_device_t) attr_device, MIDI_NOTE_ON ,map[(prev)],0);
prev = inlet_pad;
}]]></code.krate>
      </object>
   </patchobj>
   <obj type="string/c" uuid="4aa90a90c435a742ddfa152d232883fc5b2f1b3" name="c_1" x="420" y="392">
      <params/>
      <attribs>
         <table attributeName="str" table="/JOANx"/>
      </attribs>
   </obj>
   <obj type="table/save" uuid="3e4108b607d56d9e1cd10abb898b58eea11e53b2" name="save_1" x="574" y="392">
      <params/>
      <attribs>
         <objref attributeName="table" obj="midiloopA"/>
      </attribs>
   </obj>
   <obj type="patch/load" uuid="634bf1f8c313920d7f19fc402ba937fd1ee27802" name="load_3" x="714" y="392">
      <params/>
      <attribs>
         <table attributeName="filename" table="/init joan upload/patch.bin"/>
      </attribs>
   </obj>
   <comment type="patch/comment" x="392" y="490" text="*****column 1*******************************************************************************************************************************************"/>
   <comment type="patch/comment" x="392" y="504" text="cilpslot column input"/>
   <comment type="patch/comment" x="518" y="504" text="note recorder"/>
   <comment type="patch/comment" x="714" y="504" text="clipslot column lights"/>
   <patchobj type="patch/object" uuid="6411fc27-1e72-4aba-8d01-c4fcbac8320a" name="mlpad_2" x="392" y="518">
      <params/>
      <attribs>
         <spinner attributeName="column" value="1"/>
         <combo attributeName="input" selection="usb host port 1"/>
      </attribs>
      <object id="patch/object" uuid="6411fc27-1e72-4aba-8d01-c4fcbac8320a">
         <sDescription>outputs the state of the top-row buttons of a &apos;novation launchpad&apos;.
DOES NOT work with the &apos;LP mark 1&apos;.</sDescription>
         <author>Robert Schirmer</author>
         <license>BSD</license>
         <helpPatch>launchpad.axh</helpPatch>
         <inlets>
            <bool32 name="clearshift"/>
         </inlets>
         <outlets>
            <int32 name="clipslot"/>
            <bool32 name="trigger"/>
            <bool32 name="stop"/>
            <bool32 name="cleartrigger"/>
            <bool32 name="ccdub"/>
            <bool32 name="chold"/>
         </outlets>
         <displays/>
         <params/>
         <attribs>
            <spinner name="column" MinValue="1" MaxValue="8" DefaultValue="1"/>
            <combo name="input">
               <MenuEntries>
                  <string>omni</string>
                  <string>din</string>
                  <string>usb host port 1</string>
                  <string>usb host port 2</string>
                  <string>usb host port 3</string>
                  <string>usb host port 4</string>
                  <string>internal port 1</string>
                  <string>internal port 2</string>
                  <string>usb device port 1</string>
               </MenuEntries>
               <CEntries>
                  <string>true</string>
                  <string>dev == MIDI_DEVICE_DIN &amp;&amp; port == 1</string>
                  <string>dev == MIDI_DEVICE_USB_HOST &amp;&amp; port == 1</string>
                  <string>dev == MIDI_DEVICE_USB_HOST &amp;&amp; port == 2</string>
                  <string>dev == MIDI_DEVICE_USB_HOST &amp;&amp; port == 3</string>
                  <string>dev == MIDI_DEVICE_USB_HOST &amp;&amp; port == 4</string>
                  <string>dev == MIDI_DEVICE_INTERNAL &amp;&amp; port == 1</string>
                  <string>dev == MIDI_DEVICE_INTERNAL &amp;&amp; port == 2</string>
                  <string>dev == MIDI_DEVICE_USB_DEVICE &amp;&amp; port == 1</string>
               </CEntries>
            </combo>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[int note;
int clipslot;
int trigger;
int stop;
int ccdub;
int shift;
bool chold;
bool ccb;]]></code.declaration>
         <code.init><![CDATA[ccb=0;]]></code.init>
         <code.krate><![CDATA[outlet_clipslot = clipslot;
if (inlet_clearshift){
	shift=1;
}
if (!inlet_clearshift&&!trigger&&!chold){
	shift=0;
}
if (!shift){
	outlet_trigger = trigger;
	outlet_cleartrigger=0;

	}
else if (shift){
	outlet_trigger = 0;

	outlet_cleartrigger=trigger;
	}
if (shift&&chold){
	outlet_chold=chold;
	ccb=0;
}
else {outlet_chold=0;}
outlet_stop=stop;

outlet_ccdub=ccb;]]></code.krate>
         <code.midihandler><![CDATA[if (attr_input){
if ((status == MIDI_NOTE_ON + 0) && (data2)) {
		if ((data1==(0+(attr_column-1))) || (data1==8))   {
			note=data1;
			clipslot=0;	
			trigger=1;
		}
		if ((data1==(16+(attr_column-1))) || (data1==24)){
			note=data1;
			clipslot=1;	
			trigger=1;
		}
		if ((data1==(32+(attr_column-1))) || (data1==40)){
			note=data1;
			clipslot=2;	
			trigger=1;
		}
		if ((data1==(48+(attr_column-1))) || (data1==56)){
			note=data1;
			clipslot=3;	
			trigger=1;
		}
		if ((data1==(64+(attr_column-1))) || (data1==72)){
			note=data1;
			clipslot=4;	
			trigger=1;
		}
		if ((data1==(80+(attr_column-1))) || (data1==88)){
			note=data1;
			clipslot=5;	
			trigger=1;
		}
		if ((data1==(96+(attr_column-1))) || (data1==104)){
			note=data1;
			clipslot=6;	
			trigger=1;
		}
		if ((data1==(112+(attr_column-1))) || (data1==120)){
			note=data1;
			//clipslot=7;
			trigger=0;	
			stop=1;
		}
		
	}

else if ((status == MIDI_NOTE_ON + 0) && (!data2)) {
	if (note==data1){
		trigger=0;
		stop=0;
	}
	}
		
if ((status == MIDI_CONTROL_CHANGE + 0)&&(data1==104+attr_column-1)   ){
	if (data2){
	ccb=!ccb;
	}
	chold=data2;
}




}]]></code.midihandler>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="03301436-b416-4e11-8fda-1e91f59581ac" name="mnote_1" x="518" y="518">
      <params>
         <bool32.tgl name="quantize" value="0"/>
         <int32.hradio name="quantization" value="4"/>
         <bool32.tgl name="triplets" value="0"/>
      </params>
      <attribs>
         <combo attributeName="input" selection="din"/>
         <combo attributeName="output" selection="din"/>
         <spinner attributeName="channel" value="2"/>
         <objref attributeName="table" obj="midiloopA"/>
         <combo attributeName="size" selection="32768"/>
         <spinner attributeName="maxbar" value="8"/>
         <spinner attributeName="maxslots" value="7"/>
         <spinner attributeName="startnote" value="0"/>
         <spinner attributeName="endnote" value="127"/>
         <combo attributeName="resolution" selection="96ppq"/>
      </attribs>
      <object id="patch/object" uuid="03301436-b416-4e11-8fda-1e91f59581ac">
         <sDescription>writes and outputs 4 values to a table.</sDescription>
         <author>robert schirmer</author>
         <license>who cares</license>
         <inlets>
            <int32 name="offset" description="sets an offset for writing to the table"/>
            <int32 name="192ppq"/>
            <bool32 name="quantize" description="turn on quantize (turn off parameter if using inlet)"/>
            <int32 name="quantization"/>
            <bool32.risingfalling name="triplets" description="quantize in triplets (quantize needs to be turned on also"/>
            <int32 name="slot" description="select slot"/>
            <bool32.rising name="trigger" description="trigger slot. if empty, slot starts recording at beginning of next bar. if slot is full, slot starts playing at next bar. if already playing, it will restart."/>
            <bool32.rising name="stop" description="stops at next bar"/>
            <bool32.rising name="overdub" description="trigger to toggle overdub on/off"/>
            <bool32.rising name="record" description="forces record at next bar, even if slot is full"/>
            <bool32.rising name="clearslot" description="clear selected slot"/>
            <bool32.risingfalling name="erase" description="erase shift - if this input is high and you hold a note, any instances of that note that play will be deleted"/>
            <bool32.rising name="undo" description="undo (delete) last note recorded"/>
            <int32 name="maxbar"/>
         </inlets>
         <outlets>
            <int32 name="offset" description="size on table+ offset inlet"/>
            <int32 name="currentslot" description="slot that is currently playing"/>
            <bool32 name="record" description="feedback output for record"/>
            <bool32 name="play" description="feedback output for play"/>
            <bool32 name="overdub" description="feedback output for overdub"/>
            <int32 name="maxnotes" description="maximum amount of notes for each slot - depends on &quot;size&quot; and &quot;maxslots&quot; attributes"/>
            <int32 name="slotnotes" description="amount of notes recorded in current slot"/>
            <bool32 name="full" description="feedback outlet - high if clip already present"/>
            <bool32 name="wait" description="feedback outlet - high if waiting to play/stop/record"/>
            <int32 name="playstate" description="playstate - 0=stopped, 1=play, 2=record, 3=waiting"/>
            <int32 name="synclock" description="sequencer clock running at 192ppq, following the loop"/>
         </outlets>
         <displays/>
         <params>
            <bool32.tgl name="quantize"/>
            <int32.hradio name="quantization" description="if not triplets: 1bar, 1/2bar, 1/4, 1/8th, 1/16th, 1/32nd. if triplets: 1bar, 1/3,1/6th, etc">
               <MaxValue i="6"/>
            </int32.hradio>
            <bool32.tgl name="triplets"/>
         </params>
         <attribs>
            <combo name="input">
               <MenuEntries>
                  <string>omni</string>
                  <string>din</string>
                  <string>usb host port 1</string>
                  <string>usb host port 2</string>
                  <string>usb host port 3</string>
                  <string>usb host port 4</string>
                  <string>internal port 1</string>
                  <string>internal port 2</string>
                  <string>usb device port 1</string>
               </MenuEntries>
               <CEntries>
                  <string>true</string>
                  <string>dev == MIDI_DEVICE_DIN &amp;&amp; port == 1</string>
                  <string>dev == MIDI_DEVICE_USB_HOST &amp;&amp; port == 1</string>
                  <string>dev == MIDI_DEVICE_USB_HOST &amp;&amp; port == 2</string>
                  <string>dev == MIDI_DEVICE_USB_HOST &amp;&amp; port == 3</string>
                  <string>dev == MIDI_DEVICE_USB_HOST &amp;&amp; port == 4</string>
                  <string>dev == MIDI_DEVICE_INTERNAL &amp;&amp; port == 1</string>
                  <string>dev == MIDI_DEVICE_INTERNAL &amp;&amp; port == 2</string>
                  <string>dev == MIDI_DEVICE_USB_DEVICE &amp;&amp; port == 1</string>
               </CEntries>
            </combo>
            <combo name="output">
               <MenuEntries>
                  <string>din</string>
                  <string>usb host port 1</string>
                  <string>usb host port 2</string>
                  <string>usb host port 3</string>
                  <string>usb host port 4</string>
                  <string>internal port 1</string>
                  <string>internal port 2</string>
                  <string>usb device port 1</string>
               </MenuEntries>
               <CEntries>
                  <string>MIDI_DEVICE_DIN, 1</string>
                  <string>MIDI_DEVICE_USB_HOST, 1</string>
                  <string>MIDI_DEVICE_USB_HOST, 2</string>
                  <string>MIDI_DEVICE_USB_HOST, 3</string>
                  <string>MIDI_DEVICE_USB_HOST, 4</string>
                  <string>MIDI_DEVICE_INTERNAL, 1</string>
                  <string>MIDI_DEVICE_INTERNAL, 2</string>
                  <string>MIDI_DEVICE_USB_DEVICE, 1</string>
               </CEntries>
            </combo>
            <spinner name="channel" description="midi channel" MinValue="1" MaxValue="16" DefaultValue="1"/>
            <objref name="table" description="table must be same size or greater than attribute size"/>
            <combo name="size" description="total size on table">
               <MenuEntries>
                  <string>2</string>
                  <string>4</string>
                  <string>8</string>
                  <string>16</string>
                  <string>32</string>
                  <string>64</string>
                  <string>128</string>
                  <string>256</string>
                  <string>512</string>
                  <string>1024</string>
                  <string>2048</string>
                  <string>4096</string>
                  <string>8192</string>
                  <string>16384</string>
                  <string>32768</string>
                  <string>65536</string>
                  <string>131072</string>
                  <string>262144</string>
                  <string>524288</string>
                  <string>1048576</string>
                  <string>2097152</string>
                  <string>4194304</string>
               </MenuEntries>
               <CEntries>
                  <string>1</string>
                  <string>2</string>
                  <string>3</string>
                  <string>4</string>
                  <string>5</string>
                  <string>6</string>
                  <string>7</string>
                  <string>8</string>
                  <string>9</string>
                  <string>10</string>
                  <string>11</string>
                  <string>12</string>
                  <string>13</string>
                  <string>14</string>
                  <string>15</string>
                  <string>16</string>
                  <string>17</string>
                  <string>18</string>
                  <string>19</string>
                  <string>20</string>
                  <string>21</string>
                  <string>22</string>
               </CEntries>
            </combo>
            <spinner name="maxbar" description="maximum amount of bars per slot" MinValue="1" MaxValue="30000" DefaultValue="1"/>
            <spinner name="maxslots" description="maximum amount of slots" MinValue="1" MaxValue="32" DefaultValue="1"/>
            <spinner name="startnote" MinValue="0" MaxValue="127" DefaultValue="0"/>
            <spinner name="endnote" MinValue="0" MaxValue="127" DefaultValue="127"/>
            <combo name="resolution">
               <MenuEntries>
                  <string>192ppq</string>
                  <string>96ppq</string>
                  <string>48ppq</string>
                  <string>24ppq</string>
               </MenuEntries>
               <CEntries>
                  <string>0</string>
                  <string>1</string>
                  <string>2</string>
                  <string>3</string>
               </CEntries>
            </combo>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[int voices=attr_endnote-attr_startnote+1;
int noteon[127];
int gate[127];
int vel[127];
int outgateB[127];
int gtrig[127];
int goffset[127];
int gvel[127];
int gnote[127];
int gstart[127];
int gend[127];
int gon[127];
int Pmax[127];
int Plength[127];
int Pstart[127];
int Pend[127];
int Pnote[127];
int Pvel[127];
int outnote[127];
int outvel[127];
int outgate[127];
int offnote[127];
int prevoutgate[127];
int mute[127];
int Page[127];
int Oage[127];
int Quant[14];
int temp[6];
int px;

int closegates;
int PSC;
int p;
int countoffset;
int age;
int prevage;
int Cage;
int controloffset;
int size;
int synclocko;
int cltrig;
int init;
int prevslot;
int offsethold;
int Cvel;
int Cnote;
int Cstart;
int Cend;
int offset;
int restart;
int recstart;
int clear;
int barhold;
int prevmaxbar;
int play;
int synclock;
int prevsynclock;
int kquantclock;
int quantclock;
int quantize;
int quantizeon;
int recording;
int stophold;
int playhold;
int rechold;
int barrecord;
int Rnotecount;
int rec;
int halfsync;
int Pindex;
int assigned;
int early;
int trigr;
int prevPindex;
int tempR;
int tempO;
int etrig;
int erase;
int paused;
int holdscan;
int startclear;
int currentslot;
int wait;
int dialclock;
int ppq;
int cptrig;
int trigtrig;
int full;
int clearoffset;
int currentbar;
int maxbar;
int maxppq;
int untrig;
int lastnote;
int quantization;
int undo;
int loopend;
int listshift;
int Pshift;
int generation;
int pgen;
int tempG;
int Cgen;
int lastgen;
int ultrig;
int unloop;
int lock;
int maximum;
int wlight;
int scan;
int scanmax;
int prevscan;
int prevppq1;
int bar192;
int pretrig;
int ltrig;
int overdub;
int maxnotes;
int prevRnote;
int dubtrig;
int clearmax;
int playreset;
int reclight;
int recend;
int slotsize;
int ppq1;
int playstate;

bool strig;
bool sttrig;
bool ctrig;]]></code.declaration>
         <code.init><![CDATA[//barcount=-1;
Plength[1]=-1;
clear=-1;
//prevPcount=-1;


assigned=1;
Quant[0]=1;
Quant[1]=2;
Quant[2]=4;
Quant[3]=8;
Quant[4]=16;
Quant[5]=32;
Quant[6]=1;
Quant[7]=3;
Quant[8]=6;
Quant[9]=12;
Quant[10]=24;
Quant[11]=48;


init=1;]]></code.init>
         <code.krate><![CDATA[//space for 8 globals per slot - 3 used (note count, bar length and note age)
controloffset=8;
size=(1<<attr_size);
slotsize= (((1<<attr_size)-32)/attr_maxslots);
outlet_offset=size+inlet_offset;

//per slot
maxnotes=((slotsize-8)>>3)-2;
if ((inlet_maxbar<=attr_maxbar)&&(inlet_maxbar>0)){
maximum=inlet_maxbar;
}
else {maximum=attr_maxbar;}
Rnotecount=attr_table.array[countoffset];
maxbar=attr_table.array[countoffset +1];
age=attr_table.array[countoffset +2];
generation=attr_table.array[countoffset +3];
if (inlet_undo&&!untrig){
	
	if (age>1){
	lastnote=age;
	undo=1;
	untrig=1;
	}
	if (age==1){
	startclear=1;
	}
	
}
if (!inlet_undo&&!undo){
	untrig=0;
}

 
if (init){
		currentslot=inlet_slot;
		offset=inlet_offset+32+((controloffset+slotsize)*inlet_slot) +controloffset;
		countoffset=inlet_offset+32+((controloffset+slotsize)*inlet_slot);
		init=0;
		}

erase=inlet_erase;
if (inlet_erase&&!etrig){
	etrig=1;
	tempR=recording;
	tempO=overdub;
	recording=0;
	overdub=0;
}
if (!inlet_erase&&etrig){
	etrig=0;
	recording=tempR;
	overdub=tempO;
}

if (inlet_overdub&&!dubtrig){
	dubtrig=1;
	
	if (overdub){
		overdub=0;
		recording=0;
	}
	else if (!overdub){
		overdub=1;
		recording=1;
	}
}
if (!inlet_overdub){
	dubtrig=0;
}

if (inlet_clearslot&&!cltrig){
	cltrig=1;
	startclear=1;  
	}

if (!inlet_clearslot){
	cltrig=0;
}


if (startclear){
	startclear=0;
	clearoffset=inlet_offset+32+((controloffset+slotsize)*inlet_slot);
  	clearmax=attr_table.array[clearoffset]+controloffset;
  	attr_table.array[clearoffset]=0;
  	attr_table.array[clearoffset + 1]=0;
  	attr_table.array[clearoffset + 2]=0;
	clear=0;
	if (inlet_slot==currentslot){
		play=0;
		recording=0;
		playreset=1;
		reclight=0;
	}
}


quantizeon=param_quantize+inlet_quantize;
maxppq=maxbar*(768>>attr_resolution);

if ((param_quantization+inlet_quantization)<=5){
quantization=param_quantization+inlet_quantization;
}
else {quantization=5;} 

if ((!param_triplets)&&(!inlet_triplets)){
	quantize=Quant[quantization];
	}
else if (param_triplets || inlet_triplets){
	quantize=Quant[quantization+6];
}


if (inlet_slot!=prevslot){
	prevslot=inlet_slot;
	offsethold=1;
	if (reclight){
		attr_table.array[countoffset+1]=currentbar+1;
	}
	if (inlet_192ppq<0){
		offsethold=0;
	offset=inlet_offset+32+((controloffset+slotsize)*inlet_slot) +controloffset;
		countoffset=inlet_offset+32+((controloffset+slotsize)*inlet_slot);
		 Rnotecount=attr_table.array[countoffset];
		 maxbar=attr_table.array[countoffset +1];
		age=attr_table.array[countoffset +2];
		generation=attr_table.array[countoffset +3];
		 currentslot=inlet_slot;
		 prevRnote=Rnotecount;
		prevmaxbar=maxbar;
		prevage=age;
		pgen=generation;
		
	full=attr_table.array[inlet_offset+inlet_slot];
	if (full){
		play=1;
		strig=1;
		ltrig=0;
		Pshift=-2;
	}
	}
}
// create 1ppq 0-3 beat counter and a 192ppq bar loop from 192ppq counter
if (inlet_192ppq>=0){
	bar192=inlet_192ppq-((inlet_192ppq/768)*768);
	ppq1=bar192/192;
	}

else {
	bar192=-1;
	ppq1=0;	
	prevppq1=0;
	}

if ((ppq1!=prevppq1)&&(ppq1>=0)){
	prevppq1=ppq1;
	loopend=0;
	
	if ((ppq1==2)){
		
		if ((currentbar==(maximum-1)) && (barrecord)){
			wlight=1;
		}
	}
	//bartrigger
	if (ppq1==0){
		wlight=0;
		if (stophold){
			play=0;
			playreset=1;
			recording=0;
			stophold=0;
		}
		if (playhold){
			restart=1;
			play=1;
			playhold=0;
			if (overdub){
				recording=1;
				}
			}
		if (rechold){
			rec=1;
			reclight=1;
			if (!play){
				play=1;
				}
			restart=1;
			rechold=0;
			}
		if (barhold){
			reclight=0;
			barhold=0;
			barrecord=0;
			maxbar=currentbar+1;
			restart=1;
			if (!overdub){
				recording=0;currentbar=0;
				}
			}
		
		currentbar+=1;
		if (currentbar>=maxbar){
			if (barrecord&&(maxbar==maximum)){
				barhold=0;
				reclight=0;
				barrecord=0;
				maxbar=currentbar;
				restart=1;
				if (!overdub){
					recording=0;currentbar=0;
				}
			}
			currentbar=0;
			restart=1;
			}
		}
	
	
	}



//pre bar trigger (1/32nd before next bar)
if ((bar192>=744) &&!pretrig){
	pretrig=1;
	if ((offsethold) &&(rechold || playhold || barhold))
		{	//set offset when different clip triggered
		offsethold=0;
		offset=inlet_offset+32+((controloffset+slotsize)*inlet_slot) +controloffset;
		countoffset=inlet_offset+32+((controloffset+slotsize)*inlet_slot);
		 Rnotecount=attr_table.array[countoffset];
		 maxbar=attr_table.array[countoffset +1];
		age=attr_table.array[countoffset +2];
		generation=attr_table.array[countoffset +3];
		 currentslot=inlet_slot;
		 prevRnote=Rnotecount;
		prevmaxbar=maxbar;
		prevage=age;
		pgen=generation;
		}
	if (((currentbar+1)>=maxbar) || playhold || rechold || barhold || offsethold){	
			playreset=1;
			loopend=1;
			generation+=1;
	
		if ((barhold) || (barrecord&&(maxbar==(maximum-1)))){
			playreset=1;
			recend=1;
			// need to close gates? revisit
			closegates=1;
			
		}
		if (rechold){
			//clear and start recording
			recstart=1;
			clearmax=Rnotecount+controloffset;
			clearoffset=offset-controloffset;
			clear=0;
			Rnotecount=0;
			recording=1;
			}
	}

}
if (bar192==0){
	pretrig=0;
}




//clock started
if ((inlet_192ppq>=0)&&!strig){
	
	strig=1;
	if (playhold){
			restart=1;
			play=1;
			playhold=0;
			if (overdub){
				recording=1;
				}
			}
	loopend=0;
	}
//clock stopped
if ((inlet_192ppq<0)&&strig){
	strig=0;
	playreset=1;
	loopend=1;
	generation+=1;
	recording=0;
	if (play){
		playhold=1;
		play=0;
	}
} 



//clip present?
full=attr_table.array[inlet_offset+inlet_slot];

if (inlet_trigger&&!trigtrig){
	trigtrig=1;
	if (!full){
		rechold=1;
		}
	else if (full){
		if (barrecord){
			barhold=1;
			}
		if (!barrecord){
			playhold=1;
			}
		}
	}

	
if (!inlet_trigger){
	trigtrig=0;
}

if (inlet_stop&&!sttrig){
		stophold=1;
	if (playhold){
		playhold=0;
	}
	sttrig=1;
}
if (!inlet_stop){
	sttrig=0;
}

if (restart){
	restart=0;
	currentbar=0;
	}

	
if (inlet_192ppq>=0){
synclock=(bar192+(currentbar*768))>>attr_resolution;
synclocko=(bar192+(currentbar*768));
}
else {
	synclock=-1;
	synclocko=-1;
	prevsynclock=-1;
	
}

//clock info for quantize
quantclock=synclock/((768>>attr_resolution)/quantize);
halfsync=((768>>attr_resolution)/quantize)>>1;
kquantclock=quantclock*((768>>attr_resolution)/quantize);
// early or late?
if (synclock<(kquantclock+halfsync)){
	early=0;
}
if (synclock>=(kquantclock+halfsync)){
	early=1;
}

if (inlet_record&&!trigr){
	trigr=1;
	if (!barrecord){
		rechold=1;
	}
	else if (barrecord){
		barhold=1;
	}
	
}
if (!inlet_record){
	trigr=0;
}

if (rec){
	rec=0;
	currentbar=0;
	barrecord=1;
	maxbar=maximum;
	attr_table.array[currentslot+inlet_offset]=1;
	Rnotecount=0;
	recstart=0;
	}
	
//clear note data
if (clear>=0){
	if (clear<=clearmax){
		int tx;
		for (tx= 0;tx<6;tx++){	
			attr_table.array[clearoffset+(clear<<3) +tx]=0;
		}
		if (clearoffset==(offset-controloffset)){
			closegates=1;
		}
		
		
		clear+=1;
	
		if (clear>=clearmax){
			attr_table.array[inlet_slot+inlet_offset]=0;
			clear=-1;
			if (clearoffset==(offset-controloffset)){
				playreset=1;
				}
			}
		}
}



	//note assign  ===========================================================================	
if (loopend&&!ltrig){
	listshift=0;
	PSC=listshift;
	ltrig=1;
}
if (!loopend){
	ltrig=0;
}

if ((synclock==prevsynclock)&&!playreset){
	
	//assign notes from list - mute if notes clash with incoming note, delete if overdubbing
	for (Pindex = 0;Pindex<32;Pindex++){
		if ((Pindex+PSC)<maxnotes) {
				
			Cstart=attr_table.array[offset+((Pindex+PSC)<<3) +0];
			Cend=attr_table.array[offset+((Pindex+PSC)<<3) +1];
			Cnote=attr_table.array[offset+((Pindex+PSC)<<3) +2];
			Cvel=attr_table.array[offset+((Pindex+PSC)<<3) +3];
			Cage=attr_table.array[offset+((Pindex+PSC)<<3) +4];
			Cgen=attr_table.array[offset+((Pindex+PSC)<<3) +5];
			//clash?
				

			if (synclock!=Pshift){
				//ignore notes being moved by scanner
				if ((Pindex==0)&&(Cstart<(synclock+1)) && (Cstart>0) &&!loopend && (synclock>0)){
					lock+=1;
				}
						
					
				//if note start is reached	
				if   (( ( (((Cstart-1)==(synclock+1))&&!loopend) || ( ((Cstart-1)==0) && loopend))   && (Cstart>0) )  && (Cgen!=generation)){
					
						
					if (Cage>=Page[Cnote]){
						if (gate[Cnote]){
							mute[Cnote]=1;
							}
						listshift+=1;
						if (!mute[Cnote]){	
							
							Pstart[Cnote]=Cstart;
							Pend[Cnote]=Cend;
							Pnote[Cnote]=Cnote;
							Pvel[Cnote]=Cvel;
							Page[Cnote]=Cage;
							}
						else if (mute[Cnote]){
							if (((overdub&&!reclight)||(erase))  &&  (attr_table.array[offset+((Pindex+PSC)<<3) +0]>0)){
								int tx;
								for (tx= 0;tx<6;tx++){	
									attr_table.array[offset+((Pindex+PSC)<<3) +tx]=0;
									}
								Rnotecount-=1;
								}
							}
						}
					}		
				}
			}
		}
if (lock==0){
Pshift=synclock;
}
if (lock>0){
	lock=0;
}
PSC=listshift;

}
if (playreset){
	lock=0;
}


for (px = 0;px<voices;px++){
	p=px+attr_startnote;
	
	
	if (!gate[p]) {
			mute[p]=0;
			}
	
	//reset players && midi output
	if (playreset){
		Pstart[p]=0;
		Plength[p]=-1;
		outgate[p]=0;
		Page[p]=0;
		}
	//reset midi input
	if (closegates){
			gate[p]=0;
			}
	
	//  recording  **************************************************************
	//set quantize at note on
	if (gate[p]&&!gtrig[p]){
	
		gtrig[p]=1;
		if (quantizeon){
			if (early){
				goffset[p]= ( halfsync - (synclock-(kquantclock+halfsync)));
			}
			if (!early){
				goffset[p]=-(synclock-kquantclock);
			}
		}
		else if (!quantizeon){
			goffset[p]=0;
		}
		if ((synclock+goffset[p])<maxppq){
			gstart[p]=synclock+goffset[p];
			}
		else if ((synclock+goffset[p])>=maxppq){
				gstart[p]=0;
			}
		if (recstart){
				gstart[p]=0;
		}
		gnote[p]=noteon[p];
		gvel[p]=vel[p];
		if (recording){
			gon[p]=1;
			attr_table.array[offset+(Rnotecount<<3) +5]=generation;
			
		}
		
		
	}
	//stamp note data at note off
	if (!gate[p]&&gtrig[p]){
		gtrig[p]=0;
		if (gon[p]){
			gon[p]=0;
			gend[p]=synclock+goffset[p];
			if (recstart){
				gend[p]=halfsync;
		}
			//stamp note
			if (Rnotecount<maxnotes){
				attr_table.array[offset+(Rnotecount<<3) +0]=gstart[p]+1;
				attr_table.array[offset+(Rnotecount<<3) +1]=gend[p]+1;
				attr_table.array[offset+(Rnotecount<<3) +2]=gnote[p];
				attr_table.array[offset+(Rnotecount<<3) +3]=gvel[p];
				age+=1;
				attr_table.array[offset+(Rnotecount<<3) +4]=age;
				Rnotecount+=1;
				}
			}
		}
		
		///////////////////////////////////play

	
	if (synclock!=prevsynclock){
		if (play){
			// play  **********************************************
			//length - note off at end
			if (Plength[p]>=0){
				Plength[p]+=1;
				if (Plength[p]>=Pmax[p]){
					Plength[p]=-1;
					outgate[p]=0;
					Oage[p]=0;
				}
			}
			//trigger note on
			if (((synclock)==(Pstart[p]-1))&&(Pstart[p]>0)){
					if (!mute[p]){
						Plength[p]=0;
						if (Pend[p]>Pstart[p]){
							Pmax[p]=Pend[p]-Pstart[p];
						}
						else if (Pend[p]<=Pstart[p]){
							Pmax[p]=(maxppq+Pend[p])-Pstart[p];
						}
						outnote[p]=Pnote[p];
						outvel[p]=Pvel[p];
						Oage[p]=Page[p];
						outgate[p]=1;
						outgateB[p]=0;
						Pstart[p]=0;
						Pend[p]=0;
						Page[p]=0;
						}
					}
			}
			}
	//triggermidi  ===========================================
	if (outgateB[p]!=prevoutgate[p]){
		if (outgateB[p]){
			MidiSend3((midi_device_t) attr_output, MIDI_NOTE_ON + (attr_channel-1),outnote[p],outvel[p]);
			offnote[p]=outnote[p];  
		}
		else if (!outgateB[p]){
			MidiSend3((midi_device_t) attr_output, MIDI_NOTE_OFF + (attr_channel-1),offnote[p],outvel[p]);
		}
		
		prevoutgate[p]=outgateB[p];
	}
	
	outgateB[p]=outgate[p];
//// end loop
}
/////////////////////////
//keep outside loop	
prevsynclock=synclock;
playreset=0;
closegates=0;


// reorder notes for overdubbing
if (scan!=prevscan){
	
	if (((scan!=(Rnotecount+2))&& (( synclock==prevsynclock) && (synclock==Pshift)))){
			//scan counting down from last note! 

		//undo
		if ((undo)&& (attr_table.array[offset+(scan<<3) +4]==lastnote)){
			
			int tx;
			for (tx= 0;tx<6;tx++){	
				attr_table.array[offset+(scan<<3) +tx]=0;
			}
			age-=1;
			Rnotecount-=1;
			undo=0;
		}

				//if two notes at same position and same note, delete old note
		if (((attr_table.array[offset+(scan<<3) +0])==(attr_table.array[offset+(prevscan<<3) +0]))
			&& ((attr_table.array[offset+(scan<<3) +2])==(attr_table.array[offset+(prevscan<<3) +2]))
			&&
			((attr_table.array[offset+(scan<<3) +0]) !=0 )
			&&
			((attr_table.array[offset+(prevscan<<3) +0]) !=0 ) )
			{
			int tx;
			for (tx= 0;tx<6;tx++){	
				attr_table.array[offset+(scan<<3) +tx]=0;
				}
			Rnotecount-=1;
			}
	
		//swap backwards, earlier earlier - notes in ascending order.
		
		if ( (  ((attr_table.array[offset+(scan<<3) +0])>(attr_table.array[offset+(prevscan<<3) +0]))
			|| ( ((attr_table.array[offset+(scan<<3) +0])==(attr_table.array[offset+(prevscan<<3) +0])) && ((attr_table.array[offset+(scan<<3) +2])<(attr_table.array[offset+(prevscan<<3) +2])) ) )
			&&
			((attr_table.array[offset+(scan<<3) +0]) !=0 )
			&&
			((attr_table.array[offset+(prevscan<<3) +0]) !=0 ) )
			{
			int tx;
			for (tx= 0;tx<6;tx++){	
				temp[tx]=attr_table.array[offset+(prevscan<<3) +tx];		
				attr_table.array[offset+(prevscan<<3) +tx] = attr_table.array[offset+(scan<<3) +tx];	
				attr_table.array[offset+(scan<<3) +tx]=temp[tx];	
				}	
			}
				//swap 0 values other way to move deleted notes out of list
		if ( ((attr_table.array[offset+(scan<<3) +0]) ==0 ) && ((attr_table.array[offset+(prevscan<<3) +0]) !=0 ) ){
			int tx;
			for (tx= 0;tx<6;tx++){	
				attr_table.array[offset+(scan<<3) +tx] = attr_table.array[offset+(prevscan<<3) +tx];
				attr_table.array[offset+(prevscan<<3) +tx]=0;
				}
			}
		}
	prevscan=scan;
	}

scan-=1;
scanmax=Rnotecount;
if (scan<0){
	scan=Rnotecount;
	prevscan=Rnotecount+1;
}


//wait output for light feedback
if (stophold||playhold||rechold||barhold||wlight){
	wait=1;
}
if (!stophold&&!playhold&&!rechold&&!barhold&&!wlight){
	wait=0;
	
}

//write note count, bar length and last note age
if (Rnotecount!=prevRnote){
	prevRnote=Rnotecount;
 attr_table.array[countoffset]=Rnotecount;
}
if (maxbar!=prevmaxbar){
	prevmaxbar=maxbar;
 attr_table.array[countoffset+1]=maxbar;
}
if (age!=prevage){
	prevage=age;
	attr_table.array[countoffset+2]=age;
}
if (generation!=pgen){
	pgen=generation;
	attr_table.array[countoffset+3]=generation;
}

if (!reclight){
outlet_overdub=overdub;
}
if (reclight){
outlet_overdub=0;
}
outlet_record=reclight;
outlet_play=play;
outlet_maxnotes=maxnotes;
outlet_slotnotes=Rnotecount;
outlet_currentslot=currentslot;
outlet_full=full;
outlet_wait=wait;
if (play){
	outlet_synclock=synclocko;
}
else {outlet_synclock=-1;}


if (!wait&&!play&&!reclight){
	playstate=0;
	}
else if (play&&!reclight&&!wait) {
	playstate=1;
}
else if (play&&reclight&&!wait){
	playstate=2;
}
if (wait){
	playstate=3;
}
outlet_playstate=playstate;


recend=0;]]></code.krate>
         <code.midihandler><![CDATA[if (attr_input){
if ((status == MIDI_NOTE_ON + (attr_channel-1)) && (data2) && (data1>=attr_startnote) && (data1<=attr_endnote)) {

gate[data1]=1;
vel[data1]=data2;
noteon[data1]=data1;

//if note clashes with already playing note, cut it short and mute ntoe off
if (outgate[data1]){
	Plength[data1]=-1;
	outgate[data1]=0;
	outgateB[data1]=0;
	Oage[data1]=0;
	prevoutgate[data1]=outgateB[data1];
	
	}

	
} else if (((status == MIDI_NOTE_ON + (attr_channel-1)) && (!data2))||
          (status == MIDI_NOTE_OFF + (attr_channel-1))) {
      if ((data1>=attr_startnote) && (data1<=attr_endnote)){
          gate[data1]=0;
      }
          	
          	
          	
          	
          	
			
          }

          	

}]]></code.midihandler>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="ffc989e1-2c2a-4b8e-8497-76018402e7b5" name="mcolumn_3" x="714" y="518">
      <params/>
      <attribs>
         <combo attributeName="output" selection="usb host port 1"/>
         <spinner attributeName="column" value="1"/>
         <objref attributeName="table" obj="midiloopA"/>
      </attribs>
      <object id="patch/object" uuid="ffc989e1-2c2a-4b8e-8497-76018402e7b5">
         <license>GPL</license>
         <inlets>
            <int32 name="offset"/>
            <bool32 name="refresh"/>
            <int32 name="slot"/>
            <bool32 name="overdub"/>
            <bool32 name="cleartrigger"/>
            <int32 name="playstate"/>
            <bool32 name="ccdub"/>
         </inlets>
         <outlets/>
         <displays/>
         <params/>
         <attribs>
            <combo name="output">
               <MenuEntries>
                  <string>din</string>
                  <string>usb host port 1</string>
                  <string>usb host port 2</string>
                  <string>usb host port 3</string>
                  <string>usb host port 4</string>
                  <string>internal port 1</string>
                  <string>internal port 2</string>
                  <string>usb device port 1</string>
               </MenuEntries>
               <CEntries>
                  <string>MIDI_DEVICE_DIN, 1</string>
                  <string>MIDI_DEVICE_USB_HOST, 1</string>
                  <string>MIDI_DEVICE_USB_HOST, 2</string>
                  <string>MIDI_DEVICE_USB_HOST, 3</string>
                  <string>MIDI_DEVICE_USB_HOST, 4</string>
                  <string>MIDI_DEVICE_INTERNAL, 1</string>
                  <string>MIDI_DEVICE_INTERNAL, 2</string>
                  <string>MIDI_DEVICE_USB_DEVICE, 1</string>
               </CEntries>
            </combo>
            <spinner name="column" MinValue="1" MaxValue="8" DefaultValue="1"/>
            <objref name="table"/>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[int map[9];
int i;
int previ;
int rtrig;
int colour;
int stopcolour;
int prevstcolour;
int full;
int prevfull[9];
int statecolour[4];
int trig;
int offset;
int oncolour;
int offcolour;
int currentcolour;
int prevcurcol;
int prevslot;
int lastfull;
int cltrig;
int wtrig;
int trigc;
int rectrig;
int ptrig;
int currentfull;
int waitcolour;
int playcolour;
int reccolour;
int prevplaystate;
int currentslot;
int pslot;
int pccdub;
int cctrig;
int dubcolour;]]></code.declaration>
         <code.init><![CDATA[map[0] = 0+(attr_column-1);
map[1] = 16+(attr_column-1);
map[2] = 32+(attr_column-1);
map[3] = 48+(attr_column-1);
map[4] = 64+(attr_column-1);
map[5] = 80+(attr_column-1);
map[6] = 96+(attr_column-1);
map[7] = 112+(attr_column-1);
map[8] = 104+(attr_column-1);

i=-1;
previ=-1;
prevfull[0]=-1;
prevfull[1]=-1;
prevfull[2]=-1;
prevfull[3]=-1;
prevfull[4]=-1;
prevfull[5]=-1;
prevfull[6]=-1;
prevfull[7]=-1;
trig=1;
prevcurcol=-1;
pccdub=-1;]]></code.init>
         <code.krate><![CDATA[oncolour=18;
offcolour=0;
offset=inlet_offset;
stopcolour=1;
//waitcolour=127;
//playcolour=48;
//recclolour=3;
statecolour[0]=0;
statecolour[1]=48;
statecolour[2]=3;
statecolour[3]=127;

if (inlet_cleartrigger){
	if (!cltrig){
	MidiSend3((midi_device_t) attr_output, MIDI_NOTE_ON +0,map[inlet_slot],offcolour);
	
	}
	//prevslot=inlet_currentslot;
	cltrig=1;
}
if (!inlet_cleartrigger){
	cltrig=0;
}
if (inlet_playstate!=prevplaystate){

	currentslot=inlet_slot;
	currentcolour=statecolour[inlet_playstate];
	prevplaystate=inlet_playstate;
	trigc=1;
}
if (inlet_ccdub!=pccdub){
	pccdub=inlet_ccdub;
	if (inlet_ccdub){
		dubcolour=statecolour[2];
	}
	else {dubcolour=statecolour[1];}
	cctrig=1;
}


//	if (inlet_currentslot!=prevslot){
//		
//		lastfull=attr_table.array[prevslot];
//		if ((!inlet_wait)&&!cltrig){
//			if (prevfull){
//				MidiSend3((midi_device_t) attr_output, MIDI_NOTE_ON +0,map[prevslot],oncolour);
//			}
//			if (!prevfull){
//				MidiSend3((midi_device_t) attr_output, MIDI_NOTE_ON +0,map[prevslot],offcolour);
//			}
//			prevslot=inlet_currentslot;
//			}
//		}
if (currentcolour!=prevcurcol){
	prevcurcol=currentcolour;
	trigc=1;
}
if (!inlet_cleartrigger){
	if ((i!=previ)&&(i>=0)){
		if (i==8){
			if (cctrig){
				MidiSend3((midi_device_t) attr_output, MIDI_CONTROL_CHANGE +0,map[i],dubcolour);
				cctrig=0;
			}
		}
		else if (i==7){
				if (stopcolour!=prevstcolour){
					prevstcolour=stopcolour;
					trig=0;
				}
				colour=stopcolour;
				}
		else {
			full=attr_table.array[offset+i];
			if (i!=currentslot){
				if (prevfull[i]!=full) { 
					trig=0;
					}
				if ((pslot!=currentslot)&&(i==pslot)){
					pslot=currentslot;
					trig=0;
				}
				prevfull[i]=full;
				if (full){
			     	colour=oncolour;
					}
				else if (!full){
					colour=offcolour;
				}
				
				}
			if (i==currentslot){
				if (trigc){
					trigc=0;
					trig=0;
					if (currentcolour>0){
						colour=currentcolour;
						}
					if (currentcolour==0){
							if (full){
						     	colour=oncolour;
								}
							else if (!full){
								colour=offcolour;
								}
						}
					}
				}
		}
			
		
		if (!trig){
		MidiSend3((midi_device_t) attr_output, MIDI_NOTE_ON +0,map[i],colour);
		trig=1;
		}
		previ=i;
	}
}

if (i>=0){
	
i+=1;
if (i>=9){
	i=0;
}
}



if (inlet_refresh&&!rtrig){
	rtrig=1;
	i=0;
	previ=-1;
prevfull[0]=-1;
prevfull[1]=-1;
prevfull[2]=-1;
prevfull[3]=-1;
prevfull[4]=-1;
prevfull[5]=-1;
prevfull[6]=-1;
prevfull[7]=-1;
trig=1;
prevstcolour=-1;
prevcurcol=-1;
pccdub=-1;
}
if (!inlet_refresh){
	rtrig=0;
}]]></code.krate>
      </object>
   </patchobj>
   <comment type="patch/comment" x="854" y="532" text="clear mechanism for clearing slot/automation"/>
   <obj type="logic/or 2" uuid="3805d3c84d30032a44fbdbe42d9a2988a1790a3e" name="or_1" x="854" y="546">
      <params/>
      <attribs/>
   </obj>
   <obj type="mux/mux 2" uuid="16f90f81694766b0bc8187bfcba5a021e5701d81" name="mux_1" x="924" y="546">
      <params/>
      <attribs/>
   </obj>
   <comment type="patch/comment" x="714" y="742" text="pitch bend recorder"/>
   <comment type="patch/comment" x="868" y="742" text="channel touch recorder"/>
   <comment type="patch/comment" x="1008" y="742" text="cc recorder"/>
   <comment type="patch/comment" x="1162" y="742" text="total size on table"/>
   <comment type="patch/comment" x="84" y="756" text="metronom"/>
   <patchobj type="patch/object" uuid="16d73047-6c6f-4799-aca2-f26ae67c5ffa" name="bend" x="714" y="756">
      <params/>
      <attribs>
         <combo attributeName="input" selection="din"/>
         <combo attributeName="output" selection="din"/>
         <spinner attributeName="channel" value="2"/>
         <objref attributeName="table" obj="midiloopA"/>
         <spinner attributeName="maxbar" value="8"/>
         <spinner attributeName="maxslots" value="7"/>
         <combo attributeName="resolution" selection="96ppq"/>
      </attribs>
      <object id="patch/object" uuid="16d73047-6c6f-4799-aca2-f26ae67c5ffa">
         <sDescription>object that records pitch bend, after touch and midi CCs.
for use with the midi looper objects.
could be used standalone, inlet stepunQCC expects a clock running at 96ppq</sDescription>
         <author>Mattilyn Mattroe</author>
         <license>if you use the object to play a wedding in september you have to come round and fix the dodgy extractor fan in my bathroom. otherwise, do as you will</license>
         <helpPatch>midi looper help.axh</helpPatch>
         <inlets>
            <int32 name="offset"/>
            <int32 name="slot"/>
            <int32 name="synclock"/>
            <bool32 name="rec"/>
            <bool32 name="play"/>
            <bool32 name="reset"/>
            <bool32 name="overdub"/>
            <bool32 name="clear"/>
            <int32 name="cslot"/>
         </inlets>
         <outlets>
            <int32 name="offset"/>
         </outlets>
         <displays/>
         <params/>
         <attribs>
            <combo name="input">
               <MenuEntries>
                  <string>omni</string>
                  <string>din</string>
                  <string>usb host port 1</string>
                  <string>usb host port 2</string>
                  <string>usb host port 3</string>
                  <string>usb host port 4</string>
                  <string>internal port 1</string>
                  <string>internal port 2</string>
                  <string>usb device port 1</string>
               </MenuEntries>
               <CEntries>
                  <string>true</string>
                  <string>dev == MIDI_DEVICE_DIN &amp;&amp; port == 1</string>
                  <string>dev == MIDI_DEVICE_USB_HOST &amp;&amp; port == 1</string>
                  <string>dev == MIDI_DEVICE_USB_HOST &amp;&amp; port == 2</string>
                  <string>dev == MIDI_DEVICE_USB_HOST &amp;&amp; port == 3</string>
                  <string>dev == MIDI_DEVICE_USB_HOST &amp;&amp; port == 4</string>
                  <string>dev == MIDI_DEVICE_INTERNAL &amp;&amp; port == 1</string>
                  <string>dev == MIDI_DEVICE_INTERNAL &amp;&amp; port == 2</string>
                  <string>dev == MIDI_DEVICE_USB_DEVICE &amp;&amp; port == 1</string>
               </CEntries>
            </combo>
            <combo name="output">
               <MenuEntries>
                  <string>din</string>
                  <string>usb host port 1</string>
                  <string>usb host port 2</string>
                  <string>usb host port 3</string>
                  <string>usb host port 4</string>
                  <string>internal port 1</string>
                  <string>internal port 2</string>
                  <string>usb device port 1</string>
               </MenuEntries>
               <CEntries>
                  <string>MIDI_DEVICE_DIN, 1</string>
                  <string>MIDI_DEVICE_USB_HOST, 1</string>
                  <string>MIDI_DEVICE_USB_HOST, 2</string>
                  <string>MIDI_DEVICE_USB_HOST, 3</string>
                  <string>MIDI_DEVICE_USB_HOST, 4</string>
                  <string>MIDI_DEVICE_INTERNAL, 1</string>
                  <string>MIDI_DEVICE_INTERNAL, 2</string>
                  <string>MIDI_DEVICE_USB_DEVICE, 1</string>
               </CEntries>
            </combo>
            <spinner name="channel" MinValue="1" MaxValue="16" DefaultValue="1"/>
            <objref name="table"/>
            <spinner name="maxbar" MinValue="1" MaxValue="32" DefaultValue="0"/>
            <spinner name="maxslots" MinValue="1" MaxValue="32" DefaultValue="1"/>
            <combo name="resolution">
               <MenuEntries>
                  <string>192ppq</string>
                  <string>96ppq</string>
                  <string>48ppq</string>
                  <string>24ppq</string>
               </MenuEntries>
               <CEntries>
                  <string>0</string>
                  <string>1</string>
                  <string>2</string>
                  <string>3</string>
               </CEntries>
            </combo>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[int bendA;
int bendB;




int synclock;
int ObendA;
int ObendB;

int prevstep;
int voice;
int slotsize;

int offset;
int clear;
int ctrig;


int resetrig;]]></code.declaration>
         <code.init><![CDATA[voice=(768*attr_maxbar)>>attr_resolution;
slotsize=(voice*2);
clear=-1;]]></code.init>
         <code.krate><![CDATA[offset=inlet_offset + (slotsize*inlet_slot);
outlet_offset=inlet_offset + (slotsize*attr_maxslots);
if (inlet_synclock>=0){
	synclock=inlet_synclock>>attr_resolution;
	}
else {synclock=-1;}

ObendA=attr_table.array[synclock+offset];
ObendB=attr_table.array[synclock+offset+voice];

if (inlet_clear&&!ctrig){
	clear=0;
	ctrig=1;
}
if (!inlet_clear){
	ctrig=0;
}
if ((clear>=0)&& (clear<slotsize)){
	attr_table.array[clear+inlet_offset + (slotsize*inlet_cslot)]= 0;
	attr_table.array[clear+inlet_offset + (slotsize*inlet_cslot)+voice]= 0;
	
	
	
	clear+=1;
	if (clear>=slotsize){
		clear=-1;
	}
}
if (synclock!=prevstep){
//play
	if (inlet_play){
	
		
		if ((ObendA>0)||(ObendB>0)){
			MidiSend3((midi_device_t) attr_output, MIDI_PITCH_BEND + (attr_channel-1),(ObendA-1),(ObendB-1));
			}
	}

//record
	if (inlet_rec){
			attr_table.array[synclock+offset]= 0;
			attr_table.array[synclock+offset+voice]= 0;
		
			
		}
	if ((inlet_rec || inlet_overdub) && (inlet_play)){
		
		
			if ((bendA>0)||(bendB>0)){
					attr_table.array[synclock+offset]= bendA;
					attr_table.array[synclock+offset+voice]= bendB;
				}
			
			
		}


	bendA=0;
	bendB=0;

	prevstep=synclock;
	}


//reset bend & touch
	if ((inlet_reset || (synclock<1))&&!resetrig){
		MidiSend3((midi_device_t) attr_output, MIDI_PITCH_BEND+ (attr_channel-1),0,64);
		
		resetrig=1;
		
		}

if (!inlet_reset && (synclock>0)){
	resetrig=0;
	}]]></code.krate>
         <code.midihandler><![CDATA[if(attr_input) {
       


if (status == MIDI_PITCH_BEND +(attr_channel-1)){
	bendA=data1+1;
	bendB=data2+1;

	
	}

	
}]]></code.midihandler>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="16d73047-6c6f-4799-aca2-f26ae67c5ffa" name="channel touch___" x="868" y="756">
      <params/>
      <attribs>
         <combo attributeName="input" selection="din"/>
         <combo attributeName="output" selection="din"/>
         <spinner attributeName="channel" value="2"/>
         <objref attributeName="table" obj="midiloopA"/>
         <spinner attributeName="maxbar" value="8"/>
         <spinner attributeName="maxslots" value="7"/>
         <combo attributeName="resolution" selection="96ppq"/>
      </attribs>
      <object id="patch/object" uuid="16d73047-6c6f-4799-aca2-f26ae67c5ffa">
         <sDescription>object that records pitch bend, after touch and midi CCs.
for use with the midi looper objects.
could be used standalone, inlet stepunQCC expects a clock running at 96ppq</sDescription>
         <author>Mattilyn Mattroe</author>
         <license>if you use the object to play a wedding in september you have to come round and fix the dodgy extractor fan in my bathroom. otherwise, do as you will</license>
         <helpPatch>midi looper help.axh</helpPatch>
         <inlets>
            <int32 name="offset"/>
            <int32 name="slot"/>
            <int32 name="synclock"/>
            <bool32 name="rec"/>
            <bool32 name="play"/>
            <bool32 name="reset"/>
            <bool32 name="overdub"/>
            <bool32 name="clear"/>
            <int32 name="cslot"/>
         </inlets>
         <outlets>
            <int32 name="offset"/>
         </outlets>
         <displays/>
         <params/>
         <attribs>
            <combo name="input">
               <MenuEntries>
                  <string>omni</string>
                  <string>din</string>
                  <string>usb host port 1</string>
                  <string>usb host port 2</string>
                  <string>usb host port 3</string>
                  <string>usb host port 4</string>
                  <string>internal port 1</string>
                  <string>internal port 2</string>
                  <string>usb device port 1</string>
               </MenuEntries>
               <CEntries>
                  <string>true</string>
                  <string>dev == MIDI_DEVICE_DIN &amp;&amp; port == 1</string>
                  <string>dev == MIDI_DEVICE_USB_HOST &amp;&amp; port == 1</string>
                  <string>dev == MIDI_DEVICE_USB_HOST &amp;&amp; port == 2</string>
                  <string>dev == MIDI_DEVICE_USB_HOST &amp;&amp; port == 3</string>
                  <string>dev == MIDI_DEVICE_USB_HOST &amp;&amp; port == 4</string>
                  <string>dev == MIDI_DEVICE_INTERNAL &amp;&amp; port == 1</string>
                  <string>dev == MIDI_DEVICE_INTERNAL &amp;&amp; port == 2</string>
                  <string>dev == MIDI_DEVICE_USB_DEVICE &amp;&amp; port == 1</string>
               </CEntries>
            </combo>
            <combo name="output">
               <MenuEntries>
                  <string>din</string>
                  <string>usb host port 1</string>
                  <string>usb host port 2</string>
                  <string>usb host port 3</string>
                  <string>usb host port 4</string>
                  <string>internal port 1</string>
                  <string>internal port 2</string>
                  <string>usb device port 1</string>
               </MenuEntries>
               <CEntries>
                  <string>MIDI_DEVICE_DIN, 1</string>
                  <string>MIDI_DEVICE_USB_HOST, 1</string>
                  <string>MIDI_DEVICE_USB_HOST, 2</string>
                  <string>MIDI_DEVICE_USB_HOST, 3</string>
                  <string>MIDI_DEVICE_USB_HOST, 4</string>
                  <string>MIDI_DEVICE_INTERNAL, 1</string>
                  <string>MIDI_DEVICE_INTERNAL, 2</string>
                  <string>MIDI_DEVICE_USB_DEVICE, 1</string>
               </CEntries>
            </combo>
            <spinner name="channel" MinValue="1" MaxValue="16" DefaultValue="1"/>
            <objref name="table"/>
            <spinner name="maxbar" MinValue="1" MaxValue="32" DefaultValue="0"/>
            <spinner name="maxslots" MinValue="1" MaxValue="32" DefaultValue="1"/>
            <combo name="resolution">
               <MenuEntries>
                  <string>192ppq</string>
                  <string>96ppq</string>
                  <string>48ppq</string>
                  <string>24ppq</string>
               </MenuEntries>
               <CEntries>
                  <string>0</string>
                  <string>1</string>
                  <string>2</string>
                  <string>3</string>
               </CEntries>
            </combo>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[int touch;


int synclock;

int Otouch;
int prevstep;
int voice;
int slotsize;
int play;
int rec;
int offset;
int clear;
int ctrig;


int resetrig;]]></code.declaration>
         <code.init><![CDATA[voice=(768*attr_maxbar)>>attr_resolution;
slotsize=voice;
clear=-1;]]></code.init>
         <code.krate><![CDATA[offset=inlet_offset + (slotsize*inlet_slot);
outlet_offset=inlet_offset + (slotsize*attr_maxslots);
if (inlet_synclock>=0){
	synclock=inlet_synclock>>attr_resolution;
	}
else {synclock=-1;}

Otouch=attr_table.array[synclock+offset];
if (inlet_clear&&!ctrig){
	clear=0;
	ctrig=1;
}
if (!inlet_clear){
	ctrig=0;
}
if ((clear>=0)&& (clear<slotsize)){
	attr_table.array[clear+inlet_offset + (slotsize*inlet_cslot)]= 0;

	
	
	clear+=1;
	if (clear>=slotsize){
		clear=-1;
	}
}
if (synclock!=prevstep){
//play
	if (inlet_play){
		
		if (Otouch>0){
			MidiSend2((midi_device_t) attr_output, MIDI_CHANNEL_PRESSURE + (attr_channel-1),(Otouch-1)); 
			}
		}

//record
	if (inlet_rec){
			attr_table.array[synclock+offset]= 0;
			
			
		}
//overdub
	if ((inlet_rec || inlet_overdub) && (inlet_play)){
		
			
				
			
			if (touch>0){
					attr_table.array[synclock+offset]= touch;
				}
		}


	touch=0;
	prevstep=synclock;
	}


//reset bend & touch
	if ((inlet_reset || (synclock<1))&&!resetrig){
	
		MidiSend2((midi_device_t) attr_output, MIDI_CHANNEL_PRESSURE + (attr_channel-1),0); 
		resetrig=1;
		
		}

if (!inlet_reset && (synclock>0)){
	resetrig=0;
	}]]></code.krate>
         <code.midihandler><![CDATA[if(attr_input) {
       


if (status == MIDI_CHANNEL_PRESSURE+(attr_channel-1)){
	touch=data1+1;

	
	}
	
}]]></code.midihandler>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="16d73047-6c6f-4799-aca2-f26ae67c5ffa" name="CC" x="1008" y="756">
      <params/>
      <attribs>
         <combo attributeName="input" selection="din"/>
         <combo attributeName="output" selection="din"/>
         <spinner attributeName="channel" value="2"/>
         <objref attributeName="table" obj="midiloopA"/>
         <spinner attributeName="maxbar" value="8"/>
         <spinner attributeName="maxslots" value="7"/>
         <combo attributeName="resolution" selection="96ppq"/>
      </attribs>
      <object id="patch/object" uuid="16d73047-6c6f-4799-aca2-f26ae67c5ffa">
         <sDescription>object that records pitch bend, after touch and midi CCs.
for use with the midi looper objects.
could be used standalone, inlet stepunQCC expects a clock running at 96ppq</sDescription>
         <author>Mattilyn Mattroe</author>
         <license>if you use the object to play a wedding in september you have to come round and fix the dodgy extractor fan in my bathroom. otherwise, do as you will</license>
         <helpPatch>midi looper help.axh</helpPatch>
         <inlets>
            <int32 name="offset"/>
            <int32 name="slot"/>
            <int32 name="synclock"/>
            <bool32 name="rec"/>
            <bool32 name="play"/>
            <bool32 name="overdub"/>
            <bool32 name="clear"/>
            <int32 name="cslot"/>
         </inlets>
         <outlets>
            <int32 name="offset"/>
         </outlets>
         <displays/>
         <params/>
         <attribs>
            <combo name="input">
               <MenuEntries>
                  <string>omni</string>
                  <string>din</string>
                  <string>usb host port 1</string>
                  <string>usb host port 2</string>
                  <string>usb host port 3</string>
                  <string>usb host port 4</string>
                  <string>internal port 1</string>
                  <string>internal port 2</string>
                  <string>usb device port 1</string>
               </MenuEntries>
               <CEntries>
                  <string>true</string>
                  <string>dev == MIDI_DEVICE_DIN &amp;&amp; port == 1</string>
                  <string>dev == MIDI_DEVICE_USB_HOST &amp;&amp; port == 1</string>
                  <string>dev == MIDI_DEVICE_USB_HOST &amp;&amp; port == 2</string>
                  <string>dev == MIDI_DEVICE_USB_HOST &amp;&amp; port == 3</string>
                  <string>dev == MIDI_DEVICE_USB_HOST &amp;&amp; port == 4</string>
                  <string>dev == MIDI_DEVICE_INTERNAL &amp;&amp; port == 1</string>
                  <string>dev == MIDI_DEVICE_INTERNAL &amp;&amp; port == 2</string>
                  <string>dev == MIDI_DEVICE_USB_DEVICE &amp;&amp; port == 1</string>
               </CEntries>
            </combo>
            <combo name="output">
               <MenuEntries>
                  <string>din</string>
                  <string>usb host port 1</string>
                  <string>usb host port 2</string>
                  <string>usb host port 3</string>
                  <string>usb host port 4</string>
                  <string>internal port 1</string>
                  <string>internal port 2</string>
                  <string>usb device port 1</string>
               </MenuEntries>
               <CEntries>
                  <string>MIDI_DEVICE_DIN, 1</string>
                  <string>MIDI_DEVICE_USB_HOST, 1</string>
                  <string>MIDI_DEVICE_USB_HOST, 2</string>
                  <string>MIDI_DEVICE_USB_HOST, 3</string>
                  <string>MIDI_DEVICE_USB_HOST, 4</string>
                  <string>MIDI_DEVICE_INTERNAL, 1</string>
                  <string>MIDI_DEVICE_INTERNAL, 2</string>
                  <string>MIDI_DEVICE_USB_DEVICE, 1</string>
               </CEntries>
            </combo>
            <spinner name="channel" MinValue="1" MaxValue="16" DefaultValue="1"/>
            <objref name="table"/>
            <spinner name="maxbar" MinValue="1" MaxValue="32" DefaultValue="0"/>
            <spinner name="maxslots" MinValue="1" MaxValue="32" DefaultValue="1"/>
            <combo name="resolution">
               <MenuEntries>
                  <string>192ppq</string>
                  <string>96ppq</string>
                  <string>48ppq</string>
                  <string>24ppq</string>
               </MenuEntries>
               <CEntries>
                  <string>0</string>
                  <string>1</string>
                  <string>2</string>
                  <string>3</string>
               </CEntries>
            </combo>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[int cc;
int ccv;
int bendA;
int bendB;
int touch;

int Occ;
int Occv;
int OccB;
int OccvB;
int OccC;
int OccvC;

int synclock;
int ObendA;
int ObendB;
int Otouch;
int prevstep;
int voice;
int slotsize;
int play;
int rec;
int offset;
int clear;
int ctrig;


int resetrig;]]></code.declaration>
         <code.init><![CDATA[voice=(768*attr_maxbar)>>attr_resolution;
slotsize=(voice*6);
clear=-1;]]></code.init>
         <code.krate><![CDATA[offset=inlet_offset + (slotsize*inlet_slot);
outlet_offset=inlet_offset + (slotsize*attr_maxslots);
if (inlet_synclock>=0){
	synclock=inlet_synclock>>attr_resolution;
	}
else {synclock=-1;}
Occ=attr_table.array[synclock+offset];
Occv=attr_table.array[synclock+offset+voice];
OccB=attr_table.array[synclock+offset+voice+voice];
OccvB=attr_table.array[synclock+offset+voice+voice+voice];
OccC=attr_table.array[synclock+offset+voice+voice+voice+voice];
OccvC=attr_table.array[synclock+offset+voice+voice+voice+voice+voice];

if (inlet_clear&&!ctrig){
	clear=0;
	ctrig=1;
}
if (!inlet_clear){
	ctrig=0;
}
if ((clear>=0)&& (clear<slotsize)){
	attr_table.array[clear+inlet_offset + (slotsize*inlet_cslot)]= 0;
	attr_table.array[clear+inlet_offset + (slotsize*inlet_cslot)+voice]= 0;
	attr_table.array[clear+inlet_offset + (slotsize*inlet_cslot)+voice+voice]= 0;
	attr_table.array[clear+inlet_offset + (slotsize*inlet_cslot)+voice+voice+voice]= 0;
	attr_table.array[clear+inlet_offset + (slotsize*inlet_cslot)+voice+voice+voice+voice]= 0;
	attr_table.array[clear+inlet_offset + (slotsize*inlet_cslot)+voice+voice+voice+voice+voice]= 0;
	
	
	
	clear+=1;
	if (clear>=slotsize){
		clear=-1;
	}
}
if (synclock!=prevstep){
//play
	if (inlet_play){
		if (Occv>0){
			MidiSend3((midi_device_t) attr_output, MIDI_CONTROL_CHANGE + (attr_channel-1),(Occ-1),(Occv-1));
		}
		if (OccvB>0){
			MidiSend3((midi_device_t) attr_output, MIDI_CONTROL_CHANGE + (attr_channel-1),(OccB-1),(OccvB-1));
		}
		if (OccvC>0){
			MidiSend3((midi_device_t) attr_output, MIDI_CONTROL_CHANGE + (attr_channel-1),(OccC-1),(OccvC-1));
		}
		
		
		}

//record
	if (inlet_rec){
			attr_table.array[synclock+offset]= 0;
			attr_table.array[synclock+offset+voice]= 0;
			attr_table.array[synclock+offset+voice+voice]= 0;
			attr_table.array[synclock+offset+voice+voice+voice]= 0;
			attr_table.array[synclock+offset+voice+voice+voice+voice]= 0;
			attr_table.array[synclock+offset+voice+voice+voice+voice+voice]= 0;
			
			
		}
//overdub
	if ((inlet_rec || inlet_overdub) && (inlet_play)){
		
			if (ccv>0){
				if (Occv && (Occ==cc))   {
					attr_table.array[synclock+offset]= cc;
					attr_table.array[synclock+offset+voice]= ccv;
					}
				else if (OccvB && (OccB==cc)){
					attr_table.array[synclock+offset+voice+voice]= cc;
					attr_table.array[synclock+offset+voice+voice+voice]= ccv;
				}
				else if (OccvC && (OccC==cc)){
					attr_table.array[synclock+offset+voice+voice+voice+voice]= cc;
					attr_table.array[synclock+offset+voice+voice+voice+voice+voice]= ccv;
				}
				else if (!Occv)   {
					attr_table.array[synclock+offset]= cc;
					attr_table.array[synclock+offset+voice]= ccv;
					}
				else if (!OccvB){
					attr_table.array[synclock+offset+voice+voice]= cc;
					attr_table.array[synclock+offset+voice+voice+voice]= ccv;
				}
				else if (!OccvC){
					attr_table.array[synclock+offset+voice+voice+voice+voice]= cc;
					attr_table.array[synclock+offset+voice+voice+voice+voice+voice]= ccv;
				}
				}
			
		}

	cc=0;
	ccv=0;
	
	prevstep=synclock;
	}]]></code.krate>
         <code.midihandler><![CDATA[if(attr_input) {
       
if (status == MIDI_CONTROL_CHANGE+(attr_channel-1)){
	cc=data1+1;
	ccv=data2+1;

	
	}


	
}]]></code.midihandler>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="698d0117-38a6-4ae6-ba05-43a11ac44520" name="i_5" x="1162" y="756">
      <params/>
      <attribs/>
      <object id="patch/object" uuid="698d0117-38a6-4ae6-ba05-43a11ac44520">
         <sDescription>display integer</sDescription>
         <author>Johannes Taelman</author>
         <license>BSD</license>
         <helpPatch>disp.axh</helpPatch>
         <inlets>
            <int32 name="in" description="input"/>
         </inlets>
         <outlets/>
         <displays>
            <int32.label name="v" noLabel="true"/>
         </displays>
         <params/>
         <attribs/>
         <includes/>
         <code.krate><![CDATA[disp_v=inlet_in;
]]></code.krate>
      </object>
   </patchobj>
   <obj type="noise/pink" uuid="72c03a2468ee865f248733fcf9b12d4cf42b5a61" name="pink_1" x="0" y="770">
      <params/>
      <attribs/>
   </obj>
   <obj type="env/d" uuid="190ae648e41832b41adbedb465317c18a010aefe" name="d_1" x="84" y="770">
      <params>
         <frac32.s.map name="d" value="-46.0"/>
      </params>
      <attribs/>
   </obj>
   <obj type="math/*" uuid="922423f2db9f222aa3e5ba095778288c446da47a" name="*_2" x="210" y="770">
      <params/>
      <attribs/>
   </obj>
   <obj type="gain/vca" uuid="a9f2dcd18043e2f47364e45cb8814f63c2a37c0d" name="vca_4" x="280" y="770">
      <params/>
      <attribs/>
   </obj>
   <obj type="audio/out left" uuid="b11a3c09b2fdd575ea8212f2ce7743d5269253b1" name="out_2" x="378" y="770">
      <params/>
      <attribs/>
   </obj>
   <comment type="patch/comment" x="84" y="854" text="bar pulse"/>
   <obj type="env/d" uuid="190ae648e41832b41adbedb465317c18a010aefe" name="d_2" x="84" y="868">
      <params>
         <frac32.s.map name="d" value="-23.0"/>
      </params>
      <attribs/>
   </obj>
   <obj type="math/*" uuid="922423f2db9f222aa3e5ba095778288c446da47a" name="*_1" x="196" y="868">
      <params/>
      <attribs/>
   </obj>
   <obj type="gain/vca" uuid="a9f2dcd18043e2f47364e45cb8814f63c2a37c0d" name="vca_5" x="266" y="868">
      <params/>
      <attribs/>
   </obj>
   <obj type="audio/out left" uuid="b11a3c09b2fdd575ea8212f2ce7743d5269253b1" name="out_3" x="378" y="868">
      <params/>
      <attribs/>
   </obj>
   <nets>
      <net>
         <source obj="c_1" outlet="out"/>
         <dest obj="save_1" inlet="filename"/>
      </net>
      <net>
         <source obj="mlpad_1" outlet="save"/>
         <dest obj="save_1" inlet="trig"/>
      </net>
      <net>
         <source obj="mlpad_1" outlet="init"/>
         <dest obj="load_3" inlet="trig"/>
      </net>
      <net>
         <source obj="mlpad_1" outlet="clearshift"/>
         <dest obj="mnote_1" inlet="erase"/>
         <dest obj="mlpad_2" inlet="clearshift"/>
      </net>
      <net>
         <source obj="mlpad_1" outlet="refreshtrig"/>
         <dest obj="step_1" inlet="redraw"/>
         <dest obj="mcolumn_3" inlet="refresh"/>
      </net>
      <net>
         <source obj="mclock_1" outlet="pulse"/>
         <dest obj="d_1" inlet="trig"/>
      </net>
      <net>
         <source obj="mlpad_2" outlet="clipslot"/>
         <dest obj="mux_1" inlet="i1"/>
         <dest obj="mnote_1" inlet="slot"/>
         <dest obj="mcolumn_3" inlet="slot"/>
      </net>
      <net>
         <source obj="mlpad_2" outlet="cleartrigger"/>
         <dest obj="or_1" inlet="i1"/>
         <dest obj="mnote_1" inlet="clearslot"/>
         <dest obj="mcolumn_3" inlet="cleartrigger"/>
      </net>
      <net>
         <source obj="mlpad_2" outlet="trigger"/>
         <dest obj="mnote_1" inlet="trigger"/>
      </net>
      <net>
         <source obj="mlpad_2" outlet="stop"/>
         <dest obj="mnote_1" inlet="stop"/>
      </net>
      <net>
         <source obj="mlpad_1" outlet="overdub"/>
         <dest obj="mnote_1" inlet="overdub"/>
      </net>
      <net>
         <source obj="mclock_1" outlet="start"/>
         <dest obj="bend" inlet="reset"/>
         <dest obj="channel touch___" inlet="reset"/>
      </net>
      <net>
         <source obj="loadbang_1" outlet="trig"/>
         <dest obj="mlpad_1" inlet="refresh"/>
      </net>
      <net>
         <source obj="mnote_1" outlet="playstate"/>
         <dest obj="mcolumn_3" inlet="playstate"/>
      </net>
      <net>
         <source obj="mnote_1" outlet="overdub"/>
         <dest obj="mcolumn_3" inlet="overdub"/>
      </net>
      <net>
         <source obj="mlpad_1" outlet="quantize"/>
         <dest obj="mnote_1" inlet="quantize"/>
      </net>
      <net>
         <source obj="mlpad_2" outlet="chold"/>
         <dest obj="or_1" inlet="i2"/>
         <dest obj="mux_1" inlet="s"/>
      </net>
      <net>
         <source obj="1_5" outlet="pad"/>
         <dest obj="step_1" inlet="pad"/>
      </net>
      <net>
         <source obj="1_5" outlet="barlength"/>
         <dest obj="mnote_1" inlet="maxbar"/>
      </net>
      <net>
         <source obj="pink_1" outlet="out"/>
         <dest obj="vca_4" inlet="a"/>
         <dest obj="vca_5" inlet="a"/>
      </net>
      <net>
         <source obj="d_1" outlet="env"/>
         <dest obj="*_2" inlet="a"/>
      </net>
      <net>
         <source obj="d_2" outlet="env"/>
         <dest obj="*_1" inlet="a"/>
      </net>
      <net>
         <source obj="dial_1" outlet="out"/>
         <dest obj="*_2" inlet="b"/>
         <dest obj="*_1" inlet="b"/>
      </net>
      <net>
         <source obj="*_1" outlet="result"/>
         <dest obj="vca_5" inlet="v"/>
      </net>
      <net>
         <source obj="vca_4" outlet="o"/>
         <dest obj="out_2" inlet="wave"/>
      </net>
      <net>
         <source obj="vca_5" outlet="o"/>
         <dest obj="out_3" inlet="wave"/>
      </net>
      <net>
         <source obj="*_2" outlet="result"/>
         <dest obj="vca_4" inlet="v"/>
      </net>
      <net>
         <source obj="mnote_1" outlet="offset"/>
         <dest obj="bend" inlet="offset"/>
      </net>
      <net>
         <source obj="mclock_1" outlet="bartrig"/>
         <dest obj="d_2" inlet="trig"/>
      </net>
      <net>
         <source obj="mux_1" outlet="o"/>
         <dest obj="bend" inlet="cslot"/>
         <dest obj="CC" inlet="cslot"/>
         <dest obj="channel touch___" inlet="cslot"/>
      </net>
      <net>
         <source obj="or_1" outlet="o"/>
         <dest obj="bend" inlet="clear"/>
         <dest obj="CC" inlet="clear"/>
         <dest obj="channel touch___" inlet="clear"/>
      </net>
      <net>
         <source obj="mlpad_2" outlet="ccdub"/>
         <dest obj="bend" inlet="overdub"/>
         <dest obj="CC" inlet="overdub"/>
         <dest obj="channel touch___" inlet="overdub"/>
         <dest obj="mcolumn_3" inlet="ccdub"/>
      </net>
      <net>
         <source obj="mnote_1" outlet="record"/>
         <dest obj="bend" inlet="rec"/>
         <dest obj="CC" inlet="rec"/>
         <dest obj="channel touch___" inlet="rec"/>
      </net>
      <net>
         <source obj="mnote_1" outlet="play"/>
         <dest obj="bend" inlet="play"/>
         <dest obj="CC" inlet="play"/>
         <dest obj="channel touch___" inlet="play"/>
      </net>
      <net>
         <source obj="mnote_1" outlet="synclock"/>
         <dest obj="bend" inlet="synclock"/>
         <dest obj="CC" inlet="synclock"/>
         <dest obj="channel touch___" inlet="synclock"/>
      </net>
      <net>
         <source obj="mnote_1" outlet="currentslot"/>
         <dest obj="bend" inlet="slot"/>
         <dest obj="CC" inlet="slot"/>
         <dest obj="mux_1" inlet="i2"/>
         <dest obj="channel touch___" inlet="slot"/>
      </net>
      <net>
         <source obj="mclock_1" outlet="192ppq"/>
         <dest obj="mnote_1" inlet="192ppq"/>
      </net>
      <net>
         <source obj="bend" outlet="offset"/>
         <dest obj="channel touch___" inlet="offset"/>
      </net>
      <net>
         <source obj="channel touch___" outlet="offset"/>
         <dest obj="CC" inlet="offset"/>
      </net>
      <net>
         <source obj="toggle_1" outlet="o"/>
         <dest obj="clock_4" inlet="run"/>
         <dest obj="clock_4" inlet="rst"/>
      </net>
      <net>
         <source obj="*c_1" outlet="out"/>
         <dest obj="+c_1" inlet="in"/>
      </net>
      <net>
         <source obj="+c_1" outlet="out"/>
         <dest obj="clock_4" inlet="speed"/>
      </net>
      <net>
         <source obj="dial_2" outlet="out"/>
         <dest obj="*c_1" inlet="in"/>
      </net>
      <net>
         <source obj="CC" outlet="offset"/>
         <dest obj="i_5" inlet="in"/>
      </net>
   </nets>
   <settings>
      <subpatchmode>no</subpatchmode>
      <MidiChannel>10</MidiChannel>
      <NPresets>0</NPresets>
      <NPresetEntries>0</NPresetEntries>
      <NModulationSources>0</NModulationSources>
      <NModulationTargetsPerSource>0</NModulationTargetsPerSource>
   </settings>
   <notes><![CDATA[]]></notes>
   <windowPos>
      <x>-8</x>
      <y>-8</y>
      <width>1616</width>
      <height>876</height>
   </windowPos>
</patch-1.0>