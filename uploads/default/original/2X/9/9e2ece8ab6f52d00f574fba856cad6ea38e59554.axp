<patch-1.0 appVersion="1.0.12">
   <comment type="patch/comment" x="420" y="84" text="main controls for song"/>
   <obj type="ctrl/i" uuid="a3786816db6ea5bc6ac4193a5cccdb2c83b83496" name="song" x="378" y="112">
      <params>
         <int32 name="value" value="2"/>
      </params>
      <attribs/>
   </obj>
   <obj type="ctrl/button" uuid="ef3d13774349df85aa9bfecf30dbc91ab8488b3f" name="load" x="434" y="112">
      <params>
         <bool32.mom name="b" value="0"/>
      </params>
      <attribs/>
   </obj>
   <obj type="ctrl/button" uuid="ef3d13774349df85aa9bfecf30dbc91ab8488b3f" name="save" x="504" y="112">
      <params>
         <bool32.mom name="b" value="0"/>
      </params>
      <attribs/>
   </obj>
   <obj type="string/indexed" uuid="a28740deef67c39ffc65bd0f341a47c9b196f46" name="indexed_1" x="602" y="112">
      <params/>
      <attribs>
         <table attributeName="prefix" table="0:/track"/>
         <table attributeName="suffix" table=".tab"/>
      </attribs>
   </obj>
   <obj type="ctrl/button" uuid="ef3d13774349df85aa9bfecf30dbc91ab8488b3f" name="copy to next" x="378" y="182">
      <params>
         <bool32.mom name="b" value="0"/>
      </params>
      <attribs/>
   </obj>
   <obj type="ctrl/button" uuid="ef3d13774349df85aa9bfecf30dbc91ab8488b3f" name="copy from" x="448" y="182">
      <params>
         <bool32.mom name="b" value="0"/>
      </params>
      <attribs/>
   </obj>
   <obj type="ctrl/i" uuid="a3786816db6ea5bc6ac4193a5cccdb2c83b83496" name="from" x="518" y="182">
      <params>
         <int32 name="value" value="9"/>
      </params>
      <attribs/>
   </obj>
   <obj type="table/load" uuid="600cc22c6734d23a82620da1a14e78782a7e168e" name="load_1" x="602" y="196">
      <params/>
      <attribs>
         <objref attributeName="table" obj="songtable"/>
      </attribs>
   </obj>
   <obj type="ctrl/toggle" uuid="42b8134fa729d54bfc8d62d6ef3fa99498c1de99" name="play" x="378" y="266">
      <params>
         <bool32.tgl name="b" value="1"/>
      </params>
      <attribs/>
   </obj>
   <obj type="ctrl/button" uuid="ef3d13774349df85aa9bfecf30dbc91ab8488b3f" name="pause" x="448" y="266">
      <params>
         <bool32.mom name="b" value="0"/>
      </params>
      <attribs/>
   </obj>
   <obj type="ctrl/button" uuid="ef3d13774349df85aa9bfecf30dbc91ab8488b3f" name="stop" x="518" y="266">
      <params>
         <bool32.mom name="b" value="0"/>
      </params>
      <attribs/>
   </obj>
   <obj type="table/save" uuid="3e4108b607d56d9e1cd10abb898b58eea11e53b2" name="save_1" x="602" y="280">
      <params/>
      <attribs>
         <objref attributeName="table" obj="songtable"/>
      </attribs>
   </obj>
   <obj type="ctrl/button" uuid="ef3d13774349df85aa9bfecf30dbc91ab8488b3f" name="reset" x="378" y="322">
      <params>
         <bool32.mom name="b" value="0"/>
      </params>
      <attribs/>
   </obj>
   <obj type="ctrl/dial b" uuid="862e7d7f29093cb1ce4aed72244d118ad4d46692" name="tempo" x="448" y="322">
      <params>
         <frac32.s.map name="value" value="-16.0"/>
      </params>
      <attribs/>
   </obj>
   <comment type="patch/comment" x="784" y="364" text="random &quot;preset&quot; offset generators"/>
   <obj type="ctrl/i" uuid="a3786816db6ea5bc6ac4193a5cccdb2c83b83496" name="reset to part" x="378" y="378">
      <params>
         <int32 name="value" value="0"/>
      </params>
      <attribs/>
   </obj>
   <obj type="ctrl/dial b" uuid="862e7d7f29093cb1ce4aed72244d118ad4d46692" name="rnd offset1" x="966" y="378">
      <params>
         <frac32.s.map name="value" value="14.209999561309814"/>
      </params>
      <attribs/>
   </obj>
   <obj type="ctrl/dial b" uuid="862e7d7f29093cb1ce4aed72244d118ad4d46692" name="rnd offset2" x="1036" y="378">
      <params>
         <frac32.s.map name="value" value="35.02999925613403"/>
      </params>
      <attribs/>
   </obj>
   <comment type="patch/comment" x="252" y="448" text="song editor"/>
   <comment type="patch/comment" x="364" y="448" text="song tracker counter"/>
   <comment type="patch/comment" x="700" y="448" text="random values table"/>
   <comment type="patch/comment" x="0" y="462" text="check &quot;init&quot; to see how to &quot;write&quot; a song as text"/>
   <patchobj type="patch/object" uuid="0d31138b-39d7-4cee-b3f6-628800dddc3c" name="songtable" x="224" y="462">
      <params>
         <int32 name="part" value="39"/>
         <int32 name="preset" value="25"/>
         <int32 name="nominator" value="2"/>
         <int32 name="denominator" value="2"/>
         <int32 name="measures" value="1"/>
         <int32 name="bars" value="1"/>
         <bool32.tgl name="loopback" value="0"/>
         <int32 name="loop2part" value="1"/>
         <int32 name="loops" value="2"/>
         <int32 name="songpart" value="1"/>
         <int32 name="character" value="1"/>
         <int32 name="lastpart" value="39"/>
         <bool32.tgl name="loopparts" value="1"/>
      </params>
      <attribs>
         <combo attributeName="size" selection="65536"/>
         <text attributeName="init">
            <sText><![CDATA[DO=1;	
uint32_t PS=0;

//Below is the "tracker list"
//each verticle column sets the value for one of the parameters of the tracker
//note that some columns have different value ranges! The character and songpart could also go to 127, but have noted these to go to 16 as a reminder to use with a 16x slider selector.

//to edit this list, you can just edit the numbers behind the "array[PS+2]="....
//to add lines, just copy and paste a line. Don't forget to also copy the "PS+=10;" part, otherwise you won't advance through the list and constantly overwrite the same array indices.
//never loop back before another looppoint, this will make the sequencer stuck between these loop points! If you really need to loop back, use the "reset" input on the tracker and reset back to a part manually
//see right side for further information about what the horizontal sets are doing

//different range///															///note that these two DO have other ranges////	           ///note that these two DO have other ranges////
/* preset(0-127)    nominator(1-127)   denominator(1-127)   measures(1-127)	  bars(1-127)	        loop (0/1)       loop2part(0-127)	 loops(1-127)	     character(1-16)	(songpart(1-16)	 	part# (important to keep track of loop points)                 */
//intro
   array[PS]=0;      array[PS+1]=4;      array[PS+2]=1;      array[PS+3]=4;      array[PS+4]=2;      array[PS+5]=0;      array[PS+6]=0;      array[PS+7]=2;      array[PS+8]=2;      array[PS+9]=3;  PS+=10;//part0         //copy line for next part
//couplet1  
   array[PS]=1;      array[PS+1]=3;      array[PS+2]=2;      array[PS+3]=1;      array[PS+4]=1;      array[PS+5]=0;      array[PS+6]=0;      array[PS+7]=2;      array[PS+8]=3;      array[PS+9]=5;  PS+=10;//part1  /// 3 counts at half rate->1/2 division, , 
   array[PS]=2;      array[PS+1]=5;      array[PS+2]=2;      array[PS+3]=1;      array[PS+4]=1;      array[PS+5]=0;      array[PS+6]=0;      array[PS+7]=2;      array[PS+8]=3;      array[PS+9]=5;  PS+=10;//part2  /// 1 measure
   array[PS]=1;      array[PS+1]=3;      array[PS+2]=2;      array[PS+3]=1;      array[PS+4]=1;      array[PS+5]=0;      array[PS+6]=0;      array[PS+7]=2;      array[PS+8]=3;      array[PS+9]=5;  PS+=10;//part3  /// 1 bar
   array[PS]=2;      array[PS+1]=2;      array[PS+2]=2;      array[PS+3]=1;      array[PS+4]=1;      array[PS+5]=0;      array[PS+6]=0;      array[PS+7]=2;      array[PS+8]=3;      array[PS+9]=5;  PS+=10;//part4  /// no looping for first 4 parts
   array[PS]=3;      array[PS+1]=3;      array[PS+2]=2;      array[PS+3]=1;      array[PS+4]=1;      array[PS+5]=1;      array[PS+6]=1;      array[PS+7]=4;      array[PS+8]=3;      array[PS+9]=5;  PS+=10;//part5  /// loop back to part1 four times after fifth part
//intermezzo1
   array[PS]=4;      array[PS+1]=6;      array[PS+2]=3;      array[PS+3]=4;      array[PS+4]=1;      array[PS+5]=0;      array[PS+6]=0;      array[PS+7]=2;      array[PS+8]=4;      array[PS+9]=4;  PS+=10;//part6  /// start intermezzo1 after loop is finished
//couplet2
   array[PS]=5;      array[PS+1]=5;      array[PS+2]=2;      array[PS+3]=1;      array[PS+4]=1;      array[PS+5]=0;      array[PS+6]=0;      array[PS+7]=2;      array[PS+8]=5;      array[PS+9]=5;  PS+=10;//part7  /// start another couplet with mostly same settings as first couplet
   array[PS]=1;      array[PS+1]=3;      array[PS+2]=2;      array[PS+3]=1;      array[PS+4]=1;      array[PS+5]=0;      array[PS+6]=0;      array[PS+7]=2;      array[PS+8]=6;      array[PS+9]=5;  PS+=10;//part8  /// some variations in preset selection and nominators (swapped)
   array[PS]=5;      array[PS+1]=3;      array[PS+2]=2;      array[PS+3]=1;      array[PS+4]=1;      array[PS+5]=0;      array[PS+6]=0;      array[PS+7]=2;      array[PS+8]=5;      array[PS+9]=5;  PS+=10;//part9
   array[PS]=1;      array[PS+1]=2;      array[PS+2]=2;      array[PS+3]=1;      array[PS+4]=1;      array[PS+5]=0;      array[PS+6]=0;      array[PS+7]=2;      array[PS+8]=6;      array[PS+9]=5;  PS+=10;//part10
   array[PS]=6;      array[PS+1]=6;      array[PS+2]=3;      array[PS+3]=1;      array[PS+4]=1;      array[PS+5]=1;      array[PS+6]=7;      array[PS+7]=2;      array[PS+8]=7;      array[PS+9]=5;  PS+=10;//part11  ///loop back to part7 two times, last part is twice as fast and length is doubled to remain "on the beat"
//intermezzo2
   array[PS]=4;      array[PS+1]=3;      array[PS+2]=3;      array[PS+3]=4;      array[PS+4]=2;      array[PS+5]=0;      array[PS+6]=0;      array[PS+7]=2;      array[PS+8]=7;      array[PS+9]=4;  PS+=10;//part12  /// start intermezzo2 after loop is finished with an intermediate faster timing
//chorus
   array[PS]=7;      array[PS+1]=3;      array[PS+2]=6;      array[PS+3]=1;      array[PS+4]=1;      array[PS+5]=0;      array[PS+6]=0;      array[PS+7]=2;      array[PS+8]=8;      array[PS+9]=6;  PS+=10;//part13  ///start chorus with some new presets and faster timing
   array[PS]=7;      array[PS+1]=3;      array[PS+2]=6;      array[PS+3]=1;      array[PS+4]=1;      array[PS+5]=0;      array[PS+6]=0;      array[PS+7]=2;      array[PS+8]=9;      array[PS+9]=6;  PS+=10;//part14
   array[PS]=7;      array[PS+1]=2;      array[PS+2]=6;      array[PS+3]=1;      array[PS+4]=1;      array[PS+5]=1;      array[PS+6]=13;     array[PS+7]=2;      array[PS+8]=10;     array[PS+9]=6;  PS+=10;//part15  loop back to part13 two times
//intermezzo3
   array[PS]=6;      array[PS+1]=8;      array[PS+2]=6;      array[PS+3]=1;      array[PS+4]=1;      array[PS+5]=0;      array[PS+6]=0;      array[PS+7]=2;      array[PS+8]=8;      array[PS+9]=4;  PS+=10;//part16
   array[PS]=5;      array[PS+1]=7;      array[PS+2]=5;      array[PS+3]=1;      array[PS+4]=1;      array[PS+5]=0;      array[PS+6]=0;      array[PS+7]=2;      array[PS+8]=6;      array[PS+9]=4;  PS+=10;//part17
   array[PS]=4;      array[PS+1]=6;      array[PS+2]=4;      array[PS+3]=1;      array[PS+4]=1;      array[PS+5]=0;      array[PS+6]=0;      array[PS+7]=2;      array[PS+8]=4;      array[PS+9]=4;  PS+=10;//part18
   array[PS]=3;      array[PS+1]=5;      array[PS+2]=3;      array[PS+3]=1;      array[PS+4]=1;      array[PS+5]=0;      array[PS+6]=0;      array[PS+7]=2;      array[PS+8]=3;      array[PS+9]=4;  PS+=10;//part19
   array[PS]=2;      array[PS+1]=4;      array[PS+2]=2;      array[PS+3]=1;      array[PS+4]=1;      array[PS+5]=0;      array[PS+6]=0;      array[PS+7]=2;      array[PS+8]=2;      array[PS+9]=4;  PS+=10;//part20
//couplet3
   array[PS]=9;      array[PS+1]=3;      array[PS+2]=3;      array[PS+3]=1;      array[PS+4]=1;      array[PS+5]=0;      array[PS+6]=0;      array[PS+7]=2;      array[PS+8]=4;      array[PS+9]=5;  PS+=10;//part21
   array[PS]=10;     array[PS+1]=5;      array[PS+2]=3;      array[PS+3]=1;      array[PS+4]=1;      array[PS+5]=0;      array[PS+6]=0;      array[PS+7]=2;      array[PS+8]=5;      array[PS+9]=5;  PS+=10;//part22
   array[PS]=9;      array[PS+1]=3;      array[PS+2]=3;      array[PS+3]=1;      array[PS+4]=1;      array[PS+5]=0;      array[PS+6]=0;      array[PS+7]=2;      array[PS+8]=4;      array[PS+9]=5;  PS+=10;//part23
   array[PS]=10;     array[PS+1]=2;      array[PS+2]=3;      array[PS+3]=1;      array[PS+4]=1;      array[PS+5]=0;      array[PS+6]=0;      array[PS+7]=2;      array[PS+8]=6;      array[PS+9]=5;  PS+=10;//part24
   array[PS]=11;     array[PS+1]=4;      array[PS+2]=4;      array[PS+3]=1;      array[PS+4]=1;      array[PS+5]=1;      array[PS+6]=21;     array[PS+7]=4;      array[PS+8]=8;      array[PS+9]=5;  PS+=10;//part25  loop back to part 21 4 times
//chorus
   array[PS]=12;     array[PS+1]=3;      array[PS+2]=6;      array[PS+3]=1;      array[PS+4]=1;      array[PS+5]=0;      array[PS+6]=0;      array[PS+7]=2;      array[PS+8]=11;     array[PS+9]=6;  PS+=10;//part26  ///start chorus with some new presets and faster timing
   array[PS]=13;     array[PS+1]=2;      array[PS+2]=6;      array[PS+3]=1;      array[PS+4]=1;      array[PS+5]=0;      array[PS+6]=0;      array[PS+7]=2;      array[PS+8]=11;     array[PS+9]=6;  PS+=10;//part27
   array[PS]=14;     array[PS+1]=3;      array[PS+2]=6;      array[PS+3]=1;      array[PS+4]=1;      array[PS+5]=0;      array[PS+6]=0;      array[PS+7]=2;      array[PS+8]=12;     array[PS+9]=6;  PS+=10; //part28 
   array[PS]=15;     array[PS+1]=3;      array[PS+2]=6;      array[PS+3]=1;      array[PS+4]=1;      array[PS+5]=0;      array[PS+6]=0;      array[PS+7]=2;      array[PS+8]=15;     array[PS+9]=7;  PS+=10;//part29  
   array[PS]=16;     array[PS+1]=2;      array[PS+2]=6;      array[PS+3]=1;      array[PS+4]=1;      array[PS+5]=0;      array[PS+6]=0;      array[PS+7]=2;      array[PS+8]=16;     array[PS+9]=7;  PS+=10;//part30
   array[PS]=17;     array[PS+1]=2;      array[PS+2]=6;     array[PS+3]=1;      array[PS+4]=1;      array[PS+5]=0;      array[PS+6]=0;      array[PS+7]=1;      array[PS+8]=16;     array[PS+9]=7;  PS+=10; //part31
   array[PS]=18;     array[PS+1]=2;      array[PS+2]=6;     array[PS+3]=1;      array[PS+4]=1;      array[PS+5]=1;      array[PS+6]=26;     array[PS+7]=2;      array[PS+8]=16;     array[PS+9]=7;  PS+=10; //part32

/* preset(0-127)    nominator(1-127)   denominator(1-127)   measures(1-128)	  bars(1-128)	        loop (0/1)       loop2part(0-127)	 loops(1-127)	     character(1-16)	(songpart(1-16)	 	part# (important to keep track of loop points)                 */

//outro
   array[PS]=19;     array[PS+1]=2;      array[PS+2]=4;      array[PS+3]=1;      array[PS+4]=1;      array[PS+5]=0;      array[PS+6]=0;      array[PS+7]=2;      array[PS+8]=13;     array[PS+9]=3;  PS+=10;//part33   ///decending denominator to reduce tempo
   array[PS]=20;     array[PS+1]=2;      array[PS+2]=3;      array[PS+3]=1;      array[PS+4]=1;      array[PS+5]=0;      array[PS+6]=0;      array[PS+7]=2;      array[PS+8]=10;     array[PS+9]=3;  PS+=10;//part34   ///all 1 measure and 1 bar, but different presets
   array[PS]=21;     array[PS+1]=2;      array[PS+2]=3;      array[PS+3]=1;      array[PS+4]=1;      array[PS+5]=0;      array[PS+6]=0;      array[PS+7]=2;      array[PS+8]=7;      array[PS+9]=3;  PS+=10;//part35   
   array[PS]=22;     array[PS+1]=2;      array[PS+2]=2;      array[PS+3]=1;      array[PS+4]=1;      array[PS+5]=0;      array[PS+6]=0;      array[PS+7]=2;      array[PS+8]=4;      array[PS+9]=2;  PS+=10;//part36
   array[PS]=23;     array[PS+1]=2;      array[PS+2]=2;      array[PS+3]=1;      array[PS+4]=1;      array[PS+5]=0;      array[PS+6]=0;      array[PS+7]=2;      array[PS+8]=2;      array[PS+9]=2;  PS+=10;//part37
   array[PS]=24;     array[PS+1]=2;      array[PS+2]=2;      array[PS+3]=1;      array[PS+4]=1;      array[PS+5]=0;      array[PS+6]=0;      array[PS+7]=2;      array[PS+8]=1;      array[PS+9]=1;  PS+=10;//part38
   array[PS]=25;     array[PS+1]=4;      array[PS+2]=1;      array[PS+3]=4;      array[PS+4]=4;      array[PS+5]=0;      array[PS+6]=0;      array[PS+7]=2;      array[PS+8]=1;      array[PS+9]=1;  PS+=10;//part39   ///last fade out
   array[PS]=26;     array[PS+1]=8;      array[PS+2]=1;      array[PS+3]=4;      array[PS+4]=4;      array[PS+5]=0;      array[PS+6]=0;      array[PS+7]=2;      array[PS+8]=1;      array[PS+9]=1;  PS+=10;//part40   ///last fade out


   //a bit of post editing to adjust the array values to the right set
   for(int i=0;i<(PS/10);i++){
   	int k=i*10;
   array[k+1]-=1;
   array[k+2]-=1;
   array[k+3]-=1;
   array[k+4]-=1;
   array[k+7]-=1;
   array[k+8]-=1;
   array[k+9]-=1;}
]]></sText>
         </text>
      </attribs>
      <object id="patch/object" uuid="0d31138b-39d7-4cee-b3f6-628800dddc3c">
         <sDescription>(USE WITH THE MODULE: patt/songtracker)
a songtracker to create songs
a song is divided into parts where each part is divided in bars, bars in measures and measures in steps.
Each part has it&apos;s own settings for:
-nominator (steps in measure)
-denominator (rate within the measure based on main tempo)
-amount of measures within a bar
-amount of bars within the part
-whether the part loops back to another part (repeating several parts as a whole)
-which part to loop back to
-how many times this loop has to be performed before going further to the next part after the loop. (don&apos;t loop back within another loop, otherwise it will loop endlessly)

the remaining controls set the last part of the song and whether the song will repeat after the last part has been played

These two modules should be able to setup whole songs (hopefully)</sDescription>
         <author>Remco van der Most</author>
         <license>BSD</license>
         <helpPatch>table.axh</helpPatch>
         <inlets>
            <bool32 name="copy2next" description="copies the current part to the next part (useful for quick polyrhythmic variations)"/>
            <bool32 name="copyfrom" description="copies the part selected with the &quot;from&quot; input to the current input."/>
            <int32 name="from" description="selects the part to copy from"/>
            <bool32 name="update" description="when triggered, updates the controls to the internal array (eg. when you load a song from SDcard-&gt;connect load button to this input)"/>
         </inlets>
         <outlets/>
         <displays/>
         <params>
            <int32 name="part" description="selects part in the song to edit">
               <MinValue i="1"/>
               <MaxValue i="128"/>
            </int32>
            <int32 name="preset" description="selects a preset for this part">
               <MinValue i="1"/>
               <MaxValue i="128"/>
            </int32>
            <int32 name="nominator" description="selects the amount of steps per measure for this part">
               <MinValue i="1"/>
               <MaxValue i="128"/>
            </int32>
            <int32 name="denominator" description="selects the rate of the measure for this part (measure can be understood as the &quot;beat&quot;, denominator sets division of this &quot;beat&quot;)">
               <MinValue i="1"/>
               <MaxValue i="128"/>
            </int32>
            <int32 name="measures" description="selects the amount of measures per bar for this part">
               <MinValue i="1"/>
               <MaxValue i="128"/>
            </int32>
            <int32 name="bars" description="selects the amount of bars for this part">
               <MinValue i="1"/>
               <MaxValue i="128"/>
            </int32>
            <bool32.tgl name="loopback" description="when high and the loopmax hasn&apos;t been reach yet, sends the song back to the selected part"/>
            <int32 name="loop2part" description="selects the part to which the song has to return when this part has ended">
               <MinValue i="1"/>
               <MaxValue i="128"/>
            </int32>
            <int32 name="loops" description="selects how many times the parts must loop before continuing to the next part">
               <MinValue i="2"/>
               <MaxValue i="128"/>
            </int32>
            <int32 name="songpart">
               <MinValue i="1"/>
               <MaxValue i="128"/>
            </int32>
            <int32 name="character">
               <MinValue i="1"/>
               <MaxValue i="128"/>
            </int32>
            <int32 name="lastpart" description="selects the last part of the song">
               <MinValue i="1"/>
               <MaxValue i="128"/>
            </int32>
            <bool32.tgl name="loopparts" description="when high, restarts the song at start position. When low, song stops playing after the last part has been played"/>
         </params>
         <attribs>
            <combo name="size">
               <MenuEntries>
                  <string>2</string>
                  <string>4</string>
                  <string>8</string>
                  <string>16</string>
                  <string>32</string>
                  <string>64</string>
                  <string>128</string>
                  <string>256</string>
                  <string>512</string>
                  <string>1024</string>
                  <string>2048</string>
                  <string>4096</string>
                  <string>8192</string>
                  <string>16384</string>
                  <string>32768</string>
                  <string>65536</string>
                  <string>131072</string>
                  <string>262144</string>
                  <string>524288</string>
                  <string>1048576</string>
                  <string>2097152</string>
                  <string>4194304</string>
               </MenuEntries>
               <CEntries>
                  <string>1</string>
                  <string>2</string>
                  <string>3</string>
                  <string>4</string>
                  <string>5</string>
                  <string>6</string>
                  <string>7</string>
                  <string>8</string>
                  <string>9</string>
                  <string>10</string>
                  <string>11</string>
                  <string>12</string>
                  <string>13</string>
                  <string>14</string>
                  <string>15</string>
                  <string>16</string>
                  <string>17</string>
                  <string>18</string>
                  <string>19</string>
                  <string>20</string>
                  <string>21</string>
                  <string>22</string>
               </CEntries>
            </combo>
            <text name="init"/>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[static const uint32_t LENGTHPOW = (attr_size);
static const uint32_t LENGTH = (1<<attr_size);
static const uint32_t LENGTHMASK = ((1<<attr_size)-1);
static const uint32_t BITS = 8;
static const uint32_t GAIN = 20;
int8_t *array;
int part,i,max;
bool upd,DO,loop,copy,from;
int32_t total,ptotal;]]></code.declaration>
         <code.init><![CDATA[static int8_t _array[LENGTH*10] __attribute__ ((section (".sdram")));
array = &_array[0];

//  for(i=0;i<LENGTH<<3;i++){ array[i]=0;
//}
attr_init;
part=10;
DO=0;]]></code.init>
         <code.krate><![CDATA[if(inlet_update&&!upd){upd=1;
DO=1;
}
else if(upd&&!inlet_update){upd=0;}
if(inlet_copyfrom&&!from){
	from=1;
	DO=1;
	for(i=0;i<10;i++){
	array[(param_part-1)*10+i]=array[i+(__USAT(inlet_from-1,28)<<3)];
	}
}
else if(from&&!inlet_copyfrom){from=0;}


if((!(((param_part-1)*10)==part))||DO){
	part=(param_part-1)*10;
	for(i=0;i<10;i++){
	PExParameterChange(&parent->PExch[PARAM_INDEX_attr_legal_name_preset+i],array[part+i]+(!(i==5)?1:0),0xFFFD);
	}
	if(DO){DO=0;}
}

if(inlet_copy2next&&!copy){
	copy=1;
	for(i=0;i<10;i++){
		array[part+i+10]=array[part+i];
	}
}
else if(copy&&!inlet_copy2next){copy=0;}




loop=param_loopparts;
max=param_lastpart-1;
array[part]=param_preset-1;
array[part+1]=param_nominator-1;
array[part+2]=param_denominator-1;
array[part+3]=param_measures-1;
array[part+4]=param_bars-1;
array[part+5]=param_loopback;
array[part+6]=param_loop2part-1;
array[part+7]=param_loops-1;
array[part+8]=param_character-1;
array[part+9]=param_songpart-1;
total=0;
for(i=0;i<10;i++){
	total+=array[part+i];
}
if((!(ptotal==total))&&(param_part>param_lastpart)){
	PExParameterChange(&parent->PExch[PARAM_INDEX_attr_legal_name_lastpart],param_part,0xFFFD);
}


ptotal=total;]]></code.krate>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="cc7921fa-bcb4-41be-91b8-a512646fbf6c" name="counter_1" x="336" y="462">
      <params>
         <frac32.u.map name="addLoop" value="16.18499994277954"/>
      </params>
      <attribs>
         <objref attributeName="memory" obj="songtable"/>
      </attribs>
      <object id="patch/object" uuid="cc7921fa-bcb4-41be-91b8-a512646fbf6c">
         <sDescription>(USE WITH MODULE: patt/songsetup)
A tracker consisting of several counters that uses the stored table of the &quot;songsetup&quot; module to play a song.

The integer outputs give the &quot;counter position&quot; or &quot;counter maximum&quot; of the respective counters.
These are seperated into:
-independent outputs for the different counters (steps/measure, measures/bar,bars/part,parts/song) and their own maximum steplength.
-combinations of 2,3 or 4 counters and their combined maximum steplength.

By controlling pattern and preset generators/controllers with these outputs, these two modules should be able to setup whole songs (hopefully)</sDescription>
         <author>Johannes Taelman</author>
         <license>BSD</license>
         <helpPatch>counter.axh</helpPatch>
         <inlets>
            <frac32 name="tempo" description="sets tempo base (tempo of the measure, denominator sets the rate according to the amount of steps per measure based on this tempo)"/>
            <bool32.rising name="r" description="instant restart of the song while playing at the selected part"/>
            <int32 name="reset2part" description="selected part to reset to"/>
            <bool32 name="play" description="when triggered, song starts playing"/>
            <bool32 name="pause" description="when triggered, song pauses at current position until play is pressed"/>
            <bool32 name="stop" description="when triggered, song stops and is reset to start position"/>
         </inlets>
         <outlets>
            <bool32 name="run" description="goes high when sequencer is running"/>
            <bool32.pulse name="clock" description="main clock output (denominator * main tempo)"/>
            <int32 name="step" description="step position within measure"/>
            <int32 name="maxstep" description="maximum steps in the measure"/>
            <int32 name="measure" description="measure position within the bar"/>
            <int32 name="maxmeasure" description="maximum measures in the bar"/>
            <int32 name="bar" description="bar position within the part"/>
            <int32 name="maxbar" description="maximum bars in the part"/>
            <int32 name="part" description="part position within the song"/>
            <int32 name="loop" description="loop position of parts"/>
            <int32 name="loopmax" description="maximum loops of parts"/>
            <int32 name="maxparts" description="maximum pars in the song"/>
            <int32 name="preset" description="preset selection of the part"/>
            <int32 name="character" description="same as preset, could be used to define the part of a song as chorus, couplet, intermezzo to add variations in sound character"/>
            <int32 name="songpart" description="same as preset, could be used to define the part of a song as chorus, couplet, intermezzo to add variations in presets"/>
            <int32 name="sm" description="position of stop+measure within bar"/>
            <int32 name="smmax" description="maximum steps in bar"/>
            <int32 name="smb" description="position of stop+measure+bar within part"/>
            <int32 name="smbmax" description="maximum steps in part"/>
            <int32 name="smbp" description="WRONG position of stop+measure+bar+part within song(difference in steps per part!)"/>
            <int32 name="smbpmax" description="WRONG maximum steps in song (difference in steps per part!)"/>
            <int32 name="mb" description="position of measure+bar within part (steps quantized to measure)"/>
            <int32 name="mbmax" description="maximumum measures in part"/>
            <int32 name="mbp" description="WRONG position of measure+bar+part within song  (difference in measures per part!)"/>
            <int32 name="mbpmax" description="WRONG maximum measures in song (difference in measures per part!)"/>
            <int32 name="bp" description="WRONG position of bar+part within song (difference in bars per part!)"/>
            <int32 name="bpmax" description="WRONG maximum bars in song (difference in bars per part!)"/>
            <bool32 name="replay" description="outputs a trigger when song restarts (useful for randomisations for a &quot;new&quot; song)"/>
         </outlets>
         <displays/>
         <params>
            <frac32.u.map name="addLoop" description="when parts are looping, the looping index is multiplied with this value for an offset of the counters. Normally not really useful, but in this patch is provides extra variation"/>
         </params>
         <attribs>
            <objref name="memory"/>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[int32_t phs;
bool ntrig,rtrig,start,play,pause,stop,run,replay;
   int i;
   int cnt[5];
int Sc;
int Sm;
int Mc;
int Mm;
int Bc;
int Bm;
int Pc;
int Pm;
int lc,lm;
int character,songpart,pst;]]></code.declaration>
         <code.init><![CDATA[for(i=0;i<5;i++){
cnt[i]=0;
}
   ntrig = 0;
   rtrig = 0;
   start=1;
   run=0;]]></code.init>
         <code.krate><![CDATA[replay=0;
if(inlet_play&&!play){
     replay=1; ///remove when you don't want to update at play start
	play=1;
	run=1;
}
else if(play&&!inlet_play){play=0;}

if(inlet_pause&&!pause){
	pause=1;
	run=0;
}
else if(pause&&!inlet_pause){pause=0;}
int rst=inlet_r;
if(inlet_stop&&!stop){
	stop=1;
	run=0;
	phs=1;
	ntrig=0;
	for(i=0;i<5;i++){cnt[i]=0;}
	replay=1;
}
else if(stop&&!inlet_stop){stop=0;}


if ((rst>0) && !rtrig) {
for(i=0;i<5;i++){
cnt[i]=0;
}
cnt[3]=inlet_reset2part>0?inlet_reset2part-1:0;
rtrig = 1;
start=1;}
else if (!(rst>0)){
	rtrig=0;
}
int part=cnt[3]*10;
outlet_clock=0;
if(run>0){
int32_t frq;
MTOF(inlet_tempo,frq)
frq=frq>>2;

phs+=frq*(attr_memory.array[2+part]+1);
if(phs>0){	outlet_clock=1;}
if ((phs>0) && !ntrig) {

   cnt[0] += 1;//steps cnt[0]
   if(start==1){
   	cnt[0]=0;
   	start=0;
   }
   if (cnt[0]>=(attr_memory.array[part+1]+1))
   {//measure cnt[1]
   	cnt[0] = 0;
   	cnt[1]+=1;
   	if (cnt[1]>=(attr_memory.array[part+3]+1))
   	{//bars cnt[3]
   		cnt[1]=0;
   		cnt[2]+=1;
  		if(cnt[2]>=(attr_memory.array[part+4]+1))
   		{
   			if(attr_memory.array[part+5]==0)
   			{//loopback off
   				cnt[3]+=1;
   			}
   			else
   			{//loopback on
   				if(cnt[4]<(attr_memory.array[7]+1))
   				{
   					cnt[3]=attr_memory.array[part+6];
   					cnt[4]+=1;
   				}
   				else
				{
   					cnt[3]+=1;cnt[4]=0;
   				}
   			}
   			cnt[2]=0;
   		}
   	}
   }
   ntrig=1;
}
else if
	(!(phs>0)) {ntrig=0;
}

}



if(cnt[3]>attr_memory.max){
if(attr_memory.loop>0){
	for(i=0;i<5;i++){
		cnt[i]=0;
		
	}
	start=1;
	replay=1;
}
else{run=0;
for(i=0;i<5;i++)
{
cnt[i]=0;
}
start=1;}
}
outlet_run=run;

if(run>0){
Sc=cnt[0];
Sm=attr_memory.array[part+1]+1;
Mc=cnt[1];
Mm=attr_memory.array[part+3]+1;
Bc=cnt[2];
Bm=attr_memory.array[part+4]+1;
Pc=cnt[3];
Pm=attr_memory.max;
lc=cnt[4];
lm=attr_memory.array[part+7]+1;
character=attr_memory.array[part+8];
songpart=attr_memory.array[part+9];
pst=attr_memory.array[part];
}
int add=(param_addLoop>>27-attr_memory.LENGTHPOW)*lc;
outlet_step=Sc;
outlet_maxstep=Sm;
outlet_measure=Mc;
outlet_maxmeasure=Mm;
outlet_bar=Bc;
outlet_maxbar=Bm;
outlet_part=Pc;
outlet_maxparts=Pm;
outlet_loop=lc;
outlet_loopmax=lm;
outlet_character=character;
outlet_songpart=songpart;
outlet_preset=pst;

outlet_sm=Sc+Mc*Sm+add;
outlet_smmax=Sm*Mm;
outlet_smb=outlet_sm+Bc*Mm*Sm+add;
outlet_smbmax=outlet_smmax*Bm;
outlet_smbp=outlet_smb+Pc*Bm*Mm*Sm+add;
outlet_smbpmax=outlet_smbmax*Pm;
outlet_mb=Mc+Bc*Mm+add;
outlet_mbmax=Mm*Bm;
outlet_mbp=outlet_mb+Pc*Mm*Bm+add;
outlet_mbpmax=outlet_mbmax*Pm;
outlet_bp=Bc+Pc*Bm+add;
outlet_bpmax=Bm*Pm;
outlet_replay=replay;]]></code.krate>
      </object>
   </patchobj>
   <obj type="logic/counter" uuid="7a141ba82230e54e5f5cd12da5dbe5a74ba854a5" name="counter_2" x="490" y="462">
      <params>
         <int32 name="maximum" value="1"/>
      </params>
      <attribs/>
   </obj>
   <obj type="rand/uniform i" uuid="9b1f945f346af0165ed99b8e19136cdbf744e594" name="uniform_2" x="574" y="462">
      <params>
         <int32 name="max" value="8"/>
      </params>
      <attribs/>
   </obj>
   <obj type="mux/mux 7" uuid="acffd8c464bff1c18d4083c854668d443d656b41" name="preset modulate" x="658" y="462">
      <params/>
      <attribs/>
   </obj>
   <patchobj type="patch/object" uuid="850e5735-a8ed-4b9a-b6b5-40e3b6de9721" name="alloc_1" x="728" y="462">
      <params/>
      <attribs>
         <combo attributeName="size" selection="16384"/>
      </attribs>
      <object id="patch/object" uuid="850e5735-a8ed-4b9a-b6b5-40e3b6de9721">
         <sDescription>allocate table in SDRAM memory, -128..127</sDescription>
         <author>Johannes Taelman</author>
         <license>BSD</license>
         <helpPatch>table.axh</helpPatch>
         <inlets>
            <bool32 name="rnd"/>
         </inlets>
         <outlets/>
         <displays/>
         <params/>
         <attribs>
            <combo name="size">
               <MenuEntries>
                  <string>2</string>
                  <string>4</string>
                  <string>8</string>
                  <string>16</string>
                  <string>32</string>
                  <string>64</string>
                  <string>128</string>
                  <string>256</string>
                  <string>512</string>
                  <string>1024</string>
                  <string>2048</string>
                  <string>4096</string>
                  <string>8192</string>
                  <string>16384</string>
                  <string>32768</string>
                  <string>65536</string>
                  <string>131072</string>
                  <string>262144</string>
                  <string>524288</string>
                  <string>1048576</string>
                  <string>2097152</string>
                  <string>4194304</string>
               </MenuEntries>
               <CEntries>
                  <string>1</string>
                  <string>2</string>
                  <string>3</string>
                  <string>4</string>
                  <string>5</string>
                  <string>6</string>
                  <string>7</string>
                  <string>8</string>
                  <string>9</string>
                  <string>10</string>
                  <string>11</string>
                  <string>12</string>
                  <string>13</string>
                  <string>14</string>
                  <string>15</string>
                  <string>16</string>
                  <string>17</string>
                  <string>18</string>
                  <string>19</string>
                  <string>20</string>
                  <string>21</string>
                  <string>22</string>
               </CEntries>
            </combo>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[static const uint32_t LENGTHPOW = (attr_size);
static const uint32_t LENGTH = (1<<attr_size);
static const uint32_t LENGTHMASK = ((1<<attr_size)-1);
static const uint32_t BITS = 8;
static const uint32_t GAIN = 20;
uint8_t *array;
bool rnd;]]></code.declaration>
         <code.init><![CDATA[static uint8_t _array[LENGTH] __attribute__ ((section (".sdram")));
array = &_array[0];
{ 
  int i;
  for(i=0;i<LENGTH;i++) array[i]=(uint8_t)GenerateRandomNumber();
}]]></code.init>
         <code.krate><![CDATA[if(inlet_rnd&&!rnd){
	rnd=1;
	for(int i=0;i<LENGTH;i++){
		array[i]=(int8_t)GenerateRandomNumber();
	}
}
else if(rnd&&!inlet_rnd){rnd=0;}]]></code.krate>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="31254712-5f42-4fd2-8af1-256f0024ef1f" name="*_1" x="910" y="462">
      <params/>
      <attribs>
         <objref attributeName="table" obj="alloc_1"/>
      </attribs>
      <object id="patch/object" uuid="31254712-5f42-4fd2-8af1-256f0024ef1f">
         <sDescription>multiply</sDescription>
         <author>Johannes Taelman</author>
         <license>BSD</license>
         <helpPatch>math.axh</helpPatch>
         <inlets>
            <int32 name="a" description="input"/>
            <frac32 name="b" description="input"/>
         </inlets>
         <outlets>
            <frac32 name="result" description="output"/>
         </outlets>
         <displays/>
         <params/>
         <attribs>
            <objref name="table"/>
         </attribs>
         <includes/>
         <code.krate><![CDATA[outlet_result= (int64_t)inlet_a*inlet_b>>27-attr_table.LENGTHPOW;]]></code.krate>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="31254712-5f42-4fd2-8af1-256f0024ef1f" name="*_2" x="1036" y="462">
      <params/>
      <attribs>
         <objref attributeName="table" obj="alloc_1"/>
      </attribs>
      <object id="patch/object" uuid="31254712-5f42-4fd2-8af1-256f0024ef1f">
         <sDescription>multiply</sDescription>
         <author>Johannes Taelman</author>
         <license>BSD</license>
         <helpPatch>math.axh</helpPatch>
         <inlets>
            <int32 name="a" description="input"/>
            <frac32 name="b" description="input"/>
         </inlets>
         <outlets>
            <frac32 name="result" description="output"/>
         </outlets>
         <displays/>
         <params/>
         <attribs>
            <objref name="table"/>
         </attribs>
         <includes/>
         <code.krate><![CDATA[outlet_result= (int64_t)inlet_a*inlet_b>>27-attr_table.LENGTHPOW;]]></code.krate>
      </object>
   </patchobj>
   <comment type="patch/comment" x="1190" y="462" text="random +7/-7 key change"/>
   <patchobj type="patch/object" uuid="7f2498dd-5219-4a81-afa9-60001dbf0b56" name="uniform_1" x="1218" y="476">
      <params/>
      <attribs/>
      <object id="patch/object" uuid="7f2498dd-5219-4a81-afa9-60001dbf0b56">
         <sDescription>uniform distributed (white) noise, k-rate generation. Range 0..(n-1)</sDescription>
         <author>Johannes Taelman</author>
         <license>BSD</license>
         <inlets>
            <bool32.rising name="trig" description="trigger"/>
         </inlets>
         <outlets>
            <int32 name="v" description="random value"/>
         </outlets>
         <displays/>
         <params/>
         <attribs/>
         <includes/>
         <code.declaration><![CDATA[int32_t val;
int ntrig;
]]></code.declaration>
         <code.init><![CDATA[val = 0;
ntrig = 0;
]]></code.init>
         <code.krate><![CDATA[if ((inlet_trig>0) && !ntrig) {

         val += (int32_t)(GenerateRandomNumber()&1)>0?7:-7;
      val+=val>11?-12:0;
      val+=val<0?12:0;
      ntrig=1;
   }
   else if (!(inlet_trig>0)) ntrig=0;
   outlet_v = val;]]></code.krate>
      </object>
   </patchobj>
   <obj type="math/+" uuid="44553fdc8628c67ab535845ed1be304ad6c9553b" name="+_2" x="770" y="546">
      <params/>
      <attribs/>
   </obj>
   <comment type="patch/comment" x="1540" y="560" text="REMOVE MAX INPUTS"/>
   <comment type="patch/comment" x="2100" y="560" text="guitar chord based note quantizer"/>
   <comment type="patch/comment" x="490" y="574" text="individual outputs"/>
   <patchobj type="patch/object" uuid="ded2f803-c81f-4965-bc9c-b59c410a420b" name="object_21" x="980" y="574">
      <params>
         <frac32.u.map name="treshold" value="43.0"/>
      </params>
      <attribs>
         <objref attributeName="table" obj="alloc_1"/>
      </attribs>
      <object id="patch/object" uuid="ded2f803-c81f-4965-bc9c-b59c410a420b">
         <inlets>
            <int32 name="count"/>
            <int32 name="max"/>
            <bool32 name="rnd"/>
            <frac32 name="ofs"/>
         </inlets>
         <outlets>
            <bool32 name="out"/>
         </outlets>
         <displays/>
         <params>
            <frac32.u.map name="treshold"/>
         </params>
         <attribs>
            <objref name="table"/>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[bool rnd;
int ofs,count;
int i;]]></code.declaration>
         <code.init><![CDATA[ofs=(int32_t)GenerateRandomNumber();]]></code.init>
         <code.krate><![CDATA[if(inlet_rnd&&!rnd){
	rnd=1;
	ofs=(int32_t)GenerateRandomNumber();
}
else if(rnd&&!inlet_rnd){rnd=0;}

outlet_out=attr_table.array[(inlet_count+ofs+inlet_ofs)&attr_table.LENGTHMASK]>(param_treshold>>19)?(!(inlet_count==count)):0;
count=inlet_count;]]></code.krate>
      </object>
   </patchobj>
   <obj type="logic/counter" uuid="7a141ba82230e54e5f5cd12da5dbe5a74ba854a5" name="counter_4" x="1106" y="574">
      <params>
         <int32 name="maximum" value="2"/>
      </params>
      <attribs/>
   </obj>
   <patchobj type="patch/object" uuid="ded2f803-c81f-4965-bc9c-b59c410a420b" name="object_6" x="1190" y="574">
      <params>
         <frac32.s.map name="max" value="4.0"/>
         <frac32.s.map name="min" value="0.0"/>
      </params>
      <attribs>
         <objref attributeName="table" obj="alloc_1"/>
      </attribs>
      <object id="patch/object" uuid="ded2f803-c81f-4965-bc9c-b59c410a420b">
         <inlets>
            <int32 name="count"/>
            <int32 name="max"/>
            <bool32 name="rnd"/>
            <frac32 name="ofs"/>
         </inlets>
         <outlets>
            <frac32 name="out"/>
         </outlets>
         <displays/>
         <params>
            <frac32.s.map name="max"/>
            <frac32.s.map name="min"/>
         </params>
         <attribs>
            <objref name="table"/>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[bool rnd;
int ofs;
int i;]]></code.declaration>
         <code.init><![CDATA[ofs=(int32_t)GenerateRandomNumber();]]></code.init>
         <code.krate><![CDATA[if(inlet_rnd&&!rnd){
	rnd=1;
	ofs=(int32_t)GenerateRandomNumber();
}
else if(rnd&&!inlet_rnd){rnd=0;}
int32_t width=param_max-param_min<<3;
outlet_out=___SMMUL((attr_table.array[(inlet_count+ofs+inlet_ofs)&attr_table.LENGTHMASK]<<21),width)+param_min;]]></code.krate>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="ded2f803-c81f-4965-bc9c-b59c410a420b" name="object_25" x="1316" y="574">
      <params>
         <frac32.s.map name="max" value="4.0"/>
         <frac32.s.map name="min" value="0.0"/>
      </params>
      <attribs>
         <objref attributeName="table" obj="alloc_1"/>
      </attribs>
      <object id="patch/object" uuid="ded2f803-c81f-4965-bc9c-b59c410a420b">
         <inlets>
            <int32 name="count"/>
            <int32 name="max"/>
            <bool32 name="rnd"/>
            <frac32 name="ofs"/>
         </inlets>
         <outlets>
            <frac32 name="out"/>
         </outlets>
         <displays/>
         <params>
            <frac32.s.map name="max"/>
            <frac32.s.map name="min"/>
         </params>
         <attribs>
            <objref name="table"/>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[bool rnd;
int ofs;
int i;]]></code.declaration>
         <code.init><![CDATA[ofs=(int32_t)GenerateRandomNumber();]]></code.init>
         <code.krate><![CDATA[if(inlet_rnd&&!rnd){
	rnd=1;
	ofs=(int32_t)GenerateRandomNumber();
}
else if(rnd&&!inlet_rnd){rnd=0;}
int32_t width=param_max-param_min<<3;
outlet_out=___SMMUL((attr_table.array[(inlet_count+ofs+inlet_ofs)&attr_table.LENGTHMASK]<<21),width)+param_min;]]></code.krate>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="ded2f803-c81f-4965-bc9c-b59c410a420b" name="object_24" x="1470" y="574">
      <params>
         <frac32.s.map name="max" value="8.0"/>
         <frac32.s.map name="min" value="0.0"/>
      </params>
      <attribs>
         <objref attributeName="table" obj="alloc_1"/>
      </attribs>
      <object id="patch/object" uuid="ded2f803-c81f-4965-bc9c-b59c410a420b">
         <inlets>
            <int32 name="count"/>
            <int32 name="max"/>
            <bool32 name="rnd"/>
            <frac32 name="ofs"/>
         </inlets>
         <outlets>
            <frac32 name="out"/>
         </outlets>
         <displays/>
         <params>
            <frac32.s.map name="max"/>
            <frac32.s.map name="min"/>
         </params>
         <attribs>
            <objref name="table"/>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[bool rnd;
int ofs;
int i;]]></code.declaration>
         <code.init><![CDATA[ofs=(int32_t)GenerateRandomNumber();]]></code.init>
         <code.krate><![CDATA[if(inlet_rnd&&!rnd){
	rnd=1;
	ofs=(int32_t)GenerateRandomNumber();
}
else if(rnd&&!inlet_rnd){rnd=0;}
int32_t width=param_max-param_min<<3;
outlet_out=___SMMUL((attr_table.array[(inlet_count+ofs+inlet_ofs)&attr_table.LENGTHMASK]<<21),width)+param_min;]]></code.krate>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="ded2f803-c81f-4965-bc9c-b59c410a420b" name="object_4" x="1596" y="574">
      <params>
         <frac32.s.map name="max" value="8.0"/>
         <frac32.s.map name="min" value="0.0"/>
      </params>
      <attribs>
         <objref attributeName="table" obj="alloc_1"/>
      </attribs>
      <object id="patch/object" uuid="ded2f803-c81f-4965-bc9c-b59c410a420b">
         <inlets>
            <int32 name="count"/>
            <int32 name="max"/>
            <bool32 name="rnd"/>
            <frac32 name="ofs"/>
         </inlets>
         <outlets>
            <frac32 name="out"/>
         </outlets>
         <displays/>
         <params>
            <frac32.s.map name="max"/>
            <frac32.s.map name="min"/>
         </params>
         <attribs>
            <objref name="table"/>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[bool rnd;
int ofs;
int i;]]></code.declaration>
         <code.init><![CDATA[ofs=(int32_t)GenerateRandomNumber();]]></code.init>
         <code.krate><![CDATA[if(inlet_rnd&&!rnd){
	rnd=1;
	ofs=(int32_t)GenerateRandomNumber();
}
else if(rnd&&!inlet_rnd){rnd=0;}
int32_t width=param_max-param_min<<3;
outlet_out=___SMMUL((attr_table.array[(inlet_count+ofs+inlet_ofs)&attr_table.LENGTHMASK]<<21),width)+param_min;]]></code.krate>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="ded2f803-c81f-4965-bc9c-b59c410a420b" name="object_8" x="1722" y="574">
      <params>
         <frac32.s.map name="max" value="11.0"/>
         <frac32.s.map name="min" value="-1.0"/>
      </params>
      <attribs>
         <objref attributeName="table" obj="alloc_1"/>
      </attribs>
      <object id="patch/object" uuid="ded2f803-c81f-4965-bc9c-b59c410a420b">
         <inlets>
            <int32 name="count"/>
            <int32 name="max"/>
            <bool32 name="rnd"/>
            <frac32 name="ofs"/>
         </inlets>
         <outlets>
            <frac32 name="out"/>
         </outlets>
         <displays/>
         <params>
            <frac32.s.map name="max"/>
            <frac32.s.map name="min"/>
         </params>
         <attribs>
            <objref name="table"/>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[bool rnd;
int ofs;
int i;]]></code.declaration>
         <code.init><![CDATA[ofs=(int32_t)GenerateRandomNumber();]]></code.init>
         <code.krate><![CDATA[if(inlet_rnd&&!rnd){
	rnd=1;
	ofs=(int32_t)GenerateRandomNumber();
}
else if(rnd&&!inlet_rnd){rnd=0;}
int32_t width=param_max-param_min<<3;
outlet_out=___SMMUL((attr_table.array[(inlet_count+ofs+inlet_ofs)&attr_table.LENGTHMASK]<<21),width)+param_min;]]></code.krate>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="ded2f803-c81f-4965-bc9c-b59c410a420b" name="object_11" x="1848" y="574">
      <params>
         <frac32.s.map name="max" value="7.0"/>
         <frac32.s.map name="min" value="0.0"/>
      </params>
      <attribs>
         <objref attributeName="table" obj="alloc_1"/>
      </attribs>
      <object id="patch/object" uuid="ded2f803-c81f-4965-bc9c-b59c410a420b">
         <inlets>
            <int32 name="count"/>
            <int32 name="max"/>
            <bool32 name="rnd"/>
            <frac32 name="ofs"/>
         </inlets>
         <outlets>
            <frac32 name="out"/>
         </outlets>
         <displays/>
         <params>
            <frac32.s.map name="max"/>
            <frac32.s.map name="min"/>
         </params>
         <attribs>
            <objref name="table"/>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[bool rnd;
int ofs;
int i;]]></code.declaration>
         <code.init><![CDATA[ofs=(int32_t)GenerateRandomNumber();]]></code.init>
         <code.krate><![CDATA[if(inlet_rnd&&!rnd){
	rnd=1;
	ofs=(int32_t)GenerateRandomNumber();
}
else if(rnd&&!inlet_rnd){rnd=0;}
int32_t width=param_max-param_min<<3;
outlet_out=___SMMUL((attr_table.array[(inlet_count+ofs+inlet_ofs)&attr_table.LENGTHMASK]<<21),width)+param_min;]]></code.krate>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="ded2f803-c81f-4965-bc9c-b59c410a420b" name="object_12" x="1974" y="574">
      <params>
         <frac32.s.map name="max" value="8.0"/>
         <frac32.s.map name="min" value="0.0"/>
      </params>
      <attribs>
         <objref attributeName="table" obj="alloc_1"/>
      </attribs>
      <object id="patch/object" uuid="ded2f803-c81f-4965-bc9c-b59c410a420b">
         <inlets>
            <int32 name="count"/>
            <int32 name="max"/>
            <bool32 name="rnd"/>
            <frac32 name="ofs"/>
         </inlets>
         <outlets>
            <frac32 name="out"/>
         </outlets>
         <displays/>
         <params>
            <frac32.s.map name="max"/>
            <frac32.s.map name="min"/>
         </params>
         <attribs>
            <objref name="table"/>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[bool rnd;
int ofs;
int i;]]></code.declaration>
         <code.init><![CDATA[ofs=(int32_t)GenerateRandomNumber();]]></code.init>
         <code.krate><![CDATA[if(inlet_rnd&&!rnd){
	rnd=1;
	ofs=(int32_t)GenerateRandomNumber();
}
else if(rnd&&!inlet_rnd){rnd=0;}
int32_t width=param_max-param_min<<3;
outlet_out=___SMMUL((attr_table.array[(inlet_count+ofs+inlet_ofs)&attr_table.LENGTHMASK]<<21),width)+param_min;]]></code.krate>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="f559e1b0-bd3b-4990-81d9-4daef1f1e453" name="+_1" x="2100" y="574">
      <params>
         <int32 name="offset" value="1"/>
      </params>
      <attribs/>
      <object id="patch/object" uuid="f559e1b0-bd3b-4990-81d9-4daef1f1e453">
         <sDescription>add</sDescription>
         <author>Johannes Taelman</author>
         <license>BSD</license>
         <helpPatch>math.axh</helpPatch>
         <inlets>
            <int32 name="chord" description="select 1 out of 7 chords in the scale"/>
            <int32 name="change" description="selects one of upper 3 channels to modulate"/>
            <int32 name="note" description="sets note to modulate the selected channel"/>
            <int32 name="key" description="offsets the scale"/>
            <int32 name="shift" description="shift chord over the fretboard, creating other chords (follows key/scale)"/>
            <bool32 name="negativeHrm"/>
         </inlets>
         <outlets>
            <int32 name="o1" description="E string"/>
            <int32 name="o2" description="A string"/>
            <int32 name="o3" description="D string"/>
            <int32 name="o4" description="G string"/>
            <int32 name="o5" description="B string"/>
            <int32 name="o6" description="E string"/>
            <int32 name="bass" description="note for the bassline"/>
            <int32 name="sel" description="used to connect to a mux to select which &quot;string&quot; is the bass note of the guitar chord"/>
         </outlets>
         <displays/>
         <params>
            <int32 name="offset">
               <MinValue i="-6"/>
               <MaxValue i="6"/>
            </int32>
         </params>
         <attribs/>
         <includes/>
         <code.declaration><![CDATA[int NT[6][8]=
{
	{0,1,3,5,7,8,10,12},
	{0,2,3,5,7,8,10,12},
	{0,2,3,5,7,9,10,12},
	{0,2,4,5,7,9,10,12},
	{0,1,3,5,6,8,10,12},
	{0,1,3,5,7,8,10,12}
};

int B[7]={1,2,0,0,0,1,1};

int chord[7][6]=
{
	{0,2,1,0,1,0},//C
	{1,0,0,1,2,1},//Dm
	{0,1,1,0,0,0},//Em
	{1,2,2,1,1,1},//F
	{2,1,0,0,0,3},//G
	{0,0,1,1,1,0},//Am
	{1,1,0,2,2,1}//Bdim
};

int Notes[2][12];]]></code.declaration>
         <code.init><![CDATA[int i;
for(i=0;i<12;i++){
	Notes[0][i]=i;
	Notes[1][i]=11-i;
}]]></code.init>
         <code.krate><![CDATA[int note[6];
int semi;
int oct;
int in=inlet_chord;
in=in-in/7*7;
in+=in<0?7:0;
int S=(inlet_change+3);
S=S>0?S:-S;
S=S-S/6*6;
for(int i=0;i<6;i++){
int sel=(chord[in][i]);
if(i==S){
	sel=inlet_note&7;
}
sel+=inlet_shift-inlet_key;
note[i]=NT[i][sel&7]+inlet_key+((sel>>3)&1)*12;
}

note[1]+=5;
note[2]+=10;
note[3]+=15;
note[4]+=19;
note[5]+=24;

for(int i=0;i<6;i++){
int Oct;
int Semi;
Oct=note[i]/12;
Semi=note[i]-Oct*12;
if(semi<0){
	Semi+=12;
	Oct-=1;
}
if(inlet_negativeHrm){
	Semi=11-Semi+param_offset;
}
int out=Semi+Oct*12;
int diff=note[i]-out;
int rect=diff>0?diff:-diff;
if(rect>6){
	out+=diff>0?-12:12;
}
note[i]=out;
}


outlet_o1=note[0];
outlet_o2=note[1];
outlet_o3=note[2];
outlet_o4=note[3];
outlet_o5=note[4];
outlet_o6=note[5];
outlet_sel=B[in];
//outlet_bass=NT[(B[in])][(chord[in][(B[in])])]-24;
for(int i=0;i<6;i++){
	note[i]=note[i]-note[i]/12*12;
	note[i]+=note[i]<0?12:0;
}
outlet_bass=note[(B[in])];]]></code.krate>
      </object>
   </patchobj>
   <obj type="mux/mux 6" uuid="b9b8d71bdd1ecf4ee032c22b28f39986b62d98e5" name="mux_2" x="2240" y="574">
      <params/>
      <attribs/>
   </obj>
   <obj type="mux/mux 4" uuid="bd572dad58644793774a69385f376bda2e1fd9be" name="mux_1" x="2310" y="574">
      <params/>
      <attribs/>
   </obj>
   <comment type="patch/comment" x="490" y="686" text="&quot;fine&quot; summed outputs"/>
   <patchobj type="patch/object" uuid="359407dc-4fe9-4dff-b7dd-70b43d7468d3" name="mux_3" x="2240" y="700">
      <params/>
      <attribs/>
      <object id="patch/object" uuid="359407dc-4fe9-4dff-b7dd-70b43d7468d3">
         <sDescription>input multiplexer. Output is i1 when s &lt; 1, i[i] when....</sDescription>
         <author>Johannes Taelman</author>
         <license>BSD</license>
         <helpPatch>mux.axh</helpPatch>
         <inlets>
            <int32 name="i0" description="input 0"/>
            <int32 name="i1" description="input 1"/>
            <int32 name="i2" description="input 2"/>
            <int32 name="i3" description="input 3"/>
            <int32.positive name="s1" description="select"/>
            <int32.positive name="s2"/>
         </inlets>
         <outlets>
            <int32 name="o" description="output"/>
         </outlets>
         <displays/>
         <params/>
         <attribs/>
         <includes/>
         <code.krate><![CDATA[switch((inlet_s1+inlet_s2)&3){
      case 0: outlet_o= inlet_i0;break;
      case 1: outlet_o= inlet_i1;break;
      case 2: outlet_o= inlet_i2;break;
      case 3: outlet_o= inlet_i3;break;
      default: outlet_o= inlet_i3;break;
}]]></code.krate>
      </object>
   </patchobj>
   <comment type="patch/comment" x="490" y="756" text="measure quantized summed outputs"/>
   <obj type="disp/bool" uuid="a0ee71d48208b71752cbb8c05e55145106ef3946" name="bool_1" x="2170" y="756">
      <params/>
      <attribs/>
   </obj>
   <comment type="patch/comment" x="490" y="812" text="bar quantized summed outputs"/>
   <patchobj type="patch/object" uuid="ded2f803-c81f-4965-bc9c-b59c410a420b" name="object_19" x="798" y="812">
      <params>
         <frac32.u.map name="treshold" value="12.0"/>
         <bool32.tgl name="gated" value="1"/>
      </params>
      <attribs>
         <objref attributeName="table" obj="alloc_1"/>
      </attribs>
      <object id="patch/object" uuid="ded2f803-c81f-4965-bc9c-b59c410a420b">
         <inlets>
            <int32 name="count"/>
            <int32 name="max"/>
            <bool32 name="rnd"/>
            <frac32 name="ofs"/>
         </inlets>
         <outlets>
            <bool32 name="out"/>
         </outlets>
         <displays/>
         <params>
            <frac32.u.map name="treshold"/>
            <bool32.tgl name="gated"/>
         </params>
         <attribs>
            <objref name="table"/>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[bool rnd;
int ofs,count;
int i;]]></code.declaration>
         <code.init><![CDATA[ofs=(int32_t)GenerateRandomNumber();]]></code.init>
         <code.krate><![CDATA[if(inlet_rnd&&!rnd){
	rnd=1;
	ofs=(int32_t)GenerateRandomNumber();
}
else if(rnd&&!inlet_rnd){rnd=0;}

outlet_out=attr_table.array[(inlet_count+ofs+inlet_ofs)&attr_table.LENGTHMASK]>(param_treshold>>19)?(param_gated>0?1:(!(inlet_count==count))):0;
count=inlet_count;]]></code.krate>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="ded2f803-c81f-4965-bc9c-b59c410a420b" name="object_2" x="1106" y="812">
      <params>
         <frac32.u.map name="treshold" value="41.0"/>
      </params>
      <attribs>
         <objref attributeName="table" obj="alloc_1"/>
      </attribs>
      <object id="patch/object" uuid="ded2f803-c81f-4965-bc9c-b59c410a420b">
         <inlets>
            <int32 name="count"/>
            <int32 name="max"/>
            <bool32 name="rnd"/>
            <frac32 name="ofs"/>
         </inlets>
         <outlets>
            <bool32 name="out"/>
         </outlets>
         <displays/>
         <params>
            <frac32.u.map name="treshold"/>
         </params>
         <attribs>
            <objref name="table"/>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[bool rnd;
int ofs,count;
int i;]]></code.declaration>
         <code.init><![CDATA[ofs=(int32_t)GenerateRandomNumber();]]></code.init>
         <code.krate><![CDATA[if(inlet_rnd&&!rnd){
	rnd=1;
	ofs=(int32_t)GenerateRandomNumber();
}
else if(rnd&&!inlet_rnd){rnd=0;}

outlet_out=attr_table.array[(inlet_count+ofs+inlet_ofs)&attr_table.LENGTHMASK]>(param_treshold>>19)?(!(inlet_count==count)):0;
count=inlet_count;]]></code.krate>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="ded2f803-c81f-4965-bc9c-b59c410a420b" name="object_9" x="1232" y="812">
      <params>
         <frac32.u.map name="treshold" value="42.0"/>
      </params>
      <attribs>
         <objref attributeName="table" obj="alloc_1"/>
      </attribs>
      <object id="patch/object" uuid="ded2f803-c81f-4965-bc9c-b59c410a420b">
         <inlets>
            <int32 name="count"/>
            <int32 name="max"/>
            <bool32 name="rnd"/>
            <frac32 name="ofs"/>
         </inlets>
         <outlets>
            <bool32 name="out"/>
         </outlets>
         <displays/>
         <params>
            <frac32.u.map name="treshold"/>
         </params>
         <attribs>
            <objref name="table"/>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[bool rnd;
int ofs,count;
int i;]]></code.declaration>
         <code.init><![CDATA[ofs=(int32_t)GenerateRandomNumber();]]></code.init>
         <code.krate><![CDATA[if(inlet_rnd&&!rnd){
	rnd=1;
	ofs=(int32_t)GenerateRandomNumber();
}
else if(rnd&&!inlet_rnd){rnd=0;}

outlet_out=attr_table.array[(inlet_count+ofs+inlet_ofs)&attr_table.LENGTHMASK]>(param_treshold>>19)?(!(inlet_count==count)):0;
count=inlet_count;]]></code.krate>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="ded2f803-c81f-4965-bc9c-b59c410a420b" name="object_3" x="1358" y="812">
      <params>
         <frac32.u.map name="treshold" value="41.5"/>
      </params>
      <attribs>
         <objref attributeName="table" obj="alloc_1"/>
      </attribs>
      <object id="patch/object" uuid="ded2f803-c81f-4965-bc9c-b59c410a420b">
         <inlets>
            <int32 name="count"/>
            <int32 name="max"/>
            <bool32 name="rnd"/>
            <frac32 name="ofs"/>
         </inlets>
         <outlets>
            <bool32 name="out"/>
         </outlets>
         <displays/>
         <params>
            <frac32.u.map name="treshold"/>
         </params>
         <attribs>
            <objref name="table"/>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[bool rnd;
int ofs,count;
int i;]]></code.declaration>
         <code.init><![CDATA[ofs=(int32_t)GenerateRandomNumber();]]></code.init>
         <code.krate><![CDATA[if(inlet_rnd&&!rnd){
	rnd=1;
	ofs=(int32_t)GenerateRandomNumber();
}
else if(rnd&&!inlet_rnd){rnd=0;}

outlet_out=attr_table.array[(inlet_count+ofs+inlet_ofs)&attr_table.LENGTHMASK]>(param_treshold>>19)?(!(inlet_count==count)):0;
count=inlet_count;]]></code.krate>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="ded2f803-c81f-4965-bc9c-b59c410a420b" name="object_5" x="1484" y="812">
      <params>
         <frac32.u.map name="treshold" value="43.0"/>
      </params>
      <attribs>
         <objref attributeName="table" obj="alloc_1"/>
      </attribs>
      <object id="patch/object" uuid="ded2f803-c81f-4965-bc9c-b59c410a420b">
         <inlets>
            <int32 name="count"/>
            <int32 name="max"/>
            <bool32 name="rnd"/>
            <frac32 name="ofs"/>
         </inlets>
         <outlets>
            <bool32 name="out"/>
         </outlets>
         <displays/>
         <params>
            <frac32.u.map name="treshold"/>
         </params>
         <attribs>
            <objref name="table"/>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[bool rnd;
int ofs,count;
int i;]]></code.declaration>
         <code.init><![CDATA[ofs=(int32_t)GenerateRandomNumber();]]></code.init>
         <code.krate><![CDATA[if(inlet_rnd&&!rnd){
	rnd=1;
	ofs=(int32_t)GenerateRandomNumber();
}
else if(rnd&&!inlet_rnd){rnd=0;}

outlet_out=attr_table.array[(inlet_count+ofs+inlet_ofs)&attr_table.LENGTHMASK]>(param_treshold>>19)?(!(inlet_count==count)):0;
count=inlet_count;]]></code.krate>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="ded2f803-c81f-4965-bc9c-b59c410a420b" name="object_7" x="1610" y="812">
      <params>
         <frac32.u.map name="treshold" value="14.0"/>
         <bool32.tgl name="gated" value="1"/>
      </params>
      <attribs>
         <objref attributeName="table" obj="alloc_1"/>
      </attribs>
      <object id="patch/object" uuid="ded2f803-c81f-4965-bc9c-b59c410a420b">
         <inlets>
            <int32 name="count"/>
            <int32 name="max"/>
            <bool32 name="rnd"/>
            <frac32 name="ofs"/>
         </inlets>
         <outlets>
            <bool32 name="out"/>
         </outlets>
         <displays/>
         <params>
            <frac32.u.map name="treshold"/>
            <bool32.tgl name="gated"/>
         </params>
         <attribs>
            <objref name="table"/>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[bool rnd;
int ofs,count;
int i;]]></code.declaration>
         <code.init><![CDATA[ofs=(int32_t)GenerateRandomNumber();]]></code.init>
         <code.krate><![CDATA[if(inlet_rnd&&!rnd){
	rnd=1;
	ofs=(int32_t)GenerateRandomNumber();
}
else if(rnd&&!inlet_rnd){rnd=0;}

outlet_out=attr_table.array[(inlet_count+ofs+inlet_ofs)&attr_table.LENGTHMASK]>(param_treshold>>19)?(param_gated>0?1:(!(inlet_count==count))):0;
count=inlet_count;]]></code.krate>
      </object>
   </patchobj>
   <comment type="patch/comment" x="490" y="854" text="bar quantized summed outputs"/>
   <obj type="logic/counter" uuid="7a141ba82230e54e5f5cd12da5dbe5a74ba854a5" name="counter_3" x="518" y="882">
      <params>
         <int32 name="maximum" value="6"/>
      </params>
      <attribs/>
   </obj>
   <obj type="sel/sel fp 16" uuid="3d0698411643c13e342d17c8750d68d01689c658" name="sel_1" x="210" y="980">
      <params>
         <frac32.u.mapvsl name="b0" value="29.0"/>
         <frac32.u.mapvsl name="b1" value="38.0"/>
         <frac32.u.mapvsl name="b2" value="45.0"/>
         <frac32.u.mapvsl name="b3" value="49.5"/>
         <frac32.u.mapvsl name="b4" value="51.5"/>
         <frac32.u.mapvsl name="b5" value="53.5"/>
         <frac32.u.mapvsl name="b6" value="54.0"/>
         <frac32.u.mapvsl name="b7" value="55.0"/>
         <frac32.u.mapvsl name="b8" value="55.5"/>
         <frac32.u.mapvsl name="b9" value="56.0"/>
         <frac32.u.mapvsl name="b10" value="56.5"/>
         <frac32.u.mapvsl name="b11" value="57.5"/>
         <frac32.u.mapvsl name="b12" value="59.0"/>
         <frac32.u.mapvsl name="b13" value="60.0"/>
         <frac32.u.mapvsl name="b14" value="62.5"/>
         <frac32.u.mapvsl name="b15" value="64.0"/>
      </params>
      <attribs/>
   </obj>
   <obj type="math/sqrt" uuid="f3ab4ab19662187c367731c4658f07d9bfa4fd79" name="sqrt_1" x="406" y="980">
      <params/>
      <attribs/>
   </obj>
   <patchobj type="patch/object" uuid="50cf2930-8725-42f2-acfa-ca6008d0bb55" name="glide_2" x="476" y="980">
      <params>
         <frac32.s.map name="glide" value="35.0"/>
      </params>
      <attribs/>
      <object id="patch/object" uuid="50cf2930-8725-42f2-acfa-ca6008d0bb55">
         <sDescription>exponential smooth with enable</sDescription>
         <author>Johannes Taelman</author>
         <license>BSD</license>
         <helpPatch>math.axh</helpPatch>
         <inlets>
            <frac32 name="in" description="input"/>
            <frac32 name="glide"/>
         </inlets>
         <outlets>
            <frac32 name="out" description="output"/>
         </outlets>
         <displays/>
         <params>
            <frac32.s.map.klineartime.exp name="glide"/>
         </params>
         <attribs/>
         <includes/>
         <code.declaration><![CDATA[int32_t val;]]></code.declaration>
         <code.init><![CDATA[val = 0;]]></code.init>
         <code.krate><![CDATA[int32_t glide;
MTOF(-inlet_glide-param_glide,glide)
glide=glide>>9;
int dir=inlet_in>val?1:0;

val +=inlet_in>val?glide:-glide;
if(dir){
	val=val>inlet_in?inlet_in:val;
}
else{val=val<inlet_in?inlet_in:val;}


   outlet_out= val;]]></code.krate>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="ded2f803-c81f-4965-bc9c-b59c410a420b" name="object_22" x="938" y="980">
      <params>
         <frac32.s.map name="max" value="63.0"/>
         <frac32.s.map name="min" value="27.0"/>
      </params>
      <attribs>
         <objref attributeName="table" obj="alloc_1"/>
      </attribs>
      <object id="patch/object" uuid="ded2f803-c81f-4965-bc9c-b59c410a420b">
         <inlets>
            <int32 name="count"/>
            <int32 name="max"/>
            <bool32 name="rnd"/>
            <frac32 name="ofs"/>
         </inlets>
         <outlets>
            <frac32 name="out"/>
         </outlets>
         <displays/>
         <params>
            <frac32.s.map name="max"/>
            <frac32.s.map name="min"/>
         </params>
         <attribs>
            <objref name="table"/>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[bool rnd;
int ofs;
int i;]]></code.declaration>
         <code.init><![CDATA[ofs=(int32_t)GenerateRandomNumber();]]></code.init>
         <code.krate><![CDATA[if(inlet_rnd&&!rnd){
	rnd=1;
	ofs=(int32_t)GenerateRandomNumber();
}
else if(rnd&&!inlet_rnd){rnd=0;}
int32_t width=param_max-param_min<<3;
outlet_out=___SMMUL((attr_table.array[(inlet_count+ofs+inlet_ofs)&attr_table.LENGTHMASK]<<21),width)+param_min;]]></code.krate>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="ded2f803-c81f-4965-bc9c-b59c410a420b" name="object_13" x="1106" y="980">
      <params>
         <frac32.s.map name="max" value="64.0"/>
         <frac32.s.map name="min" value="20.0"/>
      </params>
      <attribs>
         <objref attributeName="table" obj="alloc_1"/>
      </attribs>
      <object id="patch/object" uuid="ded2f803-c81f-4965-bc9c-b59c410a420b">
         <inlets>
            <int32 name="count"/>
            <int32 name="max"/>
            <bool32 name="rnd"/>
            <frac32 name="ofs"/>
         </inlets>
         <outlets>
            <frac32 name="out"/>
         </outlets>
         <displays/>
         <params>
            <frac32.s.map name="max"/>
            <frac32.s.map name="min"/>
         </params>
         <attribs>
            <objref name="table"/>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[bool rnd;
int ofs;
int i;]]></code.declaration>
         <code.init><![CDATA[ofs=(int32_t)GenerateRandomNumber();]]></code.init>
         <code.krate><![CDATA[if(inlet_rnd&&!rnd){
	rnd=1;
	ofs=(int32_t)GenerateRandomNumber();
}
else if(rnd&&!inlet_rnd){rnd=0;}
int32_t width=param_max-param_min<<3;
outlet_out=___SMMUL((attr_table.array[(inlet_count+ofs+inlet_ofs)&attr_table.LENGTHMASK]<<21),width)+param_min;]]></code.krate>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="ded2f803-c81f-4965-bc9c-b59c410a420b" name="object_15" x="1232" y="980">
      <params>
         <frac32.s.map name="max" value="59.0"/>
         <frac32.s.map name="min" value="15.0"/>
      </params>
      <attribs>
         <objref attributeName="table" obj="alloc_1"/>
      </attribs>
      <object id="patch/object" uuid="ded2f803-c81f-4965-bc9c-b59c410a420b">
         <inlets>
            <int32 name="count"/>
            <int32 name="max"/>
            <bool32 name="rnd"/>
            <frac32 name="ofs"/>
         </inlets>
         <outlets>
            <frac32 name="out"/>
         </outlets>
         <displays/>
         <params>
            <frac32.s.map name="max"/>
            <frac32.s.map name="min"/>
         </params>
         <attribs>
            <objref name="table"/>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[bool rnd;
int ofs;
int i;]]></code.declaration>
         <code.init><![CDATA[ofs=(int32_t)GenerateRandomNumber();]]></code.init>
         <code.krate><![CDATA[if(inlet_rnd&&!rnd){
	rnd=1;
	ofs=(int32_t)GenerateRandomNumber();
}
else if(rnd&&!inlet_rnd){rnd=0;}
int32_t width=param_max-param_min<<3;
outlet_out=___SMMUL((attr_table.array[(inlet_count+ofs+inlet_ofs)&attr_table.LENGTHMASK]<<21),width)+param_min;]]></code.krate>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="ded2f803-c81f-4965-bc9c-b59c410a420b" name="object_16" x="1358" y="980">
      <params>
         <frac32.s.map name="max" value="59.0"/>
         <frac32.s.map name="min" value="16.0"/>
      </params>
      <attribs>
         <objref attributeName="table" obj="alloc_1"/>
      </attribs>
      <object id="patch/object" uuid="ded2f803-c81f-4965-bc9c-b59c410a420b">
         <inlets>
            <int32 name="count"/>
            <int32 name="max"/>
            <bool32 name="rnd"/>
            <frac32 name="ofs"/>
         </inlets>
         <outlets>
            <frac32 name="out"/>
         </outlets>
         <displays/>
         <params>
            <frac32.s.map name="max"/>
            <frac32.s.map name="min"/>
         </params>
         <attribs>
            <objref name="table"/>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[bool rnd;
int ofs;
int i;]]></code.declaration>
         <code.init><![CDATA[ofs=(int32_t)GenerateRandomNumber();]]></code.init>
         <code.krate><![CDATA[if(inlet_rnd&&!rnd){
	rnd=1;
	ofs=(int32_t)GenerateRandomNumber();
}
else if(rnd&&!inlet_rnd){rnd=0;}
int32_t width=param_max-param_min<<3;
outlet_out=___SMMUL((attr_table.array[(inlet_count+ofs+inlet_ofs)&attr_table.LENGTHMASK]<<21),width)+param_min;]]></code.krate>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="ded2f803-c81f-4965-bc9c-b59c410a420b" name="object_17" x="1484" y="980">
      <params>
         <frac32.s.map name="max" value="59.0"/>
         <frac32.s.map name="min" value="16.0"/>
      </params>
      <attribs>
         <objref attributeName="table" obj="alloc_1"/>
      </attribs>
      <object id="patch/object" uuid="ded2f803-c81f-4965-bc9c-b59c410a420b">
         <inlets>
            <int32 name="count"/>
            <int32 name="max"/>
            <bool32 name="rnd"/>
            <frac32 name="ofs"/>
         </inlets>
         <outlets>
            <frac32 name="out"/>
         </outlets>
         <displays/>
         <params>
            <frac32.s.map name="max"/>
            <frac32.s.map name="min"/>
         </params>
         <attribs>
            <objref name="table"/>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[bool rnd;
int ofs;
int i;]]></code.declaration>
         <code.init><![CDATA[ofs=(int32_t)GenerateRandomNumber();]]></code.init>
         <code.krate><![CDATA[if(inlet_rnd&&!rnd){
	rnd=1;
	ofs=(int32_t)GenerateRandomNumber();
}
else if(rnd&&!inlet_rnd){rnd=0;}
int32_t width=param_max-param_min<<3;
outlet_out=___SMMUL((attr_table.array[(inlet_count+ofs+inlet_ofs)&attr_table.LENGTHMASK]<<21),width)+param_min;]]></code.krate>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="ded2f803-c81f-4965-bc9c-b59c410a420b" name="object_14" x="1610" y="980">
      <params>
         <frac32.s.map name="max" value="59.0"/>
         <frac32.s.map name="min" value="16.0"/>
      </params>
      <attribs>
         <objref attributeName="table" obj="alloc_1"/>
      </attribs>
      <object id="patch/object" uuid="ded2f803-c81f-4965-bc9c-b59c410a420b">
         <inlets>
            <int32 name="count"/>
            <int32 name="max"/>
            <bool32 name="rnd"/>
            <frac32 name="ofs"/>
         </inlets>
         <outlets>
            <frac32 name="out"/>
         </outlets>
         <displays/>
         <params>
            <frac32.s.map name="max"/>
            <frac32.s.map name="min"/>
         </params>
         <attribs>
            <objref name="table"/>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[bool rnd;
int ofs;
int i;]]></code.declaration>
         <code.init><![CDATA[ofs=(int32_t)GenerateRandomNumber();]]></code.init>
         <code.krate><![CDATA[if(inlet_rnd&&!rnd){
	rnd=1;
	ofs=(int32_t)GenerateRandomNumber();
}
else if(rnd&&!inlet_rnd){rnd=0;}
int32_t width=param_max-param_min<<3;
outlet_out=___SMMUL((attr_table.array[(inlet_count+ofs+inlet_ofs)&attr_table.LENGTHMASK]<<21),width)+param_min;]]></code.krate>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="ded2f803-c81f-4965-bc9c-b59c410a420b" name="object_18" x="1750" y="980">
      <params>
         <frac32.s.map name="max" value="17.0"/>
         <frac32.s.map name="min" value="-13.0"/>
      </params>
      <attribs>
         <objref attributeName="table" obj="alloc_1"/>
      </attribs>
      <object id="patch/object" uuid="ded2f803-c81f-4965-bc9c-b59c410a420b">
         <inlets>
            <int32 name="count"/>
            <int32 name="max"/>
            <bool32 name="rnd"/>
            <frac32 name="ofs"/>
         </inlets>
         <outlets>
            <frac32 name="out"/>
         </outlets>
         <displays/>
         <params>
            <frac32.s.map name="max"/>
            <frac32.s.map name="min"/>
         </params>
         <attribs>
            <objref name="table"/>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[bool rnd;
int ofs;
int i;]]></code.declaration>
         <code.init><![CDATA[ofs=(int32_t)GenerateRandomNumber();]]></code.init>
         <code.krate><![CDATA[if(inlet_rnd&&!rnd){
	rnd=1;
	ofs=(int32_t)GenerateRandomNumber();
}
else if(rnd&&!inlet_rnd){rnd=0;}
int32_t width=param_max-param_min<<3;
outlet_out=___SMMUL((attr_table.array[(inlet_count+ofs+inlet_ofs)&attr_table.LENGTHMASK]<<21),width)+param_min;]]></code.krate>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="ded2f803-c81f-4965-bc9c-b59c410a420b" name="object_20" x="1876" y="980">
      <params>
         <frac32.s.map name="max" value="34.0"/>
         <frac32.s.map name="min" value="-9.0"/>
      </params>
      <attribs>
         <objref attributeName="table" obj="alloc_1"/>
      </attribs>
      <object id="patch/object" uuid="ded2f803-c81f-4965-bc9c-b59c410a420b">
         <inlets>
            <int32 name="count"/>
            <int32 name="max"/>
            <bool32 name="rnd"/>
            <frac32 name="ofs"/>
         </inlets>
         <outlets>
            <frac32 name="out"/>
         </outlets>
         <displays/>
         <params>
            <frac32.s.map name="max"/>
            <frac32.s.map name="min"/>
         </params>
         <attribs>
            <objref name="table"/>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[bool rnd;
int ofs;
int i;]]></code.declaration>
         <code.init><![CDATA[ofs=(int32_t)GenerateRandomNumber();]]></code.init>
         <code.krate><![CDATA[if(inlet_rnd&&!rnd){
	rnd=1;
	ofs=(int32_t)GenerateRandomNumber();
}
else if(rnd&&!inlet_rnd){rnd=0;}
int32_t width=param_max-param_min<<3;
outlet_out=___SMMUL((attr_table.array[(inlet_count+ofs+inlet_ofs)&attr_table.LENGTHMASK]<<21),width)+param_min;]]></code.krate>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="c258a75d-9b65-40b9-9ec7-5d5d99ba6a9b" name="divremc_6" x="798" y="1190">
      <params>
         <int32 name="oct" value="-2"/>
         <int32 name="ofs" value="8"/>
         <int32 name="range" value="4"/>
      </params>
      <attribs/>
      <object id="patch/object" uuid="c258a75d-9b65-40b9-9ec7-5d5d99ba6a9b">
         <sDescription>divide integer with constant, also outputs remainder (modulo)</sDescription>
         <author>Johannes Taelman</author>
         <license>BSD</license>
         <helpPatch>math.axh</helpPatch>
         <inlets>
            <int32 name="a" description="nominator"/>
         </inlets>
         <outlets>
            <int32 name="rem" description="remainder of division by denominator"/>
         </outlets>
         <displays/>
         <params>
            <int32 name="oct">
               <MinValue i="-8"/>
               <MaxValue i="8"/>
            </int32>
            <int32 name="ofs">
               <MinValue i="0"/>
               <MaxValue i="12"/>
            </int32>
            <int32 name="range">
               <MinValue i="1"/>
               <MaxValue i="8"/>
            </int32>
         </params>
         <attribs/>
         <includes/>
         <code.krate><![CDATA[int r;
int32_t in=inlet_a-param_ofs;
if (in >=0)
  r = ((unsigned int)in)/12;
else  r = -(((unsigned int)(12-in))/12);
int tmp=r;
tmp=tmp-tmp/param_range*param_range;
tmp+=tmp<0?param_range:0;
tmp*=12;
outlet_rem = inlet_a-(r*12)+param_oct*12+tmp;]]></code.krate>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="c258a75d-9b65-40b9-9ec7-5d5d99ba6a9b" name="divremc_5" x="1106" y="1190">
      <params>
         <int32 name="oct" value="-2"/>
         <int32 name="ofs" value="8"/>
         <int32 name="range" value="4"/>
      </params>
      <attribs/>
      <object id="patch/object" uuid="c258a75d-9b65-40b9-9ec7-5d5d99ba6a9b">
         <sDescription>divide integer with constant, also outputs remainder (modulo)</sDescription>
         <author>Johannes Taelman</author>
         <license>BSD</license>
         <helpPatch>math.axh</helpPatch>
         <inlets>
            <int32 name="a" description="nominator"/>
         </inlets>
         <outlets>
            <int32 name="rem" description="remainder of division by denominator"/>
         </outlets>
         <displays/>
         <params>
            <int32 name="oct">
               <MinValue i="-8"/>
               <MaxValue i="8"/>
            </int32>
            <int32 name="ofs">
               <MinValue i="0"/>
               <MaxValue i="12"/>
            </int32>
            <int32 name="range">
               <MinValue i="1"/>
               <MaxValue i="8"/>
            </int32>
         </params>
         <attribs/>
         <includes/>
         <code.krate><![CDATA[int r;
int32_t in=inlet_a-param_ofs;
if (in >=0)
  r = ((unsigned int)in)/12;
else  r = -(((unsigned int)(12-in))/12);
int tmp=r;
tmp=tmp-tmp/param_range*param_range;
tmp+=tmp<0?param_range:0;
tmp*=12;
outlet_rem = inlet_a-(r*12)+param_oct*12+tmp;]]></code.krate>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="c258a75d-9b65-40b9-9ec7-5d5d99ba6a9b" name="divremc_2" x="1232" y="1190">
      <params>
         <int32 name="oct" value="-3"/>
         <int32 name="ofs" value="0"/>
         <int32 name="range" value="2"/>
      </params>
      <attribs/>
      <object id="patch/object" uuid="c258a75d-9b65-40b9-9ec7-5d5d99ba6a9b">
         <sDescription>divide integer with constant, also outputs remainder (modulo)</sDescription>
         <author>Johannes Taelman</author>
         <license>BSD</license>
         <helpPatch>math.axh</helpPatch>
         <inlets>
            <int32 name="a" description="nominator"/>
         </inlets>
         <outlets>
            <int32 name="rem" description="remainder of division by denominator"/>
         </outlets>
         <displays/>
         <params>
            <int32 name="oct">
               <MinValue i="-8"/>
               <MaxValue i="8"/>
            </int32>
            <int32 name="ofs">
               <MinValue i="0"/>
               <MaxValue i="12"/>
            </int32>
            <int32 name="range">
               <MinValue i="1"/>
               <MaxValue i="8"/>
            </int32>
         </params>
         <attribs/>
         <includes/>
         <code.krate><![CDATA[int r;
int32_t in=inlet_a-param_ofs;
if (in >=0)
  r = ((unsigned int)in)/12;
else  r = -(((unsigned int)(12-in))/12);
int tmp=r;
tmp=tmp-tmp/param_range*param_range;
tmp+=tmp<0?param_range:0;
tmp*=12;
outlet_rem = inlet_a-(r*12)+param_oct*12+tmp;]]></code.krate>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="c258a75d-9b65-40b9-9ec7-5d5d99ba6a9b" name="divremc_3" x="1358" y="1190">
      <params>
         <int32 name="oct" value="-2"/>
         <int32 name="ofs" value="4"/>
         <int32 name="range" value="2"/>
      </params>
      <attribs/>
      <object id="patch/object" uuid="c258a75d-9b65-40b9-9ec7-5d5d99ba6a9b">
         <sDescription>divide integer with constant, also outputs remainder (modulo)</sDescription>
         <author>Johannes Taelman</author>
         <license>BSD</license>
         <helpPatch>math.axh</helpPatch>
         <inlets>
            <int32 name="a" description="nominator"/>
         </inlets>
         <outlets>
            <int32 name="rem" description="remainder of division by denominator"/>
         </outlets>
         <displays/>
         <params>
            <int32 name="oct">
               <MinValue i="-8"/>
               <MaxValue i="8"/>
            </int32>
            <int32 name="ofs">
               <MinValue i="0"/>
               <MaxValue i="12"/>
            </int32>
            <int32 name="range">
               <MinValue i="1"/>
               <MaxValue i="8"/>
            </int32>
         </params>
         <attribs/>
         <includes/>
         <code.krate><![CDATA[int r;
int32_t in=inlet_a-param_ofs;
if (in >=0)
  r = ((unsigned int)in)/12;
else  r = -(((unsigned int)(12-in))/12);
int tmp=r;
tmp=tmp-tmp/param_range*param_range;
tmp+=tmp<0?param_range:0;
tmp*=12;
outlet_rem = inlet_a-(r*12)+param_oct*12+tmp;]]></code.krate>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="c258a75d-9b65-40b9-9ec7-5d5d99ba6a9b" name="divremc_4" x="1484" y="1190">
      <params>
         <int32 name="oct" value="-1"/>
         <int32 name="ofs" value="8"/>
         <int32 name="range" value="2"/>
      </params>
      <attribs/>
      <object id="patch/object" uuid="c258a75d-9b65-40b9-9ec7-5d5d99ba6a9b">
         <sDescription>divide integer with constant, also outputs remainder (modulo)</sDescription>
         <author>Johannes Taelman</author>
         <license>BSD</license>
         <helpPatch>math.axh</helpPatch>
         <inlets>
            <int32 name="a" description="nominator"/>
         </inlets>
         <outlets>
            <int32 name="rem" description="remainder of division by denominator"/>
         </outlets>
         <displays/>
         <params>
            <int32 name="oct">
               <MinValue i="-8"/>
               <MaxValue i="8"/>
            </int32>
            <int32 name="ofs">
               <MinValue i="0"/>
               <MaxValue i="12"/>
            </int32>
            <int32 name="range">
               <MinValue i="1"/>
               <MaxValue i="8"/>
            </int32>
         </params>
         <attribs/>
         <includes/>
         <code.krate><![CDATA[int r;
int32_t in=inlet_a-param_ofs;
if (in >=0)
  r = ((unsigned int)in)/12;
else  r = -(((unsigned int)(12-in))/12);
int tmp=r;
tmp=tmp-tmp/param_range*param_range;
tmp+=tmp<0?param_range:0;
tmp*=12;
outlet_rem = inlet_a-(r*12)+param_oct*12+tmp;]]></code.krate>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="c258a75d-9b65-40b9-9ec7-5d5d99ba6a9b" name="divremc_1" x="1652" y="1190">
      <params>
         <int32 name="oct" value="-3"/>
         <int32 name="ofs" value="0"/>
         <int32 name="range" value="2"/>
      </params>
      <attribs/>
      <object id="patch/object" uuid="c258a75d-9b65-40b9-9ec7-5d5d99ba6a9b">
         <sDescription>divide integer with constant, also outputs remainder (modulo)</sDescription>
         <author>Johannes Taelman</author>
         <license>BSD</license>
         <helpPatch>math.axh</helpPatch>
         <inlets>
            <int32 name="a" description="nominator"/>
         </inlets>
         <outlets>
            <int32 name="rem" description="remainder of division by denominator"/>
         </outlets>
         <displays/>
         <params>
            <int32 name="oct">
               <MinValue i="-8"/>
               <MaxValue i="8"/>
            </int32>
            <int32 name="ofs">
               <MinValue i="0"/>
               <MaxValue i="12"/>
            </int32>
            <int32 name="range">
               <MinValue i="1"/>
               <MaxValue i="8"/>
            </int32>
         </params>
         <attribs/>
         <includes/>
         <code.krate><![CDATA[int r;
int32_t in=inlet_a-param_ofs;
if (in >=0)
  r = ((unsigned int)in)/12;
else  r = -(((unsigned int)(12-in))/12);
int tmp=r;
tmp=tmp-tmp/param_range*param_range;
tmp+=tmp<0?param_range:0;
tmp*=12;
outlet_rem = inlet_a-(r*12)+param_oct*12+tmp;]]></code.krate>
      </object>
   </patchobj>
   <obj type="logic/and 2" uuid="c67031682f552aa0a80b23377495c51ea28a8c9c" name="and_6" x="322" y="1302">
      <params/>
      <attribs/>
   </obj>
   <obj type="logic/and 2" uuid="c67031682f552aa0a80b23377495c51ea28a8c9c" name="and_1" x="392" y="1302">
      <params/>
      <attribs/>
   </obj>
   <obj type="logic/and 2" uuid="c67031682f552aa0a80b23377495c51ea28a8c9c" name="and_2" x="462" y="1302">
      <params/>
      <attribs/>
   </obj>
   <obj type="logic/and 2" uuid="c67031682f552aa0a80b23377495c51ea28a8c9c" name="and_3" x="532" y="1302">
      <params/>
      <attribs/>
   </obj>
   <obj type="logic/and 2" uuid="c67031682f552aa0a80b23377495c51ea28a8c9c" name="and_4" x="602" y="1302">
      <params/>
      <attribs/>
   </obj>
   <obj type="logic/and 2" uuid="c67031682f552aa0a80b23377495c51ea28a8c9c" name="and_5" x="672" y="1302">
      <params/>
      <attribs/>
   </obj>
   <obj type="ctrl/button" uuid="ef3d13774349df85aa9bfecf30dbc91ab8488b3f" name="button_2" x="714" y="1302">
      <params>
         <bool32.mom name="b" value="0"/>
      </params>
      <attribs/>
   </obj>
   <patchobj type="patch/object" uuid="aa6a0379-fb48-4e3b-94ad-7159c9b5a857" name="note_8" x="798" y="1302">
      <params/>
      <attribs>
         <spinner attributeName="channel" value="1"/>
      </attribs>
      <object id="patch/object" uuid="aa6a0379-fb48-4e3b-94ad-7159c9b5a857">
         <sDescription>Midi note output. Sends to midi/in/* objects only.</sDescription>
         <author>Johannes Taelman</author>
         <license>BSD</license>
         <inlets>
            <frac32.bipolar name="note" description="note (-64..63)"/>
            <frac32.positive name="velo" description="velocity"/>
            <bool32.rising name="trig" description="trigger"/>
         </inlets>
         <outlets/>
         <displays/>
         <params/>
         <attribs>
            <spinner name="channel" MinValue="1" MaxValue="16" DefaultValue="0"/>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[int ntrig;
int lastnote;
int lastchannel;
int cnt;]]></code.declaration>
         <code.init><![CDATA[ntrig=0;
cnt=0;]]></code.init>
         <code.krate><![CDATA[if ((inlet_trig>0) && !ntrig) {
lastnote = (64+(inlet_note>>21))&0x7F;
lastchannel=attr_channel-1;
PatchMidiInHandler(MIDI_DEVICE_INTERNAL,0,MIDI_NOTE_ON + lastchannel,lastnote,inlet_velo>>20);  ntrig=1;
}
if (!(inlet_trig>0) && ntrig) {PatchMidiInHandler((midi_device_t) 0,0,MIDI_NOTE_OFF + lastchannel,lastnote,__USAT(inlet_velo>>20,7)); ntrig=0;}]]></code.krate>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="aa6a0379-fb48-4e3b-94ad-7159c9b5a857" name="note_4" x="1106" y="1302">
      <params/>
      <attribs>
         <spinner attributeName="channel" value="2"/>
      </attribs>
      <object id="patch/object" uuid="aa6a0379-fb48-4e3b-94ad-7159c9b5a857">
         <sDescription>Midi note output. Sends to midi/in/* objects only.</sDescription>
         <author>Johannes Taelman</author>
         <license>BSD</license>
         <inlets>
            <frac32.bipolar name="note" description="note (-64..63)"/>
            <frac32.positive name="velo" description="velocity"/>
            <bool32.rising name="trig" description="trigger"/>
            <int32 name="channel"/>
         </inlets>
         <outlets/>
         <displays/>
         <params/>
         <attribs>
            <spinner name="channel" MinValue="1" MaxValue="16" DefaultValue="0"/>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[int ntrig;
int lastnote;
int lastchannel;]]></code.declaration>
         <code.init><![CDATA[ntrig=0;]]></code.init>
         <code.krate><![CDATA[if ((inlet_trig>0) && !ntrig) {
lastnote = (64+(inlet_note>>21))&0x7F;
lastchannel=inlet_channel&15;
PatchMidiInHandler(MIDI_DEVICE_INTERNAL,0,MIDI_NOTE_ON + lastchannel,lastnote,inlet_velo>>20);  ntrig=1;
}
if (!(inlet_trig>0) && ntrig) {PatchMidiInHandler((midi_device_t) 0,0,MIDI_NOTE_OFF + lastchannel,lastnote,__USAT(inlet_velo>>20,7)); ntrig=0;}]]></code.krate>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="aa6a0379-fb48-4e3b-94ad-7159c9b5a857" name="note_5" x="1232" y="1302">
      <params/>
      <attribs>
         <spinner attributeName="channel" value="8"/>
      </attribs>
      <object id="patch/object" uuid="aa6a0379-fb48-4e3b-94ad-7159c9b5a857">
         <sDescription>Midi note output. Sends to midi/in/* objects only.</sDescription>
         <author>Johannes Taelman</author>
         <license>BSD</license>
         <inlets>
            <frac32.bipolar name="note" description="note (-64..63)"/>
            <frac32.positive name="velo" description="velocity"/>
            <bool32.rising name="trig" description="trigger"/>
         </inlets>
         <outlets/>
         <displays/>
         <params/>
         <attribs>
            <spinner name="channel" MinValue="1" MaxValue="16" DefaultValue="0"/>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[int ntrig;
int lastnote;
int lastchannel;
int cnt;]]></code.declaration>
         <code.init><![CDATA[ntrig=0;
cnt=0;]]></code.init>
         <code.krate><![CDATA[if ((inlet_trig>0) && !ntrig) {
lastnote = (64+(inlet_note>>21))&0x7F;
lastchannel=attr_channel-1;
PatchMidiInHandler(MIDI_DEVICE_INTERNAL,0,MIDI_NOTE_ON + lastchannel,lastnote,inlet_velo>>20);  ntrig=1;
}
if (!(inlet_trig>0) && ntrig) {PatchMidiInHandler((midi_device_t) 0,0,MIDI_NOTE_OFF + lastchannel,lastnote,__USAT(inlet_velo>>20,7)); ntrig=0;}]]></code.krate>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="aa6a0379-fb48-4e3b-94ad-7159c9b5a857" name="note_6" x="1358" y="1302">
      <params/>
      <attribs>
         <spinner attributeName="channel" value="9"/>
      </attribs>
      <object id="patch/object" uuid="aa6a0379-fb48-4e3b-94ad-7159c9b5a857">
         <sDescription>Midi note output. Sends to midi/in/* objects only.</sDescription>
         <author>Johannes Taelman</author>
         <license>BSD</license>
         <inlets>
            <frac32.bipolar name="note" description="note (-64..63)"/>
            <frac32.positive name="velo" description="velocity"/>
            <bool32.rising name="trig" description="trigger"/>
         </inlets>
         <outlets/>
         <displays/>
         <params/>
         <attribs>
            <spinner name="channel" MinValue="1" MaxValue="16" DefaultValue="0"/>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[int ntrig;
int lastnote;
int lastchannel;
int cnt;]]></code.declaration>
         <code.init><![CDATA[ntrig=0;
cnt=0;]]></code.init>
         <code.krate><![CDATA[if ((inlet_trig>0) && !ntrig) {
lastnote = (64+(inlet_note>>21))&0x7F;
lastchannel=attr_channel-1;
PatchMidiInHandler(MIDI_DEVICE_INTERNAL,0,MIDI_NOTE_ON + lastchannel,lastnote,inlet_velo>>20);  ntrig=1;
}
if (!(inlet_trig>0) && ntrig) {PatchMidiInHandler((midi_device_t) 0,0,MIDI_NOTE_OFF + lastchannel,lastnote,__USAT(inlet_velo>>20,7)); ntrig=0;}]]></code.krate>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="aa6a0379-fb48-4e3b-94ad-7159c9b5a857" name="note_7" x="1484" y="1302">
      <params/>
      <attribs>
         <spinner attributeName="channel" value="10"/>
      </attribs>
      <object id="patch/object" uuid="aa6a0379-fb48-4e3b-94ad-7159c9b5a857">
         <sDescription>Midi note output. Sends to midi/in/* objects only.</sDescription>
         <author>Johannes Taelman</author>
         <license>BSD</license>
         <inlets>
            <frac32.bipolar name="note" description="note (-64..63)"/>
            <frac32.positive name="velo" description="velocity"/>
            <bool32.rising name="trig" description="trigger"/>
         </inlets>
         <outlets/>
         <displays/>
         <params/>
         <attribs>
            <spinner name="channel" MinValue="1" MaxValue="16" DefaultValue="0"/>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[int ntrig;
int lastnote;
int lastchannel;
int cnt;]]></code.declaration>
         <code.init><![CDATA[ntrig=0;
cnt=0;]]></code.init>
         <code.krate><![CDATA[if ((inlet_trig>0) && !ntrig) {
lastnote = (64+(inlet_note>>21))&0x7F;
lastchannel=attr_channel-1;
PatchMidiInHandler(MIDI_DEVICE_INTERNAL,0,MIDI_NOTE_ON + lastchannel,lastnote,inlet_velo>>20);  ntrig=1;
}
if (!(inlet_trig>0) && ntrig) {PatchMidiInHandler((midi_device_t) 0,0,MIDI_NOTE_OFF + lastchannel,lastnote,__USAT(inlet_velo>>20,7)); ntrig=0;}]]></code.krate>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="aa6a0379-fb48-4e3b-94ad-7159c9b5a857" name="note_3" x="1652" y="1302">
      <params/>
      <attribs>
         <spinner attributeName="channel" value="6"/>
      </attribs>
      <object id="patch/object" uuid="aa6a0379-fb48-4e3b-94ad-7159c9b5a857">
         <sDescription>Midi note output. Sends to midi/in/* objects only.</sDescription>
         <author>Johannes Taelman</author>
         <license>BSD</license>
         <inlets>
            <frac32.bipolar name="note" description="note (-64..63)"/>
            <frac32.positive name="velo" description="velocity"/>
            <bool32.rising name="trig" description="trigger"/>
         </inlets>
         <outlets/>
         <displays/>
         <params/>
         <attribs>
            <spinner name="channel" MinValue="1" MaxValue="16" DefaultValue="0"/>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[int ntrig;
int lastnote;
int lastchannel;
int cnt;]]></code.declaration>
         <code.init><![CDATA[ntrig=0;
cnt=0;]]></code.init>
         <code.krate><![CDATA[if ((inlet_trig>0) && !ntrig) {
lastnote = (64+(inlet_note>>21))&0x7F;

lastchannel=attr_channel-1+cnt;
PatchMidiInHandler(MIDI_DEVICE_INTERNAL,0,MIDI_NOTE_ON + lastchannel,lastnote,inlet_velo>>20);  ntrig=1;
cnt=(cnt+1)&1;
}
if (!(inlet_trig>0) && ntrig) {PatchMidiInHandler((midi_device_t) 0,0,MIDI_NOTE_OFF + lastchannel,lastnote,__USAT(inlet_velo>>20,7)); ntrig=0;}]]></code.krate>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="50cf2930-8725-42f2-acfa-ca6008d0bb55" name="glide_1" x="1330" y="1414">
      <params>
         <frac32.s.map name="glide" value="28.0"/>
      </params>
      <attribs/>
      <object id="patch/object" uuid="50cf2930-8725-42f2-acfa-ca6008d0bb55">
         <sDescription>exponential smooth with enable</sDescription>
         <author>Johannes Taelman</author>
         <license>BSD</license>
         <helpPatch>math.axh</helpPatch>
         <inlets>
            <frac32 name="in" description="input"/>
            <frac32 name="glide"/>
         </inlets>
         <outlets>
            <frac32 name="out" description="output"/>
         </outlets>
         <displays/>
         <params>
            <frac32.s.map.klineartime.exp name="glide"/>
         </params>
         <attribs/>
         <includes/>
         <code.declaration><![CDATA[int32_t val;]]></code.declaration>
         <code.init><![CDATA[val = 0;]]></code.init>
         <code.krate><![CDATA[int32_t glide;
MTOF(-inlet_glide-param_glide,glide)
glide=glide>>9;
int dir=inlet_in>val?1:0;

val +=inlet_in>val?glide:-glide;
if(dir){
	val=val>inlet_in?inlet_in:val;
}
else{val=val<inlet_in?inlet_in:val;}


   outlet_out= val;]]></code.krate>
      </object>
   </patchobj>
   <obj type="conv/interp" uuid="d68c1a8709d8b55e3de8715d727ec0a2d8569d9a" name="interp_1" x="1442" y="1442">
      <params/>
      <attribs/>
   </obj>
   <obj type="ctrl/button" uuid="ef3d13774349df85aa9bfecf30dbc91ab8488b3f" name="button_1" x="448" y="1484">
      <params>
         <bool32.mom name="b" value="0"/>
      </params>
      <attribs/>
   </obj>
   <obj type="logic/inv" uuid="2bd44b865d3b63ff9b80862242bf5be779e3ad5" name="inv_1" x="574" y="1484">
      <params/>
      <attribs/>
   </obj>
   <patchobj type="patch/object" uuid="cccf637c-1e68-415c-9e22-89759f676def" name="alloc_2" x="546" y="1540">
      <params>
         <frac32.u.map name="hrms" value="20.0"/>
         <frac32.u.map name="range" value="25.5"/>
         <bool32.mom name="rnd" value="0"/>
         <frac32.u.map name="mod" value="46.0"/>
         <frac32.u.map name="root" value="64.0"/>
      </params>
      <attribs>
         <combo attributeName="size" selection="512"/>
      </attribs>
      <object id="patch/object" uuid="cccf637c-1e68-415c-9e22-89759f676def">
         <sDescription>allocate 16bit table in SDRAM memory, -128.00 .. 127.99</sDescription>
         <author>Johannes Taelman</author>
         <license>BSD</license>
         <helpPatch>table.axh</helpPatch>
         <inlets>
            <bool32 name="rnd"/>
         </inlets>
         <outlets/>
         <displays/>
         <params>
            <frac32.u.map name="hrms"/>
            <frac32.u.map name="range"/>
            <bool32.mom name="rnd"/>
            <frac32.u.map name="mod"/>
            <frac32.u.map name="root" description="root chance"/>
         </params>
         <attribs>
            <combo name="size">
               <MenuEntries>
                  <string>2</string>
                  <string>4</string>
                  <string>8</string>
                  <string>16</string>
                  <string>32</string>
                  <string>64</string>
                  <string>128</string>
                  <string>256</string>
                  <string>512</string>
                  <string>1024</string>
                  <string>2048</string>
                  <string>4096</string>
                  <string>8192</string>
                  <string>16384</string>
                  <string>32768</string>
                  <string>65536</string>
                  <string>131072</string>
                  <string>262144</string>
                  <string>524288</string>
                  <string>1048576</string>
                  <string>2097152</string>
                  <string>4194304</string>
               </MenuEntries>
               <CEntries>
                  <string>1</string>
                  <string>2</string>
                  <string>3</string>
                  <string>4</string>
                  <string>5</string>
                  <string>6</string>
                  <string>7</string>
                  <string>8</string>
                  <string>9</string>
                  <string>10</string>
                  <string>11</string>
                  <string>12</string>
                  <string>13</string>
                  <string>14</string>
                  <string>15</string>
                  <string>16</string>
                  <string>17</string>
                  <string>18</string>
                  <string>19</string>
                  <string>20</string>
                  <string>21</string>
                  <string>22</string>
               </CEntries>
            </combo>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[static const uint32_t LENGTHPOW = (attr_size);
static const uint32_t LENGTH = (1<<attr_size);
static const uint32_t LENGTHMASK = ((1<<attr_size)-1);
static const uint32_t BITS = 16;
static const uint32_t GAIN = 12;
int16_t *array;
int i,j;
bool rnd;
bool DO;]]></code.declaration>
         <code.init><![CDATA[static int16_t _array[LENGTH*8] __attribute__ ((section (".sdram")));
array = &_array[0];
DO=1;
/*{ 

  for(i=0;i<LENGTH*8;i++){
  array[i]=0;
  }
  int32_t tmp;
  for(int l=0;l<8;l++){
  	uint32_t pl=l*LENGTH;
  	int hrms=16;
  	int range=64;
  for(j=0;j<hrms;j++){
  	int k=((int32_t)(GenerateRandomNumber()%range)+1);
  	int32_t PHS=(int32_t)GenerateRandomNumber();
  	if(j<1){k=1;}
  	uint32_t mod=(1<<31)-(___SMMUL((1<<26),(int32_t)(GenerateRandomNumber()>>1))<<5);
  	for(i=0;i<LENGTH;i++){
  	SINE2TINTERP((i*k<<32-LENGTHPOW)+PHS,tmp)
  	
  	array[i+pl]+=___SMMUL(tmp,mod)/k/hrms>>15;
  }
  }
  int32_t lvl=0;
  for(i=0;i<LENGTH;i++){
  	tmp=array[i+pl];
  	tmp=tmp>0?tmp:-tmp;
  	lvl=tmp>lvl?tmp:lvl;
  }
  float32_t ratio=(float32_t)(1<<12)/lvl;
   for(i=0;i<LENGTH;i++){
   	array[i+pl]*=ratio;
   }
  }
}*/]]></code.init>
         <code.krate><![CDATA[bool RND=inlet_rnd||param_rnd;

if(((RND||DO)>0)&&!rnd){
	rnd=1;
	DO=0;
	int range=param_range>>20;

	range=range>0?range:1;
for(i=0;i<(LENGTH*8);i++){
  array[i]=0;
  }
  int32_t tmp;
  for(int l=0;l<8;l++){
  	uint32_t pl=l*LENGTH;
  	int hrms=param_hrms>>21;
	hrms=(int32_t)(GenerateRandomNumber()%(hrms))+1;
	hrms=hrms>0?hrms:1;
  for(j=0;j<hrms;j++){
  	int k=((int32_t)(GenerateRandomNumber()%(range))+1);
  	int32_t PHS=(int32_t)(GenerateRandomNumber()&3)<<30;
  	uint32_t mod=(1<<29)-(___SMMUL(param_mod,(int32_t)(GenerateRandomNumber()>>1))<<5);
  	if((j<1)&&((param_root<<(l&1))>((int32_t)(GenerateRandomNumber()>>5)))){k=1;PHS=0;mod=(1<<29);}
  	
  	
  	for(i=0;i<LENGTH;i++){
  	SINE2TINTERP((i*k<<32-LENGTHPOW)+PHS,tmp)
  	
  	array[i+pl]=__SSAT(array[i+pl]+(___SMMUL(tmp,mod)/k>>17),16);///hrms>>18),16);
  }
  }
  int32_t lvl=0;
  for(i=0;i<LENGTH;i++){
  	tmp=array[i+pl];
  	tmp=tmp>0?tmp:-tmp;
  	lvl=tmp>lvl?tmp:lvl;
  }
  float32_t ratio=(float32_t)(1<<12)/lvl;
   for(i=0;i<LENGTH;i++){
   	array[i+pl]*=ratio;
   }
  }
}
else if(RND<1){rnd=0;}]]></code.krate>
      </object>
   </patchobj>
   <patcher type="patch/patcher" uuid="bd98c10b-eac3-45b7-87bb-36cb64d73cdc" name="patcher_1" x="714" y="1540">
      <params>
         <frac32.s.map name="read_11:pitch" value="-24.0"/>
         <int32.hradio name="read_11:wave" value="0"/>
         <frac32.s.map name="ad_1:a" value="-64.0"/>
         <frac32.s.map name="ad_1:d" value="37.0"/>
      </params>
      <attribs>
         <combo attributeName="poly" selection="3"/>
         <combo attributeName="midichannel" selection="1"/>
         <combo attributeName="mididevice" selection="internal"/>
         <combo attributeName="midiport" selection="omni"/>
      </attribs>
      <subpatch appVersion="1.0.12">
         <obj type="midi/in/keyb" uuid="53b04874696932f38aceaa168bd5d9efb743716d" name="keyb_1" x="392" y="196">
            <params/>
            <attribs/>
         </obj>
         <patchobj type="patch/object" uuid="27f2babc-8f6d-4102-b0fe-ce9e602cd15d" name="interp_1" x="490" y="196">
            <params/>
            <attribs/>
            <object id="patch/object" uuid="27f2babc-8f6d-4102-b0fe-ce9e602cd15d">
               <sDescription>linear interpolation from k- to s-rate</sDescription>
               <author>Johannes Taelman</author>
               <license>BSD</license>
               <inlets>
                  <frac32 name="i" description="input"/>
               </inlets>
               <outlets>
                  <frac32buffer name="o" description="output"/>
               </outlets>
               <displays/>
               <params/>
               <attribs/>
               <includes/>
               <code.declaration><![CDATA[   int32_t _prev;
    int32_t _step;
]]></code.declaration>
               <code.krate><![CDATA[   _step = (inlet_i - _prev)>>4;
   int32_t _i = _prev;
   _prev = inlet_i;
]]></code.krate>
               <code.srate><![CDATA[   outlet_o = _i;
   _i += _step;
]]></code.srate>
            </object>
         </patchobj>
         <patchobj type="patch/object" uuid="5410c151-e341-4a49-82d5-57f53837f73a" name="read_11" x="644" y="196">
            <params>
               <frac32.s.map name="pitch" onParent="true" value="-24.0"/>
               <int32.hradio name="wave" onParent="true" value="0"/>
            </params>
            <attribs>
               <objref attributeName="table" obj="../alloc_2"/>
            </attribs>
            <object id="patch/object" uuid="5410c151-e341-4a49-82d5-57f53837f73a">
               <sDescription>delay read, linear interpolated</sDescription>
               <author>Johannes Taelman</author>
               <license>BSD</license>
               <helpPatch>delay.axh</helpPatch>
               <inlets>
                  <frac32 name="pitch"/>
                  <frac32buffer name="wave"/>
                  <frac32buffer name="freq"/>
               </inlets>
               <outlets>
                  <frac32buffer name="out" description="wave"/>
               </outlets>
               <displays/>
               <params>
                  <frac32.s.map.pitch name="pitch"/>
                  <int32.hradio name="wave">
                     <MaxValue i="8"/>
                  </int32.hradio>
               </params>
               <attribs>
                  <objref name="table"/>
               </attribs>
               <includes/>
               <code.declaration><![CDATA[uint32_t phs;
int32_t frq;
int32_t wave;
int32_t sel1,sel2;
int32_t hp;
int32_t tp;
int32_t dcl;
int32_t vi27=(1<<27)-1;
int32_t v5=5<<21;
int32_t READ(uint32_t P,int SEL){
	 uint32_t tmp_d =  P>>5;
      uint32_t tmp_di = (tmp_d>>(27-attr_table.LENGTHPOW));
      uint32_t tmp_w1 = (tmp_d<<(attr_table.LENGTHPOW+3)) & 0x3FFFFFFF;
      uint32_t tmp_w2 = (1<<30) - tmp_w1;
      int32_t tmp_a1 = attr_table.array[(tmp_di&attr_table.LENGTHMASK)+SEL]<<14;
      int32_t tmp_a2 = attr_table.array[((tmp_di+1)&attr_table.LENGTHMASK)+SEL]<<14;
      int32_t tmp_r = tmp_a1+(___SMMUL(tmp_a2-tmp_a1,tmp_w1)<<2);
      wave=tmp_r;

}]]></code.declaration>
               <code.init><![CDATA[dcl=0;
phs=0;]]></code.init>
               <code.krate><![CDATA[MTOFEXTENDED(param_pitch+inlet_pitch,frq)]]></code.krate>
               <code.srate><![CDATA[int32_t mix=(inlet_wave*4)&vi27;
sel1=mix>>24;
mix-=sel1<<24;
mix=mix<<7;
sel1=(param_wave+sel1)&7;
sel2=(sel1+1)&7;
sel1=sel1<<attr_table.LENGTHPOW;
sel2=sel2<<attr_table.LENGTHPOW;

phs+=frq+(___SMMUL(frq,inlet_freq)<<7);
READ(phs,sel1);
int32_t tmp=wave;
READ(phs,sel2);
tmp+=___SMMUL(mix,wave-tmp<<1);
int32_t diff=tmp-tp;

diff=diff>0?diff:-diff;
if(diff>v5){
	dcl+=tp-tmp;
}
tp=tmp;
tmp+=dcl;
dcl-=dcl>>9;

hp+=tmp-hp>>8;
outlet_out=tmp-hp;]]></code.srate>
            </object>
         </patchobj>
         <patchobj type="patch/object" uuid="4ba7c41d-7d55-43f5-8214-06ad0770666e" name="ad_1" x="770" y="196">
            <params>
               <frac32.s.map name="a" onParent="true" value="-64.0"/>
               <frac32.s.map name="d" onParent="true" value="5.0"/>
            </params>
            <attribs/>
            <object id="patch/object" uuid="4ba7c41d-7d55-43f5-8214-06ad0770666e">
               <sDescription>Attack/decay envelope, linear attack, exponential decay</sDescription>
               <author>Johannes Taelman</author>
               <license>BSD</license>
               <helpPatch>env.axh</helpPatch>
               <inlets>
                  <bool32.rising name="trig" description="trigger"/>
                  <frac32 name="a"/>
                  <frac32 name="d"/>
               </inlets>
               <outlets>
                  <frac32.positive name="env" description="envelope output"/>
               </outlets>
               <displays/>
               <params>
                  <frac32.s.map.klineartime.exp name="a"/>
                  <frac32.s.map.klineartime.exp name="d"/>
               </params>
               <attribs/>
               <includes/>
               <code.declaration><![CDATA[int8_t stage;
int ntrig;
int32_t val;]]></code.declaration>
               <code.init><![CDATA[ntrig = 0;
val = 0;]]></code.init>
               <code.krate><![CDATA[int32_t d;
MTOF(-param_d-inlet_d,d)
if ((inlet_trig>0) && !ntrig) {
   ntrig = 1;
   stage = 1;
} else if (!(inlet_trig>0)) {
   ntrig = 0;
}
if (stage == 0){
   val -= ___SMMUL(val,d)>>1;
} else {
   int32_t t;
   MTOF(-param_a-inlet_a,t);
   val = val + (t>>3);
   if (val<0) {
      val =0x7FFFFFFF;
      stage = 0;
   }
}
outlet_env = val>>4;]]></code.krate>
            </object>
         </patchobj>
         <obj type="math/*" uuid="922423f2db9f222aa3e5ba095778288c446da47a" name="*_1" x="868" y="196">
            <params/>
            <attribs/>
         </obj>
         <obj type="gain/vca" uuid="a9f2dcd18043e2f47364e45cb8814f63c2a37c0d" name="vca_1" x="924" y="196">
            <params/>
            <attribs/>
         </obj>
         <obj type="patch/outlet a" uuid="abd8c5fd3b0524a6630f65cad6dc27f6c58e2a3e" name="outlet_1" x="980" y="196">
            <params/>
            <attribs/>
         </obj>
         <nets>
            <net>
               <source obj="keyb_1" outlet="note"/>
               <dest obj="read_11" inlet="pitch"/>
               <dest obj="interp_1" inlet="i"/>
            </net>
            <net>
               <source obj="keyb_1" outlet="gate"/>
               <dest obj="ad_1" inlet="trig"/>
            </net>
            <net>
               <source obj="ad_1" outlet="env"/>
               <dest obj="*_1" inlet="a"/>
            </net>
            <net>
               <source obj="keyb_1" outlet="velocity"/>
               <dest obj="*_1" inlet="b"/>
            </net>
            <net>
               <source obj="*_1" outlet="result"/>
               <dest obj="vca_1" inlet="v"/>
            </net>
            <net>
               <source obj="read_11" outlet="out"/>
               <dest obj="vca_1" inlet="a"/>
            </net>
            <net>
               <source obj="vca_1" outlet="o"/>
               <dest obj="outlet_1" inlet="outlet"/>
            </net>
            <net>
               <source obj="interp_1" outlet="o"/>
               <dest obj="read_11" inlet="wave"/>
            </net>
         </nets>
         <settings>
            <subpatchmode>polyphonic</subpatchmode>
            <MidiChannel>1</MidiChannel>
            <HasMidiChannelSelector>true</HasMidiChannelSelector>
            <NPresets>0</NPresets>
            <NPresetEntries>0</NPresetEntries>
            <NModulationSources>0</NModulationSources>
            <NModulationTargetsPerSource>0</NModulationTargetsPerSource>
         </settings>
         <notes><![CDATA[]]></notes>
         <windowPos>
            <x>0</x>
            <y>0</y>
            <width>1361</width>
            <height>774</height>
         </windowPos>
      </subpatch>
   </patcher>
   <patchobj type="patch/object" uuid="b854c38a-0409-4f50-865e-290c1875cf7e" name="keyb_1" x="924" y="1540">
      <params>
         <int32 name="minchannel" value="2"/>
         <frac32.s.map name="a" value="-22.0"/>
         <frac32.s.map name="d" value="1.0"/>
         <frac32.s.map name="self" value="1.0"/>
         <frac32.u.map name="absS" value="3.0"/>
         <frac32.s.map name="all" value="-1.0"/>
         <frac32.u.map name="absA" value="0.0"/>
      </params>
      <attribs>
         <spinner attributeName="voices" value="4"/>
         <objref attributeName="table" obj="alloc_1"/>
      </attribs>
      <object id="patch/object" uuid="b854c38a-0409-4f50-865e-290c1875cf7e">
         <sDescription>Monophonic MIDI keyboard note input, gate, velocity and release velocity</sDescription>
         <author>Johannes Taelman</author>
         <license>BSD</license>
         <helpPatch>midi_in.axh</helpPatch>
         <inlets>
            <frac32 name="preset"/>
         </inlets>
         <outlets>
            <frac32buffer name="out"/>
         </outlets>
         <displays/>
         <params>
            <int32 name="minchannel">
               <MinValue i="1"/>
               <MaxValue i="16"/>
            </int32>
            <frac32.s.map.klineartime.exp name="a"/>
            <frac32.s.map.klineartime.exp name="d"/>
            <frac32.s.map name="self"/>
            <frac32.u.map name="absS"/>
            <frac32.s.map name="all"/>
            <frac32.u.map name="absA"/>
         </params>
         <attribs>
            <spinner name="voices" MinValue="1" MaxValue="8" DefaultValue="1"/>
            <objref name="table"/>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[int32_t frq[attr_voices];
int32_t gate[attr_voices];
int32_t note[attr_voices],fine[attr_voices],prv,snc,ofs;
int32_t velo[attr_voices];
int32_t vl[attr_voices];
int min,i;
int32_t phs[attr_voices],val[attr_voices];
int8_t stage[attr_voices];
bool ntrig[attr_voices],pgate;
int32_t out,ind[attr_voices];
int32_t hp1[attr_voices],hp2[attr_voices],HP,Hp;
int32_t absA[attr_voices],absS[attr_voices],all[attr_voices],self[attr_voices];]]></code.declaration>
         <code.init><![CDATA[for(i=0;i<attr_voices;i++){
gate[i] = 0;
note[i] = 0;
ntrig[i] = 0;
val[i] = 0;
fine[i]=(int32_t)GenerateRandomNumber()>>14;
}
ofs=(int32_t)GenerateRandomNumber();]]></code.init>
         <code.krate><![CDATA[min=param_minchannel-1;
int32_t a[attr_voices],d[attr_voices];
for(i=0;i<attr_voices;i++){
MTOFEXTENDED(((int32_t)note[i]<<21)+fine[i],frq[i])

MTOF(-__SSAT(param_a+(attr_table.array[(ofs+inlet_preset+i+(attr_voices<<4))&attr_table.LENGTHMASK]<<19),28),a[i])
MTOF(-__SSAT(param_d+(attr_table.array[(ofs+inlet_preset+i+(attr_voices<<5))&attr_table.LENGTHMASK]<<19),28),d[i])
a[i]=a[i]>>3;
d[i]=d[i]>>7;

}]]></code.krate>
         <code.srate><![CDATA[int32_t sum=0;
for(i=0;i<attr_voices;i++){
absA[i]+=__USAT(param_absA+(attr_table.array[(ofs+inlet_preset+i)&attr_table.LENGTHMASK]<<20),27)-absA[i]>>10;
absS[i]+=__USAT(param_absS+(attr_table.array[(ofs+inlet_preset+i+(attr_voices))&attr_table.LENGTHMASK]<<20),27)-absS[i]>>14;
all[i]+=__SSAT(param_all+((int8_t)attr_table.array[(ofs+inlet_preset+i+(attr_voices<<1))&attr_table.LENGTHMASK]<<19),28)-all[i]>>14;
self[i]+=__SSAT(param_self+((int8_t)attr_table.array[(ofs+inlet_preset+i+(attr_voices<<2))&attr_table.LENGTHMASK]<<19),28)-self[i]>>14;
	
if ((gate[i]>0) && !ntrig[i]) {
   ntrig[i] = 1;
   stage[i] = 1;
   pgate=1;
} else if (!(gate[i]>0)) {
   ntrig[i] = 0;
}
if (stage[i] == 0){
   val[i] -= ___SMMUL(val[i],d[i]);
} else {

   val[i] = val[i] + (a[i]>>3);
   if (val[i]<0) {
      val[i] =0x7FFFFFFF;
      stage[i] = 0;
   }
}

	
	phs[i]+=frq[i]+(___SMMUL(frq[i],___SMMUL(out,all[i])+___SMMUL(ind[i],self[i])<<3)<<6);
	int32_t r;
	SINE2TINTERP(phs[i],r)
	vl[i]+=(velo[i]<<18)-vl[i]>>4;
	r=___SMMUL(r,vl[i]);
	hp2[i]+=r-hp2[i]>>9;
	r-=hp2[i];
	ind[i]=___SMMUL(r,val[i])<<1;
	
	sum+=___SMMUL(r,val[i])<<1;
	ind[i]=ind[i]+(___SMMUL((___SMMUL(ind[i],ind[i])<<5)-ind[i],absS[i])<<5);
	hp1[i]+=ind[i]-hp1[i]>>8;
	ind[i]-=hp1[i];
}

out=sum;
out=out+(___SMMUL((___SMMUL(sum,sum)<<5)-sum,absA[i])<<5);
HP+=out-HP>>8;
out-=HP;

//snc-=snc>>3;
//if(pgate>0){
//	int32_t tp=sum-prv;
//snc-=tp-(tp>>5);
//	pgate=0;
//}
int32_t tmp=sum;//+snc<<1;
Hp+=tmp-Hp>>8;
tmp-=Hp;
outlet_out=tmp;
prv=sum;]]></code.srate>
         <code.midihandler><![CDATA[for(i=0;i<attr_voices;i++){
if ((status == MIDI_NOTE_ON + i+min) && (data2)) {
  velo[i] = data2;
  note[i] = data1-64;
  gate[i] = 1<<27;

} else if (((status == MIDI_NOTE_ON + i+min) && (!data2))||
          (status == MIDI_NOTE_OFF + i+min)) {


    if(note[i]==data1-64){
    gate[i] = 0;}
  
} else if ((status == i+min + MIDI_CONTROL_CHANGE)&&(data1 == MIDI_C_ALL_NOTES_OFF)) {
  gate[i] = 0;
}
}]]></code.midihandler>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="b854c38a-0409-4f50-865e-290c1875cf7e" name="keyb_4" x="1050" y="1540">
      <params>
         <int32 name="minchannel" value="8"/>
         <frac32.s.map name="a" value="10.0"/>
         <frac32.s.map name="d" value="4.0"/>
         <frac32.s.map name="vector" value="0.0"/>
         <frac32.s.map name="strength" value="10.0"/>
         <frac32.s.map name="position" value="11.0"/>
         <frac32.s.map name="modv" value="53.0"/>
         <frac32.s.map name="mods" value="29.0"/>
         <frac32.s.map name="modp" value="34.0"/>
         <frac32.u.map name="hrm" value="1.0"/>
      </params>
      <attribs>
         <spinner attributeName="voices" value="3"/>
         <objref attributeName="table" obj="alloc_1"/>
      </attribs>
      <object id="patch/object" uuid="b854c38a-0409-4f50-865e-290c1875cf7e">
         <sDescription>Monophonic MIDI keyboard note input, gate, velocity and release velocity</sDescription>
         <author>Johannes Taelman</author>
         <license>BSD</license>
         <helpPatch>midi_in.axh</helpPatch>
         <inlets>
            <frac32 name="preset"/>
            <frac32buffer name="hrm"/>
         </inlets>
         <outlets>
            <frac32buffer name="out"/>
         </outlets>
         <displays/>
         <params>
            <int32 name="minchannel">
               <MinValue i="1"/>
               <MaxValue i="16"/>
            </int32>
            <frac32.s.map.klineartime.exp name="a"/>
            <frac32.s.map.klineartime.exp name="d"/>
            <frac32.s.map name="vector"/>
            <frac32.s.map name="strength"/>
            <frac32.s.map name="position"/>
            <frac32.s.map name="modv"/>
            <frac32.s.map name="mods"/>
            <frac32.s.map name="modp"/>
            <frac32.u.map name="hrm"/>
         </params>
         <attribs>
            <spinner name="voices" MinValue="1" MaxValue="8" DefaultValue="0"/>
            <objref name="table"/>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[int32_t frq[attr_voices];
int32_t gate[attr_voices];
int32_t note[attr_voices];
int32_t velo[attr_voices];
int32_t a[attr_voices];
int32_t d[attr_voices];
int min,i;
int32_t phs[attr_voices],val[attr_voices],ofs;
int8_t stage[attr_voices];
bool ntrig[attr_voices],pgate;
int32_t sum,Hp;
int32_t fine[attr_voices];
int32_t prv,snc,hprv,vl[attr_voices];
int32_t VCT(int32_t phase,int32_t V,int32_t S){
int32_t STR=__SSAT(S,28);
STR=___SMMUL(STR,STR)<<5;
int32_t str=STR>>24;
int32_t mx=STR-(str<<24)<<7;
int32_t mix=phase+(1<<31);
mix=mix>0?mix:-mix;
for(int i=0;i<str;i++){
mix=___SMMUL(mix,mix)<<1;
}
mix+=___SMMUL(mx,___SMMUL(mix,mix)-(mix>>1))<<2;
phase=___SMMUL(mix,___SMMUL(phase,V)<<5)<<1;
return phase;
}

int32_t vector,strength,p1,vc,sh,pp;]]></code.declaration>
         <code.init><![CDATA[for(i=0;i<attr_voices;i++){
gate[i] = 0;
note[i] = 0;
ntrig[i] = 0;
val[i] = 0;
fine[i]=(int32_t)GenerateRandomNumber()>>14;
}
ofs=(int32_t)GenerateRandomNumber();]]></code.init>
         <code.krate><![CDATA[min=param_minchannel-1;
int ss[attr_voices];

for(i=0;i<attr_voices;i++){
MTOFEXTENDED(((int32_t)note[i]<<21)+fine[i],frq[i])

ss[i]=(attr_table.array[(i+inlet_preset+(attr_voices*5))&attr_table.LENGTHMASK])+1;



MTOF(-__SSAT(param_a+(((int8_t)attr_table.array[(i+inlet_preset)&attr_table.LENGTHMASK])<<18),28),a[i])
MTOF(-__SSAT(param_d+(((int8_t)attr_table.array[(i+attr_voices+inlet_preset)&attr_table.LENGTHMASK])<<18),28),d[i])



}]]></code.krate>
         <code.srate><![CDATA[sum=0;
int32_t hrm=param_hrm+inlet_hrm;
hrm=hrm>0?hrm:-hrm;
int32_t stp=hrm>>23;
int32_t MX=hrm-(stp<<23)<<7;
hrm=stp+1;

for(i=0;i<attr_voices;i++){

int HRM=hrm;
int Hrm=hrm+1;
HRM*=ss[i];
Hrm*=ss[i];
HRM=HRM&31;
Hrm=Hrm&31;
if ((gate[i]>0) && !ntrig[i]) {
	pgate=1;
   ntrig[i] = 1;
   stage[i] = 1;
} else if (!(gate[i]>0)) {
   ntrig[i] = 0;
}
if (stage[i] == 0){
   val[i] -= ___SMMUL(val[i],d[i])>>6;
} else {
   int32_t t;
   
   val[i] = val[i] + (a[i]>>6);
   if (val[i]<0) {
      val[i] =0x7FFFFFFF;
      stage[i] = 0;
   }
}

	
	phs[i]+=frq[i];
	
	int32_t r;
	vc+=(((int8_t)attr_table.array[(i+(attr_voices<<1)+inlet_preset+ofs)&attr_table.LENGTHMASK])<<20)-vc>>14;
	sh+=(((int8_t)attr_table.array[(i+(attr_voices<<2)+inlet_preset+ofs)&attr_table.LENGTHMASK])<<20)-sh>>14;
	pp+=(((int8_t)attr_table.array[(i+(attr_voices<<3)+inlet_preset+ofs)&attr_table.LENGTHMASK])<<20)-pp>>14;
     vector=__SSAT((___SMMUL((val[i]>>4)+vc,param_modv)<<5)+param_vector,28);
	strength=__SSAT((___SMMUL((val[i]>>4)+sh,param_mods)<<5)+param_strength,28);
	p1=(___SMMUL((val[i]>>4)+pp,param_modp)<<1)+param_position;
	r=VCT(phs[i],vector,strength);
	int32_t q1,q2;
	SINE2TINTERP((r<<5)+phs[i]*HRM+(p1<<4),q1)
	SINE2TINTERP((r<<5)+phs[i]*Hrm+(p1<<4),q2)
	q1=q1>>2;
	q2=q2>>2;
	r=q1+(___SMMUL(q2-q1,MX)<<2);
	vl[i]+=(velo[i]<<19)-vl[i]>>4;
	r=___SMMUL(r,vl[i]);
	
	sum+=___SMMUL(r,val[i])<<2;
	

}
snc-=snc>>4;
if(pgate>0){
	pgate=0;
	int32_t tp=sum-prv;
	snc-=tp-(tp>>5);
}

int32_t tmp=sum+snc;
Hp+=tmp-Hp>>9;
tmp-=Hp;
outlet_out=tmp;
prv=sum;]]></code.srate>
         <code.midihandler><![CDATA[for(i=0;i<attr_voices;i++){
if ((status == MIDI_NOTE_ON + i+min) && (data2)) {
  velo[i] = data2;
  note[i] = data1-64;
  gate[i] = 1<<27;

} else if (((status == MIDI_NOTE_ON + i+min) && (!data2))||
          (status == MIDI_NOTE_OFF + i+min)) {


    if(note[i]==data1-64){
    gate[i] = 0;}
  
} else if ((status == i+min + MIDI_CONTROL_CHANGE)&&(data1 == MIDI_C_ALL_NOTES_OFF)) {
  gate[i] = 0;
}
}]]></code.midihandler>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="b854c38a-0409-4f50-865e-290c1875cf7e" name="keyb_3" x="1176" y="1540">
      <params>
         <int32 name="minchannel" value="6"/>
         <frac32.s.map name="a" value="-12.0"/>
         <frac32.s.map name="d" value="-4.0"/>
         <frac32.u.map name="s" value="46.5"/>
         <frac32.s.map name="r" value="33.0"/>
         <frac32.s.map name="vector" value="0.0"/>
         <frac32.s.map name="strength" value="30.0"/>
         <frac32.s.map name="position" value="17.0"/>
         <frac32.s.map name="modv" value="11.0"/>
         <frac32.s.map name="mods" value="-12.0"/>
         <frac32.s.map name="modp" value="14.0"/>
         <int32 name="hrm" value="5"/>
         <bool32.tgl name="lower" value="0"/>
      </params>
      <attribs>
         <spinner attributeName="voices" value="2"/>
         <objref attributeName="table" obj="alloc_1"/>
      </attribs>
      <object id="patch/object" uuid="b854c38a-0409-4f50-865e-290c1875cf7e">
         <sDescription>Monophonic MIDI keyboard note input, gate, velocity and release velocity</sDescription>
         <author>Johannes Taelman</author>
         <license>BSD</license>
         <helpPatch>midi_in.axh</helpPatch>
         <inlets>
            <frac32 name="preset"/>
         </inlets>
         <outlets>
            <frac32buffer name="out"/>
         </outlets>
         <displays/>
         <params>
            <int32 name="minchannel">
               <MinValue i="1"/>
               <MaxValue i="16"/>
            </int32>
            <frac32.s.map.klineartime.exp2 name="a"/>
            <frac32.s.map.kdecaytime.exp name="d"/>
            <frac32.u.map name="s"/>
            <frac32.s.map.kdecaytime.exp name="r"/>
            <frac32.s.map name="vector"/>
            <frac32.s.map name="strength"/>
            <frac32.s.map name="position"/>
            <frac32.s.map name="modv"/>
            <frac32.s.map name="mods"/>
            <frac32.s.map name="modp"/>
            <int32 name="hrm">
               <MinValue i="1"/>
               <MaxValue i="8"/>
            </int32>
            <bool32.tgl name="lower"/>
         </params>
         <attribs>
            <spinner name="voices" MinValue="1" MaxValue="8" DefaultValue="0"/>
            <objref name="table"/>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[int32_t frq[attr_voices];
int32_t gate[attr_voices];
int32_t note[attr_voices];
int32_t velo[attr_voices];
int32_t vl[attr_voices];
int min,i;
int32_t phs[attr_voices],val[attr_voices],prv,snc,Hp;
int8_t stage[attr_voices];
bool ntrig[attr_voices],pgate;
int32_t fine[attr_voices];
int32_t ofs;
int32_t VCT(int32_t phase,int32_t V,int32_t S){
int32_t STR=__SSAT(S,28);
STR=___SMMUL(STR,STR)<<5;
int32_t str=STR>>24;
int32_t mx=STR-(str<<24)<<7;
int32_t mix=phase+(1<<31);
mix=mix>0?mix:-mix;
for(int i=0;i<str;i++){
mix=___SMMUL(mix,mix)<<1;
}
mix+=___SMMUL(mx,___SMMUL(mix,mix)-(mix>>1))<<2;
phase=___SMMUL(mix,___SMMUL(phase,V)<<5)<<1;
return phase;
}
int32_t vector,strength,p1,vc,sh,pp;]]></code.declaration>
         <code.init><![CDATA[for(i=0;i<attr_voices;i++){
gate[i] = 0;
note[i] = 0;
ntrig[i] = 0;
val[i] = 0;
fine[i]=(int32_t)GenerateRandomNumber()>>14;
}
ofs=(int32_t)GenerateRandomNumber();]]></code.init>
         <code.krate><![CDATA[min=param_minchannel-1;

for(i=0;i<attr_voices;i++){
MTOFEXTENDED(((int32_t)note[i]<<21)+fine[i],frq[i])
if(param_lower){
frq[i]=frq[i]/param_hrm;}


}

int32_t a,d,s,r;
MTOF(-param_a,a)
MTOF(-param_d,d)
MTOF(-param_r,r)]]></code.krate>
         <code.srate><![CDATA[int32_t sum=0;
for(i=0;i<attr_voices;i++){

if ((gate[i]>0) && !ntrig[i]) {
	pgate=1;
   stage[i] = 1;
   ntrig[i] = 1;
}
if (!(gate[i]>0) && ntrig[i]) {
   stage[i] = 0;
   ntrig[i]=0;
}
if (stage[i] == 0){
   val[i] -= ___SMMUL(val[i],r)>>4;
} else if (stage[i] == 1){
   val[i] = val[i] + (a>>7);
   if (val[i]<0) {
      val[i] =0x7FFFFFFF;
      stage[i] = 2;
   }
} else if (stage[i] == 2) {
   val[i] += ___SMMUL((s<<4) - val[i],d)>>4;
}

	
	phs[i]+=frq[i];
	
	int32_t r;
	vc+=(((int8_t)attr_table.array[(i+(attr_voices<<1)+inlet_preset+ofs)&attr_table.LENGTHMASK])<<18)-vc>>13;
	sh+=(((int8_t)attr_table.array[(i+(attr_voices<<2)+inlet_preset+ofs)&attr_table.LENGTHMASK])<<18)-sh>>13;
	pp+=(((int8_t)attr_table.array[(i+(attr_voices<<3)+inlet_preset+ofs)&attr_table.LENGTHMASK])<<18)-pp>>13;
     vector=__SSAT((___SMMUL((val[i]>>4)+vc,param_modv)<<5)+param_vector,28);
	strength=__SSAT((___SMMUL((val[i]>>4)+sh,param_mods)<<5)+param_strength,28);
	p1=(___SMMUL((val[i]>>4)+pp,param_modp)<<1)+param_position;
	r=VCT(phs[i],vector,strength);
	SINE2TINTERP((r<<5)+phs[i]*param_hrm+(p1<<5),r)
	vl[i]+=(velo[i]<<19)-vl[i]>>4;
	r=___SMMUL(r,vl[i]);
	sum+=___SMMUL(r,val[i])<<1;
}
snc-=snc>>3;
if(pgate>0){
	int32_t tp=sum-prv;
	snc-=tp-(tp>>5);
	pgate=0;
}

int32_t tmp=sum+snc;
Hp+=tmp-Hp>>9;
tmp-=Hp;
outlet_out=tmp;
prv=sum;]]></code.srate>
         <code.midihandler><![CDATA[for(i=0;i<attr_voices;i++){
if ((status == MIDI_NOTE_ON + i+min) && (data2)) {
  velo[i] = data2;
  note[i] = data1-64;
  gate[i] = 1<<27;

} else if (((status == MIDI_NOTE_ON + i+min) && (!data2))||
          (status == MIDI_NOTE_OFF + i+min)) {

    if(note[i]==data1-64){
    gate[i] = 0;}
  
} else if ((status == i+min + MIDI_CONTROL_CHANGE)&&(data1 == MIDI_C_ALL_NOTES_OFF)) {
  gate[i] = 0;
}
}]]></code.midihandler>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="9ae8d050-53cf-4c9e-8a0a-d7ebfbc46740" name="mix_1" x="1302" y="1540">
      <params>
         <frac32.u.map name="gain1" value="30.5"/>
         <frac32.u.map name="gain2" value="31.0"/>
         <frac32.u.map name="gain3" value="22.0"/>
         <frac32.u.map name="gain4" value="0.0"/>
         <frac32.u.map name="gain5" value="32.0"/>
      </params>
      <attribs/>
      <object id="patch/object" uuid="9ae8d050-53cf-4c9e-8a0a-d7ebfbc46740">
         <sDescription>5 input s-rate mixer, square gain scale</sDescription>
         <author>Johannes Taelman</author>
         <license>BSD</license>
         <inlets>
            <frac32buffer name="bus_in" description="input with unity gain"/>
            <frac32buffer name="in1" description="input 1"/>
            <frac32buffer name="in2" description="input 2"/>
            <frac32buffer name="in3" description="input 3"/>
            <frac32buffer name="in4" description="input 4"/>
            <frac32buffer name="in5" description="input 5"/>
         </inlets>
         <outlets>
            <frac32buffer name="out" description="mix out"/>
         </outlets>
         <displays/>
         <params>
            <frac32.u.map.squaregain name="gain1">
               <DefaultValue v="32.0"/>
            </frac32.u.map.squaregain>
            <frac32.u.map.squaregain name="gain2">
               <DefaultValue v="32.0"/>
            </frac32.u.map.squaregain>
            <frac32.u.map.squaregain name="gain3">
               <DefaultValue v="32.0"/>
            </frac32.u.map.squaregain>
            <frac32.u.map.squaregain name="gain4">
               <DefaultValue v="32.0"/>
            </frac32.u.map.squaregain>
            <frac32.u.map.squaregain name="gain5">
               <DefaultValue v="32.0"/>
            </frac32.u.map.squaregain>
         </params>
         <attribs/>
         <includes/>
         <code.srate><![CDATA[int32_t accum = ___SMMUL(inlet_in1,param_gain1);
   accum = ___SMMLA(inlet_in2,param_gain2,accum);
;   accum = ___SMMLA(inlet_in3,param_gain3,accum);
;   accum = ___SMMLA(inlet_in4,param_gain4,accum);
;   accum = ___SMMLA(inlet_in5,param_gain5,accum);
;   outlet_out=  inlet_bus__in + (accum<<1);]]></code.srate>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="e1a04650-e10d-440e-af7f-740b29380ff5" name="vca_1" x="1428" y="1540">
      <params/>
      <attribs/>
      <object id="patch/object" uuid="e1a04650-e10d-440e-af7f-740b29380ff5">
         <sDescription>&quot;voltage controlled amplifier&quot;, multiplies v and a inputs, with linear interpolation from k- to s-rate</sDescription>
         <author>Johannes Taelman</author>
         <license>BSD</license>
         <inlets>
            <frac32 name="v" description="gain input"/>
            <frac32buffer name="a" description="audio input"/>
         </inlets>
         <outlets>
            <frac32buffer name="o" description="output"/>
         </outlets>
         <displays/>
         <params/>
         <attribs/>
         <includes/>
         <code.declaration><![CDATA[   int32_t prev;
    int32_t step;
]]></code.declaration>
         <code.krate><![CDATA[   step = (inlet_v - prev)>>4;
   int32_t i = prev;
   prev = inlet_v;
]]></code.krate>
         <code.srate><![CDATA[   outlet_o =  ___SMMUL(inlet_a,i)<<5;
   i += step;
]]></code.srate>
      </object>
   </patchobj>
   <obj type="sss/dyn/compander" uuid="4a709004-666d-401a-b174-0201aee45a0b" name="compander_1" x="1498" y="1540">
      <params>
         <frac32.u.map name="gainIn" value="12.0"/>
         <frac32.u.map name="tresh" value="33.0"/>
         <frac32.u.map name="ratio" value="64.0"/>
         <frac32.u.map name="expand" value="0.0"/>
         <frac32.u.map name="slope" value="0.0"/>
         <frac32.s.map name="release" value="22.0"/>
      </params>
      <attribs/>
   </obj>
   <obj type="sss/audio/StOutVol" uuid="0ca9cf1e-1ce3-469c-80da-a4a885c21246" name="StOutVol_1" x="1750" y="1540">
      <params>
         <frac32.u.map name="volume" value="55.0"/>
      </params>
      <attribs/>
   </obj>
   <nets>
      <net>
         <source obj="tempo" outlet="out"/>
         <dest obj="counter_1" inlet="tempo"/>
      </net>
      <net>
         <source obj="indexed_1" outlet="out"/>
         <dest obj="save_1" inlet="filename"/>
         <dest obj="load_1" inlet="filename"/>
      </net>
      <net>
         <source obj="save" outlet="o"/>
         <dest obj="save_1" inlet="trig"/>
      </net>
      <net>
         <source obj="load" outlet="o"/>
         <dest obj="load_1" inlet="trig"/>
         <dest obj="songtable" inlet="update"/>
      </net>
      <net>
         <source obj="reset" outlet="o"/>
         <dest obj="counter_1" inlet="r"/>
      </net>
      <net>
         <source obj="play" outlet="o"/>
         <dest obj="counter_1" inlet="play"/>
      </net>
      <net>
         <source obj="pause" outlet="o"/>
         <dest obj="counter_1" inlet="pause"/>
      </net>
      <net>
         <source obj="copy to next" outlet="o"/>
         <dest obj="songtable" inlet="copy2next"/>
      </net>
      <net>
         <source obj="copy from" outlet="o"/>
         <dest obj="songtable" inlet="copyfrom"/>
      </net>
      <net>
         <source obj="from" outlet="out"/>
         <dest obj="songtable" inlet="from"/>
      </net>
      <net>
         <source obj="song" outlet="out"/>
         <dest obj="indexed_1" inlet="index"/>
      </net>
      <net>
         <source obj="reset to part" outlet="out"/>
         <dest obj="counter_1" inlet="reset2part"/>
      </net>
      <net>
         <source obj="counter_1" outlet="step"/>
         <dest obj="object_13" inlet="count"/>
         <dest obj="object_2" inlet="count"/>
         <dest obj="object_6" inlet="count"/>
         <dest obj="object_24" inlet="count"/>
      </net>
      <net>
         <source obj="counter_1" outlet="maxstep"/>
         <dest obj="object_13" inlet="max"/>
         <dest obj="object_2" inlet="max"/>
         <dest obj="object_6" inlet="max"/>
         <dest obj="object_24" inlet="max"/>
      </net>
      <net>
         <source obj="counter_2" outlet="c"/>
         <dest obj="object_9" inlet="rnd"/>
         <dest obj="object_3" inlet="rnd"/>
         <dest obj="object_5" inlet="rnd"/>
         <dest obj="object_8" inlet="rnd"/>
         <dest obj="object_11" inlet="rnd"/>
         <dest obj="object_12" inlet="rnd"/>
         <dest obj="object_7" inlet="rnd"/>
         <dest obj="object_14" inlet="rnd"/>
         <dest obj="object_4" inlet="rnd"/>
         <dest obj="uniform_1" inlet="trig"/>
         <dest obj="object_15" inlet="rnd"/>
         <dest obj="object_16" inlet="rnd"/>
         <dest obj="object_17" inlet="rnd"/>
         <dest obj="object_13" inlet="rnd"/>
         <dest obj="object_18" inlet="rnd"/>
         <dest obj="object_20" inlet="rnd"/>
         <dest obj="object_2" inlet="rnd"/>
         <dest obj="alloc_1" inlet="rnd"/>
         <dest obj="object_6" inlet="rnd"/>
         <dest obj="object_19" inlet="rnd"/>
         <dest obj="object_22" inlet="rnd"/>
         <dest obj="object_24" inlet="rnd"/>
         <dest obj="object_25" inlet="rnd"/>
         <dest obj="object_21" inlet="rnd"/>
      </net>
      <net>
         <source obj="object_6" outlet="out"/>
         <dest obj="note_4" inlet="channel"/>
         <dest obj="mux_3" inlet="s1"/>
      </net>
      <net>
         <source obj="object_2" outlet="out"/>
         <dest obj="and_1" inlet="i1"/>
      </net>
      <net>
         <source obj="+_1" outlet="o1"/>
         <dest obj="mux_2" inlet="i0"/>
         <dest obj="divremc_2" inlet="a"/>
      </net>
      <net>
         <source obj="+_1" outlet="o2"/>
         <dest obj="mux_2" inlet="i1"/>
         <dest obj="divremc_3" inlet="a"/>
      </net>
      <net>
         <source obj="+_1" outlet="o3"/>
         <dest obj="mux_2" inlet="i2"/>
         <dest obj="divremc_4" inlet="a"/>
      </net>
      <net>
         <source obj="+_1" outlet="o4"/>
         <dest obj="mux_2" inlet="i3"/>
         <dest obj="mux_1" inlet="i1"/>
         <dest obj="mux_3" inlet="i1"/>
      </net>
      <net>
         <source obj="+_1" outlet="o5"/>
         <dest obj="mux_2" inlet="i4"/>
         <dest obj="mux_1" inlet="i2"/>
         <dest obj="mux_3" inlet="i2"/>
      </net>
      <net>
         <source obj="+_1" outlet="o6"/>
         <dest obj="mux_2" inlet="i5"/>
         <dest obj="mux_1" inlet="i3"/>
         <dest obj="mux_3" inlet="i3"/>
      </net>
      <net>
         <source obj="counter_1" outlet="mb"/>
         <dest obj="object_12" inlet="count"/>
         <dest obj="object_9" inlet="count"/>
         <dest obj="object_3" inlet="count"/>
         <dest obj="object_4" inlet="count"/>
         <dest obj="object_15" inlet="count"/>
         <dest obj="object_16" inlet="count"/>
         <dest obj="object_17" inlet="count"/>
         <dest obj="object_20" inlet="count"/>
         <dest obj="object_25" inlet="count"/>
         <dest obj="object_21" inlet="count"/>
      </net>
      <net>
         <source obj="counter_1" outlet="mbmax"/>
         <dest obj="object_12" inlet="max"/>
         <dest obj="object_9" inlet="max"/>
         <dest obj="object_3" inlet="max"/>
         <dest obj="object_4" inlet="max"/>
         <dest obj="object_15" inlet="max"/>
         <dest obj="object_16" inlet="max"/>
         <dest obj="object_17" inlet="max"/>
         <dest obj="object_20" inlet="max"/>
         <dest obj="object_25" inlet="max"/>
         <dest obj="object_21" inlet="max"/>
      </net>
      <net>
         <source obj="object_4" outlet="out"/>
         <dest obj="+_1" inlet="chord"/>
      </net>
      <net>
         <source obj="mux_1" outlet="o"/>
         <dest obj="divremc_5" inlet="a"/>
      </net>
      <net>
         <source obj="object_7" outlet="out"/>
         <dest obj="and_5" inlet="i1"/>
      </net>
      <net>
         <source obj="+_2" outlet="out"/>
         <dest obj="object_9" inlet="ofs"/>
         <dest obj="object_3" inlet="ofs"/>
         <dest obj="object_5" inlet="ofs"/>
         <dest obj="object_8" inlet="ofs"/>
         <dest obj="object_11" inlet="ofs"/>
         <dest obj="object_12" inlet="ofs"/>
         <dest obj="object_7" inlet="ofs"/>
         <dest obj="object_14" inlet="ofs"/>
         <dest obj="object_4" inlet="ofs"/>
         <dest obj="object_15" inlet="ofs"/>
         <dest obj="object_16" inlet="ofs"/>
         <dest obj="object_17" inlet="ofs"/>
         <dest obj="object_13" inlet="ofs"/>
         <dest obj="object_18" inlet="ofs"/>
         <dest obj="object_20" inlet="ofs"/>
         <dest obj="object_2" inlet="ofs"/>
         <dest obj="object_6" inlet="ofs"/>
         <dest obj="object_19" inlet="ofs"/>
         <dest obj="object_22" inlet="ofs"/>
         <dest obj="keyb_3" inlet="preset"/>
         <dest obj="object_24" inlet="ofs"/>
         <dest obj="object_25" inlet="ofs"/>
         <dest obj="keyb_1" inlet="preset"/>
         <dest obj="keyb_4" inlet="preset"/>
         <dest obj="object_21" inlet="ofs"/>
      </net>
      <net>
         <source obj="object_9" outlet="out"/>
         <dest obj="and_2" inlet="i1"/>
      </net>
      <net>
         <source obj="object_3" outlet="out"/>
         <dest obj="and_3" inlet="i1"/>
      </net>
      <net>
         <source obj="object_5" outlet="out"/>
         <dest obj="and_4" inlet="i1"/>
      </net>
      <net>
         <source obj="rnd offset1" outlet="out"/>
         <dest obj="*_1" inlet="b"/>
      </net>
      <net>
         <source obj="counter_1" outlet="smb"/>
         <dest obj="object_8" inlet="count"/>
         <dest obj="object_11" inlet="count"/>
         <dest obj="object_18" inlet="count"/>
         <dest obj="object_7" inlet="count"/>
         <dest obj="object_14" inlet="count"/>
         <dest obj="object_22" inlet="count"/>
      </net>
      <net>
         <source obj="counter_1" outlet="smbmax"/>
         <dest obj="object_8" inlet="max"/>
         <dest obj="object_11" inlet="max"/>
         <dest obj="object_18" inlet="max"/>
         <dest obj="object_7" inlet="max"/>
         <dest obj="object_14" inlet="max"/>
         <dest obj="object_22" inlet="max"/>
      </net>
      <net>
         <source obj="object_8" outlet="out"/>
         <dest obj="+_1" inlet="change"/>
      </net>
      <net>
         <source obj="object_11" outlet="out"/>
         <dest obj="+_1" inlet="note"/>
      </net>
      <net>
         <source obj="object_12" outlet="out"/>
         <dest obj="+_1" inlet="shift"/>
      </net>
      <net>
         <source obj="counter_1" outlet="replay"/>
         <dest obj="counter_2" inlet="trig"/>
         <dest obj="uniform_2" inlet="trig"/>
         <dest obj="inv_1" inlet="i"/>
         <dest obj="counter_3" inlet="trig"/>
      </net>
      <net>
         <source obj="uniform_1" outlet="v"/>
         <dest obj="+_1" inlet="key"/>
      </net>
      <net>
         <source obj="divremc_5" outlet="rem"/>
         <dest obj="note_4" inlet="note"/>
      </net>
      <net>
         <source obj="object_13" outlet="out"/>
         <dest obj="note_4" inlet="velo"/>
      </net>
      <net>
         <source obj="object_14" outlet="out"/>
         <dest obj="note_3" inlet="velo"/>
      </net>
      <net>
         <source obj="keyb_1" outlet="out"/>
         <dest obj="mix_1" inlet="in1"/>
      </net>
      <net>
         <source obj="keyb_3" outlet="out"/>
         <dest obj="mix_1" inlet="in5"/>
      </net>
      <net>
         <source obj="+_1" outlet="sel"/>
         <dest obj="mux_2" inlet="s"/>
      </net>
      <net>
         <source obj="+_1" outlet="bass"/>
         <dest obj="divremc_1" inlet="a"/>
      </net>
      <net>
         <source obj="divremc_1" outlet="rem"/>
         <dest obj="note_3" inlet="note"/>
      </net>
      <net>
         <source obj="counter_1" outlet="maxbar"/>
         <dest obj="preset modulate" inlet="i1"/>
      </net>
      <net>
         <source obj="counter_1" outlet="part"/>
         <dest obj="preset modulate" inlet="i2"/>
      </net>
      <net>
         <source obj="counter_1" outlet="bp"/>
         <dest obj="preset modulate" inlet="i4"/>
      </net>
      <net>
         <source obj="preset modulate" outlet="o"/>
         <dest obj="*_1" inlet="a"/>
      </net>
      <net>
         <source obj="uniform_2" outlet="v"/>
         <dest obj="preset modulate" inlet="s"/>
      </net>
      <net>
         <source obj="counter_1" outlet="mbp"/>
         <dest obj="object_5" inlet="count"/>
         <dest obj="preset modulate" inlet="i6"/>
      </net>
      <net>
         <source obj="counter_1" outlet="mbpmax"/>
         <dest obj="object_5" inlet="max"/>
      </net>
      <net>
         <source obj="mix_1" outlet="out"/>
         <dest obj="vca_1" inlet="a"/>
      </net>
      <net>
         <source obj="keyb_4" outlet="out"/>
         <dest obj="mix_1" inlet="in2"/>
      </net>
      <net>
         <source obj="divremc_2" outlet="rem"/>
         <dest obj="note_5" inlet="note"/>
      </net>
      <net>
         <source obj="divremc_3" outlet="rem"/>
         <dest obj="note_6" inlet="note"/>
      </net>
      <net>
         <source obj="divremc_4" outlet="rem"/>
         <dest obj="note_7" inlet="note"/>
      </net>
      <net>
         <source obj="object_15" outlet="out"/>
         <dest obj="note_5" inlet="velo"/>
      </net>
      <net>
         <source obj="object_16" outlet="out"/>
         <dest obj="note_6" inlet="velo"/>
      </net>
      <net>
         <source obj="object_17" outlet="out"/>
         <dest obj="note_7" inlet="velo"/>
      </net>
      <net>
         <source obj="counter_1" outlet="measure"/>
         <dest obj="preset modulate" inlet="i5"/>
      </net>
      <net>
         <source obj="counter_1" outlet="preset"/>
         <dest obj="preset modulate" inlet="i0"/>
      </net>
      <net>
         <source obj="counter_1" outlet="bar"/>
         <dest obj="preset modulate" inlet="i3"/>
      </net>
      <net>
         <source obj="glide_1" outlet="out"/>
         <dest obj="interp_1" inlet="i"/>
      </net>
      <net>
         <source obj="object_18" outlet="out"/>
         <dest obj="glide_1" inlet="in"/>
      </net>
      <net>
         <source obj="interp_1" outlet="o"/>
         <dest obj="keyb_4" inlet="hrm"/>
      </net>
      <net>
         <source obj="object_20" outlet="out"/>
         <dest obj="glide_1" inlet="glide"/>
      </net>
      <net>
         <source obj="and_1" outlet="o"/>
         <dest obj="note_4" inlet="trig"/>
      </net>
      <net>
         <source obj="and_2" outlet="o"/>
         <dest obj="note_5" inlet="trig"/>
      </net>
      <net>
         <source obj="and_3" outlet="o"/>
         <dest obj="note_6" inlet="trig"/>
      </net>
      <net>
         <source obj="and_4" outlet="o"/>
         <dest obj="note_7" inlet="trig"/>
      </net>
      <net>
         <source obj="and_5" outlet="o"/>
         <dest obj="note_3" inlet="trig"/>
      </net>
      <net>
         <source obj="counter_1" outlet="run"/>
         <dest obj="and_1" inlet="i2"/>
         <dest obj="and_2" inlet="i2"/>
         <dest obj="and_3" inlet="i2"/>
         <dest obj="and_4" inlet="i2"/>
         <dest obj="and_5" inlet="i2"/>
         <dest obj="and_6" inlet="i2"/>
      </net>
      <net>
         <source obj="mux_2" outlet="o"/>
         <dest obj="mux_1" inlet="i0"/>
         <dest obj="mux_3" inlet="i0"/>
      </net>
      <net>
         <source obj="counter_1" outlet="character"/>
         <dest obj="sel_1" inlet="in"/>
      </net>
      <net>
         <source obj="counter_1" outlet="songpart"/>
         <dest obj="*_2" inlet="a"/>
      </net>
      <net>
         <source obj="vca_1" outlet="o"/>
         <dest obj="compander_1" inlet="in"/>
      </net>
      <net>
         <source obj="sel_1" outlet="o"/>
         <dest obj="sqrt_1" inlet="in"/>
      </net>
      <net>
         <source obj="sqrt_1" outlet="out"/>
         <dest obj="glide_2" inlet="in"/>
      </net>
      <net>
         <source obj="rnd offset2" outlet="out"/>
         <dest obj="*_2" inlet="b"/>
      </net>
      <net>
         <source obj="glide_2" outlet="out"/>
         <dest obj="vca_1" inlet="v"/>
      </net>
      <net>
         <source obj="*_1" outlet="result"/>
         <dest obj="+_2" inlet="in1"/>
      </net>
      <net>
         <source obj="*_2" outlet="result"/>
         <dest obj="+_2" inlet="in2"/>
      </net>
      <net>
         <source obj="inv_1" outlet="o"/>
         <dest obj="alloc_2" inlet="rnd"/>
      </net>
      <net>
         <source obj="divremc_6" outlet="rem"/>
         <dest obj="note_8" inlet="note"/>
      </net>
      <net>
         <source obj="compander_1" outlet="out"/>
         <dest obj="StOutVol_1" inlet="left"/>
         <dest obj="StOutVol_1" inlet="right"/>
      </net>
      <net>
         <source obj="patcher_1" outlet="outlet_1"/>
         <dest obj="mix_1" inlet="in3"/>
      </net>
      <net>
         <source obj="object_19" outlet="out"/>
         <dest obj="and_6" inlet="i1"/>
      </net>
      <net>
         <source obj="object_22" outlet="out"/>
         <dest obj="note_8" inlet="velo"/>
      </net>
      <net>
         <source obj="and_6" outlet="o"/>
         <dest obj="note_8" inlet="trig"/>
      </net>
      <net>
         <source obj="mux_3" outlet="o"/>
         <dest obj="divremc_6" inlet="a"/>
      </net>
      <net>
         <source obj="object_24" outlet="out"/>
         <dest obj="mux_1" inlet="s"/>
      </net>
      <net>
         <source obj="object_25" outlet="out"/>
         <dest obj="mux_3" inlet="s2"/>
      </net>
      <net>
         <source obj="counter_1" outlet="sm"/>
         <dest obj="object_19" inlet="count"/>
      </net>
      <net>
         <source obj="counter_1" outlet="smmax"/>
         <dest obj="object_19" inlet="max"/>
      </net>
      <net>
         <source obj="counter_3" outlet="c"/>
         <dest obj="counter_1" inlet="stop"/>
      </net>
      <net>
         <source obj="object_21" outlet="out"/>
         <dest obj="counter_4" inlet="trig"/>
      </net>
      <net>
         <source obj="counter_4" outlet="o"/>
         <dest obj="bool_1" inlet="in"/>
         <dest obj="+_1" inlet="negativeHrm"/>
      </net>
   </nets>
   <settings>
      <subpatchmode>no</subpatchmode>
   </settings>
   <notes><![CDATA[]]></notes>
   <windowPos>
      <x>-11</x>
      <y>-2</y>
      <width>1818</width>
      <height>1096</height>
   </windowPos>
</patch-1.0>